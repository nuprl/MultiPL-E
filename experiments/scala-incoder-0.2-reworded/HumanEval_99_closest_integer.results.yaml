language: scala
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmps6os9_lf.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            smallest - difference\n        else\n\
    \            largest + difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpofeql02n.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpofeql02n.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = parts.min\n        val\
    \ max = parts.max\n        val diff = max - min\n        val closest = (min +\
    \ diff) / 2\n        val diff2 = closest - value\n        if (diff2 > 0) closest\
    \ else -closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp93v5vpyb.scala:23:28 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mdiff2\e[0m = closest - value\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m None\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m  \
    \ |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m\
    \  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short):\
    \ Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((value\
    \ : String))\n1 error found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts separated by a dot\n        val\
    \ firstPart = parts(0)\n        val secondPart = parts(1)\n        val firstPartAsLong\
    \ = firstPart.toLong\n        val secondPartAsLong = secondPart.toLong\n     \
    \   val difference = secondPartAsLong - firstPartAsLong\n        val closestInteger\
    \ = firstPartAsLong + difference\n        closestInteger\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpnpkx44xw.scala:20)\n\tat Problem$.main(tmpnpkx44xw.scala:28)\n\
    \tat Problem.main(tmpnpkx44xw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = max - min\n\
    \        if (diff == 0) min else min - diff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpge8onag2.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpge8onag2.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpijpmrgvb.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpijpmrgvb.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArraySum\
    \ = intArray.sum\n        val intArrayDiff = intArraySum - intArray(0)\n     \
    \   val intArrayDiffSquared = intArrayDiff * intArrayDiff\n        val intArrayDiffSquaredLength\
    \ = intArrayDiffSquared.length\n        val intArrayDiffSquaredSum = intArrayDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiff = intArrayDiffSquaredSum - intArrayDiffSquared(0)\n\
    \        val intArrayDiffSquaredDiffSquared = intArrayDiffSquaredDiff * intArrayDiffSquaredDiff\n\
    \        val intArrayDiffSquaredDiffSquaredLength = intArrayDiffSquaredDiffSquared.length\n\
    \        val intArrayDiffSquaredDiffSquaredSum = intArrayDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiff = intArrayDiffSquaredDiffSquaredSum\
    \ - intArrayDiffSquaredDiffSquared(0)\n        val intArrayDiffSquaredDiffSquaredDiffSquared\
    \ = intArrayDiffSquaredDiffSquaredDiffSquared.asInstanceOf[Long]\n        val\
    \ intArrayDiffSquaredDiffSquaredDiffSquaredLength = intArrayDiffSquaredDiffSquaredDiffSquared.length\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredSum = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiff = intArrayDiffSquaredDiffSquaredDiffSquaredSum\
    \ - intArrayDiffSquaredDiffSquaredDiffSquared(0)\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.asInstanceOf[Long]\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredLength = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.length\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredDiff = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum\
    \ - intArrayDiffSquaredDiffSquaredDiffSquaredDiff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt310wy4x.scala:24:60 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredLength\e\
    [0m = intArrayDiffSquared.length\n\e[31m\e[31m   |\e[0m                      \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                           value length is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpt310wy4x.scala:25:57 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredSum\e\
    [0m = intArrayDiffSquared.sum\n\e[31m\e[31m   |\e[0m                         \
    \            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                  value sum is not a member of Int\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpt310wy4x.scala:31:56 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m = intArrayDiffSquaredDiffSquaredDiffSquared.asInstanceOf[\e[35mLong\e[0m]\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m    Recursive \e[33mvalue\e[0m \e[35mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt310wy4x.scala:35:67\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e[0m = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                        \
    \                           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt310wy4x.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659805522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = max - min\n\
    \        if (diff < 0)\n            min - diff\n        else\n            max\
    \ + diff\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmb2_b8tj.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmb2_b8tj.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        val closest =\
    \ (min + diff) / 2\n        val closestInteger = if (diff > 0) closest else -closest\n\
    \        closestInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0e_m4ag1.scala:27)\n\tat Problem.main(tmp0e_m4ag1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805522
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val min = math.min(num, math.min(num - math.abs(num), num + math.abs(num)))\n\
    \        val max = math.max(num, math.max(num - math.abs(num), num + math.abs(num)))\n\
    \        math.round(min + (max - min) / 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpbdchijew.scala:18)\n\
    \tat Problem$.main(tmpbdchijew.scala:25)\n\tat Problem.main(tmpbdchijew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val minNum = math.min(nums.map(_.toDouble))\n\
    \        val maxNum = math.max(nums.map(_.toDouble))\n        val diff = (maxNum\
    \ - minNum).toInt\n        val closestNum = math.round(minNum + diff / 2)\n  \
    \      closestNum.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmphf_uxvip.scala:19:26 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminNum\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmphf_uxvip.scala:20:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxNum\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = max - min\n        val closest = (min + max)\
    \ / 2\n        if (diff < 0)\n            closest - diff\n        else\n     \
    \       closest + diff\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpijedpyir.scala:30)\n\tat Problem.main(tmpijedpyir.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val diff = Math.abs(num - Math.floor(num))\n        val diff2 = Math.abs(num\
    \ - Math.ceil(num))\n        if (diff < diff2) {\n            Math.floor(num)\n\
    \        } else {\n            Math.ceil(num)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48tjvkso.scala:22:22\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            Math.floor(num)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Found:    Double\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48tjvkso.scala:24:21 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            Math.ceil(num)\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Double\n\e\
    [31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.trim\n        val intParts = intValue.split(\"\\\\.\").map(_.toInt)\n\
    \        val intPartLength = intParts.length\n        val intPartIndex = 0\n \
    \       val intPartMin = math.min(math.min(intParts(intPartIndex)),math.min(intParts(intPartIndex+1)))\n\
    \        val intPartMax = math.max(math.max(intParts(intPartIndex)),math.max(intParts(intPartIndex+1)))\n\
    \        val intPartDiff = intPartMax - intPartMin\n        val intPartDiffAbs\
    \ = math.abs(intPartDiff)\n        val intPartDiffAbsMin = math.min(intPartDiffAbs)\n\
    \        val intPartDiffAbsMax = math.max(intPartDiffAbs)\n        val intPartDiffAbsMinAbs\
    \ = math.abs(intPartDiffAbsMin)\n        val intPartDiffAbsMaxAbs = math.abs(intPartDiffAbsMax)\n\
    \        val intPartDiffAbsMinAbsMax = math.max(intPartDiffAbsMinAbs,intPartDiffAbsMaxAbs)\n\
    \        val intPartDiffAbsMinAbsMaxAbs = math.min(intPartDiffAbsMinAbsMax,intPartDiffAbsMaxAbs)\n\
    \        val intPartDiffAbsMinAbsMaxAbsAbs = math.abs(intPartDiffAbsMinAbsMaxAbs)\n\
    \        val intPartDiffAbsMinAbsMaxAbsAbsAbs = math.abs(intPartDiffAbsMinAbsMaxAbsAbs)\n\
    \        val intPartDiffAbsMinAbsMaxAbsAbsAbsAbs = math.abs(intPartDiffAbsMinAbsMaxAbsAbsAbs)\n\
    \        val intPartDiffAbsMinAbsMaxAbsAbsAbsAbsAbs = math.abs(intPartDiffAbsMinAbsMaxAbsAbsAbsAbsAbs)\n\
    \        val intPartDiffAbsMinAbsMaxAbsAbsAbsAbsAbsAbs = math.abs(intPartDiffAbsMinAbsMaxAbsAbsAbsAbsAbsAbs)\n\
    \        val intPartDiffAbsMinAbsMaxAbsAbsAbsAbsAbsAbsAbs = math.abs(intPartDiffAbsMinAbsMaxAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val intPartDiffAbsMinAbs\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7473geg0.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp7473geg0.scala:22:39\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e\
    [0m \e[36mintPartMin\e[0m = math.min(math.min(intParts(intPartIndex)),math.min(intParts(intPartIndex+\e\
    [31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments (Int)\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmp7473geg0.scala:22:72 -----------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m        \e[33mval\e[0m \e[36mintPartMin\e[0m = math.min(math.min(intParts(intPartIndex)),math.min(intParts(intPartIndex+\e\
    [31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                                         \
    \                          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Int)\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp7473geg0.scala:23:39 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mintPartMax\e[0m = math.max(math.max(intParts(intPartIndex)),math.max(intParts(intPartIndex+\e\
    [31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y:"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        val closestLong = math.round(closest)\n\
    \        closestLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp9tpdfmlh.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp9tpdfmlh.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Long]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsDouble = intValue.asInstanceOf[Double]\n        val intValueAsFloat\
    \ = intValue.asInstanceOf[Float]\n        val intValueAsInt = intValue.asInstanceOf[Int]\n\
    \        val intValueAsShort = intValue.asInstanceOf[Short]\n        val intValueAsByte\
    \ = intValue.asInstanceOf[Byte]\n        val intValueAsChar = intValue.asInstanceOf[Char]\n\
    \        val intValueAsBoolean = intValue.asInstanceOf[Boolean]\n        val intValueAsByteArray\
    \ = intValue.asInstanceOf[Array[Byte]]\n        val intValueAsCharArray = intValue.asInstanceOf[Array[Char]]\n\
    \        val intValueAsShortArray = intValue.asInstanceOf[Array[Short]]\n    \
    \    val intValueAsIntArray = intValue.asInstanceOf[Array[Int]]\n        val intValueAsLongArray\
    \ = intValue.asInstanceOf[Array[Long]]\n        val intValueAsFloatArray = intValue.asInstanceOf[Array[Float]]\n\
    \        val intValueAsDoubleArray = intValue.asInstanceOf[Array[Double]]\n  \
    \      val intValueAsBooleanArray = intValue.asInstanceOf[Array[Boolean]]\n  \
    \      val intValueAsByteArrayArray = intValue.asInstanceOf[Array[Array[Byte]]]\n\
    \        val intValueAsCharArrayArray = intValue.asInstanceOf[Array[Array[Char]]]\n\
    \        val intValueAsShortArrayArray = intValue.asInstanceOf[Array[Array[Short]]]\n\
    \        val intValueAsIntArrayArray = intValue.asInstanceOf[Array[Array[Int]]]\n\
    \        val intValueAsLongArrayArray = intValue.asInstanceOf[Array[Array[Long]]]\n\
    \        val intValueAsFloatArrayArray = intValue.asInstanceOf[Array[Array[Float]]]\n\
    \        val intValueAsDoubleArrayArray = intValue.asInstanceOf[Array[Array[Double]]]\n\
    \        val intValueAsBooleanArrayArray = intValue.asInstanceOf[Array[Array[Boolean]]]\n\
    \        val intValueAsByteArrayArrayArray = intValue.asInstanceOf[Array[Array[Array[Byte]]]]\n\
    \        val intValueAsCharArrayArrayArray = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfuj81wdn.scala:44:43 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mintValueAsCharArrayArrayArray\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                           ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfuj81wdn.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        val closestInteger = math.round(closest)\n     \
    \   closestInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpbn5793d3.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpbn5793d3.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = value.split(\"\\\\.\").map(_.toLong)\n        val diffs =\
    \ nums.zip(nums.tail).map { case (a,b) => Math.abs(a-b) }\n        val minDiff\
    \ = diffs.min\n        val closestNum = nums.zip(diffs).find { case (num, diff)\
    \ => diff == minDiff }.map(_._1)\n        closestNum.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvls94hfz.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        closestNum.toLong\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of Option[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659805522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal point\n        val intParts = parts.map(_.toInt)\n\
    \        val intPartCount = intParts.size\n        val intPartSum = intParts.sum\n\
    \        val intPartSumAbs = intPartSum.abs\n        val intPartSumAbsDiff = intPartSumAbs\
    \ - intPartSum\n        val intPartSumAbsDiffAbs = intPartSumAbsDiff.abs\n   \
    \     val intPartSumAbsDiffAbsDiff = intPartSumAbsDiffAbs - intPartSumAbsDiff\n\
    \        val intPartSumAbsDiffAbsDiffAbs = intPartSumAbsDiffAbsDiff.abs\n    \
    \    val intPartSumAbsDiffAbsDiffAbsDiff = intPartSumAbsDiffAbsDiffAbs - intPartSumAbsDiffAbsDiff\n\
    \        val intPartSumAbsDiffAbsDiffAbsDiffAbs = intPartSumAbsDiffAbsDiffAbsDiff.abs\n\
    \        val intPartSumAbsDiffAbsDiffAbsDiffAbsDiff = intPartSumAbsDiffAbsDiffAbsDiffAbs\
    \ - intPartSumAbsDiffAbsDiffAbsDiff\n        val intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbs\
    \ = intPartSumAbsDiffAbsDiffAbsDiffAbsDiff.abs\n        val intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff\
    \ = intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbs - intPartSumAbsDiffAbsDiffAbsDiffAbsDiff\n\
    \        val intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs = intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff.abs\n\
    \        val intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff = intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs\
    \ - intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff\n        val intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff\
    \ = intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs - intPartSumAbsDiffAbsDiffAbs\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmsbimv9v.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mintPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff\e\
    [0m = intPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs - intPartSumAbsDiffAbsDiffAbs\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff is already\
    \ defined as \e[33mvalue\e[0m \e[35mintPartSumAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpmsbimv9v.scala:35:5 ---------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        if\
    \ (diff > 0) min else max\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmptge78_e4.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmptge78_e4.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2\n        if (diff < closest) {\n            closest\n    \
    \    } else {\n            math.round(closest)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxbpvc56c.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxbpvc56c.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.trim\n        val intArray = intValue.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayMin = intArray.min\n\
    \        val intArrayMax = intArray.max\n        val intArrayDiff = intArrayMax\
    \ - intArrayMin\n        val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMin\
    \ = intArrayDiffAbs.min\n        val intArrayDiffAbsMax = intArrayDiffAbs.max\n\
    \        val intArrayDiffAbsMinAbs = intArrayDiffAbsMin - intArrayDiffAbsMax\n\
    \        val intArrayDiffAbsMinAbsAbs = intArrayDiffAbsMinAbs.abs\n        val\
    \ intArrayDiffAbsMinAbsAbsMax = intArrayDiffAbsMinAbsAbs.max\n        val intArrayDiffAbsMinAbsAbsMaxAbs\
    \ = intArrayDiffAbsMinAbsAbsMax.abs\n        val intArrayDiffAbsMinAbsAbsMaxAbsMax\
    \ = intArrayDiffAbsMinAbsAbsMaxAbs.max\n        val intArrayDiffAbsMinAbsAbsMaxAbsMaxAbs\
    \ = intArrayDiffAbsMinAbsAbsMaxAbsMax.abs\n        val intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMax\
    \ = intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMax.max\n        val intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbs\
    \ = intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbs.abs\n        val intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbsMax\
    \ = intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbsMax.max\n        val intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbsMaxAbs\
    \ = intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbsMaxAbsMax.abs\n        val intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbsMaxAbsMax\
    \ = intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbsMaxAbsMax.max\n        val int\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwzw48y5j.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwzw48y5j.scala:27:55\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffAbsMinAbs\e[0m = intArrayDiffAbsMin - intArrayDiffAbsMax\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of Int => Int, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpwzw48y5j.scala:33:54 ---------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMax\e\
    [0m = intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMax.max\n\e[31m\e[31m   |\e[0m     \
    \                                                 ^\e[0m\n\e[31m   |\e[0m    \
    \  Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMax\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwzw48y5j.scala:34:57\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbs\e[0m = intArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbs.abs\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^\e[0m\n\e[31m   |\e[0m   Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsMinAbsAbsMaxAbsMaxAbsMaxAbs\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwzw48y5j.scala:35:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36min"
  stdout: ''
  timestamp: 1659805522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayIndex = (intArrayLength\
    \ - 1) / 2\n        val intArrayElement = intArray(intArrayIndex)\n        val\
    \ intArrayElementLength = intArrayElement.length\n        val intArrayElementIndex\
    \ = (intArrayElementLength - 1) / 2\n        val intArrayElementElement = intArrayElement(intArrayElementIndex)\n\
    \        val intArrayElementElementLength = intArrayElementElement.length\n  \
    \      val intArrayElementElementIndex = (intArrayElementElementLength - 1) /\
    \ 2\n        val intArrayElementElementElement = intArrayElementElement(intArrayElementElementIndex)\n\
    \        val intArrayElementElementElementLength = intArrayElementElementElement.length\n\
    \        val intArrayElementElementElementIndex = (intArrayElementElementElementLength\
    \ - 1) / 2\n        val intArrayElementElementElementElement = intArrayElementElementElement(intArrayElementElementElementIndex)\n\
    \        val intArrayElementElementElementElementLength = intArrayElementElementElementElement.length\n\
    \        val intArrayElementElementElementElementIndex = (intArrayElementElementElementElementLength\
    \ - 1) / 2\n        val intArrayElementElementElementElementElement = intArrayElementElementElementElement(intArrayElementElementElementElementIndex)\n\
    \        val intArrayElementElementElementElementElementLength = intArrayElementElementElementElementElement.length\n\
    \        val intArrayElementElementElementElementElementIndex = (intArrayElementElementElementElementElementLength\
    \ - 1) / 2\n        val intArrayElementElementElementElementElementElement = intArrayElementElementElementElementElement(intArrayElementElementElementElementElementIndex)\n\
    \        val intArrayElementElementElementElementElementElementLength = intArrayElementElementElementElementElementElement.length\n\
    \        val intArrayElementElementElementElementElementElementIndex = (intArrayElementElementElementElementElementElementLength\
    \ - 1) / 2\n        val intArrayElementElementElementElementElementElementElement\
    \ = intArrayElementElementElementElementElementElement(intArrayElementElementElementElementElementElementIndex)\n\
    \        val intArrayElementElementElementElementElementElementElementLength =\
    \ intArrayElementElementElementElementElementElementElement.length\n        val\
    \ intArrayElementElementElementElementElementElementElementIndex = (intArrayElementElementElementElementElementElementElementLength\
    \ - 1) / 2\n        val intArrayElementElementElementElementElementElementElementElement\
    \ = intArrayElementElementElementElementElementElementElementElement(intArrayElementElementElementElementElementElementElementElementIndex)\n\
    \        val intArrayElementElementElementElementElementElementElementElementLength\
    \ = intArrayElementElementElementElementElementElementElement\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5u6o56u0.scala:19:50 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mintArray\e[0m = intValue.toString.toDouble.split(\e\
    [31m'.'\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value split is not a member of Double\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5u6o56u0.scala:43:79 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mintArrayElementElementElementElementElementElementElementElement\e\
    [0m = intArrayElementElementElementElementElementElementElementElement(intArrayElementElementElementElementElementElementElementElementIndex)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mintArrayElementElementElementElementElementElementElementElement\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5u6o56u0.scala:43:144\
    \ -----------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayElementElementElementElementElementElementElementElement\e[0m = intArrayElementElementElementElementElementElementElementElement(intArrayElementElementElementElementElementElementElementElementIndex)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: intArrayElementElementElementElementElementElementElementElementIndex\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5u6o56u0.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation a"
  stdout: ''
  timestamp: 1659805529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split on decimal point\n        val intPart = parts(0)\n\
    \        val fractionPart = parts(1)\n        val intPartAsLong = longValue(intPart)\n\
    \        val fractionPartAsLong = fractionPart.toLong\n        val difference\
    \ = fractionPartAsLong - intPartAsLong\n        val closestInteger = intPartAsLong\
    \ + difference\n        closestInteger\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdmgvprxz.scala:21:28 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintPartAsLong\e[0m = longValue(intPart)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Not found: longValue\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805525
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val integers = numbers.map(_.toInt)\n\
    \        val difference = integers(0) - integers(1)\n        val differenceAbs\
    \ = Math.abs(difference)\n        val closestInteger = if (differenceAbs < 1)\
    \ integers(0) else integers(1)\n        closestInteger\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.closestInteger(tmpf_op6fs3.scala:20)\n\tat Problem$.main(tmpf_op6fs3.scala:26)\n\
    \tat Problem.main(tmpf_op6fs3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeInt = before.toInt\n        val afterInt = after.toInt\n        val\
    \ diff = Math.abs(afterInt - beforeInt)\n        val closest = (diff + beforeInt)\
    \ / 2\n        closest.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmperofy0c7.scala:20)\n\tat Problem$.main(tmperofy0c7.scala:28)\n\
    \tat Problem.main(tmperofy0c7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"\
    , \"9\", \"10\")\n        val numsLen = nums.length\n        val numsSum = nums.sum\n\
    \        val numsSumAbs = numsSum.abs\n        val numsSumAbsMinus1 = numsSumAbs\
    \ - 1\n        val numsSumAbsMinus2 = numsSumAbs - 2\n        val numsSumAbsMinus3\
    \ = numsSumAbs - 3\n        val numsSumAbsMinus4 = numsSumAbs - 4\n        val\
    \ numsSumAbsMinus5 = numsSumAbs - 5\n        val numsSumAbsMinus6 = numsSumAbs\
    \ - 6\n        val numsSumAbsMinus7 = numsSumAbs - 7\n        val numsSumAbsMinus8\
    \ = numsSumAbs - 8\n        val numsSumAbsMinus9 = numsSumAbs - 9\n        val\
    \ numsSumAbsMinus10 = numsSumAbs - 10\n        val numsSumAbsMinus11 = numsSumAbs\
    \ - 11\n        val numsSumAbsMinus12 = numsSumAbs - 12\n        val numsSumAbsMinus13\
    \ = numsSumAbs - 13\n        val numsSumAbsMinus14 = numsSumAbs - 14\n       \
    \ val numsSumAbsMinus15 = numsSumAbs - 15\n        val numsSumAbsMinus16 = numsSumAbs\
    \ - 16\n        val numsSumAbsMinus17 = numsSumAbs - 17\n        val numsSumAbsMinus18\
    \ = numsSumAbs - 18\n        val numsSumAbsMinus19 = numsSumAbs - 19\n       \
    \ val numsSumAbsMinus20 = numsSumAbs - 20\n        val numsSumAbsMinus21 = numsSumAbs\
    \ - 21\n        val numsSumAbsMinus22 = numsSumAbs - 22\n        val numsSumAbsMinus23\
    \ = numsSumAbs - 23\n        val numsSumAbsMinus24 = numsSumAbs - 24\n       \
    \ val numsSumAbsMinus25 = numsSumAbs - 25\n        val numsSumAbsMinus26 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpiqjul4jj.scala:48:31 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mnumsSumAbsMinus26\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpiqjul4jj.scala:21:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnumsSum\e[0m = nums.sum\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   \
    \             No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m                where:    B is a type variable with constraint >: String\n\e\
    [31m   |\e[0m                .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiqjul4jj.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        closest.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpwgiu_kwg.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpwgiu_kwg.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Long]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (min + diff) / 2\n        math.abs(closest - value.toLong)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu4fp30s6.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu4fp30s6.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val closest = (min + max) / 2\n\
    \        if (closest == min) {\n            min\n        } else {\n          \
    \  max\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpw7coo0bx.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpw7coo0bx.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805527
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split string into two parts\n        val firstPart\
    \ = parts(0)\n        val secondPart = parts(1)\n        val firstPartInt = firstPart.toInt\n\
    \        val secondPartInt = secondPart.toInt\n        val difference = secondPartInt\
    \ - firstPartInt\n        if (difference < 0)\n            firstPartInt + difference\n\
    \        else\n            firstPartInt - difference\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp7r5gh0e4.scala:20)\n\tat Problem$.main(tmp7r5gh0e4.scala:30)\n\
    \tat Problem.main(tmp7r5gh0e4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        if\
    \ (diff < 0)\n            math.round(min + diff)\n        else\n            math.round(max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmppkp67250.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmppkp67250.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        val closestInt = closest.toLong\n      \
    \  closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmcdinovs.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmcdinovs.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArraySum\
    \ = intArray(0) + intArray(1) + intArray(2)\n        val intArrayDiff = intArraySum\
    \ - intArrayMax\n        val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMin\
    \ = intArrayDiffAbs.min\n        val intArrayDiffAbsMax = intArrayDiffAbs.max\n\
    \        val intArrayDiffAbsSum = intArrayDiffAbs(0) + intArrayDiffAbs(1) + intArrayDiffAbs(2)\n\
    \        val intArrayDiffAbsDiff = intArrayDiffAbsSum - intArrayDiffAbsMax\n \
    \       val intArrayDiffAbsDiffAbs = intArrayDiffAbsDiff.abs\n        val intArrayDiffAbsDiffAbsMin\
    \ = intArrayDiffAbsDiffAbs.min\n        val intArrayDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbs(0) + intArrayDiffAbsDiffAbs(1)\
    \ + intArrayDiffAbsDiffAbs(2)\n        val intArrayDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsSum\
    \ - intArrayDiffAbsDiffAbsMax\n        val intArrayDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbsDiffAbs.min\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbsDiffAbs(0)\
    \ + intArrayDiffAbsDiffAbsDiffAbs(1) + intArrayDiffAbsDiffAbsDiffAbs(2)\n    \
    \    val intArrayDiffAbsDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsDiffAbsSum\
    \ - intArrayDiffAbsDiffAbsDiffAbsMax\n        val intArrayDiffAbsDiffAbsDiffAbsDiffAbs\
    \ = intArrayDiff\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp6031z2jp.scala:28:33 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsSum\e[0m\
    \ = intArrayDiffAbs(\e[31m0\e[0m) + intArrayDiffAbs(\e[31m1\e[0m) + intArrayDiffAbs(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          \e[33mvalue\e[0m \e[35mintArrayDiffAbs\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6031z2jp.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val closestToZero = smallest + difference\n        closestToZero\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3kss92a4.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3kss92a4.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val difference = numbers.zip(numbers).map\
    \ {\n            case (first, second) => math.abs(first - second)\n        }.max\n\
    \        val closest = (numbers.zip(numbers).map {\n            case (first, second)\
    \ => math.abs(first - second)\n        }.max)._1\n        math.round(difference\
    \ / closest) * closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnb_b8jdc.scala:24:15 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (numbers.zip(numbers).map\
    \ {\n\e[31m23 |\e[0m            \e[33mcase\e[0m (first, second) => math.abs(first\
    \ - second)\n\e[31m24 |\e[0m        }.max)._1\n\e[31m\e[31m   |\e[0m         \
    \             ^\e[0m\n\e[31m   |\e[0m                      value _1 is not a member\
    \ of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659805531
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val diff = (num - num.toInt).toLong\n        if (diff < 0)\n        \
    \    diff + num.toInt\n        else\n            diff\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkdo62ksx.scala:26)\n\tat Problem.main(tmpkdo62ksx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toLong\n        val intValues = List(intValue).sorted\n        val closestValue\
    \ = intValues.last\n        val closestValues = intValues.takeWhile(x => x < closestValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n        val closestValueIndex = closestValues.indexOf(intValue)\n\
    \        val closestValueIndex = closestValues.indexOf(intValue)\n        val\
    \ closestValueIndex = closestValues.indexOf(intValue)\n        val closestValueIndex\
    \ = closestValues.indexOf(intValue)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptd_yf5ou.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestValueIndex\e[0m =\
    \ closestValues.indexOf(intValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mclosestValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptd_yf5ou.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclosestValueIndex\e[0m =\
    \ closestValues.indexOf(intValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mclosestValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptd_yf5ou.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mclosestValueIndex\e[0m =\
    \ closestValues.indexOf(intValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mclosestValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptd_yf5ou.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mclosestValueIndex\e[0m =\
    \ closestValues.indexOf(intValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mclosestValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmptd_yf5ou.scala:27:12 -------------"
  stdout: ''
  timestamp: 1659805531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = max - min\n        val closest = (min + diff)\
    \ / 2\n        if (closest == min) {\n            0\n        } else if (closest\
    \ == max) {\n            0\n        } else {\n            closest - 1\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpytlvgprm.scala:32)\n\tat Problem.main(tmpytlvgprm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805533
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val minDiff = math.abs(num - math.floor(num))\n        val maxDiff =\
    \ math.abs(num - math.ceil(num))\n        val closestDiff = math.min(minDiff,\
    \ maxDiff)\n        math.round(num - closestDiff)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Long.parseLong(Long.java:711)\n\tat java.base/java.lang.Long.parseLong(Long.java:836)\n\
    \tat scala.collection.StringOps$.toLong$extension(StringOps.scala:928)\n\tat Problem$.closestInteger(tmpf0owhybw.scala:18)\n\
    \tat Problem$.main(tmpf0owhybw.scala:26)\n\tat Problem.main(tmpf0owhybw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val closestToZero = numbers.minBy(_.abs)\n\
    \        val closestToZeroIndex = numbers.indexOf(closestToZero)\n        val\
    \ closestToZeroInt = closestToZeroIndex.toLong\n        val closestToZeroIntAsString\
    \ = closestToZeroInt.toString\n        val closestToZeroIntAsStringWithLeadingZeros\
    \ = \n            closestToZeroIntAsString.padLeft(closestToZeroIntAsString.length,\
    \ \"0\")\n        val closestToZeroIntAsStringWithTrailingZeros = \n         \
    \   closestToZeroIntAsStringWithLeadingZeros.padRight(closestToZeroIntAsStringWithLeadingZeros.length,\
    \ \"0\")\n        val closestToZeroIntAsStringWithTrailingZeros = \n         \
    \   closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"0*$\", \"\")\n    \
    \    val closestToZeroIntAsStringWithTrailingZeros = \n            closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"\
    ^0*\", \"\")\n        val closestToZeroIntAsStringWithTrailingZeros = \n     \
    \       closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"^0*$\", \"\")\n\
    \        val closestToZeroIntAsStringWithTrailingZeros = \n            closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"\
    0*$\", \"\")\n        val closestToZeroIntAsStringWithTrailingZeros = \n     \
    \       closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"^0*\", \"\")\n\
    \        val closestToZeroIntAsStringWithTrailingZeros = \n            closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"\
    ^0*$\", \"\")\n        val closestToZeroIntAsStringWithTrailingZeros = \n    \
    \        closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"0*$\", \"\")\n\
    \        val closestToZeroIntAsStringWithTrailingZeros = \n            closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"\
    ^0*\", \"\")\n        val closestToZeroIntAsStringWithTrailingZeros = \n     \
    \       closestToZeroIntAsStringWithTrailingZeros.replaceAll(\"^0*$\", \"\")\n\
    \        val closestToZeroIntAsStringWithTrailingZeros = \n            closestToZeroIntAsStringWithTrail\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp84wp9hv6.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mclosestToZeroIntAsStringWithTrailingZeros\e\
    [0m = \n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mclosestToZeroIntAsStringWithTrailingZeros\
    \ is already defined as \e[33mvalue\e[0m \e[35mclosestToZeroIntAsStringWithTrailingZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m28 |\e[0m         \
    \   closestToZeroIntAsStringWithTrailingZeros.replaceAll(\e[31m\"0*$\"\e[0m, \e\
    [31m\"\"\e[0m)\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp84wp9hv6.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestToZeroIntAsStringWithTrailingZeros\e[0m = \n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0mclosestToZeroIntAsStringWithTrailingZeros is\
    \ already defined as \e[33mvalue\e[0m \e[35mclosestToZeroIntAsStringWithTrailingZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m30 |\e[0m         \
    \   closestToZeroIntAsStringWithTrailingZeros.replaceAll(\e[31m\"^0*\"\e[0m, \e\
    [31m\"\"\e[0m)\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp84wp9hv6.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestToZeroIntAsStringWithTrailingZeros\e[0m = \n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0mclosestToZeroIntAsStringWithTrailingZeros is\
    \ already defined as \e[33mvalue\e[0m \e[35mclosestToZeroIntAsStringWithTrailingZeros\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m32 |\e[0m         \
    \   closestToZeroIntAsStringWithTrailingZeros.replaceAll(\e[31m\"^0*$\"\e[0m,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp84wp9hv6.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestToZeroIntAsStringWithTrailingZeros\e[0m = \n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0mclosestToZeroIntAsStringWithTrailingZeros is\
    \ already d"
  stdout: ''
  timestamp: 1659805533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.trim\n        val intValueAsLong = intValue.toLong\n        val intValueAsDouble\
    \ = intValueAsLong.toDouble\n        val intValueAsInt = intValueAsDouble.asInstanceOf[Int]\n\
    \        val intValueAsLong2 = intValueAsInt.toLong\n        val intValueAsDouble2\
    \ = intValueAsLong2.toDouble\n        val intValueAsInt2 = intValueAsDouble2.asInstanceOf[Int]\n\
    \        val intValueAsLong3 = intValueAsInt2.toLong\n        val intValueAsDouble3\
    \ = intValueAsLong3.toDouble\n        val intValueAsInt3 = intValueAsDouble3.asInstanceOf[Int]\n\
    \        val intValueAsLong4 = intValueAsInt3.toLong\n        val intValueAsDouble4\
    \ = intValueAsLong4.toDouble\n        val intValueAsInt4 = intValueAsDouble4.asInstanceOf[Int]\n\
    \        val intValueAsLong5 = intValueAsInt4.toLong\n        val intValueAsDouble5\
    \ = intValueAsLong5.toDouble\n        val intValueAsInt5 = intValueAsDouble5.asInstanceOf[Int]\n\
    \        val intValueAsLong6 = intValueAsInt5.toLong\n        val intValueAsDouble6\
    \ = intValueAsLong6.toDouble\n        val intValueAsInt6 = intValueAsDouble6.asInstanceOf[Int]\n\
    \        val intValueAsLong7 = intValueAsInt6.toLong\n        val intValueAsDouble7\
    \ = intValueAsLong7.toDouble\n        val intValueAsInt7 = intValueAsDouble7.asInstanceOf[Int]\n\
    \        val intValueAsLong8 = intValueAsInt7.toLong\n        val intValueAsDouble8\
    \ = intValueAsLong8.toDouble\n        val intValueAsInt8 = intValueAsDouble8.asInstanceOf[Int]\n\
    \        val intValueAsLong9 = intValueAsInt8.toLong\n        val intValueAsDouble9\
    \ = intValueAsLong9.toDouble\n        val intValueAsInt9 = intValueAsDouble9.asInstanceOf[Int]\n\
    \        val intValueAsLong10 = intValueAsInt9.toLong\n        val intValueAsDouble10\
    \ = intValueAsLong10.toDouble\n        val intValueAsInt10 = intValueAsDouble10.asInstanceOf[Int]\n\
    \        val intValueAsLong11 = intValueAsInt10.toLong\n        val intValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf5wgk3bg.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpf5wgk3bg.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val intValue = numbers.toList.map(_.toInt)\n\
    \        val diffs = intValue.zip(intValue.tail).map(x => Math.abs(x._1 - x._2))\n\
    \        val closestDiff = diffs.max\n        val closestInt = intValue.find(x\
    \ => Math.abs(x._1 - closestDiff) < Math.abs(x._2 - closestDiff))\n        closestInt._1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprjdfbzg4.scala:22:55 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosestInt\e[0m = intValue.find(\e\
    [36mx\e[0m => Math.abs(x._1 - closestDiff) < Math.abs(x._2 - closestDiff))\n\e\
    [31m\e[31m   |\e[0m                                                     ^^^^\e\
    [0m\n\e[31m   |\e[0m                                         value _1 is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprjdfbzg4.scala:23:19\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        closestInt._1\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value _1\
    \ is not a member of Option[Int]\n2 errors found\n"
  stdout: ''
  timestamp: 1659805532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = (max - min).toLong\n\
    \        val closest = (min + diff) / 2\n        closest.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpm5h6di1f.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpm5h6di1f.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Long]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = (max - min).toInt\n \
    \       val closest = (min + diff) / 2\n        val closestInt = closest.toLong\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzxitqtin.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzxitqtin.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff == 0) ? min : min + (diff / 2)\n        closest.toLong\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpskkeo7ou.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpskkeo7ou.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpskkeo7ou.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val closest = (largest + smallest) / 2\n        if (difference == 0)\
    \ {\n            return closest\n        }\n        if (difference < 0) {\n  \
    \          return math.round(closest)\n        }\n        return math.round(closest)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1czt2f6o.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1czt2f6o.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = numbers.min\n\
    \        val largest = numbers.max\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            smallest + difference\n        else\n\
    \            smallest - difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq72k2vkw.scala:29)\n\tat Problem.main(tmpq72k2vkw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            smallest + difference\n        else\n\
    \            smallest - difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpswpfn3iq.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpswpfn3iq.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Long]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\")\n        val int1 = numbers(0).toLong\n        val\
    \ int2 = numbers(1).toLong\n        val diff = abs(int1 - int2)\n        if (diff\
    \ < 1) {\n            val round = math.round(diff * 1000) / 1000\n           \
    \ round\n        } else {\n            val round = math.round(diff * 100) / 100\n\
    \            round\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp8gkmxrd0.scala:20)\n\tat Problem$.main(tmp8gkmxrd0.scala:31)\n\
    \tat Problem.main(tmp8gkmxrd0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = (max - min).toLong\n\
    \        val closest = (min + diff) / 2\n        val closestLong = closest.toLong\n\
    \        if (closest == min) {\n            closestLong\n        } else {\n  \
    \          closestLong - 1\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp887xxzyp.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp887xxzyp.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val diff = (largest - smallest).toInt\n\
    \        val closest = (smallest + diff) / 2\n        closest.toLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0qy2rkwa.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0qy2rkwa.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff * nums.sum).toLong\n        val rounded = math.round(closest)\n\
    \        rounded\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpckh5w3y3.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpckh5w3y3.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = mutable.ArrayBuffer(num)\n        val numsSorted = nums.sorted\n\
    \        val closestNum = numsSorted.last\n        val closestNumIndex = numsSorted.indexWhere(x\
    \ => x == closestNum)\n        if (closestNumIndex == numsSorted.length - 1) {\n\
    \            val closestNumDiff = closestNum - num\n            if (closestNumDiff\
    \ < 0) {\n                closestNum\n            } else {\n                numsSorted.last\n\
    \            }\n        } else {\n            val closestNumDiff = closestNum\
    \ - numsSorted.last\n            if (closestNumDiff < 0) {\n                numsSorted.last\n\
    \            } else {\n                numsSorted.last\n            }\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyxjzanzs.scala:19:19 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer(num)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val min = numbers.min\n    \
    \    val max = numbers.max\n        val mid = (min + max) / 2\n        val diff\
    \ = max - min\n        val diffAbs = Math.abs(diff)\n        val diffSign = diff\
    \ / diffAbs\n        val diffFloor = Math.floor(diffAbs)\n        val diffCeil\
    \ = Math.ceil(diffAbs)\n        val diffFloorSign = diffFloor / diffAbs\n    \
    \    val diffCeilSign = diffCeil / diffAbs\n        val diffFloorFloor = Math.floor(diffFloor)\n\
    \        val diffCeilCeil = Math.ceil(diffCeil)\n        val diffFloorFloorSign\
    \ = diffFloorFloor / diffAbs\n        val diffCeilCeilSign = diffCeilCeil / diffAbs\n\
    \        val diffFloorCeil = Math.floor(diffCeil)\n        val diffCeilFloor =\
    \ Math.ceil(diffFloor)\n        val diffCeilFloorSign = diffCeilFloor / diffAbs\n\
    \        val diffCeilFloorFloor = Math.floor(diffCeilFloor)\n        val diffCeilFloorFloorSign\
    \ = diffCeilFloorFloor / diffAbs\n        val diffFloorFloorFloor = Math.floor(diffFloorFloor)\n\
    \        val diffFloorFloorFloorSign = diffFloorFloorFloor / diffAbs\n       \
    \ val diffFloorFloorFloorFloor = Math.floor(diffFloorFloorFloor)\n        val\
    \ diffFloorFloorFloorFloorSign = diffFloorFloorFloorFloor / diffAbs\n        val\
    \ diffFloorFloorFloorFloor = Math.floor(diffFloorFloorFloorFloor)\n        val\
    \ diffFloorFloorFloorFloorSign = diffFloorFloorFloorFloor / diffAbs\n        val\
    \ diffFloorFloorFloorFloor = Math.floor(diffFloorFloorFloorFloor)\n        val\
    \ diffFloorFloorFloorFloorSign = diffFloorFloorFloorFloor / diffAbs\n        val\
    \ diffFloorFloorFloorFloor = Math.floor(diffFloorFloorFloorFloor)\n        val\
    \ diffFloorFloorFloorFloorSign = diffFloorFloorFloorFloor / diffAbs\n        val\
    \ diffFloorFloorFloorFloor = Math.floor(diffFloorFloorFloorFloor)\n        val\
    \ diffFloorFloorFloorFloorSign = diffFloorFloorFloorFloor / diffAbs\n        val\
    \ diffFloorFloorFloorFloor = Math.floor(diffFloorFloorFloorFloor)\n        val\
    \ diffFloorFloorFloorFloorSign = diffFloorFloorFloorFloor / diffAb\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppx5q6ut8.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mdiffFloorFloorFloorFloor\e\
    [0m = Math.floor(diffFloorFloorFloorFloor)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffFloorFloorFloorFloor is already defined as \e[33mvalue\e\
    [0m \e[35mdiffFloorFloorFloorFloor\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppx5q6ut8.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mdiffFloorFloorFloorFloorSign\e\
    [0m = diffFloorFloorFloorFloor / diffAbs\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffFloorFloorFloorFloorSign is already defined as \e[33mvalue\e\
    [0m \e[35mdiffFloorFloorFloorFloorSign\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppx5q6ut8.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mdiffFloorFloorFloorFloor\e\
    [0m = Math.floor(diffFloorFloorFloorFloor)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffFloorFloorFloorFloor is already defined as \e[33mvalue\e\
    [0m \e[35mdiffFloorFloorFloorFloor\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppx5q6ut8.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mdiffFloorFloorFloorFloorSign\e\
    [0m = diffFloorFloorFloorFloor / diffAbs\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffFloorFloorFloorFloorSign is already defined as \e[33mvalue\e\
    [0m \e[35mdiffFloorFloorFloorFloorSign\e[0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659805541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArraySum = intArray.sum\n\
    \        val intArrayDifference = intArraySum - intArray(0)\n        val intArrayDifferenceAbs\
    \ = intArrayDifference.abs\n        val intArrayDifferenceAbsSum = intArrayDifferenceAbs.sum\n\
    \        val intArrayDifferenceAbsSumAbs = intArrayDifferenceAbsSum.abs\n    \
    \    val intArrayDifferenceAbsSumAbsAbs = intArrayDifferenceAbsSumAbs.abs\n  \
    \      val intArrayDifferenceAbsSumAbsAbsAbs = intArrayDifferenceAbsSumAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbs = intArrayDifferenceAbsSumAbsAbsAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbsAbs = intArrayDifferenceAbsSumAbsAbsAbsAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbs = intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbs = intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbsAbs = intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs.abs\n\
    \        val intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAb\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd3xbeccy.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd3xbeccy.scala:24:61\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDifferenceAbsSum\e[0m = intArrayDifferenceAbs.sum\n\e[31m\e[31m  \
    \ |\e[0m                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       value sum is not a member\
    \ of Int\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd3xbeccy.scala:28:51 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceAbsSumAbsAbsAbsAbs\e\
    [0m = intArrayDifferenceAbsSumAbsAbsAbsAbs.abs\n\e[31m\e[31m   |\e[0m        \
    \                                           ^\e[0m\n\e[31m   |\e[0m         Recursive\
    \ \e[33mvalue\e[0m \e[35mintArrayDifferenceAbsSumAbsAbsAbsAbs\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd3xbeccy.scala:29:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDifferenceAbsSumAbsAbsAbsAbsAbs\e[0m = intArrayDifferenceAbsSumAbsAbsAbsAbsAbs.abs\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m      Recursive \e[33mvalue\e[0m \e[35mintArrayDifferenceAbsSumAbsAbsAbsAbsAbs\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd3xbeccy.scala:31:60\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbs\e[0m = intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbs.abs\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \           Not found: intArrayDifferenceAbsSumAbsAbsAbsAbsAbsAbsAbsAbs\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanat"
  stdout: ''
  timestamp: 1659805541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = (max - min).toInt\n\
    \        val closest = (min + diff) / 2\n        val closestLong = closest.toLong\n\
    \        closestLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpvm_voptw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpvm_voptw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = parts.min\n        val\
    \ max = parts.max\n        val diff = max - min\n        val closest = (min +\
    \ diff) / 2\n        val diff2 = closest - value\n        if (diff2 > 0) closest\
    \ else -closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp93v5vpyb.scala:23:28 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mdiff2\e[0m = closest - value\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m None\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m  \
    \ |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m\
    \  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short):\
    \ Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments ((value\
    \ : String))\n1 error found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\");\n        val firstPart = parts(0).asInstanceOf[String];\n\
    \        val secondPart = parts(1).asInstanceOf[String];\n        val firstPartInt\
    \ = firstPart.toInt;\n        val secondPartInt = secondPart.toInt;\n        val\
    \ difference = secondPartInt - firstPartInt;\n        val closestInteger = firstPartInt\
    \ + difference;\n        if (closestInteger < 0)\n            closestInteger =\
    \ closestInteger + secondPartInt;\n        return closestInteger;\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp81c0i2ch.scala:26:27 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            closestInteger = closestInteger + secondPartInt;\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val closestInteger\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805538
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal point\n        val intParts = parts.map(_.toInt)\
    \ // convert to integers\n        val diffs = intParts.zip(intParts).map(x =>\
    \ Math.abs(x._1 - x._2)) // find differences between adjacent integers\n     \
    \   val minDiff = diffs.min\n        val closestDiff = diffs.find(x => x == minDiff).get\n\
    \        val closestInteger = intParts.find(x => x == closestDiff).get\n     \
    \   closestInteger.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: None.get\n\tat scala.None$.get(Option.scala:627)\n\
    \tat scala.None$.get(Option.scala:626)\n\tat Problem$.closestInteger(tmpbzxef579.scala:23)\n\
    \tat Problem$.main(tmpbzxef579.scala:27)\n\tat Problem.main(tmpbzxef579.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toLong\n        val intArray = intValue.toString.toIntArray\n      \
    \  val intArrayLength = intArray.length\n        val intArray2 = intArray.slice(1,\
    \ intArrayLength)\n        val intArray3 = intArray2.slice(1, intArrayLength)\n\
    \        val intArray4 = intArray3.slice(1, intArrayLength)\n        val intArray5\
    \ = intArray4.slice(1, intArrayLength)\n        val intArray6 = intArray5.slice(1,\
    \ intArrayLength)\n        val intArray7 = intArray6.slice(1, intArrayLength)\n\
    \        val intArray8 = intArray7.slice(1, intArrayLength)\n        val intArray9\
    \ = intArray8.slice(1, intArrayLength)\n        val intArray10 = intArray9.slice(1,\
    \ intArrayLength)\n        val intArray11 = intArray10.slice(1, intArrayLength)\n\
    \        val intArray12 = intArray11.slice(1, intArrayLength)\n        val intArray13\
    \ = intArray12.slice(1, intArrayLength)\n        val intArray14 = intArray13.slice(1,\
    \ intArrayLength)\n        val intArray15 = intArray14.slice(1, intArrayLength)\n\
    \        val intArray16 = intArray15.slice(1, intArrayLength)\n        val intArray17\
    \ = intArray16.slice(1, intArrayLength)\n        val intArray18 = intArray17.slice(1,\
    \ intArrayLength)\n        val intArray19 = intArray18.slice(1, intArrayLength)\n\
    \        val intArray20 = intArray19.slice(1, intArrayLength)\n        val intArray21\
    \ = intArray20.slice(1, intArrayLength)\n        val intArray22 = intArray21.slice(1,\
    \ intArrayLength)\n        val intArray23 = intArray22.slice(1, intArrayLength)\n\
    \        val intArray24 = intArray23.slice(1, intArrayLength)\n        val intArray25\
    \ = intArray24.slice(1, intArrayLength)\n        val intArray26 = intArray25.slice(1,\
    \ intArrayLength)\n        val intArray27 = intArray26.slice(1, intArrayLength)\n\
    \        val intArray28 = intArray27.slice(1, intArrayLength)\n        val intArray29\
    \ = intArray28.slice(1, intArrayLength)\n        val intArray30 = intArray29.slice(1,\
    \ intArrayLength)\n        val intArray31 = intArray30.slice(1, intArrayLength)\n\
    \        val intArray32 = intArray31.slice(1, intArrayLength\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr5m6hkds.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr5m6hkds.scala:19:41\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mintArray\e[0m = intValue.toString.toIntArray\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpr5m6hkds.scala:52:5 ---------------------\e[0m\e\
    [0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArrayDiff\
    \ = intArrayMax - intArrayMin\n        val intArrayDiffAbs = intArrayDiff.abs\n\
    \        val intArrayDiffAbsMax = intArrayDiffAbs.max\n        val intArrayDiffAbsMin\
    \ = intArrayDiffAbs.min\n        val intArrayDiffAbsMinAbs = intArrayDiffAbsMin\
    \ - intArrayDiffAbsMax\n        val intArrayDiffAbsMinAbsMax = intArrayDiffAbsMinAbs.max\n\
    \        val intArrayDiffAbsMinAbsMaxAbs = intArrayDiffAbsMinAbsMax.abs\n    \
    \    val intArrayDiffAbsMinAbsMaxAbsMax = intArrayDiffAbsMinAbsMaxAbs.max\n  \
    \      val intArrayDiffAbsMinAbsMaxAbsMaxAbs = intArrayDiffAbsMinAbsMaxAbsMax.abs\n\
    \        val intArrayDiffAbsMinAbsMaxAbsMaxAbsMax = intArrayDiffAbsMinAbsMaxAbsMaxAbsMax.abs\n\
    \        val intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbs = intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMax.abs\n\
    \        val intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMax = intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMax.abs\n\
    \        val intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbs = intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAbs.abs\n\
    \        val intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMax = intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAbsMax.abs\n\
    \        val intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAbs = intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAb\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplzeqcgpg.scala:27:55 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMinAbs\e\
    [0m = intArrayDiffAbsMin - intArrayDiffAbsMax\n\e[31m\e[31m   |\e[0m         \
    \                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue -\
    \ is not a member of Int => Int, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmplzeqcgpg.scala:32:51 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMinAbsMaxAbsMaxAbsMax\e\
    [0m = intArrayDiffAbsMinAbsMaxAbsMaxAbsMax.abs\n\e[31m\e[31m   |\e[0m        \
    \                                           ^\e[0m\n\e[31m   |\e[0m         Recursive\
    \ \e[33mvalue\e[0m \e[35mintArrayDiffAbsMinAbsMaxAbsMaxAbsMax\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzeqcgpg.scala:36:63\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMax\e[0m = intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAbsMax.abs\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m       Not found: intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAbsMax\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplzeqcgpg.scala:37:66\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAbs\e[0m = intArrayDiffAbsMinAbsMaxAbsMaxAbsMaxAbsMaxAbsMaxAb\n\
    \e[31m\e[31m   |\e[0m                "
  stdout: ''
  timestamp: 1659805543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal point\n        val intParts = parts.map(_.toInt)\
    \ // convert each part to int\n        val diff = intParts.zip(parts).map { case\
    \ (a, b) => math.abs(a - b) } // find differences between parts\n        val minDiff\
    \ = diff.min\n        val closestPart = diff.find(diff => diff == minDiff).get\n\
    \        val closestInteger = parts.map(_.toInt).find(_.toDouble == closestPart).get\n\
    \        closestInteger.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6uq__sle.scala:20:71 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdiff\e[0m = intParts.zip(parts).map\
    \ { \e[33mcase\e[0m (a, b) => math.abs(a - b) } \e[34m// find differences between\
    \ parts\e[0m\n\e[31m\e[31m   |\e[0m                                          \
    \                           ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\
    \e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m\
    \   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m \
    \ (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte):\
    \ Int\n\e[31m   |\e[0m match arguments ((b : String))\n\e[31m\e[31m-- Error: /tmp/tmp6uq__sle.scala:20:77\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36mdiff\e[0m = intParts.zip(parts).map { \e[33mcase\e[0m (a,\
    \ b) => math.abs(a - b) } \e[34m// find differences between parts\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \             ^\e[0m\n\e[31m   |\e[0m                                        \
    \  No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m             \
    \                             where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659805542
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        if (diff\
    \ < 0)\n            math.round(min + diff)\n        else\n            math.round(max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6kc0g4us.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6kc0g4us.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val smallest = nums.min\n     \
    \   val largest = nums.max\n        if (smallest == largest) {\n            smallest\n\
    \        } else {\n            val diff = largest - smallest\n            if (diff\
    \ < 1) {\n                smallest + diff\n            } else {\n            \
    \    smallest - diff\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsj1rm5ak.scala:34)\n\tat Problem.main(tmpsj1rm5ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805545
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0).toLong // convert before decimal to long\n\
    \        val after = parts(1).toLong // convert after decimal to long\n      \
    \  val difference = after - before // get the difference\n        val closest\
    \ = (difference + before.toLong) / 2\n        closest.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpbawr5_9l.scala:20)\n\tat Problem$.main(tmpbawr5_9l.scala:26)\n\
    \tat Problem.main(tmpbawr5_9l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toLong\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArray\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpche2gt9g.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpche2gt9g.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpche2gt9g.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpche2gt9g.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpche2gt9g.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805545
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArraySum\
    \ = intArray.sum\n        val intArrayDifference = intArraySum - intArray(0)\n\
    \        val intArrayDifferenceAbs = intArrayDifference / intArrayLength\n   \
    \     val intArrayDifferenceFloor = math.floor(intArrayDifferenceAbs)\n      \
    \  val intArrayDifferenceCeil = math.ceil(intArrayDifferenceAbs)\n        val\
    \ intArrayDifferenceFloorMod = intArrayDifferenceFloor % intArrayLength\n    \
    \    val intArrayDifferenceCeilMod = intArrayDifferenceCeil % intArrayLength\n\
    \        val intArrayDifferenceFloorModAbs = intArrayDifferenceFloorMod / intArrayLength\n\
    \        val intArrayDifferenceCeilModAbs = intArrayDifferenceCeilMod / intArrayLength\n\
    \        val intArrayDifferenceFloorModAbsCeil = intArrayDifferenceFloorModAbs\
    \ + intArrayDifferenceCeilModAbs\n        val intArrayDifferenceFloorModAbsFloor\
    \ = intArrayDifferenceFloorModAbs - intArrayDifferenceFloorModAbsCeil\n      \
    \  val intArrayDifferenceFloorModAbsFloorMod = intArrayDifferenceFloorModAbsFloor\
    \ % intArrayLength\n        val intArrayDifferenceFloorModAbsFloorModCeil = intArrayDifferenceFloorModAbsFloorMod\
    \ % intArrayLength\n        val intArrayDifferenceFloorModAbsFloorModFloor = intArrayDifferenceFloorModAbsFloorMod\
    \ - intArrayDifferenceFloorModAbsFloorModCeil\n        val intArrayDifferenceFloorModAbsFloorModFloorMod\
    \ = intArrayDifferenceFloorModAbsFloorMod - intArrayDifferenceFloorModAbsFloorModFloor\n\
    \        val intArrayDifferenceFloorModAbsFloorModFloorModCeil = intArrayDifferenceFloorModAbsFloorModFloor\
    \ - intArrayDifferenceFloorModAbsFloorModFloorMod\n        val intArrayDifferenceFloorModAbsFloorModFloorModFloor\
    \ = intArrayDifferenceFloorModAbsFloorModFloor - intArrayDifferenceFloorModAbsFloorModFloorModCeil\n\
    \        val intArrayDifferenceFloorModAbsFloorModFloorModFloorMod = intArrayDifferenceFloorModAbsFloorModFloorMod\
    \ - intArrayDifferenceFloorModAbsFloorModFloorModFloor\n        val intArrayDifferenceFloorModAbsFloor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl_w7c_s5.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpl_w7c_s5.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805543
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal point\
    \ and one after\n        val before = parts(0)\n        val after = parts(1)\n\
    \        val beforeInt = before.toInt\n        val afterInt = after.toInt\n  \
    \      val diff = Math.abs(afterInt - beforeInt)\n        if (diff < 1) {\n  \
    \          afterInt\n        } else {\n            beforeInt\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpz575xw9f.scala:20)\n\tat Problem$.main(tmpz575xw9f.scala:31)\n\
    \tat Problem.main(tmpz575xw9f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsDouble = intValue.asInstanceOf[Double]\n        val intValueAsFloat\
    \ = intValue.asInstanceOf[Float]\n        val intValueAsInt = intValue.asInstanceOf[Int]\n\
    \        val intValueAsShort = intValue.asInstanceOf[Short]\n        val intValueAsByte\
    \ = intValue.asInstanceOf[Byte]\n        val intValueAsChar = intValue.asInstanceOf[Char]\n\
    \        val intValueAsBoolean = intValue.asInstanceOf[Boolean]\n        val intValueAsLongLong\
    \ = intValue.asInstanceOf[LongLong]\n        val intValueAsDoubleDouble = intValue.asInstanceOf[DoubleDouble]\n\
    \        val intValueAsFloatFloat = intValue.asInstanceOf[FloatFloat]\n      \
    \  val intValueAsIntInt = intValue.asInstanceOf[IntInt]\n        val intValueAsShortShort\
    \ = intValue.asInstanceOf[ShortShort]\n        val intValueAsByteByte = intValue.asInstanceOf[ByteByte]\n\
    \        val intValueAsCharChar = intValue.asInstanceOf[CharChar]\n        val\
    \ intValueAsBooleanBoolean = intValue.asInstanceOf[BooleanBoolean]\n        val\
    \ intValueAsLongLongLong = intValue.asInstanceOf[LongLongLong]\n        val intValueAsDoubleDoubleDouble\
    \ = intValue.asInstanceOf[DoubleDoubleDouble]\n        val intValueAsFloatFloatFloat\
    \ = intValue.asInstanceOf[FloatFloatFloat]\n        val intValueAsIntIntInt =\
    \ intValue.asInstanceOf[IntIntInt]\n        val intValueAsShortShortShort = intValue.asInstanceOf[ShortShortShort]\n\
    \        val intValueAsByteByteByte = intValue.asInstanceOf[ByteByteByte]\n  \
    \      val intValueAsCharCharChar = intValue.asInstanceOf[CharCharChar]\n    \
    \    val intValueAsBooleanBooleanBoolean = intValue.asInstanceOf[BooleanBooleanBoolean]\n\
    \        val intValueAsLongLongLongLong = intValue.asInstanceOf[LongLongLongLong]\n\
    \        val intValueAsDoubleDoubleDoubleDouble = intValue.asInstanceOf[DoubleDoubleDoubleDouble]\n\
    \        val intValueAsFloatFloatFloatFloat = intValue.asInstanceOf[FloatFloatFloatFloat]\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6e2njdxe.scala:46:11 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp6e2njdxe.scala:27:55 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mintValueAsLongLong\e[0m\
    \ = intValue.asInstanceOf[\e[35mLongLong\e[0m]\n\e[31m\e[31m   |\e[0m        \
    \                                               ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                Not found: type LongLong\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6e2njdxe.scala:28:59\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mintValueAsDoubleDouble\e[0m = intValue.asInstanceOf[\e[35mDoubleDouble\e[0m]\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \     Not found: type DoubleDouble\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6e2njdxe.scala:29:57 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mintValueAsFloatFloat\e[0m = intValue.asInstanceOf[\e\
    [35mFloatFloat\e[0m]\n\e[31m\e[31m   |\e[0m                                  \
    \                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                         Not found: type FloatFloat\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6e2njdxe.scala:30:53 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mintValueAsIntInt\e[0m =\
    \ intValue.asInstanceOf[\e[35mIntInt\e[0m]\n\e[31m\e[31m   |\e[0m            \
    \                                         ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                "
  stdout: ''
  timestamp: 1659805546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = (max - min).toLong\n\
    \        val closest = (min + diff) / 2\n        val diff = math.abs(closest -\
    \ value)\n        if (diff < 1) return closest\n        else return closest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpba4hn6xf.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mdiff\e[0m = math.abs(closest\
    \ - value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiff is already defined as \e[33mvalue\e[0m \e[35mdiff\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpba4hn6xf.scala:19:23 -----------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpba4hn6xf.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659805545
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeInt = before.toInt\n        val afterInt = after.toInt\n        val\
    \ diff = afterInt - beforeInt\n        if (diff < 0)\n            afterInt + diff\n\
    \        else\n            beforeInt + diff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp5kmp01ul.scala:20)\n\tat Problem$.main(tmp5kmp01ul.scala:30)\n\
    \tat Problem.main(tmp5kmp01ul.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8bbt9uxs.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8bbt9uxs.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal point\n        val intPart = parts(0)\n\
    \        val decimalPart = parts(1)\n        val intPartAsLong = intPart.toLong\n\
    \        val decimalPartAsLong = decimalPart.toLong\n        val intPartAsDouble\
    \ = intPartAsLong.toDouble\n        val decimalPartAsDouble = decimalPartAsLong.toDouble\n\
    \        val intPartAsInt = intPartAsLong.toInt\n        val decimalPartAsInt\
    \ = decimalPartAsLong.toInt\n        val intPartAsLongLong = intPartAsLong.toLong\n\
    \        val decimalPartAsLongLong = decimalPartAsLong.toLong\n        val intPartAsInt\
    \ = intPartAsLong.toInt\n        val decimalPartAsInt = decimalPartAsLong.toInt\n\
    \        val intPartAsLongLong = intPartAsLong.toLong\n        val decimalPartAsLongLong\
    \ = decimalPartAsLong.toLong\n        val intPartAsInt = intPartAsLong.toInt\n\
    \        val decimalPartAsInt = decimalPartAsLong.toInt\n        val intPartAsLongLong\
    \ = intPartAsLong.toLong\n        val decimalPartAsLongLong = decimalPartAsLong.toLong\n\
    \        val intPartAsInt = intPartAsLong.toInt\n        val decimalPartAsInt\
    \ = decimalPartAsLong.toInt\n        val intPartAsLongLong = intPartAsLong.toLong\n\
    \        val decimalPartAsLongLong = decimalPartAsLong.toLong\n        val intPartAsInt\
    \ = intPartAsLong.toInt\n        val decimalPartAsInt = decimalPartAsLong.toInt\n\
    \        val intPartAsLongLong = intPartAsLong.toLong\n        val decimalPartAsLongLong\
    \ = decimalPartAsLong.toLong\n        val intPartAsInt = intPartAsLong.toInt\n\
    \        val decimalPartAsInt = decimalPartAsLong.toInt\n        val intPartAsLongLong\
    \ = intPartAsLong.toLong\n        val decimalPartAsLongLong = decimalPartAsLong.toLong\n\
    \        val intPartAsInt = intPartAsLong.toInt\n        val decimalPartAsInt\
    \ = decimalPartAsLong.toInt\n        val intPartAsLongLong = intPartAsLong.toLong\n\
    \        val decimalPartAsLongLong = decimalPartAsLong.toLong\n        val intPartAsInt\
    \ = intPartAsLong.toInt\n        val decimalPartAsInt = decimalPart\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxxabs5am.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mintPartAsInt\e[0m = intPartAsLong.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mintPartAsInt is already defined as \e[33mvalue\e[0m \e[35mintPartAsInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxxabs5am.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mdecimalPartAsInt\e[0m = decimalPartAsLong.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalPartAsInt is already defined as \e[33mvalue\e[0m \e\
    [35mdecimalPartAsInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxxabs5am.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mintPartAsLongLong\e[0m =\
    \ intPartAsLong.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintPartAsLongLong is already defined as \e[33mvalue\e[0m \e\
    [35mintPartAsLongLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxxabs5am.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mdecimalPartAsLongLong\e\
    [0m = decimalPartAsLong.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalPartAsLongLong is already defined as \e[33mvalue\e\
    [0m \e[35mdecimalPartAsLongLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxxabs5am.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mintPartAsInt\e[0m = int"
  stdout: ''
  timestamp: 1659805548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArray\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8mr3wl6u.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayIndex\
    \ = (intArrayLength - 1) match {\n            case 0 => 0\n            case 1\
    \ => 1\n            case _ => {\n                val intArrayDiff = intArrayIndex\
    \ - intArrayLength\n                if (intArrayDiff < 0)\n                  \
    \  intArrayIndex\n                else\n                    intArrayIndex - 1\n\
    \            }\n        }\n        val intArrayDiff = intArrayIndex - intArrayLength\n\
    \        if (intArrayDiff < 0)\n            intArrayLength\n        else\n   \
    \         intArrayLength - 1\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqv4697f2.scala:25:35 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mintArrayDiff\e[0m\
    \ = intArrayIndex - intArrayLength\n\e[31m\e[31m   |\e[0m                    \
    \               ^\e[0m\n\e[31m   |\e[0m                                Recursive\
    \ \e[33mvalue\e[0m \e[35mintArrayIndex\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpqv4697f2.scala:27:20 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    intArrayIndex\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    Recursive \e\
    [33mvalue\e[0m \e[35mintArrayIndex\e[0m needs type\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpqv4697f2.scala:29:20 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    intArrayIndex - \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m               \
    \     Recursive \e[33mvalue\e[0m \e[35mintArrayIndex\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659805546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        val closestInt = math.round(closest)\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0oia9orw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0oia9orw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").toList\n        val numsAsLong = nums.map(_.toLong)\n\
    \        val numsAsDouble = nums.map(_.toDouble)\n        val numsAsLongs = nums.map(_.toLong)\n\
    \        val numsAsDoubles = nums.map(_.toDouble)\n        val numsAsLongsMinus1\
    \ = nums.map(_.toLong - 1)\n        val numsAsDoublesMinus1 = nums.map(_.toDouble\
    \ - 1)\n        val numsAsLongsMinus1Plus1 = nums.map(_.toLong - 1 + 1)\n    \
    \    val numsAsDoublesMinus1Plus1 = nums.map(_.toDouble - 1 + 1)\n        val\
    \ numsAsLongsMinus1Plus1Plus1 = nums.map(_.toLong - 1 + 1 + 1)\n        val numsAsDoublesMinus1Plus1Plus1\
    \ = nums.map(_.toDouble - 1 + 1 + 1)\n        val numsAsLongsMinus1Plus1Plus1Plus1\
    \ = nums.map(_.toLong - 1 + 1 + 1 + 1)\n        val numsAsDoublesMinus1Plus1Plus1Plus1\
    \ = nums.map(_.toDouble - 1 + 1 + 1 + 1)\n        val numsAsLongsMinus1Plus1Plus1Plus1Plus1\
    \ = nums.map(_.toLong - 1 + 1 + 1 + 1 + 1)\n        val numsAsDoublesMinus1Plus1Plus1Plus1Plus1\
    \ = nums.map(_.toDouble - 1 + 1 + 1 + 1 + 1 + 1)\n        val numsAsLongsMinus1Plus1Plus1Plus1Plus1Plus1\
    \ = nums.map(_.toLong - 1 + 1 + 1 + 1 + 1 + 1 + 1)\n        val numsAsDoublesMinus1Plus1Plus1Plus1Plus1Plus1\
    \ = nums.map(_.toDouble - 1 + 1 + 1 + 1 + 1 + 1 + 1)\n        val numsAsLongsMinus1Plus1Plus1Plus1Plus1Plus1Plus1\
    \ = nums.map(_.toLong - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)\n        val numsAsDoublesMinus1Plus1Plus1Plus1Plus1Plus1Plus1\
    \ = nums.map(_.toDouble - 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)\n        val\
    \ numsAsLongsMinus1Plus1Plus1Plus1Plus1Plus1Plus1Plus1 = nums.map(_.toLong - 1\
    \ + 1 + 1 + 1 + \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpblqbv92w.scala:37:102 --------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnumsAsLongsMinus1Plus1Plus1Plus1Plus1Plus1Plus1Plus1\e\
    [0m = nums.map(_.toLong - \e[31m1\e[0m + \e[31m1\e[0m + \e[31m1\e[0m + \e[31m1\e\
    [0m + \n\e[31m\e[31m   |\e[0m                                                \
    \                                                      ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpblqbv92w.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        if\
    \ (diff > 0) min else max\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmptge78_e4.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmptge78_e4.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\");\n        val intPart = parts(0);\n        val fractionPart\
    \ = parts(1);\n        val fractionPartAsInt = fractionPart.toInt;\n        val\
    \ intPartAsInt = intPart.toInt;\n        val fractionPartAsLong = fractionPartAsInt\
    \ * Math.pow(10, fractionPartAsInt.length);\n        val intPartAsLong = intPartAsInt\
    \ * Math.pow(10, intPartAsInt.length);\n        val fractionPartAsDouble = fractionPartAsLong.toDouble;\n\
    \        val intPartAsDouble = intPartAsLong.toDouble;\n        val closestDouble\
    \ = Math.abs(intPartAsDouble - fractionPartAsDouble);\n        val closestLong\
    \ = Math.abs(intPartAsLong - fractionPartAsLong);\n        if (closestDouble <\
    \ closestLong) {\n            return intPartAsLong\n        } else {\n       \
    \     return intPartAsDouble\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3xsy8r_t.scala:23:84 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mfractionPartAsLong\e[0m\
    \ = fractionPartAsInt * Math.pow(\e[31m10\e[0m, fractionPartAsInt.length);\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \               value length is not a member of Int\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp3xsy8r_t.scala:24:69 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mval\e[0m \e[36mintPartAsLong\e[0m = intPartAsInt\
    \ * Math.pow(\e[31m10\e[0m, intPartAsInt.length);\n\e[31m\e[31m   |\e[0m     \
    \                                                   ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                     value length is not a member\
    \ of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3xsy8r_t.scala:30:19\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mreturn\e[0m\
    \ intPartAsLong\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                   Found:    (intPartAsLong : Double)\n\e[31m   |\e\
    [0m                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3xsy8r_t.scala:32:19 --------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m            \e[33mreturn\e[0m intPartAsDouble\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        Found:    (intPartAsDouble : Double)\n\e[31m   |\e[0m               \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = max - min\n        val closest = (min + diff)\
    \ / 2\n        val closestLong = closest.toLong\n        closestLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2sphl6ti.scala:27)\n\tat Problem.main(tmp2sphl6ti.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").toList\n        val numsAsLong = nums.map(_.toLong)\n\
    \        val min = numsAsLong.min\n        val max = numsAsLong.max\n        val\
    \ diff = (max - min) / 2\n        val closest = (min + diff)\n        val closestAsLong\
    \ = closest.toLong\n        val closestAsString = closestAsLong.toString\n   \
    \     closestAsString\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpihjq5bxr.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        closestAsString\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (closestAsString : String)\n\e[31m   |\e[0m        Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        if\
    \ (diff < 0)\n            math.round(min + diff)\n        else\n            math.round(max)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmppkp67250.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmppkp67250.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toLong)\n        val min = math.min(nums)\n   \
    \     val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2\n        val closestDiff = math.abs(closest - diff)\n    \
    \    if (closestDiff < diff) {\n            closest\n        } else {\n      \
    \      math.round(closest)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpp73b5lqr.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpp73b5lqr.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Long]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        val closestInt = math.round(closest)\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpoi2nw1a_.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpoi2nw1a_.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805549
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = parts.min\n        val\
    \ max = parts.max\n        val diff = max - min\n        val closest = (min +\
    \ diff) / 2\n        if (diff < 0)\n            closest - min\n        else\n\
    \            closest + min\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphplblkq6.scala:29)\n\tat Problem.main(tmphplblkq6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val integers = numbers.map(_.toInt)\n\
    \        val differences = numbers.zip(integers).map {\n            case (number,\
    \ integer) => math.abs(number - integer)\n        }\n        val closestDifference\
    \ = differences.min\n        val closestInteger = differences.max\n        val\
    \ closestIntegers = numbers.zip(integers).map {\n            case (number, integer)\
    \ => math.abs(number - integer) == closestDifference ? integer : number\n    \
    \    }\n        closestIntegers.max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmu2way9q.scala:21:54 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m (number, integer) => math.abs(number\
    \ - integer)\n\e[31m\e[31m   |\e[0m                                          \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpmu2way9q.scala:23:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestDifference\e[0m =\
    \ differences.min\n\e[31m\e[31m   |\e[0m                                     \
    \          ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mDeprecatedDoubleOrdering\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35mmin\e[0m\
    \ in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpmu2way9q.scala:24:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mclosestInteger\e[0m = differences.max\n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedDoubleOrdering\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmu2way9q.scala:26:98 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mcase\e[0m (number, integer) => math.abs(number\
    \ - integer) == closestDifference ? integer : number\n\e[31m\e[31"
  stdout: ''
  timestamp: 1659805555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.asInstanceOf[String]\n\
    \        val numArray = num.toDouble.split('.').map(_.toLong)\n        val numArrayLength\
    \ = numArray.length\n        val numArray2 = numArray.dropRight(numArrayLength)\n\
    \        val numArray3 = numArray2.dropRight(numArrayLength)\n        val numArray4\
    \ = numArray3.dropRight(numArrayLength)\n        val numArray5 = numArray4.dropRight(numArrayLength)\n\
    \        val numArray6 = numArray5.dropRight(numArrayLength)\n        val numArray7\
    \ = numArray6.dropRight(numArrayLength)\n        val numArray8 = numArray7.dropRight(numArrayLength)\n\
    \        val numArray9 = numArray8.dropRight(numArrayLength)\n        val numArray10\
    \ = numArray9.dropRight(numArrayLength)\n        val numArray11 = numArray10.dropRight(numArrayLength)\n\
    \        val numArray12 = numArray11.dropRight(numArrayLength)\n        val numArray13\
    \ = numArray12.dropRight(numArrayLength)\n        val numArray14 = numArray13.dropRight(numArrayLength)\n\
    \        val numArray15 = numArray14.dropRight(numArrayLength)\n        val numArray16\
    \ = numArray15.dropRight(numArrayLength)\n        val numArray17 = numArray16.dropRight(numArrayLength)\n\
    \        val numArray18 = numArray17.dropRight(numArrayLength)\n        val numArray19\
    \ = numArray18.dropRight(numArrayLength)\n        val numArray20 = numArray19.dropRight(numArrayLength)\n\
    \        val numArray21 = numArray20.dropRight(numArrayLength)\n        val numArray22\
    \ = numArray21.dropRight(numArrayLength)\n        val numArray23 = numArray22.dropRight(numArrayLength)\n\
    \        val numArray24 = numArray23.dropRight(numArrayLength)\n        val numArray25\
    \ = numArray24.dropRight(numArrayLength)\n        val numArray26 = numArray25.dropRight(numArrayLength)\n\
    \        val numArray27 = numArray26.dropRight(numArrayLength)\n        val numArray28\
    \ = numArray27.dropRight(numArrayLength)\n        val numArray29 = numArray28.dropRight(numArrayLength)\n\
    \        val numArray30 = numArray29.dropRight(numArrayLength)\n        val numArray31\
    \ = numArray30.dropRight(numArrayLength)\n        val numArray32 = num\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj47uw2cg.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnumArray\e[0m = num.toDouble.split(\e\
    [31m'.'\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value split is not a member of Double\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj47uw2cg.scala:52:5 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805554
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeAsLong = before.toLong\n        val afterAsLong = after.toLong\n \
    \       val difference = afterAsLong - beforeAsLong\n        if (difference <\
    \ 0)\n            beforeAsLong + difference\n        else\n            beforeAsLong\
    \ - difference\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp2vp44it0.scala:20)\n\tat Problem$.main(tmp2vp44it0.scala:30)\n\
    \tat Problem.main(tmp2vp44it0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val mid = math.round(min + (max\
    \ - min) / 2)\n        if (min == max) {\n            mid\n        } else {\n\
    \            if (mid < numbers(0)) {\n                closestInteger(value + \"\
    .0\")\n            } else {\n                closestInteger(value + \".1\")\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp42yjj7te.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp42yjj7te.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805552
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsDouble = intValue.asInstanceOf[Double]\n        val intValueAsInt\
    \ = intValue.asInstanceOf[Int]\n        val intValueAsFloat = intValue.asInstanceOf[Float]\n\
    \        val intValueAsString = intValue.asInstanceOf[String]\n        val intValueAsBigDecimal\
    \ = intValue.asInstanceOf[BigDecimal]\n        val intValueAsBigInteger = intValue.asInstanceOf[BigInteger]\n\
    \        val intValueAsBoolean = intValue.asInstanceOf[Boolean]\n        val intValueAsChar\
    \ = intValue.asInstanceOf[Char]\n        val intValueAsByte = intValue.asInstanceOf[Byte]\n\
    \        val intValueAsShort = intValue.asInstanceOf[Short]\n        val intValueAsBytes\
    \ = intValue.asInstanceOf[Bytes]\n        val intValueAsArray = intValue.asInstanceOf[Array[Byte]]\n\
    \        val intValueAsArrayOfByte = intValue.asInstanceOf[Array[Byte]]\n    \
    \    val intValueAsArrayOfShort = intValue.asInstanceOf[Array[Short]]\n      \
    \  val intValueAsArrayOfChar = intValue.asInstanceOf[Array[Char]]\n        val\
    \ intValueAsArrayOfInt = intValue.asInstanceOf[Array[Int]]\n        val intValueAsArrayOfLong\
    \ = intValue.asInstanceOf[Array[Long]]\n        val intValueAsArrayOfFloat = intValue.asInstanceOf[Array[Float]]\n\
    \        val intValueAsArrayOfDouble = intValue.asInstanceOf[Array[Double]]\n\
    \        val intValueAsArrayOfBigDecimal = intValue.asInstanceOf[Array[BigDecimal]]\n\
    \        val intValueAsArrayOfBigInteger = intValue.asInstanceOf[Array[BigInteger]]\n\
    \        val intValueAsArrayOfBoolean = intValue.asInstanceOf[Array[Boolean]]\n\
    \        val intValueAsArrayOfChar = intValue.asInstanceOf[Array[Char]]\n    \
    \    val intValueAsArrayOfByte = intValue.asInstanceOf[Array[Byte]]\n        val\
    \ intValueAsArrayOfShort = intValue.asInstanceOf[Array[Short]]\n        val intValueAsArrayOfBytes\
    \ = intValue.asInstanceOf[Array[Bytes]]\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpqbowf5bv.scala:46:11 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpqbowf5bv.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfChar\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mChar\e[0m]]\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfChar is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqbowf5bv.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfByte\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mByte\e[0m]]\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfByte is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfByte\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqbowf5bv.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfShort\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mShort\e[0m]]\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfShort is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfShort\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqbowf5bv.scala:25:57 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintValu"
  stdout: ''
  timestamp: 1659805555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toLong\n        val intArray = intValue.toString.toIntArray\n      \
    \  val intArrayLength = intArray.length\n        val closestInteger = intArray(0)\n\
    \        val closestIntegerDistance = intArray(0)\n        val closestIntegerDistanceSquare\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRoot = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf2 = intArray(0)\n        val closestIntegerDistanceSquareRootOf3\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf4 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf5 = intArray(0)\n        val closestIntegerDistanceSquareRootOf6\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf7 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf8 = intArray(0)\n        val closestIntegerDistanceSquareRootOf9\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf10 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf11 = intArray(0)\n        val closestIntegerDistanceSquareRootOf12\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf13 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf14 = intArray(0)\n        val closestIntegerDistanceSquareRootOf15\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf16 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf17 = intArray(0)\n        val closestIntegerDistanceSquareRootOf18\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf19 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf20 = intArray(0)\n        val closestIntegerDistanceSquareRootOf21\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf22 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf23 = intArray(0)\n        val closestIntegerDistanceSquareRootOf24\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf25 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf26 = intArray(0)\n        val closestIntegerDistanceSquareRootOf27\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf28 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf29 = intArray(0)\n        val closestIntegerDistanceSquareRootOf30\
    \ = intArray(0)\n        val closestIntegerDistanceSquareRootOf31 = intArray(0)\n\
    \        val closestIntegerDistanceSquareRootOf32 = intArray(0)\n        val closestIntegerDistanceSquareRootOf33\
    \ = intArray(0)\n        val closest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2sucyfdr.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2sucyfdr.scala:19:41\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mintArray\e[0m = intValue.toString.toIntArray\n\e[31m\e[31m   |\e[0m      \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \              value toIntArray is not a member of String\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2sucyfdr.scala:58:5 ---------------------\e[0m\e\
    [0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = Math.min(numbers)\n\
    \        val largest = Math.max(numbers)\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            smallest + difference\n        else\n\
    \            smallest - difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6ffb39mg.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = Math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\
    \e[31m   |\e[0m (x$0: Float, x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1:\
    \ Long): Long\n\e[31m   |\e[0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp6ffb39mg.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = Math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mobject\e[0m \e[35mMath\e[0m with types\n\
    \e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\e[31m   |\e[0m (x$0: Float,\
    \ x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1: Long): Long\n\e[31m   |\e\
    [0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArraySum\
    \ = intArray(0) + intArray(1) + intArray(2) + intArray(3) + intArray(4) + intArray(5)\
    \ + intArray(6) + intArray(7) + intArray(8) + intArray(9)\n        val intArrayDiff\
    \ = intArraySum - intArrayMax\n        val intArrayDiffAbs = intArrayDiff.abs\n\
    \        val intArrayDiffAbsMin = intArrayDiffAbs.min\n        val intArrayDiffAbsMax\
    \ = intArrayDiffAbs.max\n        val intArrayDiffAbsSum = intArrayDiffAbs.sum\n\
    \        val intArrayDiffAbsSumMin = intArrayDiffAbsSum.min\n        val intArrayDiffAbsSumMax\
    \ = intArrayDiffAbsSum.max\n        val intArrayDiffAbsSumMinAbs = intArrayDiffAbsSumMin\
    \ / intArrayDiffAbsSumMax\n        val intArrayDiffAbsSumMaxAbs = intArrayDiffAbsSumMax\
    \ / intArrayDiffAbsSumMin\n        val intArrayDiffAbsSumMinAbsMax = intArrayDiffAbsSumMinAbs\
    \ * intArrayDiffAbsSumMaxAbs\n        val intArrayDiffAbsSumMinAbsMaxAbs = intArrayDiffAbsSumMinAbsMax\
    \ * intArrayDiffAbsSumMaxAbs\n        val intArrayDiffAbsSumMinAbsMaxAbsSum =\
    \ intArrayDiffAbsSumMinAbsMaxAbs * intArrayDiffAbsSumMaxAbsSum\n        val intArrayDiffAbsSumMinAbsMaxAbsSumMin\
    \ = intArrayDiffAbsSumMinAbsMaxAbsSum * intArrayDiffAbsSumMinAbsMaxAbsSum\n  \
    \      val intArrayDiffAbsSumMinAbsMaxAbsSumMax = intArrayDiffAbsSumMinAbsMaxAbsSumMin\
    \ * intArrayDiffAbsSumMaxAbsSumMax\n        val intArrayDiffAbsSumMinAbsMaxAbsSumMaxAbs\
    \ = intArrayDiffAbsSumMinAbsMaxAbsSumMax * intArrayDiffAbsSumMaxAbsSumMaxAbs\n\
    \        val int\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdwue7e9a.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdwue7e9a.scala:28:49\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffAbsSum\e[0m = intArrayDiffAbs.sum\n\e[31m\e[31m   |\e[0m     \
    \                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                          value sum is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpdwue7e9a.scala:40:5 ---------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805557
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val difference = abs(intValue - intValue)\n        val\
    \ closestInteger = intValue + difference\n        closestInteger\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmpt9_iev2s.scala:18)\n\
    \tat Problem$.main(tmpt9_iev2s.scala:25)\n\tat Problem.main(tmpt9_iev2s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmps6os9_lf.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val roundTo = difference / 2\n        smallest + roundTo\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8_rko3pe.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8_rko3pe.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805553
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val closestToZero = largest - smallest * math.abs(difference)\n     \
    \   math.round(closestToZero)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpeyq5zxgm.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpeyq5zxgm.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Long]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805555
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val numsSorted = nums.sort\n  \
    \      val closestNum = numsSorted.last\n        val closestNumIndex = numsSorted.lastIndex\n\
    \        val closestNumDiff = closestNum - closestNumIndex\n        val closestNumDiffAbs\
    \ = Math.abs(closestNumDiff)\n        val closestNumDiffAbsMax = Math.max(closestNumDiffAbs,\
    \ 1)\n        val closestNumDiffAbsMin = Math.min(closestNumDiffAbs, 1)\n    \
    \    val closestNumDiffAbsMaxDiff = Math.max(closestNumDiffAbsMax, closestNumDiffAbsMin)\n\
    \        val closestNumDiffAbsMaxDiffDiff = Math.min(closestNumDiffAbsMaxDiff,\
    \ closestNumDiffAbsMax)\n        val closestNumDiffAbsMaxDiffDiffDiff = Math.max(closestNumDiffAbsMaxDiffDiff,\
    \ closestNumDiffAbsMax)\n        val closestNumDiffAbsMaxDiffDiffDiffDiff = Math.min(closestNumDiffAbsMaxDiffDiffDiff,\
    \ closestNumDiffAbsMax)\n        val closestNumDiffAbsMaxDiffDiffDiffDiffDiff\
    \ = Math.max(closestNumDiffAbsMaxDiffDiffDiffDiff, closestNumDiffAbsMax)\n   \
    \     val closestNumDiffAbsMaxDiffDiffDiffDiffDiff = Math.min(closestNumDiffAbsMaxDiffDiffDiffDiff,\
    \ closestNumDiffAbsMax)\n        val closestNumDiffAbsMaxDiffDiffDiffDiffDiff\
    \ = Math.max(closestNumDiffAbsMaxDiffDiffDiffDiff, closestNumDiffAbsMax)\n   \
    \     val closestNumDiffAbsMaxDiffDiffDiffDiffDiff = Math.min(closestNumDiffAbsMaxDiffDiffDiffDiffDiff,\
    \ closestNumDiffAbsMax)\n        val closestNumDiffAbsMaxDiffDiffDiffDiffDiffDiff\
    \ = Math.max(closestNumDiffAbsMaxDiffDiffDiffDiffDiff, closestNumDiffAbsMax)\n\
    \        val closestNumDiffAbsMaxDiffDiffDiffDiffDiffDiff = Math.min(closestNumDiffAbsMaxDiffDiffDiffDiffDiffDiff,\
    \ closestNumDiffAbsMax)\n        val closestNumDiffAbsMaxDiffDiffDiffDiffDiffDiff\
    \ = Math.max(closestNumDiffAbsMaxDiffDiffDiffDiffDiffDiff, closestNumDiffAbsMax)\n\
    \        val closestNumDiffAbsMaxDiffDiffDiffDiffDiffDiff = Math.min(closestNumDiffAbsMaxDiffDiffDiffDiffDiffDiff,\
    \ closestNumDiffAbsMax)\n        val closestNumDiffAb\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpez43s923.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpez43s923.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff\e[0m = Math.min(closestNumDiffAbsMaxDiffDiffDiffDiff,\
    \ closestNumDiffAbsMax)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff is already defined\
    \ as \e[33mvalue\e[0m \e[35mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpez43s923.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff\e\
    [0m = Math.max(closestNumDiffAbsMaxDiffDiffDiffDiff, closestNumDiffAbsMax)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff is already defined\
    \ as \e[33mvalue\e[0m \e[35mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpez43s923.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff\e\
    [0m = Math.min(closestNumDiffAbsMaxDiffDiffDiffDiffDiff, closestNumDiffAbsMax)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumDiffAbsMaxDiffDiffDiffDiffDiff is already defined\
    \ as \e[33mvalue\e[0m \e[35mclosestNumDiffAbsMaxDiffDiffDiffDif"
  stdout: ''
  timestamp: 1659805559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeInt = before.toInt\n        val afterInt = after.toInt\n        val\
    \ diff = (afterInt - beforeInt)\n        val closest = (beforeInt + diff).round\n\
    \        closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpnks4ez2x.scala:20)\n\tat Problem$.main(tmpnks4ez2x.scala:28)\n\
    \tat Problem.main(tmpnks4ez2x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsDouble = intValue.asInstanceOf[Double]\n        val intValueAsInt\
    \ = intValue.asInstanceOf[Int]\n        val intValueAsFloat = intValue.asInstanceOf[Float]\n\
    \        val intValueAsChar = intValue.asInstanceOf[Char]\n        val intValueAsBoolean\
    \ = intValue.asInstanceOf[Boolean]\n        val intValueAsString = intValue.asInstanceOf[String]\n\
    \        val intValueAsArray = intValue.asInstanceOf[Array[Char]]\n        val\
    \ intValueAsArrayOfChar = intValue.asInstanceOf[Array[Char]]\n        val intValueAsArrayOfString\
    \ = intValue.asInstanceOf[Array[String]]\n        val intValueAsArrayOfArrayOfChar\
    \ = intValue.asInstanceOf[Array[Array[Char]]]\n        val intValueAsArrayOfArrayOfString\
    \ = intValue.asInstanceOf[Array[Array[String]]]\n        val intValueAsArrayOfArrayOfArrayOfChar\
    \ = intValue.asInstanceOf[Array[Array[Array[Char]]]]\n        val intValueAsArrayOfArrayOfArrayOfString\
    \ = intValue.asInstanceOf[Array[Array[Array[String]]]]\n        val intValueAsArrayOfArrayOfArrayOfArrayOfChar\
    \ = intValue.asInstanceOf[Array[Array[Array[Array[Char]]]]]\n        val intValueAsArrayOfArrayOfArrayOfArrayOfString\
    \ = intValue.asInstanceOf[Array[Array[Array[Array[String]]]]]\n        val intValueAsArrayOfArrayOfArrayOfArrayOfArrayOfChar\
    \ = intValue.asInstanceOf[Array[Array[Array[Array[Array[Char]]]]]]\n        val\
    \ intValueAsArrayOfArrayOfArrayOfArrayOfArrayOfString = intValue.asInstanceOf[Array[Array[Array[Array[Array[String]]]]]]\n\
    \        val intValueAsArrayOfArrayOfArrayOfArrayOfArrayOfArrayOfChar = intValue.asInstanceOf[Array[Array[Array[Array[Array[Array[Char]]]]]]]\n\
    \        val intValueAsArrayOfArrayOfArrayOfArrayOfArrayOfArrayOfString = intValue.asInstanceOf[Array[Array[Array[Array[Array[Array[String]]]]]]]\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_353_mvt.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        val closestInteger = math.round(closest)\n     \
    \   closestInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpbn5793d3.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpbn5793d3.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = (max - min).toInt\n\
    \        val closest = (min + diff) / 2\n        val closestInt = closest.toLong\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc35zjg3h.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc35zjg3h.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val closest = (min + max) / 2\n\
    \        if (closest == min) {\n            min\n        } else {\n          \
    \  max\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpw7coo0bx.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpw7coo0bx.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805527
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = parts.min\n        val\
    \ max = parts.max\n        if (min == max) {\n            return min\n       \
    \ }\n        if (min == 0) {\n            return max\n        }\n        if (max\
    \ == 0) {\n            return min\n        }\n        val diff = max - min\n \
    \       val diffAbs = Math.abs(diff)\n        val diffAbsMin = diffAbs / min\n\
    \        val diffAbsMax = diffAbs / max\n        if (diff < 0 && diffAbsMin <\
    \ diffAbsMax) {\n            return min\n        }\n        if (diff > 0 && diffAbsMax\
    \ < diffAbsMin) {\n            return max\n        }\n        return min + (diff\
    \ / min)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1w7tf60t.scala:44)\n\tat Problem.main(tmp1w7tf60t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.head, nums.last)\n\
    \        val max = math.max(nums.head, nums.last)\n        val diff = max - min\n\
    \        val round = math.round(diff * 0.5).toLong\n        math.max(min, round)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6c94ge1f.scala:27)\n\tat Problem.main(tmp6c94ge1f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0).trim\n        val after = parts(1).trim\n\
    \        val beforeInt = before.toInt\n        val afterInt = after.toInt\n  \
    \      val diff = Math.abs(beforeInt - afterInt)\n        val closest = Math.min(diff,\
    \ Math.abs(beforeInt + afterInt))\n        closest.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpzhdvno9u.scala:20)\n\tat Problem$.main(tmpzhdvno9u.scala:28)\n\
    \tat Problem.main(tmpzhdvno9u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\")\n        val int1 = numbers(0).toLong\n        val\
    \ int2 = numbers(1).toLong\n        val diff = (int2 - int1)\n        if (diff\
    \ < 0)\n            diff * -1\n        else\n            diff\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp64wcrzv9.scala:20)\n\tat Problem$.main(tmp64wcrzv9.scala:28)\n\
    \tat Problem.main(tmp64wcrzv9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split into integer and fraction\n        val fraction\
    \ = parts(1).toLong // fractional part\n        val integer = parts(0).toLong\
    \ // integer part\n        val difference = fraction - integer // difference between\
    \ fraction and integer\n        if (difference < 0)\n            fraction + difference\n\
    \        else\n            fraction - difference\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp_0dapc6h.scala:19)\n\tat Problem$.main(tmp_0dapc6h.scala:28)\n\
    \tat Problem.main(tmp_0dapc6h.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        val closestInt = math.round(closest)\n        closestInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3ds53oev.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3ds53oev.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into integer and fractional parts\n        val\
    \ fractionalPart = parts(1).toLong // fractional part is always a Long\n     \
    \   val integerPart = parts(0).toLong // integer part is always a Long\n     \
    \   val difference = fractionalPart - integerPart\n        if (difference < 0)\n\
    \            fractionalPart + 1\n        else\n            fractionalPart\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp8mqliov_.scala:19)\n\tat Problem$.main(tmp8mqliov_.scala:28)\n\
    \tat Problem.main(tmp8mqliov_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        val diff2 = math.abs(closest - value)\n        if\
    \ (diff2 < diff) {\n            closest\n        } else {\n            math.abs(value\
    \ - closest)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8atwtqky.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8atwtqky.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8atwtqky.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            math.abs(value - closest)\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal\n        val intParts = parts.map(_.toInt)\
    \ // convert to integers\n        val diffs = intParts.zip(intParts).map(x =>\
    \ Math.abs(x._1 - x._2)) // calculate differences\n        val maxDiff = diffs.max\
    \  // find max difference\n        val closestPart = diffs.find(x => x == maxDiff)\
    \  // find closest part\n        val closestPart = closestPart._1 // get closest\
    \ part\n        val closestInteger = closestPart.toLong // convert to long\n \
    \       return closestInteger\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxu4yykqx.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestPart\e[0m = closestPart._1\
    \ \e[34m// get closest part\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestPart is already defined as \e[33mvalue\e[0m \e[35mclosestPart\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpxu4yykqx.scala:24:41 ------------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclosestInteger\e[0m = closestPart.toLong\
    \ \e[34m// convert to long\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of\
    \ Option[Int], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            smallest + difference\n        else\n\
    \            smallest - difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpswpfn3iq.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpswpfn3iq.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Long]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val numsSorted = nums.sort\n  \
    \      val closestNum = numsSorted.last\n        val closestNumIndex = numsSorted.lastIndex\n\
    \        val closestNumDiff = closestNum - closestNumIndex\n        val closestNumDiffAbs\
    \ = Math.abs(closestNumDiff)\n        if (closestNumDiffAbs < 1) {\n         \
    \   closestNum\n        } else {\n            val closestNumDiffFloor = Math.floor(closestNumDiff)\n\
    \            if (closestNumDiffFloor == closestNumDiff) {\n                val\
    \ closestNumDiffCeil = Math.ceil(closestNumDiff)\n                if (closestNumDiffCeil\
    \ == closestNumDiff) {\n                    val closestNumDiffFloorCeil = Math.floor(closestNumDiffCeil)\n\
    \                    if (closestNumDiffFloorCeil == closestNumDiff) {\n      \
    \                  val closestNumDiffFloorFloorCeil = Math.ceil(closestNumDiffFloorCeil)\n\
    \                        if (closestNumDiffFloorFloorCeil == closestNumDiff) {\n\
    \                            val closestNumDiffFloorFloorCeil = Math.ceil(closestNumDiffFloorFloorCeil)\n\
    \                            if (closestNumDiffFloorFloorCeil == closestNumDiff)\
    \ {\n                                val closestNumDiffFloorFloorCeil = Math.ceil(closestNumDiffFloorFloorCeil)\n\
    \                                if (closestNumDiffFloorFloorCeil == closestNumDiff)\
    \ {\n                                    val closestNumDiffFloorFloorCeil = Math.ceil(closestNumDiffFloorCeil)\n\
    \                                    if (closestNumDiffFloorFloorCeil == closestNumDiff)\
    \ {\n                                        val closestNumDiffFloorFloorCeil\
    \ = Math.ceil(closestNumDiffFloorCeil)\n                                     \
    \   if (closestNumDiffFloorFloorCeil == closestNumDiff) {\n                  \
    \                          val closestNumDiffFloorFloorCeil = Math.ceil(closestNumDiffFloorCeil)\n\
    \                                            if (closestNumDiffFloorFloorCeil\
    \ == closestNumDiff) {\n                                                val closestNumDiffFloorFloorCeil\
    \ = Math.ceil(closestNumDiffFloorCeil)\n                                     \
    \           if (closestNumDiffFloorFloorCeil == closestNumDiff) {\n          \
    \                                          val closestNumDiffFloorFloorCeil =\
    \ Math.ceil(closestNumDiffFloorCeil)\n                                       \
    \             if (closestNumDiffFloorFloorCeil == closestNumDiff) {\n        \
    \                                                val closestNumDiffFloorFloorCeil\
    \ = Math.ceil(closestNumDiffFloorCeil)\n                                     \
    \                   if (closestNumDiffFloorFloorCeil == closestNumDiff) {\n  \
    \                                                          val closestNumDiffFloor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgp35m2sk.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgp35m2sk.scala:62:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpgp35m2sk.scala:19:30 ------------------------\e[0m\e[0m\n\
    \e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = nums.sort\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value\
    \ sort is not a member of Array[Int] - did you mean nums.wait?\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpgp35m2sk.scala:35:73 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                            \e[33mval\e[0m \e[36mclosestNumDiffFloorFloorCeil\e\
    [0m = Math.ceil(closestNumDiffFloorFloorCeil)\n\e[31m\e[31m   |\e[0m         \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                 Recursive \e[33mvalue\e[0m \e[35mclosestNumDiffFloorFloorCeil\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgp35m2sk.scala:37:77\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                     \
    \           \e[33mval\e[0m \e[36mclosestNumDiffFloorFloorCeil\e[0m = Math.ceil(closestNumDiffFloorFloorCeil)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^\e[0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e\
    [0m \e[35mclosestNumDiffFloorFloorCeil\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpgp35m2sk.scala:53:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m53 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 err"
  stdout: ''
  timestamp: 1659805565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toLong)\n        val min = math.min(nums)\n   \
    \     val max = math.max(nums)\n        if (min == max) {\n            return\
    \ min\n        }\n        val diff = max - min\n        if (diff < 1) {\n    \
    \        return math.round(min + diff)\n        }\n        val mid = min + (diff\
    \ / 2)\n        val midNum = math.round(mid)\n        if (midNum == mid) {\n \
    \           return mid\n        }\n        if (midNum < mid) {\n            return\
    \ math.round(midNum)\n        }\n        return math.round(midNum)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpe6cnonqs.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpe6cnonqs.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Long]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.trim\n        val intValueAsLong = intValue.toLong\n        val intValueAsDouble\
    \ = intValueAsLong.toDouble\n        val intValueAsInt = intValueAsDouble.round\n\
    \        val intValueAsLongAsInt = intValueAsInt.toLong\n        val intValueAsLongAsDouble\
    \ = intValueAsLongAsInt.toDouble\n        val intValueAsDoubleAsInt = intValueAsDoubleAsInt.round\n\
    \        val intValueAsDoubleAsLong = intValueAsDoubleAsLong.round\n        val\
    \ intValueAsDoubleAsLongAsInt = intValueAsDoubleAsLongAsInt.toLong\n        val\
    \ intValueAsDoubleAsLongAsDouble = intValueAsDoubleAsLongAsDouble.toDouble\n \
    \       val intValueAsDoubleAsLongAsDoubleAsInt = intValueAsDoubleAsLongAsDoubleAsInt.round\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLong = intValueAsDoubleAsLongAsDoubleAsLong.round\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLongAsInt = intValueAsDoubleAsLongAsDoubleAsLongAsInt.toLong\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLongAsDouble = intValueAsDoubleAsLongAsDoubleAsLongAsDouble.toDouble\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsInt = intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsInt.round\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLong = intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLong.round\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsInt = intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsInt.toLong\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsDouble = intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsDouble.toDouble\n\
    \        val intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsDoubleAsInt =\
    \ intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsDoubleAsInt.round\n    \
    \    val intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsDoubleAsLong = intValueAsDoubleAsLongAsDoubleAsLongAsDoubleAsLongAsDoubleAsLong.round\n\
    \        val intValueAsDouble\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpha_rpxt7.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpha_rpxt7.scala:24:36\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintValueAsDoubleAsInt\e[0m = intValueAsDoubleAsInt.round\n\e[31m\e[31m\
    \   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m        \
    \                Recursive \e[33mvalue\e[0m \e[35mintValueAsDoubleAsInt\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpha_rpxt7.scala:25:37\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintValueAsDoubleAsLong\e[0m = intValueAsDoubleAsLong.round\n\e[31m\e[31m\
    \   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m       \
    \                Recursive \e[33mvalue\e[0m \e[35mintValueAsDoubleAsLong\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpha_rpxt7.scala:26:42\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintValueAsDoubleAsLongAsInt\e[0m = intValueAsDoubleAsLongAsInt.toLong\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mintValueAsDoubleAsLongAsInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpha_rpxt7.scala:27:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintValueAsDoubleAsLongAsDouble\e[0m = intValueAsDoubleAsLongAsDouble.toDouble\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m               Recursive \e[33mvalue\e[0m \e[35mintValueAsDoubleAsLongAsDouble\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] C"
  stdout: ''
  timestamp: 1659805564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val diff = largest - smallest\n\
    \        val closest = (smallest + largest) / 2\n        val closestInteger =\
    \ math.round(diff * closest)\n        closestInteger\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3h0y_ckr.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3h0y_ckr.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmps6os9_lf.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0i__paxw.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").toList\n        val numsAsLongs = nums.map(_.toLong)\n\
    \        val min = numsAsLongs.min\n        val max = numsAsLongs.max\n      \
    \  val diff = max - min\n        val closestNum = min + diff / 2\n        closestNum.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc6ilogrs.scala:28)\n\tat Problem.main(tmpc6ilogrs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805568
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        val closest =\
    \ (min + diff) / 2\n        if (closest == min) {\n            closest\n     \
    \   } else {\n            closest - min\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppe8kd8qq.scala:30)\n\tat Problem.main(tmppe8kd8qq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallestDiff = math.min(numbers.map(math.abs))\n\
    \        val closestDiff = math.min(numbers.map(math.abs))\n        val closestInteger\
    \ = math.min(numbers.map(math.floor))\n        val closestInteger = math.min(numbers.map(math.ceil))\n\
    \        val closestInteger = math.min(numbers.map(math.round))\n        val closestInteger\
    \ = math.min(numbers.map(math.roundToInt))\n        val closestInteger = math.min(numbers.map(math.roundToLong))\n\
    \        val closestInteger = math.min(numbers.map(math.roundToDouble))\n    \
    \    val closestInteger = math.min(numbers.map(math.roundToFloat))\n        val\
    \ closestInteger = math.min(numbers.map(math.roundToShort))\n        val closestInteger\
    \ = math.min(numbers.map(math.roundToByte))\n        val closestInteger = math.min(numbers.map(math.roundToInt))\n\
    \        val closestInteger = math.min(numbers.map(math.roundToLong))\n      \
    \  val closestInteger = math.min(numbers.map(math.roundToDouble))\n        val\
    \ closestInteger = math.min(numbers.map(math.roundToFloat))\n        val closestInteger\
    \ = math.min(numbers.map(math.roundToShort))\n        val closestInteger = math.min(numbers.map(math.roundToByte))\n\
    \        val closestInteger = math.min(numbers.map(math.roundToInt))\n       \
    \ val closestInteger = math.min(numbers.map(math.roundToLong))\n        val closestInteger\
    \ = math.min(numbers.map(math.roundToDouble))\n        val closestInteger = math.min(numbers.map(math.roundToFloat))\n\
    \        val closestInteger = math.min(numbers.map(math.roundToShort))\n     \
    \   val closestInteger = math.min(numbers.map(math.roundToByte))\n        val\
    \ closestInteger = math.min(numbers.map(math.roundToInt))\n        val closestInteger\
    \ = math.min(numbers.map(math.roundToLong))\n        val closestInteger = math.min(numbers.map(math.roundToDouble))\n\
    \        val closestInteger = math.min(numbers.map(math.roundToFloat))\n     \
    \   val closestInteger = math.min(numbers.map(math.roundToShort))\n        val\
    \ closestInteger = math.min(numbers.map(math.roundToByte))\n        val closestInteger\
    \ = math.min(numbers.map(math.roundToInt))\n        val closestInteger = math.min(numbers.map(math.roundToLong))\n\
    \        val closestInteger = math.min(numbers.map(math.roundToDouble))\n    \
    \    val closestInteger = math.min(numbers.map(math.roundToFloat))\n        val\
    \ closestInteger = math.min(numbers.map(math.roundTo\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpemx1hq0b.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpemx1hq0b.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestInteger\e[0m = math.min(numbers.map(math.ceil))\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mclosestInteger is already defined as \e[33mvalue\e[0m \e[35mclosestInteger\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpemx1hq0b.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestInteger\e[0m = math.min(numbers.map(math.round))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestInteger is already defined as \e[33mvalue\e[0m \e[35mclosestInteger\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpemx1hq0b.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mclosestInteger\e[0m = math.min(numbers.map(math.roundToInt))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestInteger is already defined as \e[33mvalue\e[0m \e[35mclosestInteger\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpemx1hq0b.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mclosestInteger\e[0m = math.min(numbers.map(math.roundToLong))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestInteger is already defined as \e[33mvalue\e[0m \e[35mclosestInteger\e\
    [0m\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659805568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val intValue = numbers.toList.map(_.toInt)\n\
    \        val diffs = intValue.zip(diffInts(intValue)).filter(_._2 > 0).map(_._1)\n\
    \        val closestDiff = diffs.max\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffInt = diffs.maxBy(_._1)._2\n\
    \        val closestDiffInt = diffs.maxBy(_._1)._2\n        val closestDiffInt\
    \ = diffs.maxBy(_._1)._2\n        val closestDiffIn\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4605csie.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4605csie.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestDiffInt\e[0m = diffs.maxBy(_._1)._2\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclosestDiffInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mclosestDiffInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4605csie.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestDiffInt\e[0m = diffs.maxBy(_._1)._2\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclosestDiffInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mclosestDiffInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4605csie.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestDiffInt\e[0m = diffs.maxBy(_._1)._2\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclosestDiffInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mclosestDiffInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4605csie.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestDiffInt\e[0m = diffs.maxBy(_._1)._2\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclosestDiffInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mclosestDiffInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] N"
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val closestToZero = numbers.minBy(_.abs)\n\
    \        val closestToOne = numbers.maxBy(_.abs)\n        val closestToTwo = numbers.minBy(_.abs)\n\
    \        val closestToThree = numbers.maxBy(_.abs)\n        val closestToFour\
    \ = numbers.minBy(_.abs)\n        val closestToFive = numbers.maxBy(_.abs)\n \
    \       val closestToSix = numbers.minBy(_.abs)\n        val closestToSeven =\
    \ numbers.maxBy(_.abs)\n        val closestToEight = numbers.minBy(_.abs)\n  \
    \      val closestToNine = numbers.maxBy(_.abs)\n        val closestToTen = numbers.minBy(_.abs)\n\
    \        val closestToEleven = numbers.maxBy(_.abs)\n        val closestToTwelve\
    \ = numbers.minBy(_.abs)\n        val closestToThirteen = numbers.maxBy(_.abs)\n\
    \        val closestToFourteen = numbers.minBy(_.abs)\n        val closestToFifteen\
    \ = numbers.maxBy(_.abs)\n        val closestToSixteen = numbers.minBy(_.abs)\n\
    \        val closestToSeventeen = numbers.maxBy(_.abs)\n        val closestToEighteen\
    \ = numbers.minBy(_.abs)\n        val closestToNineteen = numbers.maxBy(_.abs)\n\
    \        val closestToTwenty = numbers.minBy(_.abs)\n        val closestToTwentyOne\
    \ = numbers.maxBy(_.abs)\n        val closestToTwentyTwo = numbers.minBy(_.abs)\n\
    \        val closestToTwentyThree = numbers.maxBy(_.abs)\n        val closestToTwentyFour\
    \ = numbers.minBy(_.abs)\n        val closestToTwentyFive = numbers.maxBy(_.abs)\n\
    \        val closestToTwentySix = numbers.minBy(_.abs)\n        val closestToTwentySeven\
    \ = numbers.maxBy(_.abs)\n        val closestToTwentyEight = numbers.minBy(_.abs)\n\
    \        val closestToTwentyNine = numbers.maxBy(_.abs)\n        val closestToTwentyTen\
    \ = numbers.minBy(_.abs)\n        val closestToTwentyEleven = numbers.maxBy(_.abs)\n\
    \        val closestToTwentyTwelve = numbers.minBy(_.abs)\n        val closestToTwent\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqqwiw3_2.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpqqwiw3_2.scala:53:5 ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArrayDiff\
    \ = intArrayMax - intArrayMin\n        val intArrayDiffLength = intArrayDiff /\
    \ intArrayLength\n        val intArrayDiffFloor = intArrayDiff.floor\n       \
    \ val intArrayDiffCeil = intArrayDiff.ceil\n        val intArrayDiffFloorLength\
    \ = intArrayDiffFloor / intArrayLength\n        val intArrayDiffCeilLength = intArrayDiffCeil\
    \ / intArrayLength\n        val intArrayDiffFloorFloor = intArrayDiffFloor.floor\n\
    \        val intArrayDiffFloorCeil = intArrayDiffFloor.ceil\n        val intArrayDiffCeilFloor\
    \ = intArrayDiffCeil.floor\n        val intArrayDiffCeilCeil = intArrayDiffCeil.ceil\n\
    \        val intArrayDiffFloorFloorFloor = intArrayDiffFloorFloor.floor\n    \
    \    val intArrayDiffFloorFloorCeil = intArrayDiffFloorCeil.floor\n        val\
    \ intArrayDiffFloorCeilCeil = intArrayDiffFloorCeil.ceil\n        val intArrayDiffCeilFloorFloor\
    \ = intArrayDiffCeilFloor.floor\n        val intArrayDiffCeilFloorCeil = intArrayDiffCeilFloor.ceil\n\
    \        val intArrayDiffCeilCeilFloor = intArrayDiffCeilCeil.floor\n        val\
    \ intArrayDiffCeilCeilCeil = intArrayDiffCeilCeil.ceil\n        val intArrayDiffFloorFloorFloorFloor\
    \ = intArrayDiffFloorFloorFloor.floor\n        val intArrayDiffFloorFloorFloorCeil\
    \ = intArrayDiffFloorFloorCeil.floor\n        val intArrayDiffFloorFloorCeilCeil\
    \ = intArrayDiffFloorFloorCeil.ceil\n        val intArrayDiffFloorCeilFloorFloor\
    \ = intArrayDiffFloorCeilFloor.floor\n        val intArrayDiffFloorCeilCeilFloor\
    \ = intArrayDiffFloorCeilCeil.floor\n        val intArrayDiffFloorCeilCeilCeil\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyf0bzgao.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyf0bzgao.scala:25:45\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffFloor\e[0m = intArrayDiff.floor\n\e[31m\e[31m   |\e[0m       \
    \                         ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value\
    \ floor is not a member of Int.\n\e[31m   |\e[0m      An extension method was\
    \ tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \          doubleWrapper(intArrayDiff)\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpyf0bzgao.scala:26:44 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mintArrayDiffCeil\e[0m = intArrayDiff.ceil\n\e\
    [31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      value ceil is not a member of Int.\n\e[31m   |\e[0m      An extension\
    \ method was tried, but could not be fully constructed:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m          doubleWrapper(intArrayDiff)\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpyf0bzgao.scala:43:46 ------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffFloorCeilFloorFloor\e[0m = intArrayDiffFloorCeilFloor.floor\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: intArrayDiffFloorCeilFloor\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyf0bzgao.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805568
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val min = numbers.min\n    \
    \    val max = numbers.max\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        if (diff == 0) {\n            closest\n        }\
    \ else {\n            closest.toLong\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn_7beb_0.scala:30)\n\tat Problem.main(tmpn_7beb_0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArraySum\
    \ = intArray.sum\n        val intArrayDifference = intArraySum - intArray(0)\n\
    \        val intArrayDifferenceAbs = intArrayDifference.abs\n        val intArrayDifferenceAbsMax\
    \ = intArrayDifferenceAbs.max\n        val intArrayDifferenceAbsMin = intArrayDifferenceAbs.min\n\
    \        val intArrayDifferenceAbsMaxIndex = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMax)\n\
    \        val intArrayDifferenceAbsMinIndex = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMin)\n\
    \        val intArrayDifferenceAbsMaxIndexInRange = intArrayDifferenceAbsMaxIndex\
    \ >= 0 && intArrayDifferenceAbsMaxIndex < intArrayLength\n        val intArrayDifferenceAbsMinIndexInRange\
    \ = intArrayDifferenceAbsMinIndex >= 0 && intArrayDifferenceAbsMinIndex < intArrayLength\n\
    \        val intArrayDifferenceAbsMaxIndexInRange = intArrayDifferenceAbsMaxIndexInRange\
    \ && intArrayDifferenceAbsMaxIndex != 0\n        val intArrayDifferenceAbsMinIndexInRange\
    \ = intArrayDifferenceAbsMinIndexInRange && intArrayDifferenceAbsMinIndex != 0\n\
    \        val intArrayDifferenceAbsMaxInRange = intArrayDifferenceAbsMaxIndexInRange\
    \ && intArrayDifferenceAbsMaxIndexInRange\n        val intArrayDifferenceAbsMinInRange\
    \ = intArrayDifferenceAbsMinIndexInRange && intArrayDifferenceAbsMinIndexInRange\n\
    \        val intArrayDifferenceAbsMaxInRange = intArrayDifferenceAbsMaxInRange\
    \ && intArrayDifferenceAbsMaxInRange\n        val intArrayDifferenceAbsMinInRange\
    \ = intArrayDifferenceAbsMinInRange && intArrayDifferenceAbsMinInRange\n     \
    \   val intArrayDifferenceAbsMaxInRange = intArrayDifferenceAbsMaxInRange && intArrayDifferenceAbsMaxInRange\n\
    \        val intArrayDifferenceAbsMinInRange = intArrayDifferenceAbsMinInRange\
    \ && intArrayDifferenceAbsMinInRange\n        val intArrayDifferenceAbsMaxInRange\
    \ = intArrayDifferenceAbsMaxInRange && intArrayDifferenceAbsMaxInRange\n     \
    \   val intArrayDifferenceAbsMinInRange = intArrayDifferenceAbsMinInRange && intArrayDifference\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfu17tf1l.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceAbsMaxIndexInRange\e\
    [0m = intArrayDifferenceAbsMaxIndexInRange && intArrayDifferenceAbsMaxIndex !=\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDifferenceAbsMaxIndexInRange is already defined as\
    \ \e[33mvalue\e[0m \e[35mintArrayDifferenceAbsMaxIndexInRange\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfu17tf1l.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDifferenceAbsMinIndexInRange\e[0m = intArrayDifferenceAbsMinIndexInRange\
    \ && intArrayDifferenceAbsMinIndex != \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDifferenceAbsMinIndexInRange is already defined as\
    \ \e[33mvalue\e[0m \e[35mintArrayDifferenceAbsMinIndexInRange\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfu17tf1l.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDifferenceAbsMaxInRange\e[0m = intArrayDifferenceAbsMaxInRange\
    \ && intArrayDifferenceAbsMaxInRange\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDifferenceAbsMaxInRange is already defined as \e[33mvalue\e\
    [0m \e[35mintArrayDifferenceAbsMaxInRange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfu17tf1l.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e["
  stdout: ''
  timestamp: 1659805570
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val min = numbers.min\n    \
    \    val max = numbers.max\n        val diff = (max - min).toInt\n        if (diff\
    \ < 1) {\n            val rounded = min + (diff / 2)\n            val roundedString\
    \ = rounded.toString + \".0\"\n            val roundedLong = rounded.toLong\n\
    \            val roundedDouble = rounded.toDouble\n            val roundedInt\
    \ = rounded.toInt\n            val roundedBigInt = rounded.toBigInt\n        \
    \    val roundedFloat = rounded.toFloat\n            val roundedDoubleToInt =\
    \ roundedDouble.toInt\n            val roundedDoubleToLong = roundedDouble.toLong\n\
    \            val roundedDoubleToFloat = roundedDouble.toFloat\n            val\
    \ roundedDoubleToBigInt = roundedDouble.toBigInt\n            val roundedDoubleToBigDecimal\
    \ = roundedDouble.toBigDecimal\n            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n\
    \            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n    \
    \        val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n        \
    \    val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n            val\
    \ roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n            val roundedDoubleToBigDecimal\
    \ = roundedDouble.toBigDecimal\n            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n\
    \            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n    \
    \        val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n        \
    \    val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n            val\
    \ roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n            val roundedDoubleToBigDecimal\
    \ = roundedDouble.toBigDecimal\n            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n\
    \            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n    \
    \        val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n        \
    \    val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n            val\
    \ roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n            val roundedDoubleToBigDecimal\
    \ = roundedDouble.toBigDecimal\n            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n\
    \            val roundedDoubleToBigDecimal = roundedDouble.toBigDecimal\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpya5cvt2m.scala:65:0 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpya5cvt2m.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mroundedDoubleToBigDecimal\e[0m = roundedDouble.toBigDecimal\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mroundedDoubleToBigDecimal is already defined as \e[33mvalue\e\
    [0m \e[35mroundedDoubleToBigDecimal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpya5cvt2m.scala:36:16 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mroundedDoubleToBigDecimal\e\
    [0m = roundedDouble.toBigDecimal\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mroundedDoubleToBigDecimal is already defined as \e[33mvalue\e\
    [0m \e[35mroundedDoubleToBigDecimal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpya5cvt2m.scala:37:16 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mroundedDoubleToBigDecimal\e\
    [0m = roundedDouble.toBigDecimal\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mroundedDoubleToBigDecimal is already defined as \e[33mvalue\e\
    [0m \e[35mroundedDoubleToBigDecimal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpya5cvt2m.scala:38:16 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mroundedDoubleToBigDecimal\e\
    [0m = roundedDouble.toBigDecimal\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m  "
  stdout: ''
  timestamp: 1659805571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = Math.min(numbers)\n\
    \        val largest = Math.max(numbers)\n        val difference = largest - smallest\n\
    \        val roundTo = Math.round(difference)\n        roundTo\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpagmsu7p7.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = Math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\
    \e[31m   |\e[0m (x$0: Float, x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1:\
    \ Long): Long\n\e[31m   |\e[0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpagmsu7p7.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = Math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mobject\e[0m \e[35mMath\e[0m with types\n\
    \e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\e[31m   |\e[0m (x$0: Float,\
    \ x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1: Long): Long\n\e[31m   |\e\
    [0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2\n        val closestDiff = math.abs(closest - diff)\n    \
    \    if (closestDiff < diff) {\n            closest\n        } else {\n      \
    \      math.round(closest)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpe8r9avtm.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpe8r9avtm.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\")\n        val num1 = nums(0)\n        val num2 = nums(1)\n\
    \        val num1Int = num1.toInt\n        val num2Int = num2.toInt\n        val\
    \ num1IntMinus1 = num1Int - num2Int\n        val num1IntMinus1Abs = Math.abs(num1IntMinus1)\n\
    \        val num2IntMinus1 = num2Int - num1Int\n        val num2IntMinus1Abs =\
    \ Math.abs(num2IntMinus1)\n        val num1IntMinus1AbsMinus2 = num1IntMinus1Abs\
    \ - num2IntMinus1Abs\n        val num1IntMinus1AbsMinus2Abs = Math.abs(num1IntMinus1AbsMinus2)\n\
    \        val num1IntMinus1AbsMinus2AbsMinus1 = num1IntMinus1AbsMinus2Abs - num1IntMinus1Abs\n\
    \        val num1IntMinus1AbsMinus2AbsMinus1Abs = Math.abs(num1IntMinus1AbsMinus2AbsMinus1)\n\
    \        val num1IntMinus1AbsMinus2AbsMinus1AbsMinus2 = num1IntMinus1AbsMinus2AbsMinus1Abs\
    \ - num1IntMinus1AbsMinus2AbsMinus1\n        val num1IntMinus1AbsMinus2AbsMinus1AbsMinus2Abs\
    \ = Math.abs(num1IntMinus1AbsMinus2AbsMinus1AbsMinus2)\n        val num1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMinus1\
    \ = num1IntMinus1AbsMinus2AbsMinus1AbsMinus2Abs - num1IntMinus1AbsMinus2AbsMinus1AbsMinus2Abs\n\
    \        val num1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMinus1Abs = num1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMinus1\
    \ - num1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMin\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jjvmtrx.scala:34:119 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mnum1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMinus1Abs\e\
    [0m = num1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMinus1 - num1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMin\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Not found: num1IntMinus1AbsMinus2AbsMinus1AbsMinus2AbsMin\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7jjvmtrx.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toDouble\n\
    \        val ints = List(\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"\
    ,\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\"\
    ,\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\"\
    ,\"32\",\"33\",\"34\",\"35\",\"36\",\"37\",\"38\",\"39\",\"40\",\"41\",\"42\"\
    ,\"43\",\"44\",\"45\",\"46\",\"47\",\"48\",\"49\",\"50\",\"51\",\"52\",\"53\"\
    ,\"54\",\"55\",\"56\",\"57\",\"58\",\"59\",\"60\",\"61\",\"62\",\"63\",\"64\"\
    ,\"65\",\"66\",\"67\",\"68\",\"69\",\"70\",\"71\",\"72\",\"73\",\"74\",\"75\"\
    ,\"76\",\"77\",\"78\",\"79\",\"80\",\"81\",\"82\",\"83\",\"84\",\"85\",\"86\"\
    ,\"87\",\"88\",\"89\",\"90\",\"91\",\"92\",\"93\",\"94\",\"95\",\"96\",\"97\"\
    ,\"98\",\"99\",\"100\",\"101\",\"102\",\"103\",\"104\",\"105\",\"106\",\"107\"\
    ,\"108\",\"109\",\"110\",\"111\",\"112\",\"113\",\"114\",\"115\",\"116\",\"117\"\
    ,\"118\",\"119\",\"120\",\"121\",\"122\",\"123\",\"124\",\"125\",\"126\",\"127\"\
    ,\"128\",\"129\",\"130\",\"131\",\"132\",\"133\",\"134\",\"135\",\"136\",\"137\"\
    ,\"138\",\"139\",\"140\",\"141\",\"142\",\"143\",\"144\",\"145\",\"146\",\"147\"\
    ,\"148\",\"149\",\"150\",\"151\",\"152\",\"153\",\"154\",\"155\",\"156\",\"157\"\
    ,\"158\",\"159\",\"160\",\"161\",\"162\",\"163\",\"164\",\"165\",\"166\",\"167\"\
    ,\"168\",\"169\",\"170\",\"171\",\"172\",\"173\",\"174\",\"175\",\"176\",\"177\"\
    ,\"178\",\"179\",\"180\",\"181\",\"182\",\"183\",\"184\",\"185\",\"186\",\"187\"\
    ,\"188\",\"189\",\"190\",\"191\",\"192\",\"193\",\"194\",\"195\",\"196\",\"197\"\
    ,\"198\",\"199\",\"200\",\"201\",\"202\",\"203\",\"204\",\"205\",\"206\",\"207\"\
    ,\"208\",\"209\",\"210\",\"211\",\"212\",\"213\",\"214\",\"215\",\"216\",\"217\"\
    ,\"218\",\"219\",\"220\",\"221\",\"222\",\"223\",\"224\",\"225\",\"226\",\"227\"\
    ,\"228\",\"229\",\"230\",\"231\",\"232\",\"233\",\"234\",\"235\",\"236\",\"237\"\
    ,\"238\",\"\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpt49dmkka.scala:19:1344 ---------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mints\e[0m = List(\e[31m\"\
    1\"\e[0m,\e[31m\"2\"\e[0m,\e[31m\"3\"\e[0m,\e[31m\"4\"\e[0m,\e[31m\"5\"\e[0m,\e\
    [31m\"6\"\e[0m,\e[31m\"7\"\e[0m,\e[31m\"8\"\e[0m,\e[31m\"9\"\e[0m,\e[31m\"10\"\
    \e[0m,\e[31m\"11\"\e[0m,\e[31m\"12\"\e[0m,\e[31m\"13\"\e[0m,\e[31m\"14\"\e[0m,\e\
    [31m\"15\"\e[0m,\e[31m\"16\"\e[0m,\e[31m\"17\"\e[0m,\e[31m\"18\"\e[0m,\e[31m\"\
    19\"\e[0m,\e[31m\"20\"\e[0m,\e[31m\"21\"\e[0m,\e[31m\"22\"\e[0m,\e[31m\"23\"\e\
    [0m,\e[31m\"24\"\e[0m,\e[31m\"25\"\e[0m,\e[31m\"26\"\e[0m,\e[31m\"27\"\e[0m,\e\
    [31m\"28\"\e[0m,\e[31m\"29\"\e[0m,\e[31m\"30\"\e[0m,\e[31m\"31\"\e[0m,\e[31m\"\
    32\"\e[0m,\e[31m\"33\"\e[0m,\e[31m\"34\"\e[0m,\e[31m\"35\"\e[0m,\e[31m\"36\"\e\
    [0m,\e[31m\"37\"\e[0m,\e[31m\"38\"\e[0m,\e[31m\"39\"\e[0m,\e[31m\"40\"\e[0m,\e\
    [31m\"41\"\e[0m,\e[31m\"42\"\e[0m,\e[31m\"43\"\e[0m,\e[31m\"44\"\e[0m,\e[31m\"\
    45\"\e[0m,\e[31m\"46\"\e[0m,\e[31m\"47\"\e[0m,\e[31m\"48\"\e[0m,\e[31m\"49\"\e\
    [0m,\e[31m\"50\"\e[0m,\e[31m\"51\"\e[0m,\e[31m\"52\"\e[0m,\e[31m\"53\"\e[0m,\e\
    [31m\"54\"\e[0m,\e[31m\"55\"\e[0m,\e[31m\"56\"\e[0m,\e[31m\"57\"\e[0m,\e[31m\"\
    58\"\e[0m,\e[31m\"59\"\e[0m,\e[31m\"60\"\e[0m,\e[31m\"61\"\e[0m,\e[31m\"62\"\e\
    [0m,\e[31m\"63\"\e[0m,\e[31m\"64\"\e[0m,\e[31m\"65\"\e[0m,\e[31m\"66\"\e[0m,\e\
    [31m\"67\"\e[0m,\e[31m\"68\"\e[0m,\e[31m\"69\"\e[0m,\e[31m\"70\"\e[0m,\e[31m\"\
    71\"\e[0m,\e[31m\"72\"\e[0m,\e[31m\"73\"\e[0m,\e[31m\"74\"\e[0m,\e[31m\"75\"\e\
    [0m,\e[31m\"76\"\e[0m,\e[31m\"77\"\e[0m,\e[31m\"78\"\e[0m,\e[31m\"79\"\e[0m,\e\
    [31m\"80\"\e[0m,\e[31m\"81\"\e[0m,\e[31m\"82\"\e[0m,\e[31m\"83\"\e[0m,\e[31m\"\
    84\"\e[0m,\e[31m\"85\"\e[0m,\e[31m\"86\"\e[0m,\e[31m\"87\"\e[0m,\e[31m\"88\"\e\
    [0m,\e[31m\"89\"\e[0m,\e[31m\"90\"\e[0m,\e[31m\"91\"\e[0m,\e[31m\"92\"\e[0m,\e\
    [31m\"93\"\e[0m,\e[31m\"94\"\e[0m,\e[31m\"95\"\e[0m,\e[31m\"96\"\e[0m,\e[31m\"\
    97\"\e[0m,\e[31m\"98\"\e[0m,\e[31m\"99\"\e[0m,\e[31m\"100\"\e[0m,\e[31m\"101\"\
    \e[0m,\e[31m\"102\"\e[0m,\e[31m\"103\"\e[0m,\e[31m\"104\"\e[0m,\e[31m\"105\"\e\
    [0m,\e[31m\"106\"\e[0m,\e[31m\"107\"\e[0m,\e[31m\"108\"\e[0m,\e[31m\"109\"\e[0m,\e\
    [31m\"110\"\e[0m,\e[31m\"111\"\e[0m,\e[31m\"112\"\e[0m,\e[31m\"113\"\e[0m,\e[31m\"\
    114\"\e[0m,\e[31m\"115\"\e[0m,\e[31m\"116\"\e[0m,\e[31m\"117\"\e[0m,\e[31m\"118\"\
    \e[0m,\e[31m\"119\"\e[0m,\e[31m\"120\"\e[0m,\e[31m\"121\"\e[0m,\e[31m\"122\"\e\
    [0m,\e[31m\"123\"\e[0m,\e[31m\"124\"\e[0m,\e[31m\"125\"\e[0m,\e[31m\"126\"\e[0m,\e\
    [31m\"127\"\e[0m,\e[31m\"128\"\e[0m,\e[31m\"129\"\e[0m,\e[31m\"130\"\e[0m,\e[31m\"\
    131\"\e[0m,\e[31m\"132\"\e[0m,\e[31m\"133\"\e[0m,\e[31m\"1"
  stdout: ''
  timestamp: 1659805572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArrayDiff\
    \ = intArrayMax - intArrayMin\n        val intArraySum = intArrayDiff.abs\n  \
    \      val intArraySumLength = intArraySum.length\n        val intArraySumMin\
    \ = intArraySum.min\n        val intArraySumMax = intArraySum.max\n        val\
    \ intArraySumDiff = intArraySumMax - intArraySumMin\n        val intArraySumSum\
    \ = intArraySumDiff.abs\n        val intArraySumSumLength = intArraySumSum.length\n\
    \        val intArraySumSumMin = intArraySumSum.min\n        val intArraySumSumMax\
    \ = intArraySumSum.max\n        val intArraySumSumDiff = intArraySumSumMax - intArraySumSumMin\n\
    \        val intArraySumSumSum = intArraySumSumDiff.abs\n        val intArraySumSumSumLength\
    \ = intArraySumSumSum.length\n        val intArraySumSumSumMin = intArraySumSumSum.min\n\
    \        val intArraySumSumSumMax = intArraySumSumSum.max\n        val intArraySumSumSumDiff\
    \ = intArraySumSumSumMax - intArraySumSumSumMin\n        val intArraySumSumSumSum\
    \ = intArraySumSumSumDiff.abs\n        val intArraySumSumSumSumLength = intArraySumSumSumSum.length\n\
    \        val intArraySumSumSumSumMin = intArraySumSumSumSum.min\n        val intArraySumSumSumSumMax\
    \ = intArraySumSumSumSum.max\n        val intArraySumSumSumSumDiff = intArraySumSumSumSumMax\
    \ - intArraySumSumSumSumMin\n        val intArraySumSumSumSumSum = intArraySumSumSumSumDiff.abs\n\
    \        val intArraySumSumSumSumSumLength = intArraySumSumSumSumSum.length\n\
    \        val intArraySumSumSumSumSumMin = intArraySumSumSumSumSum.min\n      \
    \  val intArraySumSumSumSumSumMax = intArraySumSumSumSumSum.max\n        val intArraySumSumSumSumSumDiff\
    \ = intArraySumSumSumSumSumMax - intArraySumSumSumSumSumMin\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp82j9_u3n.scala:25:44 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintArraySumLength\e[0m =\
    \ intArraySum.length\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value length is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp82j9_u3n.scala:28:45\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mintArraySumDiff\e[0m = intArraySumMax - intArraySumMin\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue -\
    \ is not a member of Int => Int, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp82j9_u3n.scala:50:5 ---------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toLong)\n        val min = math.min(nums)\n   \
    \     val max = math.max(nums)\n        val mid = math.round(min + (max - min)\
    \ / 2)\n        val diff = max - mid\n        if (diff < 0)\n            math.round(mid\
    \ - diff)\n        else\n            math.round(mid)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4oxcjmqr.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp4oxcjmqr.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Long]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal point\n        val intParts = parts.map(_.toInt)\
    \ // convert each part to int\n        val diffs = intParts.zip(intParts).map(x\
    \ => Math.abs(x._1 - x._2)) // find differences between the two parts\n      \
    \  val minDiff = diffs.min  // find the minimum difference\n        val closestPart\
    \ = diffs.find(x => x._1 == minDiff)._2 // find the closest part\n        val\
    \ closestInteger = closestPart.toLong // convert to long\n        return closestInteger\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw54bsn7z.scala:22:44 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosestPart\e[0m = diffs.find(\e\
    [36mx\e[0m => x._1 == minDiff)._2 \e[34m// find the closest part\e[0m\n\e[31m\e\
    [31m   |\e[0m                                          ^^^^\e[0m\n\e[31m   |\e\
    [0m                                         value _1 is not a member of Int\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpijpmrgvb.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpijpmrgvb.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArrayDiff\
    \ = intArrayMax - intArrayMin\n        val intArrayDiffAbs = intArrayDiff.abs\n\
    \        val intArrayDiffAbsMin = intArrayDiffAbs.min\n        val intArrayDiffAbsMax\
    \ = intArrayDiffAbs.max\n        val intArrayDiffAbsMinAbs = intArrayDiffAbsMin\
    \ / intArrayDiffAbsMax\n        val intArrayDiffAbsMaxAbs = intArrayDiffAbsMax\
    \ / intArrayDiffAbsMin\n        val intArrayDiffAbsMinAbsAbs = intArrayDiffAbsMinAbs\
    \ / intArrayDiffAbsMaxAbs\n        val intArrayDiffAbsMaxAbsAbs = intArrayDiffAbsMaxAbs\
    \ / intArrayDiffAbsMinAbs\n        val intArrayDiffAbsMinAbsAbsAbs = intArrayDiffAbsMinAbsAbs\
    \ / intArrayDiffAbsMaxAbsAbs\n        val intArrayDiffAbsMaxAbsAbsAbs = intArrayDiffAbsMaxAbsAbs\
    \ / intArrayDiffAbsMinAbsAbsAbs\n        val intArrayDiffAbsMinAbsAbsAbsAbs =\
    \ intArrayDiffAbsMinAbsAbsAbs / intArrayDiffAbsMaxAbsAbsAbs\n        val intArrayDiffAbsMaxAbsAbsAbsAbs\
    \ = intArrayDiffAbsMaxAbsAbsAbs / intArrayDiffAbsMinAbsAbsAbsAbs\n        val\
    \ intArrayDiffAbsMinAbsAbsAbsAbsAbs = intArrayDiffAbsMinAbsAbsAbsAbs / intArrayDiffAbsMaxAbsAbsAbsAbs\n\
    \        val intArrayDiffAbsMaxAbsAbsAbsAbsAbs = intArrayDiffAbsMaxAbsAbsAbsAbs\
    \ / intArrayDiffAbsMinAbsAbsAbsAbsAbs\n        val intArrayDiffAbsMinAbsAbsAbsAbsAbsAbs\
    \ = intArrayDiffAbsMinAbsAbsAbsAbsAbs / intArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6tlzgx01.scala:27:55 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMinAbs\e\
    [0m = intArrayDiffAbsMin / intArrayDiffAbsMax\n\e[31m\e[31m   |\e[0m         \
    \                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue /\
    \ is not a member of Int => Int, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6tlzgx01.scala:28:55 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMaxAbs\e\
    [0m = intArrayDiffAbsMax / intArrayDiffAbsMin\n\e[31m\e[31m   |\e[0m         \
    \                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue /\
    \ is not a member of Int => Int, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6tlzgx01.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val roundToZero = difference < 0\n        val roundAwayFromZero = difference\
    \ > 0\n        val roundAwayFromZeroOrClosest = roundAwayFromZero || roundToZero\n\
    \        val roundAwayFromZeroOrClosestInt = math.round(roundAwayFromZeroOrClosest)\n\
    \        val roundAwayFromZeroOrClosestLong = roundAwayFromZeroOrClosestInt.toLong\n\
    \        roundAwayFromZeroOrClosestLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf7xyeat1.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf7xyeat1.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Long]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val mid = math.round(min + (max\
    \ - min) / 2)\n        if (mid < min) mid else math.round(mid)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc5e_1yio.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc5e_1yio.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        if (min == max) {\n            return min\n        }\n\
    \        val diff = max - min\n        val closest = (diff / 2) + min\n      \
    \  if (closest == 0) {\n            return min\n        }\n        return closest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprpnp7flw.scala:33)\n\tat Problem.main(tmprpnp7flw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toLong)\n        val min = numbers.min\n    \
    \    val max = numbers.max\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        if (diff > 0) closest else -closest\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2oa9njh7.scala:26)\n\tat Problem.main(tmp2oa9njh7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayIndex\
    \ = (intArrayLength - 1) match {\n            case 0 => 0\n            case 1\
    \ => 1\n            case _ => intArrayLength - 1\n        }\n        val intArray1\
    \ = intArray(intArrayIndex - 1)\n        val intArray2 = intArray(intArrayIndex)\n\
    \        val intArray3 = intArray(intArrayIndex + 1)\n        val intArray4 =\
    \ intArray(intArrayIndex + 2)\n        val intArray5 = intArray(intArrayIndex\
    \ + 3)\n        val intArray6 = intArray(intArrayIndex + 4)\n        val intArray7\
    \ = intArray(intArrayIndex + 5)\n        val intArray8 = intArray(intArrayIndex\
    \ + 6)\n        val intArray9 = intArray(intArrayIndex + 7)\n        val intArray10\
    \ = intArray(intArrayIndex + 8)\n        val intArray11 = intArray(intArrayIndex\
    \ + 9)\n        val intArray12 = intArray(intArrayIndex + 10)\n        val intArray13\
    \ = intArray(intArrayIndex + 11)\n        val intArray14 = intArray(intArrayIndex\
    \ + 12)\n        val intArray15 = intArray(intArrayIndex + 13)\n        val intArray16\
    \ = intArray(intArrayIndex + 14)\n        val intArray17 = intArray(intArrayIndex\
    \ + 15)\n        val intArray18 = intArray(intArrayIndex + 16)\n        val intArray19\
    \ = intArray(intArrayIndex + 17)\n        val intArray20 = intArray(intArrayIndex\
    \ + 18)\n        val intArray21 = intArray(intArrayIndex + 19)\n        val intArray22\
    \ = intArray(intArrayIndex + 20)\n        val intArray23 = intArray(intArrayIndex\
    \ + 21)\n        val intArray24 = intArray(intArrayIndex + 22)\n        val intArray25\
    \ = intArray(intArrayIndex + 23)\n        val intArray26 = intArray(intArrayIndex\
    \ + 24)\n        val intArray27 = intArray(intArrayIndex + 25)\n        val intArray28\
    \ = intArray(intArrayIndex + 26)\n        val intArray29 = intArray(intArrayIndex\
    \ + 27)\n        val intArray30 = intArray(intArrayIndex + 28)\n        val intArray31\
    \ = intArray(intArrayIndex + 29)\n        val intArray32 = intArray(intArrayIndex\
    \ + 30)\n        val int\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpws4u0rrf.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpws4u0rrf.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val min = math.min(num, math.min(num))\n        val max = math.max(num,\
    \ math.max(num))\n        val diff = max - min\n        val round = math.round(diff\
    \ * 0.5).toLong\n        round + min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpoeraofis.scala:19:37 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(num,\
    \ math.min(num))\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((num : Long))\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpoeraofis.scala:20:37 -----------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = math.max(num, math.max(num))\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in\
    \ \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double,\
    \ y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e\
    [0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m  \
    \ |\e[0mmatch arguments ((num : Long))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15.3\", \"14.5\", \"14\", \"13.5\", \"13\"\
    , \"12.5\", \"12\", \"11.5\", \"11\", \"10.5\", \"10\", \"9.5\", \"9\", \"8.5\"\
    , \"8\", \"7.5\", \"7\", \"6.5\", \"6\", \"5.5\", \"5\", \"4.5\", \"4\", \"3.5\"\
    , \"3\", \"2.5\", \"2\", \"1.5\", \"1\", \"0.5\", \"0\")\n        val numsSorted\
    \ = nums.sortWith(_.toLong < _.toLong)\n        val numsSorted = numsSorted.reverse\n\
    \        val closestNum = numsSorted.find(num => num.toLong == num.toLong)\n \
    \       val closestNum = closestNum.getOrElse(0)\n        val closestNum = closestNum.toLong\n\
    \        val closestNum = closestNum - num\n        val closestNum = closestNum.toLong\n\
    \        closestNum\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr0bqewum.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = numsSorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr0bqewum.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e[0m = closestNum.getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNum is already defined as \e[33mvalue\e[0m \e[35mclosestNum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr0bqewum.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e[0m = closestNum.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mclosestNum is already defined as \e[33mvalue\e[0m \e[35mclosestNum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr0bqewum.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e[0m = closestNum - num\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mclosestNum is already defined as \e[33mvalue\e[0m \e[35mclosestNum\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpr0bqewum.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e[0m = closestNum.toLong\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclosestNum\
    \ is already define"
  stdout: ''
  timestamp: 1659805578
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0).toLong // Convert the first part to a long\n\
    \        val after = parts(1).toLong // Convert the second part to a long\n  \
    \      val diff = Math.abs(after - before) // Calculate the difference between\
    \ the two numbers\n        val closest = (diff + before) / 2 // Calculate the\
    \ closest number\n        closest.toLong // Return the closest number\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpqv59rqgg.scala:20)\n\tat Problem$.main(tmpqv59rqgg.scala:26)\n\
    \tat Problem.main(tmpqv59rqgg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val ints = numbers.map(_.toInt)\n \
    \       val diffs = ints.zip(diffInts(ints))\n        val minDiff = diffs.minBy(_._1)._2\n\
    \        val closestInt = diffs.find(_._2 == minDiff)._1\n        closestInt *\
    \ 1\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplt5tjvyd.scala:20:29 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdiffs\e[0m = ints.zip(diffInts(ints))\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: diffInts\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmplt5tjvyd.scala:22:53 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosestInt\e[0m = diffs.find(_._2\
    \ == minDiff)._1\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value _1 is not a member of Option[(Int,\
    \ Nothing)]\n2 errors found\n"
  stdout: ''
  timestamp: 1659805579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15.3\", \"14.5\", \"14\", \"13.5\", \"13\"\
    , \"12.5\", \"12\", \"11.5\", \"11\", \"10.5\", \"10\", \"9.5\", \"9\", \"8.5\"\
    , \"8\", \"7.5\", \"7\", \"6.5\", \"6\", \"5.5\", \"5\", \"4.5\", \"4\", \"3.5\"\
    , \"3\", \"2.5\", \"2\", \"1.5\", \"1\", \"0.5\", \"0\")\n        val numsSorted\
    \ = nums.sortWith((x, y) => x.toLong - y.toLong)\n        val closestNum = numsSorted.last\n\
    \        val closestNumIndex = numsSorted.lastIndex\n        val closestNumDistance\
    \ = numsSorted.take(closestNumIndex).map(x => x - num).sum\n        val closestNumDistanceAbs\
    \ = closestNumDistance * Math.sqrt(2)\n        val closestNumDistanceAbsSquared\
    \ = closestNumDistanceAbs * closestNumDistanceAbs\n        val closestNumDistanceSquared\
    \ = closestNumDistance * closestNumDistance\n        val closestNumDistanceSquaredAbs\
    \ = closestNumDistanceSquared * closestNumDistanceSquared\n        val closestNumDistanceSquaredAbsSquared\
    \ = closestNumDistanceAbsSquared * closestNumDistanceAbsSquared\n        val closestNumDistanceSquaredAbsSquaredMinus1\
    \ = closestNumDistanceAbsSquared\n            - (closestNumDistanceAbsSquared\
    \ / closestNumDistance)\n        val closestNumDistanceSquaredAbsSquaredMinus1Squared\
    \ = closestNumDistanceAbsSquared\n            - (closestNumDistanceAbsSquared\
    \ / closestNumDistance)\n        val closestNumDistanceSquaredAbsSquaredMinus1SquaredMinus1\
    \ = closestNumDistanceAbsSquared\n            - (closestNumDistanceAbsSquared\
    \ / closestNumDistance)\n        val closestNumDistanceSquaredAbsSquaredMinus1SquaredMinus1Squared\
    \ = closestNumDistanceAbsSquared\n            - (closestNumDistanceAbsSquared\
    \ / closestNumDistance)\n        val closestNumDistanceSquaredAbsSquaredMinus1SquaredMinus1SquaredMinus1\
    \ = closestNumDistanceAbsSquared\n            - (closestNumDistanceAbsSquared\
    \ / closestNumDistance)\n        val closestNumDistanceSquaredAbsSquaredMinus1SquaredMinus1SquaredMinus1Squared\
    \ = closestNumDistanceAbsSquared\n            - (closestNumDistanceAbsSquared\
    \ / closestNumDistance)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphk11ic0y.scala:20:49\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e\
    [0m = nums.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.toLong - y.toLong)\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Found:  \
    \  Long\n\e[31m   |\e[0m                                                 Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphk11ic0y.scala:22:41\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclosestNumIndex\e[0m = numsSorted.lastIndex\n\e[31m\e[31m   |\e[0m       \
    \                       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndex\
    \ is not a member of List[String] - did you mean numsSorted.lastIndexOf?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphk11ic0y.scala:23:77 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestNumDistance\e[0m\
    \ = numsSorted.take(closestNumIndex).map(\e[36mx\e[0m => x - num).sum\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \           ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmphk11ic0y.scala:23:87 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestNumDistance\e[0m\
    \ = numsSorted.take(closestNumIndex).map(\e[36mx\e[0m => x - num).sum\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                       ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mo"
  stdout: ''
  timestamp: 1659805580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        val closestInteger = math.round(closest)\n     \
    \   closestInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpg75qzq_0.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpg75qzq_0.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = (max - min).toInt\n \
    \       val closest = (min + diff) / 2\n        val closestInteger = math.round(closest)\n\
    \        closestInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpad8e1i1x.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpad8e1i1x.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpijpmrgvb.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpijpmrgvb.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpijpmrgvb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        val rounded = math.round(closest)\n    \
    \    rounded.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpn1qysalu.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpn1qysalu.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.min(nums.map(math.abs))\n\
    \        val closestNum = nums.map(math.round).min\n        val diff = (closestNum\
    \ - minDiff).toInt\n        val closestInteger = math.min(closestNum, minDiff)\n\
    \        closestInteger + diff\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8lhpziiw.scala:19:27 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = math.min(nums.map(math.abs))\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Int])\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8lhpziiw.scala:20:34\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e\
    [0m = nums.map(math.round).min\n\e[31m\e[31m   |\e[0m                        \
    \          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                  Found:\
    \    \e[1m\e[31mLong\e[0m => Long\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32mInt\e[0m => Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = value.split(\"\\\\.\").map(_.toInt)\n\
    \        val diffArray = intArray.zip(diffArray).filter(_._1 == 0).map(_._2)\n\
    \        val diffSum = diffArray.reduce((a, b) => a + b)\n        val diffSumAbs\
    \ = Math.abs(diffSum)\n        val diffSumAbsMin = diffSumAbs.min\n        val\
    \ diffSumAbsMax = diffSumAbs.max\n        val diffSumAbsMinDiff = diffSumAbsMin\
    \ - diffSumAbsMax\n        val diffSumAbsMaxDiff = diffSumAbsMax - diffSumAbsMin\n\
    \        val diffSumAbsMinDiffAbs = Math.abs(diffSumAbsMinDiff)\n        val diffSumAbsMaxDiffAbs\
    \ = Math.abs(diffSumAbsMaxDiff)\n        val diffSumAbsMinDiffAbsMin = diffSumAbsMinDiffAbs.min\n\
    \        val diffSumAbsMaxDiffAbsMax = diffSumAbsMaxDiffAbs.max\n        val diffSumAbsMinDiffAbsMinDiff\
    \ = diffSumAbsMinDiffAbsMin - diffSumAbsMaxDiffAbsMax\n        val diffSumAbsMaxDiffAbsMaxDiff\
    \ = diffSumAbsMaxDiffAbsMax - diffSumAbsMinDiffAbsMinDiff\n        val diffSumAbsMinDiffAbsMinDiffAbs\
    \ = Math.abs(diffSumAbsMinDiffAbsMin)\n        val diffSumAbsMaxDiffAbsMaxDiffAbs\
    \ = Math.abs(diffSumAbsMaxDiffAbsMaxDiff)\n        val diffSumAbsMinDiffAbsMinDiffAbsMin\
    \ = diffSumAbsMinDiffAbsMinDiff - diffSumAbsMaxDiffAbsMaxDiffAbs\n        val\
    \ diffSumAbsMaxDiffAbsMaxDiffAbsMax = diffSumAbsMaxDiffAbsMaxDiff - diffSumAbsMinDiffAbsMinDiffAbsMin\n\
    \        val diffSumAbsMinDiffAbsMinDiffAbsMinAbs = diffSumAbsMinDiffAbsMinDiffAbsMin\
    \ - diffSumAbsMaxDiffAbsMaxDiffAbsMax\n        val diffSumAbsMaxDiffAbsMaxDiffAbsMaxAbs\
    \ = diffSumAbsMaxDiffAbsMaxDiffAbsMax - diffSumAbsMinDiffAbsMinDiffAb\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprphe4o9s.scala:20:37 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdiffArray\e[0m = intArray.zip(diffArray).filter(_._1\
    \ == \e[31m0\e[0m).map(_._2)\n\e[31m\e[31m   |\e[0m                          \
    \           ^\e[0m\n\e[31m   |\e[0m                                    Recursive\
    \ \e[33mvalue\e[0m \e[35mdiffArray\e[0m needs type\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmprphe4o9s.scala:21:51 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mdiffSum\e[0m = diffArray.reduce((\e\
    [36ma\e[0m, \e[36mb\e[0m) => a + b)\n\e[31m\e[31m   |\e[0m                   \
    \                              ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of Any, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmprphe4o9s.scala:22:30 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mdiffSumAbs\e[0m = Math.abs(diffSum)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double): Double\n\e[31m\
    \   |\e[0m (x$0: Float): Float\n\e[31m   |\e[0m (x$0: Long): Long\n\e[31m   |\e\
    [0m (x$0: Int): Int\n\e[31m   |\e[0mmatch arguments ((diffSum : Any))\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprphe4o9s.scala:39:5 ---------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmps6os9_lf.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmps6os9_lf.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split into two parts separated by a dot\n        val\
    \ intParts = parts.map(_.toInt) // convert each part to an int\n        val diffs\
    \ = intParts.map(x => x - intParts.min) // find the difference between each int\n\
    \        val diffsSum = diffs.sum // find the sum of all differences\n       \
    \ val diffsSumAbs = diffsSum.abs // find the sum of absolute differences\n   \
    \     val diffsSumAbsMin = diffsSumAbs.min // find the minimum absolute difference\n\
    \        val diffsSumAbsMax = diffsSumAbs.max // find the maximum absolute difference\n\
    \        val diffsSumAbsMaxIndex = diffsSumAbs.indexOf(diffsSumAbsMax) // find\
    \ the index of the maximum absolute difference\n        val diffsSumAbsMaxDiff\
    \ = diffsSumAbs(diffsSumAbsMaxIndex) // find the difference between the maximum\
    \ and the minimum absolute difference\n        val diffsSumAbsMaxDiffIndex = diffsSumAbsMaxIndex\
    \ + 1 // find the index of the difference between the maximum and the minimum\
    \ absolute difference\n        val diffsSumAbsMaxDiffDiff = diffsSumAbsMaxDiff\
    \ // find the difference between the maximum and the minimum absolute difference\n\
    \        val diffsSumAbsMaxDiffDiffIndex = diffsSumAbsMaxDiffIndex + 1 // find\
    \ the index of the difference between the maximum and the minimum absolute difference\n\
    \        val diffsSumAbsMaxDiffDiffDiff = diffsSumAbsMaxDiffDiff // find the difference\
    \ between the maximum and the minimum absolute difference\n        val diffsSumAbsMaxDiffDiffDiffIndex\
    \ = diffsSumAbsMaxDiffDiffIndex + 1 // find the index of the difference between\
    \ the maximum and the minimum absolute difference\n        val diffsSumAbsMaxDiffDiffDiffDiff\
    \ = diffsSumAbsMaxDiffDiffDiff // find the difference between the maximum and\
    \ the minimum absolute difference\n        val diffsSumAbsMaxDiffDiffDiffIndex\
    \ = diffsSumAbsMaxDiffDiffDiffIndex + 1 // find the index of the difference between\
    \ the maximum and the minimum absolute difference\n        val diffsSumAbsMaxDiffDiffDiffDiff\
    \ = diffsSumAbsMaxDiffDiffDiffDiff // find the difference between the maximum\
    \ and the minimum absolute difference\n        val diffsSumAbsMaxDiffDiffDiffDiffIndex\
    \ = diffsSumAbsMaxDiffDiffDiffDiffIndex + 1 // find the index of the difference\
    \ between the maximum and the minimum absolute difference\n        val diffsSumAbsMaxDiffDiffDiffDiffDiff\
    \ = diffsSumAbsMaxDiffDiff\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp516gqyxf.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mdiffsSumAbsMaxDiffDiffDiffIndex\e\
    [0m = diffsSumAbsMaxDiffDiffDiffIndex + \e[31m1\e[0m \e[34m// find the index of\
    \ the difference between the maximum and the minimum absolute difference\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffsSumAbsMaxDiffDiffDiffIndex is already defined as \e[33mvalue\e\
    [0m \e[35mdiffsSumAbsMaxDiffDiffDiffIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp516gqyxf.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdiffsSumAbsMaxDiffDiffDiffDiff\e[0m = diffsSumAbsMaxDiffDiffDiffDiff \e\
    [34m// find the difference between the maximum and the minimum absolute difference\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffsSumAbsMaxDiffDiffDiffDiff is already defined as \e[33mvalue\e\
    [0m \e[35mdiffsSumAbsMaxDiffDiffDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp516gqyxf.scala:25:46 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mdiffsSumAbsMaxIndex\e[0m\
    \ = diffsSumAbs.indexOf(diffsSumAbsMax) \e[34m// find the index of the maximum\
    \ absolute difference\e[0m\n\e[31m\e[31m   |\e[0m                            \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \     value indexOf is not a member of Int\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmp516gqyxf.scala:26:33 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mdiffsSumAbsMaxDiff\e[0m = diffsSumAbs(diffsSumAbsMaxIndex)\
    \ \e[34m// find the difference between the maximum and the minimum absolute difference\e\
    [0m\n\e[31m\e[31m   |\e[0m                          "
  stdout: ''
  timestamp: 1659805582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArray\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8mr3wl6u.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8mr3wl6u.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.trim\n\
    \        val numAsLong = num.toLong\n        val numAsString = num.toString\n\
    \        val numAsLongArray = numAsString.toCharArray\n        val numAsStringArray\
    \ = numAsString.toCharArray\n        val numAsLongArrayLength = numAsLongArray.length\n\
    \        val numAsStringArrayLength = numAsStringArray.length\n        val numAsLongArrayLength\
    \ = numAsLongArrayLength\n        val numAsStringArrayLength = numAsStringArrayLength\n\
    \        val numAsLongArrayLength = numAsLongArrayLength\n        val numAsStringArrayLength\
    \ = numAsStringArrayLength\n        val numAsLongArrayLength = numAsLongArrayLength\n\
    \        val numAsStringArrayLength = numAsStringArrayLength\n        val numAsLongArrayLength\
    \ = numAsLongArrayLength\n        val numAsStringArrayLength = numAsStringArrayLength\n\
    \        val numAsLongArrayLength = numAsLongArrayLength\n        val numAsStringArrayLength\
    \ = numAsStringArrayLength\n        val numAsLongArrayLength = numAsLongArrayLength\n\
    \        val numAsStringArrayLength = numAsStringArrayLength\n        val numAsLongArrayLength\
    \ = numAsLongArrayLength\n        val numAsStringArrayLength = numAsStringArrayLength\n\
    \        val numAsLongArrayLength = numAsLongArrayLength\n        val numAsStringArrayLength\
    \ = numAsStringArrayLength\n        val numAsLongArrayLength = numAsLongArrayLength\n\
    \        val numAsStringArrayLength = numAsStringArrayLength\n        val numAsLongArrayLength\
    \ = numAsLongArrayLength\n        val numAsStringArrayLength = numAsStringArrayLength\n\
    \        val numAsLongArrayLength = numAsLongArrayLength\n        val numAsStringArrayLength\
    \ = numAsStringArrayLength\n        val numAsLongArrayLength = numAsLongArrayLength\n\
    \        val numAsStringArrayLength = numAsStringArrayLength\n        val numAsLongArrayLength\
    \ = numAsLongArrayLength\n        val numAsStringArrayLength = numAsStringArrayLength\n\
    \        val numAsLongArrayLength = numAsLongArrayLength\n        val numAsStringArrayLength\
    \ = numAsStringArrayLength\n        val numAsLongArrayLength = numAsLongArrayLength\n\
    \        val numAsStringArrayLength = numAsStringArrayLength\n        val numAsLongArrayLength\
    \ = numAsLongArrayLength\n        val numAsStringArrayLength = numAsStringArrayLength\n\
    \        val numAsLongArrayLength = numAsLongArrayLength\n        val numAsString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb8xf34oq.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb8xf34oq.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnumAsLongArrayLength\e[0m = numAsLongArrayLength\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnumAsLongArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mnumAsLongArrayLength\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpb8xf34oq.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mnumAsStringArrayLength\e[0m = numAsStringArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumAsStringArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnumAsStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb8xf34oq.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mnumAsLongArrayLength\e[0m\
    \ = numAsLongArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumAsLongArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnumAsLongArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpb8xf34oq.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mnumAsStringArrayLength\e\
    [0m = numAsStringArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumAsStringArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnumAsStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp_f7w9zff.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp_f7w9zff.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal point\n        val intPart = parts(0)\n\
    \        val fractionPart = parts(1)\n        val fractionPartAsLong = fractionPart.toLong\n\
    \        val intPartAsLong = intPart.toLong\n        val difference = fractionPartAsLong\
    \ - intPartAsLong\n        if (difference < 0)\n            difference = difference\
    \ * -1\n        if (difference == 0)\n            return intPartAsLong\n     \
    \   else if (difference < 0)\n            return intPartAsLong + difference\n\
    \        else\n            return intPartAsLong - difference\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmplrse9vxu.scala:25:23 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            difference = difference * -\e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val difference\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue)\n        val intsSet = ints.toSet\n\
    \        val intsSetSize = intsSet.size\n        val intsSetIterator = intsSet.iterator\n\
    \        val intsSetIteratorNext = intsSetIterator.next\n        val intsSetIteratorNextValue\
    \ = intsSetIteratorNext.toInt\n        val intsSetIteratorNextNext = intsSetIteratorNext.next\n\
    \        val intsSetIteratorNextNextValue = intsSetIteratorNextNext.toInt\n  \
    \      val intsSetIteratorNextNextNext = intsSetIteratorNextNext.next\n      \
    \  val intsSetIteratorNextNextNextValue = intsSetIteratorNextNextNext.toInt\n\
    \        val intsSetIteratorNextNextNextNext = intsSetIteratorNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextValue = intsSetIteratorNextNextNextNext.toInt\n\
    \        val intsSetIteratorNextNextNextNextNext = intsSetIteratorNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNext.toInt\n\
    \        val intsSetIteratorNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNext.toInt\n\
    \        val intsSetIteratorNextNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNextNext.toInt\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNextNextNextNext.toInt\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNextNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNextNextNextNextNextNext.toInt\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextNextNext = intsSetIteratorNextNextNext\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx93nj3_o.scala:25:58 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintsSetIteratorNextNext\e\
    [0m = intsSetIteratorNext.next\n\e[31m\e[31m   |\e[0m                        \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                      value next is not a member of Int\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpx93nj3_o.scala:37:62 ---------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mintsSetIteratorNextNextNextNextNextNextNextNext\e\
    [0m = intsSetIteratorNextNextNextNextNextNextNextNext.next\n\e[31m\e[31m   |\e\
    [0m                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mintsSetIteratorNextNextNextNextNextNextNextNext\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx93nj3_o.scala:40:71\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e\
    [36mintsSetIteratorNextNextNextNextNextNextNextNextNextValue\e[0m = intsSetIteratorNextNextNextNextNextNextNextNextNextNextNext.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  Not found: intsSetIteratorNextNextNextNextNextNextNextNextNextNextNext\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx93nj3_o.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        math.abs(closest - value)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpvlauocf6.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpvlauocf6.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805581
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val diff = (intValue - intValue.toDouble).toInt\n   \
    \     val diffAbs = Math.abs(diff)\n        val closestInteger = intValue + diffAbs\
    \ / 2\n        if (diff < 0)\n            closestInteger\n        else\n     \
    \       closestInteger.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmpy12iy2yq.scala:18)\n\
    \tat Problem$.main(tmpy12iy2yq.scala:29)\n\tat Problem.main(tmpy12iy2yq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        val closestLong = math.round(closest)\n\
    \        closestLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpl12sljkv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpl12sljkv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15.3\", \"14.5\", \"14\", \"13.5\", \"13\"\
    , \"12.5\", \"12\", \"11.5\", \"11\", \"10.5\", \"10\", \"9.5\", \"9\", \"8.5\"\
    , \"8\", \"7.5\", \"7\", \"6.5\", \"6\", \"5.5\", \"5\", \"4.5\", \"4\", \"3.5\"\
    , \"3\", \"2.5\", \"2\", \"1.5\", \"1\", \"0.5\", \"0\")\n        val numsLength\
    \ = nums.length\n        val closestNum = nums.maxBy(x => Math.abs(x - num))\n\
    \        val closestNumIndex = nums.indexOf(closestNum)\n        val closestNumLength\
    \ = closestNum.length\n        val closestNumNum = closestNum.toDouble\n     \
    \   val closestNumNums = closestNumNum - num\n        val closestNumNumsLength\
    \ = closestNumNums.length\n        val closestNumNumsNum = closestNumNums.toInt\n\
    \        val closestNumNumsNumsLength = closestNumNumsNums.length\n        val\
    \ closestNumNumsNumsNum = closestNumNumsNums.toInt\n        val closestNumNumsNumsNumsLength\
    \ = closestNumNumsNumsNums.length\n        val closestNumNumsNumsNumsNum = closestNumNumsNumsNums.toInt\n\
    \        val closestNumNumsNumsNumsNumsLength = closestNumNumsNumsNumsNums.length\n\
    \        val closestNumNumsNumsNumsNumsNum = closestNumNumsNumsNumsNums.toInt\n\
    \        val closestNumNumsNumsNumsNumsNumsLength = closestNumNumsNumsNumsNumsNumsLength\n\
    \        val closestNumNumsNumsNumsNumsNumsNum = closestNumNumsNumsNumsNumsNumsNums.toInt\n\
    \        val closestNumNumsNumsNumsNumsNumsNumsLength = closestNumNumsNumsNumsNumsNumsNumsLength\n\
    \        val closestNumNumsNumsNumsNumsNumsNumsNum = closestNumNumsNumsNumsNumsNumsNumsNumsLength\n\
    \        val closestNumNumsNumsNumsNumsNumsNumsNumsLength = closestNumNumsNumsNumsNumsNumsNumsNumsNumsLength\n\
    \        val closestNumNumsNumsNumsNumsNumsNumsNumsNumsLength = closestNumNumsNumsNumsNumsNums\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvle7jkz0.scala:21:52 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e[0m = nums.maxBy(\e\
    [36mx\e[0m => Math.abs(x - num))\n\e[31m\e[31m   |\e[0m                      \
    \                            ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpvle7jkz0.scala:21:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e[0m = nums.maxBy(\e\
    [36mx\e[0m => Math.abs(x - num))\n\e[31m\e[31m   |\e[0m                      \
    \                                     ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter cmp of \e[33mmethod\e[0m \e[35mmaxBy\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpvle7jkz0.scala:28:39 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m        \e[33mval\e[0m \e[36mclosestNumNumsNumsLength\e[0m = closestNumNumsNums.length\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Not found: closestNumNumsNums\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvle7jkz0.scala:29:36\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mclosestNumNumsNumsNum\e[0m = closestNumNumsNums.toInt\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    Not fou"
  stdout: ''
  timestamp: 1659805585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\")\n        val int1 = numbers(0)\n        val int2 =\
    \ numbers(1)\n        val int1Int = int1.toInt\n        val int2Int = int2.toInt\n\
    \        val diff1 = Math.abs(int1Int - int2)\n        val diff2 = Math.abs(int1Int\
    \ - int2Int)\n        if (diff1 < diff2) {\n            return int1Int\n     \
    \   } else {\n            return int2Int\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp_0s1jxwc.scala:23:37 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mdiff1\e[0m = Math.abs(int1Int\
    \ - int2)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((int2 : String))\n1 error found\n"
  stdout: ''
  timestamp: 1659805584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split on decimal point\n        val integerPart =\
    \ parts(0)\n        val fractionalPart = parts(1).toDouble\n        val fractionalPartAbs\
    \ = Math.abs(fractionalPart)\n        val integerPartAbs = Math.abs(integerPart)\n\
    \        val fractionalPartToReturn = fractionalPartAbs.min(integerPartAbs)\n\
    \        val integerPartToReturn = integerPartAbs.min(fractionalPartAbs)\n   \
    \     val closestInteger = fractionalPartToReturn.min(integerPartToReturn)\n \
    \       closestInteger.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpjz1vost0.scala:22:34 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mintegerPartAbs\e[0m = Math.abs(integerPart)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mabs\e[0m in\
    \ \e[33mobject\e[0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double):\
    \ Double\n\e[31m   |\e[0m (x$0: Float): Float\n\e[31m   |\e[0m (x$0: Long): Long\n\
    \e[31m   |\e[0m (x$0: Int): Int\n\e[31m   |\e[0mmatch arguments ((integerPart\
    \ : String))\n1 error found\n"
  stdout: ''
  timestamp: 1659805584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val mid = math.round((min + max) / 2)\n\
    \        if (mid - min == 0) mid else mid - min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmprx5p0y7v.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmprx5p0y7v.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = max - min\n\
    \        if (diff < 0)\n            min - diff\n        else\n            max\
    \ + diff\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmb2_b8tj.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmb2_b8tj.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805518
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val ints = numbers.map(_.toInt)\n \
    \       val min = ints.min\n        val max = ints.max\n        val diff = max\
    \ - min\n        val closest = (min + diff) / 2\n        val closestInt = closest.toLong\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp03oxugpu.scala:28)\n\tat Problem.main(tmp03oxugpu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8bbt9uxs.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8bbt9uxs.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val diff = (num - math.floor(num))\n        val diffAbs = Math.abs(diff)\n\
    \        val diffSign = diff / diffAbs\n        val diffAbsSign = Math.abs(diffSign)\n\
    \        val diffSignAbs = diffAbs / diffAbsSign\n        val diffSignAbsSign\
    \ = Math.abs(diffSignAbs)\n        val diffSignAbsSignAbs = diffSignAbs / diffSignAbsSign\n\
    \        val diffSignAbsSignAbsSign = Math.abs(diffSignAbsSignAbs)\n        val\
    \ diffSignAbsSignAbsSignAbs = diffSignAbsSignAbs / diffSignAbsSignAbsSign\n  \
    \      val diffSignAbsSignAbsSignAbsSign = Math.abs(diffSignAbsSignAbsSignAbsSign)\n\
    \        val diffSignAbsSignAbsSignAbsSignAbs = diffSignAbsSignAbsSignAbsSign\
    \ / diffSignAbsSignAbsSignAbsSign\n        val diffSignAbsSignAbsSignAbsSignAbsSign\
    \ = Math.abs(diffSignAbsSignAbsSignAbsSignAbsSign)\n        val diffSignAbsSignAbsSignAbsSignAbsSignAbs\
    \ = diffSignAbsSignAbsSignAbsSignAbsSign / diffSignAbsSignAbsSignAbsSignAbsSign\n\
    \        val diffSignAbsSignAbsSignAbsSignAbsSignAbsSign = Math.abs(diffSignAbsSignAbsSignAbsSignAbsSignAbsSign)\n\
    \        val diffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbs = diffSignAbsSignAbsSignAbsSignAbsSignAbsSign\
    \ / diffSignAbsSignAbsSignAbsSignAbsSignAbsSign\n        val diffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbsSign\
    \ = Math.abs(diffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbsSign)\n        val\
    \ diffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbsSignAbs = diffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbsSign\
    \ / diffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbsSign\n        val diffSignAb\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7a19hbxt.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7a19hbxt.scala:28:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdiffSignAbsSignAbsSignAbsSign\e[0m = Math.abs(diffSignAbsSignAbsSignAbsSign)\n\
    \e[31m\e[31m   |\e[0m                                                     ^\e\
    [0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mdiffSignAbsSignAbsSignAbsSign\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7a19hbxt.scala:30:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdiffSignAbsSignAbsSignAbsSignAbsSign\e[0m = Math.abs(diffSignAbsSignAbsSignAbsSignAbsSign)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^\e[0m\n\e[31m   |\e[0m         Recursive \e[33mvalue\e[0m \e[35mdiffSignAbsSignAbsSignAbsSignAbsSign\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7a19hbxt.scala:32:67\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdiffSignAbsSignAbsSignAbsSignAbsSignAbsSign\e[0m = Math.abs(diffSignAbsSignAbsSignAbsSignAbsSignAbsSign)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mdiffSignAbsSignAbsSignAbsSignAbsSignAbsSign\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7a19hbxt.scala:34:74\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdiffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbsSign\e[0m = Math.abs(diffSignAbsSignAbsSignAbsSignAbsSignAbsSignAbsSign)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               "
  stdout: ''
  timestamp: 1659805587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength - 1\n  \
    \      val intArrayLength = intArrayLength.toInt\n        val intArrayLength =\
    \ intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArrayLength =\
    \ intArrayLength.toInt\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength.toInt\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n  \
    \      val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArrayLength =\
    \ intArrayLength.toInt\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength.toInt\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n  \
    \      val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArrayLength =\
    \ intArrayLength.toInt\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength.toInt\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n  \
    \      val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArrayLength =\
    \ intArrayLength.toInt\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength.toInt\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength.toInt\n  \
    \      val \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpha70ogvu.scala:66:11 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpha70ogvu.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpha70ogvu.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpha70ogvu.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpha70ogvu.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1659805587
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = (max - min).toInt\n        val closest =\
    \ (min + diff) / 2\n        if (closest == 0) closest else closest.toLong\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprdjcxuax.scala:26)\n\tat Problem.main(tmprdjcxuax.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsDouble = intValue.asInstanceOf[Double]\n        val intValueAsFloat\
    \ = intValue.asInstanceOf[Float]\n        val intValueAsInt = intValue.asInstanceOf[Int]\n\
    \        val intValueAsShort = intValue.asInstanceOf[Short]\n        val intValueAsByte\
    \ = intValue.asInstanceOf[Byte]\n        val intValueAsChar = intValue.asInstanceOf[Char]\n\
    \        val intValueAsBoolean = intValue.asInstanceOf[Boolean]\n        val intValueAsLongLong\
    \ = intValue.asInstanceOf[LongLong]\n        val intValueAsBigDecimal = intValue.asInstanceOf[BigDecimal]\n\
    \        val intValueAsBigInt = intValue.asInstanceOf[BigInt]\n        val intValueAsString\
    \ = intValue.asInstanceOf[String]\n        val intValueAsArray = intValue.asInstanceOf[Array[String]]\n\
    \        val intValueAsArrayOfString = intValue.asInstanceOf[Array[String]]\n\
    \        val intValueAsArrayOfChar = intValue.asInstanceOf[Array[Char]]\n    \
    \    val intValueAsArrayOfByte = intValue.asInstanceOf[Array[Byte]]\n        val\
    \ intValueAsArrayOfShort = intValue.asInstanceOf[Array[Short]]\n        val intValueAsArrayOfInt\
    \ = intValue.asInstanceOf[Array[Int]]\n        val intValueAsArrayOfLong = intValue.asInstanceOf[Array[Long]]\n\
    \        val intValueAsArrayOfFloat = intValue.asInstanceOf[Array[Float]]\n  \
    \      val intValueAsArrayOfDouble = intValue.asInstanceOf[Array[Double]]\n  \
    \      val intValueAsArrayOfBigInt = intValue.asInstanceOf[Array[BigInt]]\n  \
    \      val intValueAsArrayOfBigDecimal = intValue.asInstanceOf[Array[BigDecimal]]\n\
    \        val intValueAsArrayOfBoolean = intValue.asInstanceOf[Array[Boolean]]\n\
    \        val intValueAsArrayOfLongLong = intValue.asInstanceOf[Array[LongLong]]\n\
    \        val intValueAsArrayOfString = intValue.asInstanceOf[Array[String]]\n\
    \        val intValueAsArrayOfChar = intValue.asInstanceOf[Array[Char]]\n    \
    \    \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi2wydcbc.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfString\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mString\e[0m]]\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfString is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi2wydcbc.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfChar\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mChar\e[0m]]\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfChar is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2wydcbc.scala:27:55 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mintValueAsLongLong\e[0m\
    \ = intValue.asInstanceOf[\e[35mLongLong\e[0m]\n\e[31m\e[31m   |\e[0m        \
    \                                               ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                Not found: type LongLong\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi2wydcbc.scala:43:68\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e\
    [36mintValueAsArrayOfLongLong\e[0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e\
    [35mLongLong\e[0m]]\n\e[31m\e[31m   |\e[0m                                   \
    \                                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                   Not found: type LongLong\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e"
  stdout: ''
  timestamp: 1659805587
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into integer and fractional parts\n        val\
    \ fractionalPart = parts(1).toLong // Get fractional part\n        val integerPart\
    \ = parts(0).toLong // Get integer part\n        val difference = fractionalPart\
    \ - integerPart\n        if (difference < 0)\n            fractionalPart + 1\n\
    \        else\n            fractionalPart\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmplfiiynh_.scala:19)\n\tat Problem$.main(tmplfiiynh_.scala:28)\n\
    \tat Problem.main(tmplfiiynh_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\");\n        val numParts = parts.map(_.toInt);\n      \
    \  val maxParts = parts.map(_.toLong);\n        val maxDiff = maxParts.zip(maxParts).map\
    \ { case (a, b) => math.abs(a - b) }.max;\n        val maxDiffInt = math.round(maxDiff);\n\
    \        val maxDiffLong = math.round(maxDiff);\n        val maxDiffDouble = math.round(maxDiff);\n\
    \        val maxDiffInt = math.round(maxDiff);\n        val maxDiffLong = math.round(maxDiff);\n\
    \        val maxDiffDouble = math.round(maxDiff);\n        val maxDiffInt = math.round(maxDiff);\n\
    \        val maxDiffLong = math.round(maxDiff);\n        val maxDiffDouble = math.round(maxDiff);\n\
    \        val maxDiffInt = math.round(maxDiff);\n        val maxDiffLong = math.round(maxDiff);\n\
    \        val maxDiffDouble = math.round(maxDiff);\n        val maxDiffInt = math.round(maxDiff);\n\
    \        val maxDiffLong = math.round(maxDiff);\n        val maxDiffDouble = math.round(maxDiff);\n\
    \        val maxDiffInt = math.round(maxDiff);\n        val maxDiffLong = math.round(maxDiff);\n\
    \        val maxDiffDouble = math.round(maxDiff);\n        val maxDiffInt = math.round(maxDiff);\n\
    \        val maxDiffLong = math.round(maxDiff);\n        val maxDiffDouble = math.round(maxDiff);\n\
    \        val maxDiffInt = math.round(maxDiff);\n        val maxDiffLong = math.round(maxDiff);\n\
    \        val maxDiffDouble = math.round(maxDiff);\n        val maxDiffInt = math.round(maxDiff);\n\
    \        val maxDiffLong = math.round(maxDiff);\n        val maxDiffDouble = math.round(maxDiff);\n\
    \        val maxDiffInt = math.round(maxDiff);\n        val maxDiffLong = math.round(maxDiff);\n\
    \        val maxDiffDouble = math.round(maxDiff);\n        val maxDiffInt = math.round(maxDiff);\n\
    \        val maxDiffLong = math.round(maxDiff);\n        val maxDiffDouble = math.round(maxDiff);\n\
    \        val maxDiffInt = math.round(maxDiff);\n        val maxDiffLong = math.round(maxDiff);\n\
    \        val maxDiffDouble = math.round(maxDiff);\n        val maxDiffInt = math.round(maxDiff);\n\
    \        val maxDiffLong = math.round(maxDiff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_yc7ud3p.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_yc7ud3p.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxDiffInt\e[0m = math.round(maxDiff);\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxDiffInt is already defined as \e[33mvalue\e[0m \e[35mmaxDiffInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_yc7ud3p.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxDiffLong\e[0m = math.round(maxDiff);\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmaxDiffLong is already defined as \e[33mvalue\e[0m \e[35mmaxDiffLong\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_yc7ud3p.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxDiffDouble\e[0m = math.round(maxDiff);\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxDiffDouble is already defined as \e[33mvalue\e[0m \e[35mmaxDiffDouble\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_yc7ud3p.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxDiffInt\e[0m = math.round(maxDiff);\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmaxDiffInt is already defined as \e[33mvalue\e[0m \e[35mmaxDiffInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_yc7ud3p.scala:29:12 ----------"
  stdout: ''
  timestamp: 1659805588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsString = intValue.asInstanceOf[String]\n        val intValueAsInt\
    \ = intValue.asInstanceOf[Int]\n        val intValueAsDouble = intValue.asInstanceOf[Double]\n\
    \        val intValueAsFloat = intValue.asInstanceOf[Float]\n        val intValueAsBigDecimal\
    \ = intValue.asInstanceOf[BigDecimal]\n        val intValueAsBigInt = intValue.asInstanceOf[BigInt]\n\
    \        val intValueAsBoolean = intValue.asInstanceOf[Boolean]\n        val intValueAsByte\
    \ = intValue.asInstanceOf[Byte]\n        val intValueAsShort = intValue.asInstanceOf[Short]\n\
    \        val intValueAsChar = intValue.asInstanceOf[Char]\n        val intValueAsBytes\
    \ = intValue.asInstanceOf[Bytes]\n        val intValueAsShorts = intValue.asInstanceOf[Shorts]\n\
    \        val intValueAsChars = intValue.asInstanceOf[Chars]\n        val intValueAsStrings\
    \ = intValue.asInstanceOf[Strings]\n        val intValueAsInts = intValue.asInstanceOf[Ints]\n\
    \        val intValueAsDoubles = intValue.asInstanceOf[Doubles]\n        val intValueAsFloats\
    \ = intValue.asInstanceOf[Floats]\n        val intValueAsBigDecimals = intValue.asInstanceOf[BigDecimals]\n\
    \        val intValueAsBigInts = intValue.asInstanceOf[BigInts]\n        val intValueAsBooleans\
    \ = intValue.asInstanceOf[Booleans]\n        val intValueAsBytes = intValue.asInstanceOf[Bytes]\n\
    \        val intValueAsShorts = intValue.asInstanceOf[Shorts]\n        val intValueAsChars\
    \ = intValue.asInstanceOf[Chars]\n        val intValueAsStrings = intValue.asInstanceOf[Strings]\n\
    \        val intValueAsInts = intValue.asInstanceOf[Ints]\n        val intValueAsDoubles\
    \ = intValue.asInstanceOf[Doubles]\n        val intValueAsFloats = intValue.asInstanceOf[Floats]\n\
    \        val intValueAsBigDecimals = intValue.asInstanceOf[BigDecimals]\n    \
    \    val intValueAsBigInts = intValue.asInstanceOf[BigInts]\n        val intValueAs\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprbqom8mp.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprbqom8mp.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintValueAsBytes\e[0m = intValue.asInstanceOf[\e[35mBytes\e[0m]\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mintValueAsBytes is already defined as \e[33mvalue\e[0m \e[35mintValueAsBytes\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprbqom8mp.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mintValueAsShorts\e[0m = intValue.asInstanceOf[\e\
    [35mShorts\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsShorts is already defined as \e[33mvalue\e[0m \e\
    [35mintValueAsShorts\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprbqom8mp.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mintValueAsChars\e[0m = intValue.asInstanceOf[\e\
    [35mChars\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsChars is already defined as \e[33mvalue\e[0m \e\
    [35mintValueAsChars\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprbqom8mp.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mintValueAsStrings\e[0m =\
    \ intValue.asInstanceOf[\e[35mStrings\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsStrings is already defined as \e[33mvalue\e[0m \e\
    [35mintValueAsStrings\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val roundTo = diff / 2\n        val roundFrom = min - roundTo\n     \
    \   val roundToInt = math.round(roundTo)\n        val roundFromInt = math.round(roundFrom)\n\
    \        val roundToIntInt = math.round(roundToInt)\n        val roundFromIntInt\
    \ = math.round(roundFromInt)\n        val roundToIntIntInt = math.round(roundToIntInt)\n\
    \        val roundFromIntIntInt = math.round(roundFromIntInt)\n        val roundToIntIntIntInt\
    \ = math.round(roundToIntIntInt)\n        val roundFromIntIntIntInt = math.round(roundFromIntIntInt)\n\
    \        val roundToIntIntIntIntInt = math.round(roundToIntIntIntInt)\n      \
    \  val roundFromIntIntIntIntInt = math.round(roundFromIntIntIntInt)\n        val\
    \ roundToIntIntIntIntIntInt = math.round(roundToIntIntIntIntInt)\n        val\
    \ roundFromIntIntIntIntIntInt = math.round(roundFromIntIntIntIntInt)\n       \
    \ val roundToIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntInt)\n\
    \        val roundFromIntIntIntIntIntIntIntInt = math.round(roundFromIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundFromIntIntIntIntIntIntIntIntInt = math.round(roundFromIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundFromIntIntIntIntIntIntIntIntIntIntInt = math.round(roundFromIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundFromIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(roundFromIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg7yv5vo7.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpg7yv5vo7.scala:19:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e\
    [0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpg7yv5vo7.scala:20:23 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg7yv5vo7.scala:36:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mroundToIntIntIntIntIntIntInt\e[0m = math.round(roundToIntIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e[0m \e[35mroundToIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg7yv5vo7.scala:37:59\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mroundFromIntIntIntIntIntIntIntInt\e[0m = math.round(roundFromIntIntIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1659805588
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.head, nums.last)\n\
    \        val max = math.max(nums.head, nums.last)\n        val diff = max - min\n\
    \        val closest = (min + max) / 2\n        val closestDiff = math.abs(closest\
    \ - diff)\n        if (diff < 0 && closestDiff < diff) closest else closest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd3q71rok.scala:28)\n\tat Problem.main(tmpd3q71rok.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val closestToZero = smallest + difference\n        closestToZero\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3kss92a4.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3kss92a4.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsDouble = intValue.asInstanceOf[Double]\n        val intValueAsInt\
    \ = intValue.asInstanceOf[Int]\n        val intValueAsFloat = intValue.asInstanceOf[Float]\n\
    \        val intValueAsBigDecimal = intValue.asInstanceOf[BigDecimal]\n      \
    \  val intValueAsBigInt = intValue.asInstanceOf[BigInt]\n        val intValueAsBoolean\
    \ = intValue.asInstanceOf[Boolean]\n        val intValueAsString = intValue.asInstanceOf[String]\n\
    \        val intValueAsChar = intValue.asInstanceOf[Char]\n        val intValueAsByte\
    \ = intValue.asInstanceOf[Byte]\n        val intValueAsShort = intValue.asInstanceOf[Short]\n\
    \        val intValueAsArray = intValue.asInstanceOf[Array[String]]\n        val\
    \ intValueAsArrayOfString = intValue.asInstanceOf[Array[String]]\n        val\
    \ intValueAsArrayOfChar = intValue.asInstanceOf[Array[Char]]\n        val intValueAsArrayOfByte\
    \ = intValue.asInstanceOf[Array[Byte]]\n        val intValueAsArrayOfShort = intValue.asInstanceOf[Array[Short]]\n\
    \        val intValueAsArrayOfInt = intValue.asInstanceOf[Array[Int]]\n      \
    \  val intValueAsArrayOfLong = intValue.asInstanceOf[Array[Long]]\n        val\
    \ intValueAsArrayOfFloat = intValue.asInstanceOf[Array[Float]]\n        val intValueAsArrayOfDouble\
    \ = intValue.asInstanceOf[Array[Double]]\n        val intValueAsArrayOfBigDecimal\
    \ = intValue.asInstanceOf[Array[BigDecimal]]\n        val intValueAsArrayOfBigInt\
    \ = intValue.asInstanceOf[Array[BigInt]]\n        val intValueAsArrayOfBoolean\
    \ = intValue.asInstanceOf[Array[Boolean]]\n        val intValueAsArrayOfString\
    \ = intValue.asInstanceOf[Array[String]]\n        val intValueAsArrayOfChar =\
    \ intValue.asInstanceOf[Array[Char]]\n        val intValueAsArrayOfByte = intValue.asInstanceOf[Array[Byte]]\n\
    \        val intValueAsArrayOfShort = intValue.asInstanceOf[Array[Short]]\n  \
    \      \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0xkuz1k1.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfString\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mString\e[0m]]\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfString is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0xkuz1k1.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfChar\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mChar\e[0m]]\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfChar is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0xkuz1k1.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfByte\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mByte\e[0m]]\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfByte is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfByte\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0xkuz1k1.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mintValueAsArrayOfShort\e\
    [0m = intValue.asInstanceOf[\e[35mArray\e[0m[\e[35mShort\e[0m]]\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueAsArrayOfShort is already defined as \e[33mvalue\e\
    [0m \e[35mintValueAsArrayOfShort\e[0m\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1659805588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closestInteger((\"10\"))\n    // (10l)\n    // >>> closestInteger((\"15.3\"\
    ))\n    // (15l)\n    // Note:\n    // Rounding away from zero means that if the\
    \ given number is equidistant\n    // from two integers, the one you should return\
    \ is the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl8rgyof_.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl8rgyof_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl8rgyof_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805537
