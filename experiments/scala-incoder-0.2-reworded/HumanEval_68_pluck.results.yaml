language: scala
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evenMin = even.min\n        val evenIndex\
    \ = even.indexOf(evenMin)\n        val evenMinIndex = evenIndex\n        val evenMinValue\
    \ = evenMin\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        val evenMinValueIndex = evenMinIndex\n        val evenMinValueIndex\
    \ = evenMinIndex\n        \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp03oqiq9f.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenMinValueIndex\e[0m =\
    \ evenMinIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenMinValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mevenMinValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp03oqiq9f.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevenMinValueIndex\e[0m =\
    \ evenMinIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenMinValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mevenMinValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp03oqiq9f.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenMinValueIndex\e[0m =\
    \ evenMinIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenMinValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mevenMinValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp03oqiq9f.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenMinValueIndex\e[0m =\
    \ evenMinIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenMinValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35mevenMinValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp03oqiq9f.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenMinValueIndex\e[0m =\
    \ evenMinIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n   \
    \     val evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        if (evenSmallestIndexList.length == 1) {\n            val evenSmallestIndexValue\
    \ = evenSmallestIndexList(0)\n            val evenSmallestValueValue = evenSmallestValueList(0)\n\
    \            val evenSmallestIndexIndexValue = evenSmallestIndexList(0)\n    \
    \        val evenSmallestValueIndexValue = evenSmallestValueList(0)\n        \
    \    val evenSmallestIndexValueIndexValue = evenSmallestIndexList(0)\n       \
    \     val evenSmallestIndexValueIndexValue = 0\n            val evenSmallestIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValue =\
    \ 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = 0\n            val evenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr2l06s43.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr2l06s43.scala:70:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpr2l06s43.scala:35:54 ------------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr2l06s43.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpr2l06s43.scala:43:16 ---------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \e[36mevenSmallestIndexValueIndexValue\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexValueIndexValue is already defined as \e\
    [33mvalue\e[0m \e[35mevenSmallestIndexValueIndexValue\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr2l06s43.scala:52:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m            \e[33mval\e\
    [0m \e[36mevenSmallestIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mev"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = List(smallest, index)\n        if (evens.isEmpty) result\n\
    \        else pluck(arr.filter(_ != smallest))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmzlrzt6u.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798715
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = arr.filter(x => x % 2 == 0).min\n        val smalest_index\
    \ = arr.indexOf(smalest_value)\n        val result = List(smalest_value, smalest_index)\n\
    \        if (evens.isEmpty) result\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9cv88_ym.scala:36:27\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9cv88_ym.scala:37:13 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m\
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(x => x % 2 == 0).map(x => x -> index).toList\n\
    \        if (result.isEmpty) result else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg3pbslpu.scala:34:28\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m                       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                            Found:    \e[1m\e\
    [31m(\e[0m\e[1m\e[31mresult\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m\
    \ \e[0mList[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e\
    [0m\e[1m\e[31m)\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                      \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpg3pbslpu.scala:34:40 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mif\e[0m (result.isEmpty) result \e[33melse\e[0m result\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Found:    \e[1m\e[31m(\e[0m\e[1m\e\
    [31mresult\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[\e[1m\e\
    [31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                                  Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.isEmpty) {\n \
    \           evenSmallestIndexList.map(_ => evenSmallestValueList).filter(_ =>\
    \ _ != evenSmallestValue).headOption\n        } else {\n            evenSmallestIndexList.map(_\
    \ => evenSmallestValueList).filter(_ => _ == evenSmallestValue).headOption\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5pmjz43w.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5pmjz43w.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(even)\n        val result = arr.filter(_ != even).sortBy(x\
    \ => x).reverse\n        if (result.isEmpty) Nil\n        else result.take(index).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0pwiqc3r.scala:38)\n\tat Problem.main(tmp0pwiqc3r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List(arr.head.toLong)\n\
    \        else evens.takeWhile(x => x % 2 == 0).sortBy(x => x).reverse.head\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvne3eclj.scala:32:69\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.takeWhile(x\
    \ => x % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(x => x).reverse.head\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).toList\n        if (evens.isEmpty)\
    \ result\n        else result.updated(index, even)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_7fzm2v.scala:38)\n\tat Problem.main(tmp2_7fzm2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(_\
    \ % 2 == 0).toList\n        if (even.isEmpty) List()\n        else {\n       \
    \     val smalest_value = even.min\n            val smalest_index = even.indexOf(smalest_value)\n\
    \            val result = even.filter(_ == smalest_value).sortWith(_ < _).takeWhile(_\
    \ < smalest_index).reverse\n            even.filter(_ == smalest_value).sortWith(_\
    \ < _).takeWhile(_ < smalest_index).reverse ++ result\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp21r6gcb_.scala:40)\n\tat Problem.main(tmp21r6gcb_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(even)\n        val result = arr.filter(_ == even).sortBy(x\
    \ => x).reverse\n        if (result.isEmpty) List(even.toLong, index.toLong)\n\
    \        else result.take(1).map(x => (x.toLong, index.toLong))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp00wre8bg.scala:35:37\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.take(\e\
    [31m1\e[0m).map(x => (x.toLong, index.toLong))\n\e[31m\e[31m   |\e[0m        \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                    Found:    (Long, Long)\n\e[31m   |\e[0m \
    \                                    Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = evens.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (result.size ==\
    \ 2) result\n            else result.reverse\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplfi74jpb.scala:36:34\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (result.size\
    \ == \e[31m2\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                                  Found:   \
    \ (result : List[AnyVal])\n\e[31m   |\e[0m                                  Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplfi74jpb.scala:37:24\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result.reverse\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \              Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m       \
    \          Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n        \
    \    val minEven = evens.min\n            val minIndex = evens.indexOf(minEven)\n\
    \            val minEvenIndex = minIndex\n            val minEvenValue = minEven\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n           \
    \ val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n\
    \            val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex\
    \ = minEvenIndex\n            val minEvenValueIndex = minEvenIndex\n         \
    \   val minEvenValueIndex = minEvenIndex\n            val minEvenValueIndex =\
    \ minEvenIndex\n            val minEven\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5cilij1u.scala:83:4 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5cilij1u.scala:96:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5cilij1u.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5cilij1u.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5cilij1u.scala:40:16 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is already defined as \e[33mvalue\e[0m \e[35mminEvenValueIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5cilij1u.scala:41:16 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m            \e[33mval\e[0m \e[36mminEvenValueIndex\e[0m = minEvenIndex\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminEvenValueIndex is alread"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = evens.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (result.length\
    \ == 1) result else result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpym781q88.scala:36:36\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (result.length\
    \ == \e[31m1\e[0m) result \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m      \
    \                              ^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m        \
    \                            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpym781q88.scala:36:48 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (result.length == \e[31m1\e\
    [0m) result \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m                    \
    \                            ^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                   Found:    (result : List[AnyVal])\n\e[31m   |\e[0m       \
    \                                Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evensSortedIndex = evensSorted.zipWithIndex.toList\n        val smalestValue\
    \ = evensSortedIndex.find(x => x._2._2 < evensSortedIndex.size)\n        val smalestIndex\
    \ = evensSortedIndex.find(x => x._2._2 == evensSortedIndex.size)\n        val\
    \ smalestValueAndIndex = smalestValue.get._1 -> smalestIndex.get._1\n        val\
    \ smalestValueAndIndexList = smalestValueAndIndex.map(x => x._1 -> x._2)\n   \
    \     val smalestValueAndIndexListSorted = smalestValueAndIndexList.sortWith((x,\
    \ y) => x._1 < y._1)\n        val smalestValueAndIndexListSortedWithIndex = smalestValueAndIndexListSorted.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndex.sortWith((x, y) => x._1 < y._1)\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndex = smalestValueAndIndexListSortedWithIndexSortedWithIndex.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSorted.sortWith((x,\
    \ y) => x._1 < y._1)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndex.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortWith((x,\
    \ y) => x._1 < y._1)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalestValueAndIndex\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb9844sgy.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb9844sgy.scala:33:59\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36msmalestValue\e[0m = evensSortedIndex.find(\e[36mx\e[0m => x._2._2 < evensSortedIndex.size)\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         value _2 is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb9844sgy.scala:34:59\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36msmalestIndex\e[0m = evensSortedIndex.find(\e[36mx\e[0m => x._2._2 == evensSortedIndex.size)\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         value _2 is not a\
    \ member of Int\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpb9844sgy.scala:36:64\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e\
    [0m \e[36msmalestValueAndIndexList\e[0m = smalestValueAndIndex.map(\e[36mx\e[0m\
    \ => x._1 -> x._2)\n\e[31m\e[31m   |\e[0m                                    \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \ Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                   \
    \       I could not infer the type of the parameter x.\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpb9844sgy.scala:37:70 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalestValueAndIndexListSorted\e\
    [0m = smalestValueAndIndexList.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>"
  stdout: ''
  timestamp: 1659798717
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(_ ==\
    \ smalest_value)\n        if (smalest_evens.isEmpty) Nil\n        else smalest_evens.take(smalest_index).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg3uu30uv.scala:38)\n\tat Problem.main(tmpg3uu30uv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val min = evens.min\n            val index = evens.indexOf(min)\n\
    \            val result = List(min, index)\n            if (evens.size == 1) result\n\
    \            else result :: pluck(arr.filter(_ != min))\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7durap0f.scala:36:33\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.size\
    \ == \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                                 Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7durap0f.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\
    \ :: pluck(arr.filter(_ != min))\n\e[31m\e[31m   |\e[0m                 ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        if (evens.isEmpty) {\n            List[Long]()\n        } else {\n  \
    \          List[Long](even, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmp4fuakjhe.scala:31)\n\tat Problem$.main(tmp4fuakjhe.scala:42)\n\
    \tat Problem.main(tmp4fuakjhe.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val index = smallestEvenIndex\n        val value = smallestEven\n   \
    \     val result = List(value, index)\n        if (evensSorted.isEmpty) {\n  \
    \          result\n        } else {\n            val nextEven = evensSorted.drop(index\
    \ + 1)\n            val nextEvenIndex = nextEven.indexOf(0)\n            val nextEvenValue\
    \ = nextEven.head\n            val nextEvenIndex = nextEvenIndex + 1\n       \
    \     val nextEvenValue = nextEvenValue\n            val nextEvenIndex = nextEvenIndex\
    \ + 1\n            val nextEvenValue = nextEvenValue\n            val nextEvenIndex\
    \ = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n       \
    \     val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n\
    \            val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue\
    \ = nextEvenValue\n            val nextEvenIndex = nextEvenIndex + 1\n       \
    \     val nextEvenValue = nextEvenValue\n            val nextEvenIndex = nextEvenIndex\
    \ + 1\n            val nextEvenValue = nextEvenValue\n            val nextEvenIndex\
    \ = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n       \
    \     val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n\
    \            val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue\
    \ = nextEvenValue\n            val nextEvenIndex = nextEvenIndex + 1\n       \
    \     val nextEvenValue = nextEvenValue\n            val nextEvenIndex = nextEvenIndex\
    \ + 1\n            val nextEvenValue = nextEvenValue\n            val nextEvenIndex\
    \ = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n       \
    \     val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n\
    \            val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue\
    \ = nextEvenValue\n            val nextEvenIndex = nextEvenIndex + 1\n       \
    \     val nextEvenValue = nextEvenValue\n            val nextEvenIndex = nextEvenIndex\
    \ + 1\n            val nextEvenValue = nextEvenValue\n            val nextEvenIndex\
    \ = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n       \
    \     val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue = nextEvenValue\n\
    \            val nextEvenIndex = nextEvenIndex + 1\n            val nextEvenValue\
    \ = nextEvenValue\n            val nextEvenIndex = nextEvenIndex + 1\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_ejx80ob.scala:98:0 ----------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_ejx80ob.scala:43:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e\
    [0m \e[36mnextEvenIndex\e[0m = nextEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnextEvenIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mnextEvenIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_ejx80ob.scala:44:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m            \e[33mval\e\
    [0m \e[36mnextEvenValue\e[0m = nextEvenValue\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnextEvenValue is already\
    \ defined as \e[33mvalue\e[0m \e[35mnextEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_ejx80ob.scala:45:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e\
    [0m \e[36mnextEvenIndex\e[0m = nextEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnextEvenIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mnextEvenIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_ejx80ob.scala:46:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            \e[33mval\e\
    [0m \e[36mnextEvenValue\e[0m = nextEvenValue\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnextEvenValue is already\
    \ defined as \e[33mvalue\e[0m \e[35mnextEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/t"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evensSortedWithIndex = evensSorted.zipWithIndex.toList\n        val\
    \ smallestEven = evensSortedWithIndex.minBy(x => x._2)\n        val smallestEvenIndex\
    \ = evensSortedWithIndex.indexOf(smallestEven)\n        val smallestEvenValue\
    \ = smallestEven._1\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.to\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3evneylk.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3evneylk.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3evneylk.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3evneylk.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp3evneylk.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1659798716
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(0)\n        val result = arr.filter(_ == even).sortBy(x\
    \ => x).reverse\n        if (result.isEmpty) List()\n        else List(even, index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp943e1ohd.scala:38)\n\tat Problem.main(tmp943e1ohd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortBy(x => x)\n    \
    \    val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.max)\n        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.max)\n        val\
    \ evensSorted = evens\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdc_sl05c.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdc_sl05c.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdc_sl05c.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdc_sl05c.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdc_sl05c.scala:36:12 ---------"
  stdout: ''
  timestamp: 1659798715
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ogvx0te.scala:39)\n\tat Problem.main(tmp9ogvx0te.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted\
    \ = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n     \
    \   val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted =\
    \ evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n       \
    \ val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_\
    \ < _)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n  \
    \      val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted\
    \ = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n     \
    \   val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted =\
    \ evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n       \
    \ val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_\
    \ < _)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n  \
    \      val smallestEven = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1dyul4zb.scala:68:26 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36msmallestEven\e[0m = \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp1dyul4zb.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1dyul4zb.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEven\e[0m = evensSorted.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmallestEven is already defined as \e[33mvalue\e[0m \e[35msmallestEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1dyul4zb.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = evensSorted.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1dyul4zb.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as"
  stdout: ''
  timestamp: 1659798727
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else result.take(index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0__6tjon.scala:38)\n\tat Problem.main(tmp0__6tjon.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = arr.filter(_ == smallest).toList\n        if (result.isEmpty)\
    \ List()\n        else List(smallest, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpifbc2p2b.scala:39)\n\tat Problem.main(tmpifbc2p2b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).map(_ / 2)\n        val even = evens.head\n        val\
    \ index = evens.indexOf(0)\n        val result = arr.filter(_ % 2 == 0).sortBy(_\
    \ % 2).map(_ / 2).takeWhile(_ != even).take(index).toList\n        if (result.isEmpty)\
    \ Nil\n        else result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkc4ggj9p.scala:38)\n\tat Problem.main(tmpkc4ggj9p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val even = evens.min\n            val index = arr.indexOf(even)\n\
    \            List(even, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(_ != even).take(index).sorted\n        result.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbxunbm8w.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e\
    [32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexWhere(x => x == smalest_value)\n        if (smalest_index == -1)\
    \ arr.toList\n        else evens.take(smalest_index).filter(_ % 2 == 0).sortWith(_\
    \ < _).take(1).map(_ + smalest_value)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8z4vegjh.scala:37)\n\tat Problem.main(tmp8z4vegjh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(_\
    \ % 2 == 0).toList\n        val evenSorted = even.sortWith(_ < _)\n        val\
    \ evenSmallest = evenSorted.head\n        val evenSmallestIndex = evenSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        if (evenSmallestIndexList.length == 1) {\n            evenSmallestIndexList.head\
    \ -> evenSmallestValueList\n        } else if (evenSmallestIndexList.length ==\
    \ 0) {\n            evenSmallestIndexList -> evenSmallestValueList\n        }\
    \ else {\n            evenSmallestIndexList.head -> evenSmallestValueList\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp35mp2vul.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp35mp2vul.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzu1i6myn.scala:39)\n\tat Problem.main(tmpzu1i6myn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ Nil\n        else result.take(index).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplbm7zd7v.scala:38)\n\tat Problem.main(tmplbm7zd7v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        if (smalest_index > 0) {\n            val smalest_evens\
    \ = evens.take(smalest_index)\n            val smalest_evens_index = evens.indexOf(smalest_evens.min())\n\
    \            val smalest_evens_value = smalest_evens(smalest_evens_index)\n  \
    \          val smalest_evens_index = smalest_evens_index + 1\n            val\
    \ smalest_evens_value = smalest_evens_value.toLong\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value.toLong\n\
    \            val smalest_evens_index = smalest_evens_index + 1\n            val\
    \ smalest_evens_value = smalest_evens_value.toLong\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value.toLong\n\
    \            val smalest_evens_index = smalest_evens_index + 1\n            val\
    \ smalest_evens_value = smalest_evens_value.toLong\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value.toLong\n\
    \            val smalest_evens_index = smalest_evens_index + 1\n            val\
    \ smalest_evens_value = smalest_evens_value.toLong\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value.toLong\n\
    \            val smalest_evens_index = smalest_evens_index + 1\n            val\
    \ smalest_evens_value = smalest_evens_value.toLong\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value.toLong\n\
    \            val smalest_evens_index = smalest_evens_index + 1\n            val\
    \ smalest_evens_value = smalest_evens_value.toLong\n            val smalest_evens_index\
    \ = smalest_evens_index + 1\n            val smalest_evens_value = smalest_evens_value.toLong\n\
    \            val smalest_evens_index = smalest_evens_index + 1\n            val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0y5yz_2a.scala:62:15 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0y5yz_2a.scala:76:0 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0y5yz_2a.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36msmalest_evens_index\e[0m = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m \e[35msmalest_evens_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0y5yz_2a.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36msmalest_evens_value\e[0m = smalest_evens_value.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0y5yz_2a.scala:39:16 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36msmalest_evens_index\e\
    [0m = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0y5yz_2a.scala:"
  stdout: ''
  timestamp: 1659798729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_index_plus_1\
    \ = evens.indexOf(smalest_even) + 1\n        val smalest_even_index_plus_2 = evens.indexOf(smalest_even)\
    \ + 2\n        val smalest_even_index_plus_3 = evens.indexOf(smalest_even) + 3\n\
    \        val smalest_even_index_plus_4 = evens.indexOf(smalest_even) + 4\n   \
    \     val smalest_even_index_plus_5 = evens.indexOf(smalest_even) + 5\n      \
    \  val smalest_even_index_plus_6 = evens.indexOf(smalest_even) + 6\n        val\
    \ smalest_even_index_plus_7 = evens.indexOf(smalest_even) + 7\n        val smalest_even_index_plus_8\
    \ = evens.indexOf(smalest_even) + 8\n        val smalest_even_index_plus_9 = evens.indexOf(smalest_even)\
    \ + 9\n        val smalest_even_index_plus_10 = evens.indexOf(smalest_even) +\
    \ 10\n        val smalest_even_index_plus_11 = evens.indexOf(smalest_even) + 11\n\
    \        val smalest_even_index_plus_12 = evens.indexOf(smalest_even) + 12\n \
    \       val smalest_even_index_plus_13 = evens.indexOf(smalest_even) + 13\n  \
    \      val smalest_even_index_plus_14 = evens.indexOf(smalest_even) + 14\n   \
    \     val smalest_even_index_plus_15 = evens.indexOf(smalest_even) + 15\n    \
    \    val smalest_even_index_plus_16 = evens.indexOf(smalest_even) + 16\n     \
    \   val smalest_even_index_plus_17 = evens.indexOf(smalest_even) + 17\n      \
    \  val smalest_even_index_plus_18 = evens.indexOf(smalest_even) + 18\n       \
    \ val smalest_even_index_plus_19 = evens.indexOf(smalest_even) + 19\n        val\
    \ smalest_even_index_plus_20 = evens.indexOf(smalest_even) + 20\n        val smalest_even_index_plus_21\
    \ = evens.indexOf(smalest_even) + 21\n        val smalest_even_index_plus_22 =\
    \ evens.indexOf(smalest_even) + 22\n        val smalest_even_index_plus_23 = evens.indexOf(smalest_even)\
    \ + \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpogf62gfg.scala:57:70 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_plus_23\e\
    [0m = evens.indexOf(smalest_even) + \n\e[31m\e[31m   |\e[0m                  \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                      expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpogf62gfg.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).take(index).toList\n        if (result.isEmpty)\
    \ Nil\n        else result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp27aown7d.scala:38)\n\tat Problem.main(tmp27aown7d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmpz1a7i2xx.scala:31)\n\tat Problem$.main(tmpz1a7i2xx.scala:40)\n\
    \tat Problem.main(tmpz1a7i2xx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).takeWhile(_ < arr.last).map(x => x).reverse\n\
    \        if (even.isEmpty) Nil\n        else even.head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqeun8ljt.scala:32:18\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m even.head\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \ Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.length == 1) {\n\
    \            evenSmallestIndexList\n        } else {\n            val evenSmallestIndexListSorted\
    \ = evenSmallestIndexList.sortWith((x, y) => x.toLong < y.toLong)\n          \
    \  val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x, y) =>\
    \ x.toLong < y.toLong)\n            evenSmallestIndexListSorted.head\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6fwlwnbn.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6fwlwnbn.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven.toLong\n\
    \        val result = arr.filter(_ == smallestEvenValue)\n        if (result.isEmpty)\
    \ {\n            List()\n        } else {\n            val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n            val smallestEvenValue = smallestEven.toLong\n\
    \            val result = arr.filter(_ == smallestEvenValue)\n            val\
    \ index = arr.indexOf(0)\n            val value = arr.filter(_ == smallestEvenValue).head\n\
    \            val resultList = List(smallestEvenValue, index)\n            resultList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeo92wk4x.scala:45:12\
    \ --------------------\e[0m\e[0m\n\e[31m45 |\e[0m            resultList\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:  \
    \  (resultList : List[AnyVal])\n\e[31m   |\e[0m            Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798728
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortWith(_ < _).take(index).toList\n\
    \        if (result.isEmpty) List()\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgrxvjnr5.scala:38)\n\tat Problem.main(tmpgrxvjnr5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestValueListSortedReversed\
    \ = evenSmallestValueListSorted.reverse\n        val evenSmallestValueListSortedReversedSorted\
    \ = evenSmallestValueListSortedReversed.sortWith((x, y) => x.toLong < y.toLong)\n\
    \        val evenSmallestValueListSortedReversedSortedReversed = evenSmallestValueListSortedReversedSorted.reverse\n\
    \        val evenSmallestValueListSortedReversedSortedReversedSorted = evenSmallestValueListSortedReversedSortedReversed.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSortedReversed\
    \ = evenSmallestValueListSortedReversedSortedReversedSorted.reverse\n        val\
    \ evenSmallestValueListSortedReversedSortedReversedSortedReversedSorted = evenSmallestValueListSortedReversedSortedReversedSortedReversed.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed\
    \ = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted\
    \ = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSortedReversed\
    \ = evenSmallestValueListSorted\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpro0yb6mi.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpro0yb6mi.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpro0yb6mi.scala:45:92 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed\e\
    [0m = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong < y.toLong)\n\e[31m\e[31m   |\e[0m     \
    \                                                                            \
    \           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m \
    \  |\e[0m  evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversed\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpro0yb6mi.scala:46:98 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted\e\
    [0m = evenSmallestValueListSortedReversedSortedReversedSortedReversedSortedReversedSorted.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong < y.toLong)\n\e[31m\e[31m   |\e[0m     \
    \                                                                            \
    \                 ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e\
    [31m   |\e[0m  evenSmallestValueListSortedReversedSortedR"
  stdout: ''
  timestamp: 1659798730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val smallest = evens.head\n        val\
    \ index = evens.indexOf(0)\n        val result = (smallest :: arr.filterNot(x\
    \ => x == smallest)).toList\n        if (result.isEmpty) result\n        else\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5gvfeejf.scala:38)\n\tat Problem.main(tmp5gvfeejf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ogvx0te.scala:39)\n\tat Problem.main(tmp9ogvx0te.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(x => x % 2 == 0).take(index).map(x => x % 2 ==\
    \ 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x\
    \ => x % 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x => x %\
    \ 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x\
    \ => x == 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x => x ==\
    \ 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x\
    \ => x % 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x => x %\
    \ 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x\
    \ => x % 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x => x %\
    \ 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x\
    \ => x == 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x => x ==\
    \ 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x\
    \ => x % 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x => x %\
    \ 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x\
    \ => x % 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x => x %\
    \ 2 == 0).filter(x => x == 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x\
    \ => x == 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x => x ==\
    \ 0).take(1).map(x => x % 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x\
    \ => x % 2 == 0).map(x => x % 2 == 0).filter(x => x == 0).take(1).map(x => \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp33uw7rr0.scala:33:1539 -------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).take(index).map(\e[36mx\e[0m =>\
    \ x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e\
    [31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e[0m).take(\e[31m1\e[0m).map(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e\
    [0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e[0m).take(\e[31m1\e\
    [0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m =>\
    \ x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e[0m).take(\e\
    [31m1\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e\
    [0m => x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e\
    [0m).take(\e[31m1\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e\
    [31m0\e[0m).take(\e[31m1\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e\
    [0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e[36mx\e[0m\
    \ => x == \e[31m0\e[0m).take(\e[31m1\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m\
    \ == \e[31m0\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e\
    [36mx\e[0m => x == \e[31m0\e[0m).take(\e[31m1\e[0m).map(\e[36mx\e[0m => x % \e\
    [31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e\
    [0m).filter(\e[36mx\e[0m => x == \e[31m0\e[0m).take(\e[31m1\e[0m).map(\e[36mx\e\
    [0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m\
    \ == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e[0m).take(\e[31m1\e[0m).map(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e\
    [0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e[0m).take(\e[31m1\e\
    [0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e[0m =>\
    \ x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e[0m).take(\e\
    [31m1\e[0m).map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).map(\e[36mx\e\
    [0m => x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x == \e[31m0\e\
    [0m).take(\e[31m1\e[0m).map(\e[36mx\e[0m => "
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.isEmpty) {\n \
    \           List[Long]()\n        } else if (evenSmallestValueList.isEmpty) {\n\
    \            List[Long](evenSmallestValue)\n        } else {\n            List[Long](evenSmallestValue,\
    \ evenSmallestIndexList(0))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdkzau5ny.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpdkzau5ny.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedIndex = evensSorted.zipWithIndex.toList\n\
    \        val smallestEven = evensSortedIndex.find(x => x._1.toLong == evensSortedIndex.minBy(x\
    \ => x._1.toLong)._1.toLong).get._1\n        val smallestEvenIndex = evensSortedIndex.find(x\
    \ => x._1.toLong == evensSortedIndex.minBy(x => x._1.toLong)._1.toLong).get._2\n\
    \        val smallestEvenValue = evensSortedIndex.find(x => x._1.toLong == evensSortedIndex.minBy(x\
    \ => x._1.toLong)._1.toLong).get._1.toLong\n        val smallestEvenIndex = evensSortedIndex.find(x\
    \ => x._1.toLong == evensSortedIndex.minBy(x => x._1.toLong)._1.toLong).get._2\n\
    \        val smallestEvenValue = evensSortedIndex.find(x => x._1.toLong == evensSortedIndex.minBy(x\
    \ => x._1.toLong)._1.toLong).get._1.toLong\n        val smallestEvenIndex = evensSortedIndex.find(x\
    \ => x._1.toLong == evensSortedIndex.minBy(x => x._1.toLong)._1.toLong).get._2\n\
    \        val smallestEvenValue = evensSortedIndex.find(x => x._1.toLong == evensSortedIndex.minBy(x\
    \ => x._1.toLong)._1.toLong).get._1.toLong\n        val smallestEvenIndex = evensSortedIndex.find(x\
    \ => x._1.toLong == evensSortedIndex.minBy(x => x._1.toLong)._1.toLong).get._2\n\
    \        val smallestEvenValue = evensSortedIndex.find(x => x._1.toLong == evensSortedIndex.minBy(x\
    \ => x._1.toLong)._1.toLong).get._1.toLong\n        val smallestEvenIndex = evensSortedIndex.find(x\
    \ => x._1.toLong == evensSortedIndex.minBy(x => x._1.toLong)._1.toLong).get._2\n\
    \        val smallestEvenValue = evensSortedIndex.find(x => x._1.toLong == evensSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz4m5kt6l.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz4m5kt6l.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = evensSortedIndex.find(\e[36mx\e[0m => x._1.toLong\
    \ == evensSortedIndex.minBy(\e[36mx\e[0m => x._1.toLong)._1.toLong).get._2\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz4m5kt6l.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ evensSortedIndex.find(\e[36mx\e[0m => x._1.toLong == evensSortedIndex.minBy(\e\
    [36mx\e[0m => x._1.toLong)._1.toLong).get._1.toLong\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz4m5kt6l.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSortedIndex.find(\e[36mx\e[0m => x._1.toLong == evensSortedIndex.minBy(\e\
    [36mx\e[0m => x._1.toLong)._1.toLong).get._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0 && x != even).sorted\n      \
    \  if (result.isEmpty) Nil\n        else result.take(index).map(x => (x, index))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9qcs27uo.scala:35:41\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.take(index).map(x\
    \ => (x, index))\n\e[31m\e[31m   |\e[0m                                      \
    \   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                         Found:\
    \    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e\
    [1m\e[31m)\e[0m\n\e[31m   |\e[0m                                         Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (even.isEmpty) List()\n        else {\n  \
    \          val smalest_value = even.min\n            val smalest_index = even.indexOf(smalest_value)\n\
    \            val smalest_even_value = smalest_value % 2\n            val smalest_even_index\
    \ = smalest_index\n            val smalest_even_value_index = smalest_even_value\n\
    \            val smalest_even_value_index_list = even.filter(x => x % 2 == smalest_even_value_index).toList\n\
    \            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val smalest_even_value_index_list = smalest_even_value_index_list.minBy(x\
    \ => x)\n            val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmplvea2rvu.scala:57:15 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplvea2rvu.scala:71:0 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplvea2rvu.scala:39:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e\
    [0m \e[36msmalest_even_value_index_list\e[0m = smalest_even_value_index_list.minBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplvea2rvu.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value_index_list\e\
    [0m = smalest_even_value_index_list.minBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplvea2rvu.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_value_index_list\e\
    [0m = smalest_even_value_index_list.minBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_index_list is alrea"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val smallest = evens.head\n        val\
    \ index = evens.indexOf(smallest)\n        val result = List(smallest, index)\n\
    \        if (evens.isEmpty) result\n        else pluck(arr.filterNot(x => x %\
    \ 2 == 0).sortBy(x => x))\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6yv5k7qg.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallest = evens.min\n        val index =\
    \ evens.indexOf(smallest)\n        val result: List[Long] = if (index == -1) Nil\
    \ else List(smallest, index)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplry0b_5o.scala:38)\n\tat Problem.main(tmplry0b_5o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evensSortedWithIndex = evensSorted.zipWithIndex\n        val smallestEven\
    \ = evensSortedWithIndex.minBy(_._1)\n        val smallestEvenValue = smallestEven._1\n\
    \        val smallestEvenIndex = smallestEven._2\n        val smallestEvenIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndex\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndex\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndex\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndex\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndex\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndex\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndex\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\
    \ = evensSortedWithIndex.minBy(_._2)._2\n        val smallestEvenIndexValueIndexValueIndexValueIndexValueIndexValueIndexValueIndexValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7ytddm92.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7ytddm92.scala:31:60 --------------------\e[0m\e[0m\n\e[31m31 |\e[0m\
    \        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e[36mx\e[0m,\
    \ \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m                      \
    \                             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                      Found:    Int\n\e[31m   |\e[0m        \
    \                                           Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ytddm92.scala:52:5 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val evenSmallest\
    \ = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexList.length\n    \
    \    val evenSmallestValueListLength = evenSmallestValueList.length\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt25e4xsy.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt25e4xsy.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestIndexListLength\e[0m = evenSmallestIndexListLength\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt25e4xsy.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt25e4xsy.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpt25e4xsy.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.length == 0)\n\
    \            evenSmallestIndexList\n        else if (evenSmallestValueList.length\
    \ == 0)\n            evenSmallestValueList\n        else\n            evenSmallestValueList\
    \ :: evenSmallestIndexList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3l73idhj.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3l73idhj.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n   \
    \     val evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexList.length\n    \
    \    val evenSmallestValueListLength = evenSmallestValueList.length\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSm\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp99rckdah.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99rckdah.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestIndexListLength\e[0m = evenSmallestIndexListLength\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99rckdah.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99rckdah.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99rckdah.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798743
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) List(even,\
    \ index)\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmpwatkr3q3.scala:31)\n\tat Problem$.main(tmpwatkr3q3.scala:40)\n\
    \tat Problem.main(tmpwatkr3q3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        arr.take(index).filter(_ % 2 == 0).min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgoe9q2tp.scala:33:8\
    \ ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m        arr.take(index).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.take(smalest_index)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens)\n        val smalest_evens_value\
    \ = smalest_evens.min\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens_value)\n      \
    \  val smalest_evens_index = evens.indexOf(smalest_evens_value)\n        val smalest_evens_index\
    \ = evens.indexOf(\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzvhm63sz.scala:59:48 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = evens.indexOf(\n\e[31m\e[31m   |\e[0m                                    \
    \            ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzvhm63sz.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m = evens.indexOf(smalest_evens_value)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzvhm63sz.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzvhm63sz.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = evens.indexOf(smalest_evens_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzvhm63sz.scala:39:12 ---------------------------\e\
    [0"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq9ywj62m.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq9ywj62m.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpq9ywj62m.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq9ywj62m.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq9ywj62m.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1659798743
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List()\n \
    \       else {\n            val smallest = evens.head\n            val index =\
    \ evens.indexOf(smallest)\n            List(smallest, index)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcgmbqvki.scala:39)\n\tat Problem.main(tmpcgmbqvki.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = arr.filter(_ == even)\n        if (result.isEmpty)\
    \ Nil\n        else result.sortBy(x => x).take(1).map(x => (x, index))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl1785asu.scala:35:52\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x\
    \ => x).take(\e[31m1\e[0m).map(x => (x, index))\n\e[31m\e[31m   |\e[0m       \
    \                                             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                   Found:    \e[1m\e[31m(\e[0mLong\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m\n\e[31m \
    \  |\e[0m                                                   Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_index_plus_one\
    \ = smalest_even_index + 1\n        val smalest_even_index_plus_two = smalest_even_index\
    \ + 2\n        val smalest_even_index_plus_three = smalest_even_index + 3\n  \
    \      val smalest_even_index_plus_four = smalest_even_index + 4\n        val\
    \ smalest_even_index_plus_five = smalest_even_index + 5\n        val smalest_even_index_plus_six\
    \ = smalest_even_index + 6\n        val smalest_even_index_plus_seven = smalest_even_index\
    \ + 7\n        val smalest_even_index_plus_eight = smalest_even_index + 8\n  \
    \      val smalest_even_index_plus_nine = smalest_even_index + 9\n        val\
    \ smalest_even_index_plus_ten = smalest_even_index + 10\n        val smalest_even_index_plus_eleven\
    \ = smalest_even_index + 11\n        val smalest_even_index_plus_twelve = smalest_even_index\
    \ + 12\n        val smalest_even_index_plus_thirteen = smalest_even_index + 13\n\
    \        val smalest_even_index_plus_fourteen = smalest_even_index + 14\n    \
    \    val smalest_even_index_plus_fifteen = smalest_even_index + 15\n        val\
    \ smalest_even_index_plus_sixteen = smalest_even_index + 16\n        val smalest_even_index_plus_seventeen\
    \ = smalest_even_index + 17\n        val smalest_even_index_plus_eighteen = smalest_even_index\
    \ + 18\n        val smalest_even_index_plus_nineteen = smalest_even_index + 19\n\
    \        val smalest_even_index_plus_twenty = smalest_even_index + 20\n      \
    \  val smalest_even_index_plus_twenty_one = smalest_even_index + 21\n        val\
    \ smalest_even_index_plus_twenty_two = smalest_even_index + 22\n        val smalest_even_index_plus_twenty_three\
    \ = smalest_even_index + 23\n        val sm\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqu_ukfgz.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpqu_ukfgz.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(_\
    \ % 2 == 0).toList\n        val evenIndex = even.indexOf(0)\n        if (evenIndex\
    \ == -1) {\n            even.headOption.toList\n        } else {\n           \
    \ even.take(evenIndex).toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa88oplfi.scala:39)\n\tat Problem.main(tmpa88oplfi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = evens.take(index).min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.take(smalest_index).filter(_\
    \ % 2 == 0)\n        if (smalest_evens.isEmpty) List(smalest_value, smalest_index)\n\
    \        else List(smalest_value, smalest_index, smalest_evens)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkjtur9uc.scala:37:48\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33melse\e[0m List(smalest_value,\
    \ smalest_index, smalest_evens)\n\e[31m\e[31m   |\e[0m                       \
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                  Found:    (smalest_evens : List[Long])\n\e[31m   |\e[0m   \
    \                               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798743
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     evens\n        } else {\n            evens.take(smalest_index).reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1ct8hqr3.scala:40)\n\tat Problem.main(tmp1ct8hqr3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        if (evens.isEmpty) List()\n        else\
    \ {\n            val smallest = evens.head\n            val index = evens.indexWhere(x\
    \ => x == smallest)\n            List(smallest, index)\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqo_irb1m.scala:39)\n\tat Problem.main(tmpqo_irb1m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(x => x % 2 == 0).map(x => (x, index)).toList\n\
    \        if (result.isEmpty) result\n        else result.sortBy(_._1).head\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgfpw94_m.scala:34:28\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mresult\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[\e[1m\e[31m(\e[0mLong\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                            Required: List[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgfpw94_m.scala:35:33 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).head\n\e\
    [31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \             Found:    (Long, Int)\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven.toLong\n\
    \        val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n   \
    \     val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n      \
    \  val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n        val\
    \ evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x, y)\
    \ => x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x, y) =>\
    \ x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n\
    \        val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n   \
    \     val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n      \
    \  val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n        val\
    \ evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong)\n        val evensSorted\
    \ = evens.sortWith((x, y) => x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x, y)\
    \ => x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x, y) =>\
    \ x.toLong < y.toLong)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSorted = evens.sortWith((x, y) => x.toLong < y.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgwruvh4g.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgwruvh4g.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensSorted\e[0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.toLong\
    \ < y.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgwruvh4g.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong < y.toLong)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgwruvh4g.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong < y.toLong)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgwruvh4g.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.toLong < y.toLong)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallestEven = evens.min\n        val index\
    \ = evens.indexOf(smallestEven)\n        val result = arr.filter(_ == smallestEven).take(index)\n\
    \        result.isEmpty() match {\n            case true => List()\n         \
    \   case false => result\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpazirzqn2.scala:34:15 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        result.isEmpty() \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35misEmpty\e[0m in \e[33mclass\e[0m \e[35mList\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_09wh30_.scala:39)\n\tat Problem.main(tmp_09wh30_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList.sorted\n       \
    \ val evenSmallestValueList = evenSmallestValue.toList.sorted\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexList.length\n        val evenSmallestValueListLength = evenSmallestValueList.length\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmalle\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptobqblfa.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptobqblfa.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptobqblfa.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptobqblfa.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all b"
  stdout: ''
  timestamp: 1659798754
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        if (evens.isEmpty) {\n            List[Long]()\n        } else if (index\
    \ == 0) {\n            List[Long](even)\n        } else {\n            List[Long](even,\
    \ index)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1_87kl6e.scala:42)\n\tat Problem.main(tmp1_87kl6e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_index_in_list\
    \ = smalest_even_index\n        val smalest_even_index_in_list_in_list = evens.indexOf(smalest_even_index_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list = evens.indexOf(smalest_even_index_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list = evens.indexOf(smalest_even_index_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\
    \ = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \        val smale\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpinweuovk.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpinweuovk.scala:42:111\
    \ --------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\e\
    [0m = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                       ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpinweuovk.scala:44:135 --------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\e\
    [0m = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m\
    \  smalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpinweuovk.scala:45:143 -----------------------\e[0m\e[0m\n\e[31m45 |\e\
    [0m        \e[33mval\e[0m \e[36msmalest_even_index_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list_in_list\e\
    [0m = evens.indexOf(smalest_even_index_in_list_in_list_in_list_in_list"
  stdout: ''
  timestamp: 1659798754
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else result.take(index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvl3f3_ux.scala:38)\n\tat Problem.main(tmpvl3f3_ux.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (result.isEmpty) List(even.toLong)\n\
    \        else List(even.toLong, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmp2k6441ak.scala:31)\n\tat Problem$.main(tmp2k6441ak.scala:40)\n\
    \tat Problem.main(tmp2k6441ak.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValue\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all b"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val even = evens.head\n        val index\
    \ = arr.indexOf(even)\n        val result = List(even, index)\n        if (evens.isEmpty)\
    \ result\n        else result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw7_hfuws.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw7_hfuws.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = List(even, index)\n        if (evens.isEmpty)\
    \ result\n        else pluck(arr.drop(index))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphx3jl4jq.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     List[Long]()\n        } else {\n            evens.take(smalest_index).map(x\
    \ => (x, smalest_index)).toList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5g1ip3pk.scala:36:67\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            evens.take(smalest_index).map(\e\
    [36mx\e[0m => (x, smalest_index)).toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(0)\n        if (evens.isEmpty) {\n         \
    \   List[Long]()\n        } else if (evens.size == 1) {\n            List[Long](smallest)\n\
    \        } else {\n            List[Long](smallest, index)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2t6oe3qu.scala:42)\n\tat Problem.main(tmp2t6oe3qu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(even)\n        val result = List(even, index)\n\
    \        if (arr.isEmpty) result\n        else result.sortBy(x => x).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_5aevny.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpo_5aevny.scala:35:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x).reverse\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0mNo\
    \ implicit Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mAnyVal\e\
    [0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[AnyVal]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[AnyVal].\n2 errors found\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest\n     \
    \   val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.length == 1) {\n\
    \            val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \            val evenSmallestValueListLength = evenSmallestValueList.length\n\
    \            if (evenSmallestIndexListLength == 1) {\n                if (evenSmallestValueListLength\
    \ == 1) {\n                    val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \                    val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \                    if (evenSmallestIndexListLength == 1) {\n               \
    \         val evenSmallestIndexListLength = evenSmallestIndexListLength\n    \
    \                    val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \                        if (evenSmallestIndexListLength == 1) {\n           \
    \                 val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \                            val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \                            if (evenSmallestIndexListLength == 1) {\n       \
    \                         val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \                                val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \                                if (evenSmallestIndexListLength == 1) {\n   \
    \                                 val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \                                    val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \                                    if (evenSmallestIndexListLength == 1) {\n\
    \                                        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \                                        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \                                        if (evenSmallestIndexListLength == 1)\
    \ {\n                                            val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n                                            val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n                \
    \                            if (evenSmallestIndexListLength == 1) {\n       \
    \                                         val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \                                                val evenSmalle\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpovbssow_.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpovbssow_.scala:78:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpovbssow_.scala:31:60 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m            \
    \                                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                Found:    Int\n\e[31m   |\e[0m\
    \                                                   Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpovbssow_.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpovbssow_.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpovbssow_.scala:42:54 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m                    \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m                     \
    \                                 ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35mevenSmallestIndexListLength\e[0m needs type\n\e[31m \
    \  |\e["
  stdout: ''
  timestamp: 1659798756
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if(evens.isEmpty) List()\n        else if(evens.size\
    \ == 1) List(evens.head)\n        else {\n            val even = evens.min\n \
    \           val index = arr.indexWhere(_ == even)\n            List(even, index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplqfto359.scala:41)\n\tat Problem.main(tmplqfto359.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else evens.minBy(_\
    \ % 2 == 0).get\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmponsly1gx.scala:32:37 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.minBy(_ % \e[31m2\e[0m\
    \ == \e[31m0\e[0m).get\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             value get is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = arr.filter(_ == smallest).take(index).toList\n        if\
    \ (result.isEmpty) result else result :: Nil\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5uxsdda3.scala:34:40\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result \e[33melse\e[0m result :: Nil\n\e[31m\e[31m   |\e[0m                \
    \                        ^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                Found:    (result : List[Long])\n\e[31m   |\e[0m            \
    \                            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smallestEven = evens.min\n        val index\
    \ = arr.indexOf(smallestEven)\n        val result = if (index == -1) Nil else\
    \ List(smallestEven, index)\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptozwmfwu.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            List(smallest, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val smalest_value = evens.takeWhile(x => x != even).min\n        val\
    \ smalest_index = evens.indexOf(smalest_value)\n        val smalest_even = evens.takeWhile(x\
    \ => x != smalest_value).min\n        val smalest_even_index = evens.indexOf(smalest_even)\n\
    \        val smalest_even_even = evens.takeWhile(x => x != smalest_even).min\n\
    \        val smalest_even_even_index = evens.indexOf(smalest_even_even)\n    \
    \    val smalest_even_even_even = evens.takeWhile(x => x != smalest_even_even).min\n\
    \        val smalest_even_even_even_index = evens.indexOf(smalest_even_even_even)\n\
    \        val smalest_even_even_even_even = evens.takeWhile(x => x != smalest_even_even_even).min\n\
    \        val smalest_even_even_even_even_index = evens.indexOf(smalest_even_even_even_even)\n\
    \        val smalest_even_even_even_even_even = evens.takeWhile(x => x != smalest_even_even_even_even).min\n\
    \        val smalest_even_even_even_even_even_index = evens.indexOf(smalest_even_even_even_even_even)\n\
    \        val smalest_even_even_even_even_even_even = evens.takeWhile(x => x !=\
    \ smalest_even_even_even_even_even).min\n        val smalest_even_even_even_even_even_even_index\
    \ = evens.indexOf(smalest_even_even_even_even_even_even)\n        val smalest_even_even_even_even_even_even_even\
    \ = evens.takeWhile(x => x != smalest_even_even_even_even_even_even).min\n   \
    \     val smalest_even_even_even_even_even_even_even_index = evens.indexOf(smalest_even_even_even_even_even_even_even)\n\
    \        val smalest_even_even_even_even_even_even_even_even\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy3_gn30o.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpy3_gn30o.scala:50:5 ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        if (evens.isEmpty) List()\n        else {\n        \
    \    val even = evens.min\n            val index = arr.indexOf(even)\n       \
    \     val result = List(even, index)\n            if (arr.contains(even)) result\
    \ :+ arr.indexOf(even)\n            else result\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptmqtwe78.scala:36:36\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (arr.contains(even))\
    \ result :+ arr.indexOf(even)\n\e[31m\e[31m   |\e[0m                         \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                    Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m \
    \                                   Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptmqtwe78.scala:37:17 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(x\
    \ => x % 2 == 0).sorted\n        if (even.isEmpty) List()\n        else {\n  \
    \          val smalest_value = even.head\n            val smalest_index = even.indexOf(0)\n\
    \            val index = even.indexOf(smalest_value)\n            if (index ==\
    \ -1) List()\n            else {\n                val result = even.take(index).sorted\n\
    \                if (result.size == smalest_index) List(smalest_value, smalest_index)\n\
    \                else result\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaioew9we.scala:45)\n\tat Problem.main(tmpaioew9we.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798758
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2qlyn1ks.scala:39)\n\tat Problem.main(tmp2qlyn1ks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x % 2 == 0)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        val smalest_evens_value = smalest_evens(smalest_evens_index)\n      \
    \  if (smalest_evens_index > 0) {\n            smalest_evens_index\n        }\
    \ else {\n            smalest_value\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw50cs81m.scala:37:12\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            smalest_evens_index\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \         Found:    (smalest_evens_index : Int)\n\e[31m   |\e[0m            Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw50cs81m.scala:39:12\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m            smalest_value\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Found:    (smalest_value : Long)\n\e[31m   |\e[0m            Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = arr.indexOf(smallest)\n\
    \        val result = arr.filter(_ == smallest).take(index).toList\n        if\
    \ (result.isEmpty) Nil\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl5n_6v3x.scala:38)\n\tat Problem.main(tmpl5n_6v3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(x\
    \ => x % 2 == 0).sortWith((x, y) => x.compare(y))\n        if (even.isEmpty) List()\n\
    \        else {\n            val smalest_value = even(0)\n            val smalest_index\
    \ = even.indexWhere(x => x == smalest_value)\n            val result = even.takeWhile(x\
    \ => x != smalest_value).takeWhile(x => x != smalest_index).sortWith((x, y) =>\
    \ x.compare(y))\n            if (result.isEmpty) List()\n            else List(smalest_value,\
    \ smalest_index)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmb7wenk.scala:30:75\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36meven\e\
    [0m = arr.filter(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m            \
    \                                                      ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                       Found:    Int\n\
    \e[31m   |\e[0m                                                       Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmb7wenk.scala:35:128\
    \ -------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e\
    [36mresult\e[0m = even.takeWhile(\e[36mx\e[0m => x != smalest_value).takeWhile(\e\
    [36mx\e[0m => x != smalest_index).sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                               ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798765
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(smallest)\n        val result = evens.takeWhile(x\
    \ => x != smallest).take(index).reverse\n        if (result.isEmpty) result else\
    \ List(smallest, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa3nm79wh.scala:37)\n\tat Problem.main(tmpa3nm79wh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0).map(x => (x, index)).toList\n\
    \        if (result.isEmpty) result\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnl0u3g2f.scala:34:28\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mresult\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[\e[1m\e[31m(\e[0mLong\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                            Required: List[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnl0u3g2f.scala:35:13 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m\
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    \e[1m\e[31m(\e\
    [0m\e[1m\e[31mresult\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[\e\
    [1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e\
    [31m)\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwhn_jyiq.scala:39)\n\tat Problem.main(tmpwhn_jyiq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_index\
    \ = smalest_even_index.min(evens.indexOf(_))\n        val smalest_even_value =\
    \ evens(smalest_even_index)\n        val smalest_even_value_index = evens.indexOf(smalest_even_value)\n\
    \        val smalest_even_value_index = smalest_even_value_index.min(evens.indexOf(_))\n\
    \        val smalest_even_value_value = evens(smalest_even_value_index)\n    \
    \    val smalest_even_value_value_index = evens.indexOf(smalest_even_value_value)\n\
    \        val smalest_even_value_value_index = smalest_even_value_value_index.min(evens.indexOf(_))\n\
    \        val smalest_even_value_value_value = evens(smalest_even_value_value_index)\n\
    \        val smalest_even_value_value_index = evens.indexOf(smalest_even_value_value)\n\
    \        val smalest_even_value_value_index = smalest_even_value_value_index.min(evens.indexOf(_))\n\
    \        val smalest_even_value_value_value = evens(smalest_even_value_value_index)\n\
    \        val smalest_even_value_value_index = evens.indexOf(smalest_even_value_value)\n\
    \        val smalest_even_value_value_index = smalest_even_value_value_index.min(evens.indexOf(_))\n\
    \        val smalest_even_value_value_value = evens(smalest_even_value_value_index)\n\
    \        val smalest_even_value_value_index = evens.indexOf(smalest_even_value_value)\n\
    \        val smalest_even_value_value_index = smalest_even_value_value_index.min(evens.indexOf(_))\n\
    \        val smalest_even_value_value_value = evens(smalest_even_value_value_index)\n\
    \        val smalest_even_value_value_index = evens.indexOf(smalest_even_value_value)\n\
    \        val smalest_even_value_value_index = smalest_even_value_value_index.min(evens.indexOf(_))\n\
    \        val smalest_even_value_value_value = evens(smalest_even_value_value_index)\n\
    \        val smalest_even_value_value_index = evens.indexOf(smalest_even_value_value)\n\
    \        val smalest_even_value_value_index = smalest_even_value_value_index.min(evens.indexOf(_))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2o3u8n4d.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index.min(evens.indexOf(_))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2o3u8n4d.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_index\e\
    [0m = smalest_even_value_index.min(evens.indexOf(_))\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2o3u8n4d.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_value_index\e\
    [0m = smalest_even_value_value_index.min(evens.indexOf(_))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_value_index is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_value_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2o3u8n4d.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_value_index\e\
    [0m = evens.indexOf(smalest_even_value_value)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_value_index is already defined as \e[33mva"
  stdout: ''
  timestamp: 1659798768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List(even, index)\n        else result.sortWith((a, b) => a.toLong < b.toLong).head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplf4hki67.scala:35:60\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortWith((a,\
    \ b) => a.toLong < b.toLong).head\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.take(smalest_index)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens)\n        val smalest_evens_index_plus_one\
    \ = smalest_evens_index + 1\n        val smalest_evens_index_plus_two = smalest_evens_index_plus_one\
    \ + 2\n        val smalest_evens_index_plus_three = smalest_evens_index_plus_two\
    \ + 2\n        val smalest_evens_index_plus_four = smalest_evens_index_plus_three\
    \ + 2\n        val smalest_evens_index_plus_five = smalest_evens_index_plus_four\
    \ + 2\n        val smalest_evens_index_plus_six = smalest_evens_index_plus_five\
    \ + 2\n        val smalest_evens_index_plus_seven = smalest_evens_index_plus_six\
    \ + 2\n        val smalest_evens_index_plus_eight = smalest_evens_index_plus_seven\
    \ + 2\n        val smalest_evens_index_plus_nine = smalest_evens_index_plus_eight\
    \ + 2\n        val smalest_evens_index_plus_ten = smalest_evens_index_plus_nine\
    \ + 2\n        val smalest_evens_index_plus_eleven = smalest_evens_index_plus_ten\
    \ + 2\n        val smalest_evens_index_plus_twelve = smalest_evens_index_plus_eleven\
    \ + 2\n        val smalest_evens_index_plus_thirteen = smalest_evens_index_plus_twelve\
    \ + 2\n        val smalest_evens_index_plus_fourteen = smalest_evens_index_plus_thirteen\
    \ + 2\n        val smalest_evens_index_plus_fifteen = smalest_evens_index_plus_fourteen\
    \ + 2\n        val smalest_evens_index_plus_sixteen = smalest_evens_index_plus_fifteen\
    \ + 2\n        val smalest_evens_index_plus_seventeen = smalest_evens_index_plus_sixteen\
    \ + 2\n        val smalest_evens_index_plus_eighteen = smalest_evens_index_plus_seventeen\
    \ + 2\n        val smalest_evens_index_plus_nineteen = smale\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0q5xgph4.scala:53:48 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index_plus_nineteen\e\
    [0m = smale\n\e[31m\e[31m   |\e[0m                                           \
    \     ^^^^^\e[0m\n\e[31m   |\e[0m                                            \
    \    Not found: smale\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0q5xgph4.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val minIndex = evens.minBy(x => x)\n            val minValue = evens(minIndex)\n\
    \            val minIndexList = evens.filter(x => x == minIndex).toList\n    \
    \        val minIndexListSize = minIndexList.length\n            val minIndexListIndex\
    \ = minIndexList.indexOf(minValue)\n            val minIndexListValue = (minIndexListSize\
    \ - minIndexListIndex) + minIndex\n            val minIndexListIndex = minIndexListIndex.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndexListValue\
    \ = minIndexListValue.toLong\n            val minIndexListValue = minIndexListValue.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndexListValue\
    \ = minIndexListValue.toLong\n            val minIndexListValue = minIndexListValue.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndexListValue\
    \ = minIndexListValue.toLong\n            val minIndexListValue = minIndexListValue.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndexListValue\
    \ = minIndexListValue.toLong\n            val minIndexListValue = minIndexListValue.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndexListValue\
    \ = minIndexListValue.toLong\n            val minIndexListValue = minIndexListValue.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndexListValue\
    \ = minIndexListValue.toLong\n            val minIndexListValue = minIndexListValue.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndexListValue\
    \ = minIndexListValue.toLong\n            val minIndexListValue = minIndexListValue.toLong\n\
    \            val minIndexListValue = minIndexListValue.toLong\n            val\
    \ minIndexListValue = minIndexListValue.toLong\n            val minIndex\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1iodk_nt.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1iodk_nt.scala:84:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1iodk_nt.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36mminIndexListIndex\e[0m = minIndexListIndex.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminIndexListIndex is already defined as \e[33mvalue\e[0m \e\
    [35mminIndexListIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1iodk_nt.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mminIndexListValue\e\
    [0m = minIndexListValue.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminIndexListValue is already defined as \e[33mvalue\e[0m \e\
    [35mminIndexListValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1iodk_nt.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mminIndexListValue\e\
    [0m = minIndexListValue.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminIndexListValue is already defined as \e[33mvalue\e[0m \e\
    [35mminIndexListValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1iodk_nt.scala:42:16 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mminIndexListValue\e\
    [0m = minIndexListValue.toLong\n\e[31m\e[31m   |\e[0m         "
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index > -1) {\n        \
    \    val smalest_even = evens(smalest_index)\n            val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n            if (smalest_even_index > -1) {\n\
    \                val smalest_even_value = evens(smalest_even_index)\n        \
    \        val smalest_even_index_list = evens.filter(_ == smalest_even_value).toList\n\
    \                val smalest_even_index_list_index = smalest_even_index_list.indexOf(smalest_index)\n\
    \                if (smalest_even_index_list_index > -1) {\n                 \
    \   val smalest_even_index_list_value = smalest_even_index_list(smalest_even_index_list_index)\n\
    \                    val smalest_even_index_list_value_list = evens.filter(_ ==\
    \ smalest_even_index_list_value).toList\n                    val smalest_even_index_list_value_index_list\
    \ = smalest_even_index_list_value_list.indexOf(smalest_index)\n              \
    \      if (smalest_even_index_list_value_index_list > -1) {\n                \
    \        val smalest_even_index_list_value_index_list_value = smalest_even_index_list_value_index_list(smalest_even_index_list_value_index_list)\n\
    \                        val smalest_even_index_list_value_index_list_value_list\
    \ = evens.filter(_ == smalest_even_index_list_value_index_list_value).toList\n\
    \                        val smalest_even_index_list_value_index_list_value_index_list\
    \ = smalest_even_index_list_value_index_list_value_list.indexOf(smalest_index)\n\
    \                        if (smalest_even_index_list_value_index_list_value_index_list\
    \ > -1) {\n                            val smalest_even_index_list_value_index_list_value_index_list_value\
    \ = smalest_even_index_list_value_index_list_value_index_list(smalest_even_index_list_value_index_list_value_index_list)\n\
    \                            val smalest_even_index_list_value_index_list_value_index_list_value_list\
    \ = evens.filter(_ == smalest_even_index_list_value_index_list_value_index_list_value).toList\n\
    \                            val smalest_even_index_list_value_index_list_value_index_list_value_index_list\
    \ = smalest_even_index_list_value_index_list_value_index_list_value_list.indexOf(smalest_index)\n\
    \                            if (smalest_even_index_list_value_index_list_value_index_list_value_index_list_value_index_list\
    \ > -1) {\n                                val smalest_even_index_list_value_index_list_value_index_list_value_index_list_value_index_list_value\
    \ = smalest_even_index_\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpikvhunp7.scala:67:0 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpikvhunp7.scala:45:77\
    \ -----------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                   \
    \     \e[33mval\e[0m \e[36msmalest_even_index_list_value_index_list_value\e[0m\
    \ = smalest_even_index_list_value_index_list(smalest_even_index_list_value_index_list)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m \e[33mvalue\e[0m \e[35msmalest_even_index_list_value_index_list\e[0m\
    \ does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpikvhunp7.scala:49:98 -----------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m                            \e[33mval\e[0m \e[36msmalest_even_index_list_value_index_list_value_index_list_value\e\
    [0m = smalest_even_index_list_value_index_list_value_index_list(smalest_even_index_list_value_index_list_value_index_list)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m\e[33mvalue\e[0m \e[35msmalest_even_index_list_value_index_list_value_index_list\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpikvhunp7.scala:52:32 ------------------------\e[0m\e[0m\n\e[31m52 |\e\
    [0m                            \e[33mif\e[0m (smalest_even_index_list_value_index_list_value_index_list_value_index_list_value_index_list\
    \ > -\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: smalest_even_index_list_value_index_list_value_index_list_value_index_list_value_inde"
  stdout: ''
  timestamp: 1659798764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedIndex = evensSorted.zipWithIndex.toList\n\
    \        val evensSortedIndexSorted = evensSortedIndex.sortWith((x, y) => x._1\
    \ < y._1)\n        val evensSortedIndexSortedIndex = evensSortedIndexSorted.zipWithIndex.toList\n\
    \        val smalestValue = evensSortedIndexSortedIndex.head._2\n        val smalestIndex\
    \ = evensSortedIndexSortedIndex.head._1\n        val smalestValueIndex = evensSortedIndexSorted.find(x\
    \ => x._1 == smalestValue).get._2\n        val smalestValueIndexList = evensSortedIndexSorted.find(x\
    \ => x._1 == smalestValue).get._1\n        val smalestValueIndexList2 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._1\n        val smalestValueIndexList3 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._2\n        val smalestValueIndexList4 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._3\n        val smalestValueIndexList5 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._4\n        val smalestValueIndexList6 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._5\n        val smalestValueIndexList7 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._6\n        val smalestValueIndexList8 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._7\n        val smalestValueIndexList9 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._8\n        val smalestValueIndexList10 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._9\n        val smalestValueIndexList11 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalestValue).get._10\n        val smalestValueIndexList12 = evensSortedIndexSortedIndex.find(x\
    \ => x._1 == smalest\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx11lp1gt.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpx11lp1gt.scala:39:75\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \ \e[33mval\e[0m \e[36msmalestValueIndexList2\e[0m = evensSortedIndexSortedIndex.find(\e\
    [36mx\e[0m => x._1 == smalestValue).get._1\n\e[31m\e[31m   |\e[0m            \
    \                                                               ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types (Long, Int) and Int cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpx11lp1gt.scala:40:75 -----------------------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalestValueIndexList3\e\
    [0m = evensSortedIndexSortedIndex.find(\e[36mx\e[0m => x._1 == smalestValue).get._2\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types\
    \ (Long, Int) and Int cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpx11lp1gt.scala:41:75 -----------------------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalestValueIndexList4\e[0m =\
    \ evensSortedIndexSortedIndex.find(\e[36mx\e[0m => x._1 == smalestValue).get._3\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types\
    \ (Long, Int) and Int cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpx11lp1gt.scala:42:75 -----------------------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalestValueIndexList5\e[0m =\
    \ evensSortedIndexSortedIndex.find(\e[36mx\e[0m => x._1 == smalestValue).get._4\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types\
    \ (Long, Int) and Int cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpx11lp1gt.scala:43:75 --------------------"
  stdout: ''
  timestamp: 1659798770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List()\n \
    \       else {\n            val smallest = evens.head\n            val index =\
    \ evens.indexOf(smallest)\n            val result = List(smallest, index)\n  \
    \          if (evens.tail.forall(x => x % 2 == 0)) result ::: List(smallest, evens.indexOf((smallest\
    \ + 1).toLong))\n            else result\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7yob3_8s.scala:36:52\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.tail.forall(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)) result ::: List(smallest, evens.indexOf((smallest\
    \ + \e[31m1\e[0m).toLong))\n\e[31m\e[31m   |\e[0m                            \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m                            \
    \                      Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7yob3_8s.scala:37:17 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                 Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x.toLong)\n        val even = evens.head\n\
    \        val index = evens.indexOf(even)\n        val result = arr.filter(x =>\
    \ x % 2 == 0).sortBy(x => x).map(x => x.toLong).takeWhile(x => x != even).toList\n\
    \        if (result.isEmpty) result else (List(even, index), result)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv0opv51o.scala:34:40\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result \e[33melse\e[0m (List(even, index), result)\n\e[31m\e[31m   |\e[0m  \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                    Found:    \e[1m\e[31m(\e[0mList[\e\
    [1m\e[31mAnyVal\e[0m\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31mList\e[0m\e[1m\e[31m[\e[0mLong]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        \
    \                            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) Nil\n\
    \        else result.take(index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6lk090qc.scala:38)\n\tat Problem.main(tmp6lk090qc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val even = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).takeWhile(x => x < arr.last).map(x => x).reverse\n\
    \        if (even.isEmpty) List()\n        else even.takeWhile(x => x < arr.last).map(x\
    \ => x).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw43gf65a.scala:35)\n\tat Problem.main(tmpw43gf65a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        if (evens.isEmpty) List(arr.head.toLong)\n\
    \        else evens.takeWhile(_ % 2 == 0).sortBy(_ % 2).reverse.head\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8q6g9g7s.scala:32:63\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.takeWhile(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_ % \e[31m2\e[0m).reverse.head\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.length == 1) {\n\
    \            evenSmallestIndexList.head -> evenSmallestValueList\n        } else\
    \ if (evenSmallestIndexList.length > 1) {\n            evenSmallestIndexList.head\
    \ -> evenSmallestValueList\n        } else {\n            evenSmallestIndexList\
    \ -> evenSmallestValueList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptodcsbh5.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptodcsbh5.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(0)\n        val result = List(even, index)\n   \
    \     if (evens.isEmpty) result\n        else result.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_j50bsq7.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_j50bsq7.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798770
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x.toLong)\n        val smallest = evens.head\n\
    \        val index = evens.indexOf(smallest)\n        val result = if (index ==\
    \ -1) List(smallest) else evens.take(index).sortBy(x => x).map(x => x.toLong)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjliyofh8.scala:37)\n\tat Problem.main(tmpjliyofh8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        if (evens.isEmpty) Nil\n        else\
    \ {\n            val smallest = evens.head\n            val index = evens.indexWhere(_\
    \ == smallest)\n            val result = List(smallest, index)\n            if\
    \ (evens.tail.forall(x => x % 2 == 0)) result ::: pluck(evens.tail)\n        \
    \    else result\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzsk8am71.scala:36:52\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (evens.tail.forall(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m)) result ::: pluck(evens.tail)\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    (result :\
    \ List[AnyVal])\n\e[31m   |\e[0m                                       Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzsk8am71.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      Found:    (result : List[AnyVal])\n\e[31m   |\e[0m                 Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smalest_value = evensSorted.head\n        val smalest_index\
    \ = evensSorted.indexOf(0)\n        val smalest_evens = evensSorted.takeWhile(x\
    \ => x != smalest_value)\n        val smalest_evensSorted = smalest_evens.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n\
    \        val smalest_evensSorted_value = smalest_evensSorted.head\n        val\
    \ smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index\
    \ = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n\
    \        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n    \
    \    val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n        val\
    \ smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index\
    \ = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n\
    \        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n    \
    \    val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n        val\
    \ smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index\
    \ = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n\
    \        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n    \
    \    val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n        val\
    \ smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index\
    \ = smalest_evensSorted.indexOf(0)\n        val smalest_evensSorted_index = smalest_evensSorted.indexOf(0)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmppcg9ekoy.scala:56:11 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmppcg9ekoy.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted_index\e\
    [0m = smalest_evensSorted.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_evensSorted_index is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_evensSorted_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppcg9ekoy.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted_index\e\
    [0m = smalest_evensSorted.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_evensSorted_index is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_evensSorted_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppcg9ekoy.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSorted_index\e\
    [0m = smalest_evensSorted.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_evensSorted_index is already defined as \e[33mvalue\e[0m \e\
    [35msmalest_evensSorted_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppcg9ekoy.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_evensSor"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven.toLong\n\
    \        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n    \
    \    val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val\
    \ smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n    \
    \    val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val\
    \ smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n    \
    \    val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val\
    \ smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n    \
    \    val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val\
    \ smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n    \
    \    val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val\
    \ smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n    \
    \    val smallestEvenValue = evensSorted.indexOf(smallestEvenValue)\n        val\
    \ smallestEvenValue = evens\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpha1j5owu.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSorted.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpha1j5owu.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ evensSorted.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpha1j5owu.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ evensSorted.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpha1j5owu.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ evensSorted.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] "
  stdout: ''
  timestamp: 1659798770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = List(even, index)\n        if (evens.isEmpty)\
    \ result\n        else result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyitn5ttv.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyitn5ttv.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798771
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ogvx0te.scala:39)\n\tat Problem.main(tmp9ogvx0te.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index_list = evens.filter(_ == smalest_value)\n\
    \        val smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.toList\n        val\
    \ smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n        val\
    \ smalest_even_index_list = smalest_even_index_list.take(1)\n        val smalest_even_index_list\
    \ = smalest_even_index_list.toList\n        val smalest_even_index_list = smalest_even_index_list.sortWith(_\
    \ < _)\n        val smalest_even_index_list = smalest_even_index_list.take(1)\n\
    \        val smalest_even_index_list = smalest_even_index_list.toList\n      \
    \  val smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n   \
    \     val smalest_even_index_list = smalest_even_index_list.take(1)\n        val\
    \ smalest_even_index_list = smalest_even_index_list.toList\n        val smalest_even_index_list\
    \ = smalest_even_index_list.sortWith(_ < _)\n        val smalest_even_index_list\
    \ = smalest_even_index_list.take(1)\n        val smalest_even_index_list = smalest_even_index_list.toList\n\
    \        val smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n\
    \        val smalest_even_index_list = smalest_even_index_list.take(1)\n     \
    \   val smalest_even_index_list = smalest_even_index_list.toList\n        val\
    \ smalest_even_index_list = smalest_even_index_list.sortWith(_ < _)\n        val\
    \ smalest_even_index_list = smalest_even_index_list.take(1)\n        val smalest_even_index_list\
    \ = smalest_even_index_list.toList\n        val smalest_even_index_list = smalest_even_index_list.sortWith(_\
    \ < _)\n        val smalest_even_index_list = smalest_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9s_zl1f5.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9s_zl1f5.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9s_zl1f5.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e[0m = smalest_even_index_list.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9s_zl1f5.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list\e\
    [0m = smalest_even_index_list.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods mus"
  stdout: ''
  timestamp: 1659798778
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even).take(index)\n        result.sortWith((x,\
    \ y) => x.toLong < y.toLong)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcww8j85w.scala:37)\n\tat Problem.main(tmpcww8j85w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest\n     \
    \   val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.length == 1) {\n\
    \            evenSmallestValueList :+ evenSmallestValue\n        } else {\n  \
    \          val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x.compare(y))\n            val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x,\
    \ y) => x.compare(y))\n            evenSmallestValueListSorted.take(evenSmallestIndexListSorted.length)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7xjmknxy.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7xjmknxy.scala:35:54\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7xjmknxy.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n3 errors found\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x.toLong)\n        val even = evens.head\n\
    \        val index = evens.indexOf(even)\n        val result = arr.filter(x =>\
    \ x % 2 == 0).sortBy(x => x).map(x => x.toLong).takeWhile(x => x != even).take(index).map(x\
    \ => x.toLong)\n        if (result.isEmpty) result else result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw1lomoz9.scala:37)\n\tat Problem.main(tmpw1lomoz9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSortedWithIndex = evensSorted.zipWithIndex\n \
    \       val smallestEven = evensSortedWithIndex.head._1\n        val smallestEvenIndex\
    \ = evensSortedWithIndex.head._2\n        val evensSortedWithoutSmallestEven =\
    \ evensSorted.filterNot(x => x == smallestEven)\n        val evensSortedWithoutSmallestEvenWithIndex\
    \ = evensSortedWithoutSmallestEven.zipWithIndex\n        val smallestEvenWithoutSmallestEven\
    \ = evensSortedWithoutSmallestEvenWithIndex.head._1\n        val smallestEvenWithoutSmallestEvenIndex\
    \ = evensSortedWithoutSmallestEvenWithIndex.head._2\n        val evensSortedWithoutSmallestEvenWithoutSmallestEven\
    \ = evensSortedWithoutSmallestEven.filterNot(x => x == smallestEvenWithoutSmallestEven)\n\
    \        val evensSortedWithoutSmallestEvenWithoutSmallestEvenWithIndex = evensSortedWithoutSmallestEvenWithoutSmallestEven.zipWithIndex\n\
    \        val smallestEvenWithoutSmallestEvenWithoutSmallestEven = evensSortedWithoutSmallestEvenWithoutSmallestEvenWithIndex.head._1\n\
    \        val smallestEvenWithoutSmallestEvenWithoutSmallestEvenIndex = evensSortedWithoutSmallestEvenWithoutSmallestEvenWithIndex.head._2\n\
    \        val evensSortedWithoutSmallestEvenWithoutSmallestEvenWithoutSmallestEven\
    \ = evensSortedWithoutSmallestEvenWithoutSmallestEven.filterNot(x => x == smallestEvenWithoutSmallestEvenWithoutSmallestEven)\n\
    \        val evensSortedWithoutSmallestEvenWithoutSmallestEvenWithoutSmallestEvenWithIndex\
    \ = evensSortedWithoutSmallestEvenWithoutSmallestEvenWithoutSmallestEven.zipWithIndex\n\
    \        val smallestEvenWithoutSmallestEvenWithoutSmallestEvenWithoutSmallestEven\
    \ = evensSortedWithoutSmallestEvenWithoutSmallestEvenWithoutSmallestEvenWithIndex.head._1\n\
    \        val smallestEvenWithoutSmallestEvenWithoutSmallestEvenWithoutSmallestEvenIndex\
    \ = evensSortedWithoutSmallestEvenWithout\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9ffky82h.scala:46:89 ------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenWithoutSmallestEvenWithoutSmallestEvenWithoutSmallestEvenIndex\e\
    [0m = evensSortedWithoutSmallestEvenWithout\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         Not found: evensSortedWithoutSmallestEvenWithout\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ffky82h.scala:47:5 ---------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_).reverse\n        val smalest_value = evens.head\n      \
    \  val smalest_index = evens.indexOf(0)\n        if (evens.isEmpty) List()\n \
    \       else evens.take(smalest_index).map(x => (x, smalest_index)).sortBy(_._1).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmppgqyokx3.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmppgqyokx3.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOfMin\n        val smalest_even = evens(smalest_index)\n      \
    \  val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_value\
    \ = evens(smalest_even_index)\n        val smalest_even_index_list = evens.toList.indexOf(smalest_even)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(smalest_even_index_list)\n\
    \        val smalest_even_index_list_value = evens.toList(sm\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj210mqnq.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj210mqnq.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list_value\e[0m = evens.toList(smalest_even_index_list)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj210mqnq.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.toList(smalest_even_index_list)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj210mqnq.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.toList(smalest_even_index_list)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_value is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj210mqnq.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_value\e\
    [0m = evens.toList(smalest_eve"
  stdout: ''
  timestamp: 1659798781
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x.toLong)\n        if (evens.isEmpty)\
    \ List()\n        else {\n            val smallest = evens.head\n            val\
    \ index = evens.indexOf(smallest)\n            if (index == 0) List()\n      \
    \      else List(smallest, index)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk0rtg5x6.scala:40)\n\tat Problem.main(tmpk0rtg5x6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798782
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val smalest_value = evens.head\n    \
    \    val smalest_index = evens.indexWhere(x => x == smalest_value)\n        if\
    \ (smalest_index == -1)\n            evens\n        else\n            evens.take(smalest_index).sortBy(x\
    \ => x).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp37_uikdx.scala:39)\n\tat Problem.main(tmp37_uikdx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(x => x % 2 == 0).map(x => x -> index).toList\n\
    \        if (result.isEmpty) result else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg3pbslpu.scala:34:28\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m                       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                            Found:    \e[1m\e\
    [31m(\e[0m\e[1m\e[31mresult\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m\
    \ \e[0mList[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e\
    [0m\e[1m\e[31m)\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                      \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpg3pbslpu.scala:34:40 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mif\e[0m (result.isEmpty) result \e[33melse\e[0m result\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Found:    \e[1m\e[31m(\e[0m\e[1m\e\
    [31mresult\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[\e[1m\e\
    [31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                                  Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798716
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) Nil else List(smallest, index)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5phg74zv.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val evenIndex = arr.indexOf(even, index + 1)\n        val evenValue =\
    \ evens(evenIndex)\n        val evenIndexList = evenIndex.map(x => arr(x))\n \
    \       val evenIndexList2 = evenIndexList.map(x => arr(x))\n        val evenIndexList3\
    \ = evenIndexList2.map(x => arr(x))\n        val evenIndexList4 = evenIndexList3.map(x\
    \ => arr(x))\n        val evenIndexList5 = evenIndexList4.map(x => arr(x))\n \
    \       val evenIndexList6 = evenIndexList5.map(x => arr(x))\n        val evenIndexList7\
    \ = evenIndexList6.map(x => arr(x))\n        val evenIndexList8 = evenIndexList7.map(x\
    \ => arr(x))\n        val evenIndexList9 = evenIndexList8.map(x => arr(x))\n \
    \       val evenIndexList10 = evenIndexList9.map(x => arr(x))\n        val evenIndexList11\
    \ = evenIndexList10.map(x => arr(x))\n        val evenIndexList12 = evenIndexList11.map(x\
    \ => arr(x))\n        val evenIndexList13 = evenIndexList12.map(x => arr(x))\n\
    \        val evenIndexList14 = evenIndexList13.map(x => arr(x))\n        val evenIndexList15\
    \ = evenIndexList14.map(x => arr(x))\n        val evenIndexList16 = evenIndexList15.map(x\
    \ => arr(x))\n        val evenIndexList17 = evenIndexList16.map(x => arr(x))\n\
    \        val evenIndexList18 = evenIndexList17.map(x => arr(x))\n        val evenIndexList19\
    \ = evenIndexList18.map(x => arr(x))\n        val evenIndexList20 = evenIndexList19.map(x\
    \ => arr(x))\n        val evenIndexList21 = evenIndexList20.map(x => arr(x))\n\
    \        val evenIndexList22 = evenIndexList21.map(x => arr(x))\n        val evenIndexList23\
    \ = evenIndexList22.map(x => arr(x))\n        val evenIndexList24 = evenIndexList23.map(x\
    \ => arr(x))\n        val evenIndexList25 = evenIndexList24.map(x => arr(x))\n\
    \        val evenIndexList26 = evenIndexList25.map(x => arr(x))\n        val evenIndexList27\
    \ = evenIndexList26.map(x => arr(x))\n        val evenIndexList28 = evenIndexList27.map(x\
    \ => arr(x))\n\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wcjgvue.scala:35:38 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenIndexList\e[0m = evenIndex.map(\e\
    [36mx\e[0m => arr(x))\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value map is not a member of Int\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8wcjgvue.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evensSortedWithIndex = evensSorted.zipWithIndex\n        val smallestEven\
    \ = evensSortedWithIndex.minBy(x => x._2)\n        val smallestEvenIndex = evensSortedWithIndex.indexOf(smallestEven)\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val smallestEvenValue\
    \ = smallestEvenValue.toLong\n        val smallestEvenIndex = smallestEvenIndex.toLong\n\
    \        val smallestEvenValue = smallestEvenValue.toLong\n        val smallestEvenIndex\
    \ = smallestEvenIndex.toLong\n        val smallestEvenValue = smallestEvenValue.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl1r4nao9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl1r4nao9.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl1r4nao9.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl1r4nao9.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl1r4nao9.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1659798782
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyauyo8os.scala:39)\n\tat Problem.main(tmpyauyo8os.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val evenList = arr.filter(x => x % 2 == 0).take(index).toList\n     \
    \   val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take(index).toList\n        val evenList = evens.take(index).toList\n\
    \        val evenList = evens.take\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplsg774_8.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mevenList\e[0m = evens.take(index).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevenList is already defined as \e[33mvalue\e[0m \e[35mevenList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplsg774_8.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevenList\e[0m = evens.take(index).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevenList is already defined as \e[33mvalue\e[0m \e[35mevenList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplsg774_8.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mevenList\e[0m = evens.take(index).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevenList is already defined as \e[33mvalue\e[0m \e[35mevenList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplsg774_8.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mevenList\e[0m = evens.take(index).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevenList is already defined as \e[33mvalue\e[0m \e[35mevenList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplsg774_8.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mevenList\e[0m = evens.take(index).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevenList is alr"
  stdout: ''
  timestamp: 1659798782
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if (evens.isEmpty) Nil\n        else {\n         \
    \   val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val evens_with_smallest_index = evens.filter(_ == smalest_value)\n\
    \            val smalest_value_with_smallest_index = evens_with_smallest_index.min\n\
    \            val smalest_index_with_smallest_index = evens_with_smallest_index.indexOf(smalest_value_with_smallest_index)\n\
    \            val smalest_value_with_smallest_index_as_a_list = evens_with_smallest_index.map(x\
    \ => x.toLong).toList\n            smalest_value_with_smallest_index_as_a_list\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv86ac9g3.scala:43)\n\tat Problem.main(tmpv86ac9g3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        if (evenSmallestIndexList.isEmpty || evenSmallestValueList.isEmpty)\
    \ {\n            List[Long]()\n        } else {\n            evenSmallestIndexList.map(x\
    \ => evenSmallestValueList(x))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpldfkl40k.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpldfkl40k.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(0)\n        val result = arr.filter(x => x % 2 ==\
    \ 0 && x == even).sortBy(x => x).reverse\n        if (result.isEmpty) List(even.toLong,\
    \ index.toLong)\n        else result.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2atdpkbk.scala:35:20\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.head\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \   Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if(evens.isEmpty) List()\n        else {\n       \
    \     val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if(evens.size ==\
    \ 1) result\n            else result :+ pluck(arr.filter(_ != smallest))\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpli4b04c8.scala:36:32\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m(evens.size\
    \ == \e[31m1\e[0m) result\n\e[31m\e[31m   |\e[0m                             \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m                                Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m                                Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpli4b04c8.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\
    \ :+ pluck(arr.filter(_ != smallest))\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    List[Matchable]\n\e[31m   |\e[0m\
    \                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = (if (index == -1) arr.toList else arr.take(index)).sorted\n\
    \        (if (evens.isEmpty) result.toList else result.take(even)).distinct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcf0x5x1a.scala:34:59\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        (\e[33mif\e[0m (evens.isEmpty)\
    \ result.toList \e[33melse\e[0m result.take(even)).distinct\n\e[31m\e[31m   |\e\
    [0m                                                           ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                 Found:    (even : Long)\n\
    \e[31m   |\e[0m                                                 Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n   \
    \     val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted\
    \ = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n     \
    \   val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted =\
    \ evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n       \
    \ val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_\
    \ < _)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n  \
    \      val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted\
    \ = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n     \
    \   val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted =\
    \ evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n       \
    \ val smallestEvenIndex = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_\
    \ < _)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith(_ < _)\n  \
    \      val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvql82g5g.scala:68:11 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpvql82g5g.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvql82g5g.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEven\e[0m = evensSorted.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmallestEven is already defined as \e[33mvalue\e[0m \e[35msmallestEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvql82g5g.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = evensSorted.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvql82g5g.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overlo"
  stdout: ''
  timestamp: 1659798782
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).map(_ % 2).reverse\n        val even = evens.head\n\
    \        val index = evens.indexOf(0)\n        val result = arr.filter(_ % 2 ==\
    \ 0).sortBy(_ % 2).map(_ % 2).reverse.takeWhile(_ != 0).takeWhile(_ != even).takeWhile(_\
    \ != index).reverse\n        if (result.isEmpty) Nil\n        else result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxsj1190q.scala:38)\n\tat Problem.main(tmpxsj1190q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798785
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ Nil\n        else result.take(index).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplbm7zd7v.scala:38)\n\tat Problem.main(tmplbm7zd7v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x % 2 == 0)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        if (smalest_evens_index >= 0) {\n            smalest_evens.take(smalest_evens_index).map(x\
    \ => smalest_value)\n        } else {\n            smalest_evens.map(x => smalest_value)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphulwi2ys.scala:42)\n\tat Problem.main(tmphulwi2ys.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest\n     \
    \   val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x.compare(y))\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x,\
    \ y) => x.compare(y))\n        val evenSmallestValueListSortedHead = evenSmallestValueListSorted.head\n\
    \        val evenSmallestValueListSortedHeadIndex = evenSmallestValueListSortedHead.toList\n\
    \        val evenSmallestValueListSortedHeadValue = evenSmallestValueListSortedHead.toList\n\
    \        val evenSmallestValueListSortedHeadIndexSorted = evenSmallestValueListSortedHeadIndex.sortWith((x,\
    \ y) => x.compare(y))\n        val evenSmallestValueListSortedHeadValueSorted\
    \ = evenSmallestValueListSortedHeadValue.sortWith((x, y) => x.compare(y))\n  \
    \      val evenSmallestValueListSortedHeadIndexSortedHead = evenSmallestValueListSortedHeadIndexSorted.head\n\
    \        val evenSmallestValueListSortedHeadIndexSortedHeadIndex = evenSmallestValueListSortedHeadIndexSorted.toList\n\
    \        val evenSmallestValueListSortedHeadIndexSortedHeadValue = evenSmallestValueListSortedHeadIndexSorted.toList\n\
    \        val evenSmallestValueListSortedHeadIndexSortedHeadIndexSorted = evenSmallestValueListSortedHeadIndexSortedHead.sortWith((x,\
    \ y) => x.compare(y))\n        val evenSmallestValueListSortedHeadIndexSortedHeadValueSorted\
    \ = evenSmallestValueListSortedHeadIndexSortedHeadValue.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallestValueListSortedHeadIndexSortedHeadIndexSortedHead = evenSmallestValueListSortedHeadIndexSortedHeadIndexSorted.head\n\
    \        val evenSmallestValueListSortedHeadIndexSortedHeadIndexSortedHeadIndex\
    \ = evenSmallestValueListSortedHeadIndexSortedHeadIndexSorted.toList\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwtmnmf3s.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtmnmf3s.scala:35:54\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtmnmf3s.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwtmnmf3s.scala:52:5 ---------------------\e[0m\e\
    [0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659798785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val smallestEven = evensSorted.head\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(0)\n        val smallestEvenValue = smallestEven.toLong\n\
    \        val smallestEvenIndex = smallestEvenIndex.toLong\n        val result\
    \ = List(smallestEvenValue, smallestEvenIndex)\n        if (smallestEvenIndex\
    \ == arr.length) result\n        else pluck(arr.drop(smallestEvenIndex))\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpse06gc6d.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpse06gc6d.scala:37:45 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (smallestEvenIndex == arr.length)\
    \ result\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    (result :\
    \ List[AnyVal])\n\e[31m   |\e[0m                                       Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798790
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = arr.filter(_ == smallest).take(index).toList\n        if\
    \ (result.isEmpty) result else result.sortWith(_ < _)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfa5k3sed.scala:37)\n\tat Problem.main(tmpfa5k3sed.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798792
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List(even, index)\n        else result.sortWith((x, y) => x < y).take(1)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr6eenr7s.scala:38)\n\tat Problem.main(tmpr6eenr7s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798793
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).toList\n        if (evens.isEmpty)\
    \ result\n        else result.filter(_ == even).sortBy(x => x).take(index).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1mpbcec2.scala:38)\n\tat Problem.main(tmp1mpbcec2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798794
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortBy(x => x).take(index).map(x =>\
    \ x.toLong).toList\n        if (result.isEmpty) List(even.toLong)\n        else\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi3sp7tzd.scala:38)\n\tat Problem.main(tmpi3sp7tzd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(0)\n        val result = (smallest :: index)\n\
    \        if (evens.isEmpty) result\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuer728r3.scala:33:31 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (smallest\
    \ :: index)\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value :: is not a member of Int\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798792
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x).toList\n        val smallest = evens.head\n\
    \        val index = evens.indexOf(smallest)\n        val result = evens.takeWhile(x\
    \ => x != smallest).take(index).toList\n        if (result.isEmpty) result else\
    \ List(smallest, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuzj4fjya.scala:37)\n\tat Problem.main(tmpuzj4fjya.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        if (evenSmallestIndexList.isEmpty || evenSmallestValueList.isEmpty) {\n\
    \            List[Long]()\n        } else {\n            evenSmallestValueList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzl7ni36w.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpzl7ni36w.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq9ywj62m.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq9ywj62m.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpq9ywj62m.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq9ywj62m.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq9ywj62m.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1659798743
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n\
    \        val smalest_index = evens.indexWhere(x => x == smalest_value)\n     \
    \   val smalest_evens = evens.takeWhile(x => x != smalest_value)\n        if (smalest_evens.isEmpty)\
    \ List()\n        else List(smalest_value, smalest_index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbmcb4xd3.scala:38)\n\tat Problem.main(tmpbmcb4xd3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798796
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val evens_without_smalest_value = evens.filterNot(x => x == smalest_value)\n\
    \            if (evens_without_smalest_value.isEmpty) List()\n            else\
    \ evens_without_smalest_value.take(smalest_index).toList\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphir73oee.scala:41)\n\tat Problem.main(tmphir73oee.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOfFirst { x => x == smallest }\n        val result\
    \ = (smallest :: arr.take(index)) ++ arr.drop(index + 1)\n        result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjl499tn.scala:32:26 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = evens.indexOfFirst\
    \ { \e[36mx\e[0m => x == smallest }\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value indexOfFirst\
    \ is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659798794
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x.toLong)\n        val even = evens.head\n\
    \        val index = evens.indexOf(even)\n        if (evens.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9cih2xap.scala:37)\n\tat Problem.main(tmp9cih2xap.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798796
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = arr.filter(x => x % 2 == 0).min\n        val smalest_index\
    \ = arr.indexOf(smalest_value)\n        if (evens.isEmpty) {\n            List[Long]()\n\
    \        } else if (smalest_index == -1) {\n            List[Long](smalest_value)\n\
    \        } else {\n            List[Long](smalest_value, index)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx91dqhl4.scala:45)\n\tat Problem.main(tmpx91dqhl4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798796
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortBy(x => x).take(index).toList\n\
    \        if (result.isEmpty) Nil\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm5pgudz9.scala:38)\n\tat Problem.main(tmpm5pgudz9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val smalest_value = evens.min\n            val smalest_index = evens.indexOf(smalest_value)\n\
    \            val smalest_even = evens(smalest_index)\n            val smalest_even_index\
    \ = evens.indexOf(smalest_even)\n            val smalest_even_value = evens(smalest_even_index)\n\
    \            val smalest_even_index_list = evens.indexOf(smalest_even, smalest_index\
    \ + 1)\n            val smalest_even_index_list_size = smalest_even_index_list.length\n\
    \            val smalest_even_index_list_size = smalest_even_index_list_size +\
    \ 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val smalest_even_index_list_size = smalest_even_index_list_size\
    \ + 1\n            val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp514d7ryp.scala:61:15 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp514d7ryp.scala:75:0 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp514d7ryp.scala:40:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e\
    [0m \e[36msmalest_even_index_list_size\e[0m = smalest_even_index_list_size + \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_size is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp514d7ryp.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list_size\e\
    [0m = smalest_even_index_list_size + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_size is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_size\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp514d7ryp.scala:42:16 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36msmalest_even_index_list_size\e\
    [0m = smalest_even_index_list_size + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_size is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_index_list_size\e[0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659798796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evenSmallest = evensSorted.head\n        val evenSmallestIndex\
    \ = evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.toLong\n\
    \        val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValue\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsmrtt960.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all b"
  stdout: ''
  timestamp: 1659798755
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(even)\n        val result = arr.filter(_ == even).sortBy(x\
    \ => x).reverse\n        if (result.isEmpty) List()\n        else result.take(index).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptkou1lfz.scala:38)\n\tat Problem.main(tmptkou1lfz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val smallest = evens.minBy(_)\n        val index = evens.indexOf(smallest)\n\
    \        val result = evens.filter(_ == smallest).take(index).toList\n       \
    \ if (result.isEmpty) Nil\n        else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpitcbam3m.scala:31:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = evens.minBy(_)\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\e[31m  \
    \ |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found\
    \ that match type java.util.Comparator[Any].\n1 error found\n"
  stdout: ''
  timestamp: 1659798797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).take(index).toList\n        if (result.isEmpty)\
    \ result else result :: List[Long](even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw2z_6nmc.scala:34:40\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result \e[33melse\e[0m result :: List[\e[35mLong\e[0m](even, index)\n\e[31m\e\
    [31m   |\e[0m                                        ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                        Found:    (result : List[Long])\n\e\
    [31m   |\e[0m                                        Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest.asInstanceOf[Long]\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue\
    \ = evenSmallest.asInstanceOf[Long]\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest.asInstanceOf[Long]\n        val\
    \ evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue =\
    \ evenSmallest.asInstanceOf[Long]\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest.asInstanceOf[Long]\n        val\
    \ evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue =\
    \ evenSmallest.asInstanceOf[Long]\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest.asInstanceOf[Long]\n        val\
    \ evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue =\
    \ evenSmallest.asInstanceOf[Long]\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest.asInstanceOf[Long]\n        val\
    \ evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue =\
    \ evenSmallest.asInstanceOf[Long]\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest.asInstanceOf[Long]\n        val\
    \ evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue =\
    \ evenSmallest.asInstanceOf[Long]\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest.asInstanceOf[Long]\n        val\
    \ evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue =\
    \ evenSmallest.asInstanceOf[Long]\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxy3c5fpl.scala:62:31 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValue\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxy3c5fpl.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestIndex\e[0m = evensSorted.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mevenSmallestIndex is already defined as \e[33mvalue\e[0m \e[35mevenSmallestIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxy3c5fpl.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValue\e[0m = evenSmallest.asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValue is already defined as \e[33mvalue\e[0m \e\
    [35mevenSmallestValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxy3c5fpl.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndex\e[0m =\
    \ evensSorted.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndex is already defined as \e[33mvalue\e[0m \e\
    [35mevenSmallestIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxy3c5fpl.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValue\e[0m =\
    \ evenSmallest.asInstance"
  stdout: ''
  timestamp: 1659798796
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) List(smalest_value)\n\
    \        else evens.take(smalest_index).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdnilkoiw.scala:37)\n\tat Problem.main(tmpdnilkoiw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) Nil\n        else {\n    \
    \        val smallest = evens.min\n            val index = arr.indexOf(smallest)\n\
    \            val result = List(smallest, index)\n            if (arr.contains(smallest))\
    \ result\n            else result.reverse\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5spnviel.scala:36:40\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mif\e[0m (arr.contains(smallest))\
    \ result\n\e[31m\e[31m   |\e[0m                                        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    (result :\
    \ List[AnyVal])\n\e[31m   |\e[0m                                       Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5spnviel.scala:37:24\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result.reverse\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \              Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m       \
    \          Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val evensSorted = evens.sortWith((x, y) => x.toLong\
    \ < y.toLong)\n        val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n \
    \       val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n  \
    \      val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n   \
    \     val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n    \
    \    val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n     \
    \   val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n      \
    \  val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n       \
    \ val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n        val\
    \ evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n        val evensSorted\
    \ = evensSorted.takeWhile(x => x < arr.last.toLong)\n        val evensSorted =\
    \ evensSorted.takeWhile(x => x < arr.last.toLong)\n        val evensSorted = evensSorted.takeWhile(x\
    \ => x < arr.last.toLong)\n        val evensSorted = evensSorted.takeWhile(x =>\
    \ x < arr.last.toLong)\n        val evensSorted = evensSorted.takeWhile(x => x\
    \ < arr.last.toLong)\n        val evensSorted = evensSorted.takeWhile(x => x <\
    \ arr.last.toLong)\n        val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n\
    \        val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n \
    \       val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n  \
    \      val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n   \
    \     val evensSorted = evensSorted.takeWhile(x => x < arr.last.toLong)\n    \
    \    val evensSorted = evensSorted.takeWhile(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpukowzhtn.scala:53:48 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpukowzhtn.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e[36mx\e[0m => x < arr.last.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpukowzhtn.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.last.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpukowzhtn.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(\e\
    [36mx\e[0m => x < arr.last.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpukowzhtn.scala:35:12 ---------------------"
  stdout: ''
  timestamp: 1659798797
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortWith(_ < _).take(index)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmjivwel_.scala:37)\n\tat Problem.main(tmpmjivwel_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798799
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even)\n        if (result.isEmpty) List()\n\
    \        else List(even, index)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzu1i6myn.scala:39)\n\tat Problem.main(tmpzu1i6myn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) Nil\n        else evens.minBy(x\
    \ => x)._2\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzwluznk1.scala:32:33 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.minBy(x => x)._2\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value _2 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659798800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val smalest_value = evens.head\n    \
    \    val smalest_index = evens.indexWhere(x => x == smalest_value)\n        val\
    \ smalest_even = evens(smalest_index)\n        val smalest_even_index = evens.indexWhere(x\
    \ => x == smalest_even)\n        val smalest_even_index = smalest_even_index +\
    \ 1\n        val smalest_even_value = evens(smalest_even_index)\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even_value.toLong\n        val smalest_even_value\
    \ = smalest_even_value.toLong\n        val smalest_even_value = smalest_even_value.toLong\n\
    \        val smalest_even_value = smalest_even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw6wq0leb.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m\
    \ = smalest_even_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw6wq0leb.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even_value.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw6wq0leb.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even_value.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw6wq0leb.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m\
    \ = smalest_even_value.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_even_value\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw6wq0leb.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m4"
  stdout: ''
  timestamp: 1659798803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOfFirst { x => x.compare(smallestEven) == 0 }\n        val\
    \ smallestEvenValue = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n\
    \        val result = List(smallestEvenValue, smallestEvenIndex)\n        if (evensSorted.isEmpty)\
    \ {\n            result\n        } else {\n            val nextEven = evensSorted.drop(smallestEvenIndex\
    \ + 1)\n            val nextEvenSorted = nextEven.sortWith((x, y) => x.compare(y))\n\
    \            val nextSmallestEven = nextEvenSorted.head\n            val nextSmallestEvenIndex\
    \ = nextEvenSorted.indexOfFirst { x => x.compare(nextSmallestEven) == 0 }\n  \
    \          val nextSmallestEvenValue = nextSmallestEven\n            val nextSmallestEvenIndex\
    \ = nextSmallestEvenIndex\n            val nextSmallestEvenValue = nextSmallestEvenValue\n\
    \            val nextSmallestEvenIndex = nextSmallestEvenIndex\n            val\
    \ nextSmallestEvenValue = nextSmallestEvenValue\n            val nextSmallestEvenIndex\
    \ = nextSmallestEvenIndex\n            val nextSmallestEvenValue = nextSmallestEvenValue\n\
    \            val nextSmallestEvenIndex = nextSmallestEvenIndex\n            val\
    \ nextSmallestEvenValue = nextSmallestEvenValue\n            val nextSmallestEvenIndex\
    \ = nextSmallestEvenIndex\n            val nextSmallestEvenValue = nextSmallestEvenValue\n\
    \            val nextSmallestEvenIndex = nextSmallestEvenIndex\n            val\
    \ nextSmallestEvenValue = nextSmallestEvenValue\n            val nextSmallestEvenIndex\
    \ = nextSmallestEvenIndex\n            val nextSmallestEvenValue = nextSmallestEvenValue\n\
    \            val nextSmallestEvenIndex = nextSmallestEvenIndex\n            val\
    \ nextSmallestEvenValue = nextSmallestEvenValue\n            val nextSmallestEvenIndex\
    \ = nextSmallestEvenIndex\n            val nextSmallestEvenValue = nextSmallestEvenValue\n\
    \            val nextSmallestEvenIndex = nextSmallestEvenIndex\n            val\
    \ nextSmallestEvenValue = nextSmallestEvenValue\n            val nextSmalle\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc4h85ncr.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc4h85ncr.scala:79:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc4h85ncr.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpc4h85ncr.scala:31:60 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m            \
    \                                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                Found:    Int\n\e[31m   |\e[0m\
    \                                                   Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc4h85ncr.scala:33:44 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSorted.indexOfFirst { \e[36mx\e[0m => x.compare(smallestEven) == \e[31m0\e\
    [0m }\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value indexOfFirst is not a member\
    \ of List[Long]\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc4h85ncr.scala:45:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e\
    [0m \e[36mnextSmallestEvenIndex\e[0m = nextSmallestEvenIndex\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(smallest)\n        val result = List(smallest,\
    \ index)\n        if (evens.isEmpty) result\n        else pluck(arr.drop(index))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8lrjks70.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        val evensSorted = evens.sortWith(_ < _)\n        val\
    \ evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        if (evenSmallestIndexList.length == 1) {\n            evenSmallestValueList\
    \ :+ evenSmallestValue\n        } else if (evenSmallestIndexList.length > 1) {\n\
    \            evenSmallestValueList :+ evenSmallestValue\n        } else {\n  \
    \          evenSmallestValueList :+ evenSmallestValue\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3db48dvr.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Int - did you mean evenSmallestIndex.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3db48dvr.scala:36:54 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e[0m =\
    \ evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not a member\
    \ of Long - did you mean evenSmallestValue.toInt?\n2 errors found\n"
  stdout: ''
  timestamp: 1659798806
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortWith(_ < _).take(index).toList\n\
    \        if (result.isEmpty) Nil\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphhh2q46j.scala:38)\n\tat Problem.main(tmphhh2q46j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        if (evens.isEmpty) List()\n        else\
    \ evens.take(1).head\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8mxuotf.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e\
    [31m1\e[0m).head\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = arr.indexOf(smalest_even)\n        val smalest_even_value\
    \ = arr(smalest_even_index)\n        val smalest_even_index_list = List(smalest_even_index,\
    \ smalest_even_index + 1)\n        val smalest_even_index_list_list = List(smalest_even_index_list)\n\
    \        val smalest_even_index_list_list_list = List(smalest_even_index_list_list)\n\
    \        val smalest_even_index_list_list_list_list = List(smalest_even_index_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list = List(smalest_even_index_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list = List(smalest_even_index_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list = List(smalest_even_index_list_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list = List(smalest_even_index_list_list_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list =\
    \ List(smalest_even_index_list_list_list_list_list_list_list_list)\n        val\
    \ smalest_even_index_list_list_list_list_list_list_list_list_list_list = List(smalest_even_index_list_list_list_list_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list\
    \ = List(smalest_even_index_list_list_list_list_list_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = List(smalest_even_index_list_list_list_list_list_list_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = List(smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = List(smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list)\n\
    \        val smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ = List(smalest_even_index_list_list_list_list_list_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpir2gszqg.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpir2gszqg.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = List(smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpir2gszqg.scala:50:108 -----------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_list_list_list_list_list_list_list_list_list_list_list_list_list_list\e\
    [0m = List(smalest_even_index_list_list_list_list_list_\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: smalest_even_index_list_list_list_list_list_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpir2gszqg.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val smallest = evens.head\n \
    \       val index = evens.indexOf(0)\n        val result = arr.filter(_ == smallest).sortBy(x\
    \ => x).reverse\n        if (result.isEmpty) Nil\n        else (smallest, index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7pyq80qu.scala:35:13\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m (smallest,\
    \ index)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m             Found:    (Long, Int)\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        val even = evens.head\n     \
    \   val index = evens.indexOf(0)\n        val result = (List(even, index)).sortBy(x\
    \ => x._1).reverse\n        if (result.isEmpty) Nil\n        else result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyzd7pii0.scala:33:55 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (List(even,\
    \ index)).sortBy(\e[36mx\e[0m => x._1).reverse\n\e[31m\e[31m   |\e[0m        \
    \                                             ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                 value _1 is not a member of AnyVal\n\e[31m\e\
    [31m-- Error: /tmp/tmpyzd7pii0.scala:33:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (List(even,\
    \ index)).sortBy(\e[36mx\e[0m => x._1).reverse\n\e[31m\e[31m   |\e[0m        \
    \                                                  ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798807
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).toList\n        if (result.isEmpty)\
    \ List(even)\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmpjt57kmfm.scala:31)\n\tat Problem$.main(tmpjt57kmfm.scala:40)\n\
    \tat Problem.main(tmpjt57kmfm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val smalest_value = evens.takeWhile(x => x != even).last\n        val\
    \ smalest_index = evens.lastIndexOf(even)\n        val smalest_evens = evens.takeWhile(x\
    \ => x != smalest_value).sorted\n        val smalest_even = smalest_evens.head\n\
    \        val smalest_even_index = smalest_evens.indexOf(smalest_even)\n      \
    \  val smalest_even_evens = smalest_evens.takeWhile(x => x != smalest_even).sorted\n\
    \        val smalest_even_even = smalest_even_evens.head\n        val smalest_even_even_index\
    \ = smalest_even_evens.indexOf(smalest_even_even)\n        val smalest_even_even_evens\
    \ = smalest_even_evens.takeWhile(x => x != smalest_even_even).sorted\n       \
    \ val smalest_even_even_even = smalest_even_even_evens.head\n        val smalest_even_even_even_index\
    \ = smalest_even_even_evens.indexOf(smalest_even_even_even)\n        val smalest_even_even_even_evens\
    \ = smalest_even_even_evens.takeWhile(x => x != smalest_even_even_even).sorted\n\
    \        val smalest_even_even_even_even = smalest_even_even_even_evens.head\n\
    \        val smalest_even_even_even_even_index = smalest_even_even_even_evens.indexOf(smalest_even_even_even_even)\n\
    \        val smalest_even_even_even_even_evens = smalest_even_even_even_even_evens.takeWhile(x\
    \ => x != smalest_even_even_even_even_even).sorted\n        val smalest_even_even_even_even_even\
    \ = smalest_even_even_even_even_evens.head\n        val smalest_even_even_even_even_even_index\
    \ = smalest_even_even_even_even_evens.indexOf(smalest_even_even_even_even_even)\n\
    \        val smalest_even_even_ev\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvhw2xt4j.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvhw2xt4j.scala:47:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_even_even_even_evens\e[0m = smalest_even_even_even_even_evens.takeWhile(\e\
    [36mx\e[0m => x != smalest_even_even_even_even_even).sorted\n\e[31m\e[31m   |\e\
    [0m                                                ^\e[0m\n\e[31m   |\e[0m   \
    \         Recursive \e[33mvalue\e[0m \e[35msmalest_even_even_even_even_evens\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvhw2xt4j.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798807
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) evens.toList\n\
    \        else evens.take(smalest_index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqzcy6tjz.scala:37)\n\tat Problem.main(tmpqzcy6tjz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_).reverse\n        val smallest = evens.head\n        val\
    \ index = evens.indexOf(0)\n        if (evens.isEmpty) List()\n        else List(smallest,\
    \ index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp5ad0p2q0.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmp5ad0p2q0.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_even = evens(smalest_index)\n\
    \        val smalest_even_index = evens.indexOf(smalest_even)\n        val smalest_even_value\
    \ = evens(smalest_even_index)\n        val smalest_even_index_list = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_2 = evens.indexOf(smalest_even)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_3 = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_4 = evens.indexOf(smalest_even)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_5 = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_6 = evens.indexOf(smalest_even)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_7 = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_8 = evens.indexOf(smalest_even)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_9 = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_10 = evens.indexOf(smalest_even)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_11 = evens.indexOf(smalest_even)\n\
    \        val smalest_even_value_list = evens.indexOf(smalest_even)\n        val\
    \ smalest_even_index_list_12 = evens.indexOf(smalest_even)\n        val smalest_even_value_list\
    \ = evens.indexOf(smalest_even)\n        val smalest_even_index_list_13 = even\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pvqz6od.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pvqz6od.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pvqz6od.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9pvqz6od.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value_list\e\
    [0m = evens.indexOf(smalest_even)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_even_value_list is already defined as \e[33mvalue\e\
    [0m \e[35msmalest_even_value_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m--"
  stdout: ''
  timestamp: 1659798808
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0).map(x => if (x == even) x else\
    \ x).sorted\n        if (result.isEmpty) List(even)\n        else result.take(index).map(x\
    \ => if (x == even) x else x).sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqy7neb7q.scala:38)\n\tat Problem.main(tmpqy7neb7q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else result.take(index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_akotrp1.scala:38)\n\tat Problem.main(tmp_akotrp1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n\
    \        val smallestEven = evensSorted.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9a7bz_41.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9a7bz_41.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9a7bz_41.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEven\e[0m = evensSorted.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmallestEven is already defined as \e[33mvalue\e[0m \e[35msmallestEven\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9a7bz_41.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = evensSorted.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9a7bz_41.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that"
  stdout: ''
  timestamp: 1659798809
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).map(x => x).toList\n        if (evens.isEmpty)\
    \ List()\n        else if (evens.size == 1) List(evens.head)\n        else evens.take(evens.size\
    \ - 1).sortBy(x => x).take(evens.size - 1).map(x => x).map(x => x + 1).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6qgo6y3r.scala:36)\n\tat Problem.main(tmp6qgo6y3r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        if (smalest_index == -1) {\n       \
    \     evens.toList\n        } else {\n            evens.take(smalest_index).toList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphg47p7hw.scala:40)\n\tat Problem.main(tmphg47p7hw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x =>\
    \ x != even).take(index).toList\n        if (result.isEmpty) Nil\n        else\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb6fs885n.scala:38)\n\tat Problem.main(tmpb6fs885n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x % 2 == 0)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        if (smalest_evens_index > 0) {\n            smalest_evens(smalest_evens_index)\n\
    \        } else {\n            smalest_value\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa4e0yvjd.scala:36:25\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            smalest_evens(smalest_evens_index)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m            Found:    Long\n\e[31m   |\e[0m            Required: \e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa4e0yvjd.scala:38:12 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            smalest_value\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (smalest_value\
    \ : Long)\n\e[31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0)\n        val evensSorted = evens.sortWith((a, b) => a < b)\n     \
    \   val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val smallestEvenValue = smallestEven\n        val evensSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smallestEvenIndexWithValue = evensSortedWithIndex.filter(_._1\
    \ == smallestEvenIndex).head\n        val smallestEvenValueWithIndex = evensSortedWithIndex.filter(_._1\
    \ == smallestEvenValue).head\n        val smallestEvenIndexWithValueAndIndex =\
    \ evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex).head\n\
    \        val smallestEvenValueWithIndexAndValue = evensSortedWithIndex.filter(_._1\
    \ == smallestEvenValue && _._2 == smallestEvenIndex).head\n        val smallestEvenIndexWithValueAndIndexAndValue\
    \ = evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex\
    \ && _._3 == smallestEvenIndex).head\n        val smallestEvenValueWithIndexAndIndexAndValueAndIndex\
    \ = evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex\
    \ && _._3 == smallestEvenIndex && _._4 == smallestEvenIndex).head\n        val\
    \ smallestEvenValueWithIndexAndIndexAndValueAndIndexAndValue = evensSortedWithIndex.filter(_._1\
    \ == smallestEvenValue && _._2 == smallestEvenIndex && _._3 == smallestEvenIndex\
    \ && _._4 == smallestEvenIndex && _._5 == smallestEvenIndex).head\n        val\
    \ smallestEvenValueWithIndexAndIndexAndValueAndIndexAndIndexAndValueAndIndex =\
    \ evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex\
    \ && _._3 == smallestEvenIndex && _._4 == smallestEvenIndex && _._5 == smallestEvenIndex\
    \ && _._6 == smallestEvenIndex).head\n        val smallestEvenValueWithIndexAndIndexAndValueAndIndexAndIndexAndValueAndIndexAndValueAndIndex\
    \ = evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex\
    \ && _._3 == smallestEvenIndex && _._4 == smallestEvenIndex && _._\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpgz0pba.scala:44:251 --------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueWithIndexAndIndexAndValueAndIndexAndIndexAndValueAndIndexAndValueAndIndex\e\
    [0m = evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex\
    \ && _._3 == smallestEvenIndex && _._4 == smallestEvenIndex && _._\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                                            \
    \                                                                            \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \              an identifier expected, but '_' found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnpgz0pba.scala:38:79 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexWithValueAndIndex\e\
    [0m = evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex).head\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \           value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnpgz0pba.scala:39:79 ------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueWithIndexAndValue\e[0m =\
    \ evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex).head\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \           value _1 is not a member of Long\n\e[31m\e[31m-- [E086] Syntax Error:\
    \ /tmp/tmpnpgz0pba.scala:40:85 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexWithValueAndIndexAndValue\e\
    [0m = evensSortedWithIndex.filter(_._1 == smallestEvenValue && _._2 == smallestEvenIndex\
    \ && _._3 == smallestEvenIndex)."
  stdout: ''
  timestamp: 1659798811
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).toList\n        if (result.isEmpty)\
    \ List()\n        else List(even, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ogvx0te.scala:39)\n\tat Problem.main(tmp9ogvx0te.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).sortBy(_)\n        val smallest = evens.head\n        val index =\
    \ evens.indexOf(0)\n        val result = List(smallest, index)\n        if (evens.isEmpty)\
    \ result\n        else result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp3j704_qr.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.filter(x =>\
    \ x % 2 == 0)\n        val smalest_evens_index = smalest_evens.indexOf(smalest_value)\n\
    \        if (smalest_evens_index == -1) {\n            smalest_evens_index = smalest_index\n\
    \        }\n        val smalest_evens_index_plus_1 = smalest_evens_index + 1\n\
    \        if (smalest_evens_index_plus_1 == arr.size) {\n            smalest_evens_index_plus_1\
    \ = 0\n        }\n        val smalest_evens_index_plus_2 = smalest_evens_index_plus_1\
    \ + 1\n        if (smalest_evens_index_plus_2 == arr.size) {\n            smalest_evens_index_plus_2\
    \ = 0\n        }\n        val smalest_evens_index_plus_3 = smalest_evens_index_plus_2\
    \ + 1\n        if (smalest_evens_index_plus_3 == arr.size) {\n            smalest_evens_index_plus_3\
    \ = 0\n        }\n        val smalest_evens_index_plus_4 = smalest_evens_index_plus_3\
    \ + 1\n        if (smalest_evens_index_plus_4 == arr.size) {\n            smalest_evens_index_plus_4\
    \ = 0\n        }\n        val smalest_evens_index_plus_5 = smalest_evens_index_plus_4\
    \ + 1\n        if (smalest_evens_index_plus_5 == arr.size) {\n            smalest_evens_index_plus_5\
    \ = 0\n        }\n        val smalest_evens_index_plus_6 = smalest_evens_index_plus_5\
    \ + 1\n        if (smalest_evens_index_plus_6 == arr.size) {\n            smalest_evens_index_plus_6\
    \ = 0\n        }\n        val smalest_evens_index_plus_7 = smalest_evens_index_plus_6\
    \ + 1\n        if (smalest_evens_index_plus_7 == arr.size) {\n            smalest_evens_index_plus_7\
    \ = 0\n        }\n        val smalest_evens_index_plus_8 = smalest_evens_index_plus_7\
    \ + 1\n        if (smalest_evens_index_plus_8 == arr.size) {\n            smalest_evens_index_plus_8\
    \ = 0\n        }\n        val smalest_evens_index_plus_9 = smalest_evens_index_plus_8\
    \ + 1\n        if (smalest_evens_index_plus_9 == arr.size) {\n            smalest_evens_index_plus_9\
    \ = 0\n        }\n        val smalest_even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5657ibxm.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp5657ibxm.scala:36:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            smalest_evens_index\
    \ = smalest_index\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val smalest_evens_index\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp5657ibxm.scala:40:39 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            smalest_evens_index_plus_1 = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Reassignment to val smalest_evens_index_plus_1\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp5657ibxm.scala:44:39 -----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            smalest_evens_index_plus_2 = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Reassignment to val smalest_evens_index_plus_2\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp5657ibxm.scala:48:39 -----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m            smalest_evens_index_plus_3 = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Reassignment to val smalest_evens_index_plus_3\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp5657ibxm.scala:52:39 -----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            smalest_evens_index_plus_4 = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            Reassignment to val smalest_evens_index_plus_4\n\e[31m "
  stdout: ''
  timestamp: 1659798812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n\
    \        val evenSmallest = evensSorted.head\n        val evenSmallestIndex =\
    \ evensSorted.indexOf(0)\n        val evenSmallestValue = evenSmallest\n     \
    \   val evenSmallestIndexList = evenSmallestIndex.toList\n        val evenSmallestValueList\
    \ = evenSmallestValue.toList\n        val evenSmallestIndexListLength = evenSmallestIndexList.length\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestIndexListLength = evenSmallestIndexListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmalle\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe6764viy.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe6764viy.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestIndexListLength\e[0m = evenSmallestIndexListLength\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe6764viy.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe6764viy.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe6764viy.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List()\n \
    \       else evens.take(1).head\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoye89zte.scala:32:27\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.take(\e\
    [31m1\e[0m).head\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798814
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).sortBy(x => x)\n        val even = evens.head\n        val index\
    \ = evens.indexOf(even)\n        val result = arr.filter(_ != even).sortBy(x =>\
    \ x).take(index).map(x => x).reverse\n        if (result.isEmpty) Nil\n      \
    \  else result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9qz2m97_.scala:38)\n\tat Problem.main(tmp9qz2m97_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val smalest_value = evens.min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val smalest_evens = evens.take(smalest_index)\n\
    \        val smalest_evens_index = evens.indexOf(smalest_evens)\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        if (smalest_evens_index == evens.length)\
    \ smalest_evens_index\n        else smalest_evens_index\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf71zfpzt.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpf71zfpzt.scala:36:49 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (smalest_evens_index == evens.length)\
    \ smalest_evens_index\n\e[31m\e[31m   |\e[0m                                 \
    \                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                Found:    (smalest_evens_index : Int)\n\e[31m   |\e[0m      \
    \                             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpf71zfpzt.scala:37:13 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33melse\e[0m smalest_evens_index\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \   Found:    (smalest_evens_index : Int)\n\e[31m   |\e[0m             Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0).toList\n        if (evens.isEmpty) List()\n        else {\n \
    \           val minIndex = evens.minBy(x => x).index\n            val minValue\
    \ = evens(minIndex)\n            evens.filterNot(x => x == minValue)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9isj_yl2.scala:33:47 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mminIndex\e[0m = evens.minBy(\e\
    [36mx\e[0m => x).index\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value index is not a member of\
    \ Long\n1 error found\n"
  stdout: ''
  timestamp: 1659798813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(_\
    \ % 2 == 0).toList\n        if(evens.isEmpty) List(arr.head.toLong)\n        else\
    \ {\n            val min = evens.min\n            val index = arr.indexOf(min)\n\
    \            arr.take(index).filter(_ % 2 == 0).min.toLong\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy9vo_132.scala:35:51\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            arr.take(index).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).min.toLong\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Found:    Long\n\e[31m   |\e[0m            Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798814
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given a list representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given list is empty, return [].\n    // Example 1:\n    // >>> pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong)))\n    // (List[Long](2l.toLong, 1l.toLong))\n    // Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n    // Example\
    \ 2:\n    // >>> pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong)))\n    //\
    \ (List[Long](2l.toLong, 1l.toLong))\n    // Explanation: 2 has the smallest even\
    \ value, and 2 has the smallest index.\n    // Example 3:\n    // >>> pluck((List[Long]()))\n\
    \    // (List[Long]())\n    // Example 4:\n    // >>> pluck((List[Long](5l.toLong,\
    \ 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](0l.toLong,\
    \ 1l.toLong))\n    // Explanation: 0 is the smallest value, but  there are two\
    \ zeros,\n    // so we will choose the first zero, which has the smallest index.\n\
    \    // Constraints:\n    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n\
    \    def pluck(arr : List[Long]) : List[Long] = {\n        val evens = arr.filter(x\
    \ => x % 2 == 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n\
    \        val evensSortedWithIndex = evensSorted.zipWithIndex\n        val smallestEven\
    \ = evensSortedWithIndex.minBy(_._1)\n        val smallestEvenIndex = evensSortedWithIndex.minBy(_._2)\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n       \
    \ val smallestEvenIndex = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n\
    \        val smallestEvenIndex = smallestEven._2\n        val smallestEvenValue\
    \ = smallestEven._1\n        val smallestEvenIndex = smallestEven._2\n       \
    \ val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex = smallestEven._2\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n       \
    \ val smallestEvenIndex = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n\
    \        val smallestEvenIndex = smallestEven._2\n        val smallestEvenValue\
    \ = smallestEven._1\n        val smallestEvenIndex = smallestEven._2\n       \
    \ val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex = smallestEven._2\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n       \
    \ val smallestEvenIndex = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n\
    \        val smallestEvenIndex = smallestEven._2\n        val smallestEvenValue\
    \ = smallestEven._1\n        val smallestEvenIndex = smallestEven._2\n       \
    \ val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex = smallestEven._2\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n       \
    \ val smallestEvenIndex = smallestEven._2\n        val smallestEvenValue = smallestEven._1\n\
    \        val smallestEvenIndex = smallestEven._2\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpihnqm5k_.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEven._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpihnqm5k_.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEven._1\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpihnqm5k_.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEven._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpihnqm5k_.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEven._1\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpihnqm5k_.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEven._2\n\e[31m\e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1659798814
