language: scala
name: HumanEval_84_solve
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ == '1').reverse\n        binary.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpongonwxc.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpongonwxc.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpongonwxc.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(mutable.Map.empty[Int, Int]){\n          \
    \  case (acc, digit) =>\n                val key = digit.charAt(0).toInt\n   \
    \             val value = acc.get(key) match {\n                    case Some(sum)\
    \ => sum + digit.charAt(1).toInt\n                    case None => digit.charAt(1).toInt\n\
    \                }\n                acc + (key -> value)\n        }\n        val\
    \ result = sums.filter(_._2 > 0).map(_._1).mkString\n        result + (if (sums.isEmpty)\
    \ \"\" else s\"(${sums.last._2})\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5g9i0l3x.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(Map[String, Long]()){\n            case (acc,\
    \ digit) =>\n                val key = digit.mkString\n                val value\
    \ = acc.getOrElse(key, 0) + 1\n                acc + (key -> value)\n        }\n\
    \        val result = sums.map{case (digit, count) => s\"${digit}${count.toBinaryString}\"\
    }\n        result.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpipsybzvj.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            val digit = binary.charAt(i)\n\
    \            sum += digit.toInt\n        }\n        binary.reverse\n        binary.reverse.takeWhile(_\
    \ != '0').mkString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxjrp4hlt.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += digit.toInt\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ for(i <- N.toInt) {\n            sum += i\n            binary += i.toBinaryString\n\
    \        }\n        if(sum < 10) {\n            binary += \"0\"\n        }\n \
    \       binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxug1x7zr.scala:20:17 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m(i <- N.toInt) {\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") { (result, digit) =>\n            val sum =\
    \ result + digit\n            if (sum.length == binary.length) {\n           \
    \     sum\n            } else {\n                val newSum = sum.substring(0,\
    \ sum.length - 1) + digit\n                if (newSum.length == binary.length)\
    \ {\n                    newSum\n                } else {\n                  \
    \  newSum + digit\n                }\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppf2i5o1b.scala:35)\n\tat Problem.main(tmppf2i5o1b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyb0js5tn.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyb0js5tn.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(mutable.Map[String, Int]()){\n           \
    \ case (acc, digit) => acc + (digit -> (acc.getOrElse(digit, 0) + 1))\n      \
    \  }\n        sums.map{case (digit, count) => digit + count.toString}.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzikrtpk3.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\")(_ + _)\n        result + binary.reverse.dropWhile(_\
    \ == '0').takeWhile(_ != '0').mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiq_vysnd.scala:23)\n\tat Problem.main(tmpiq_vysnd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val binary = digits.map(x\
    \ => if (x == 0) \"0\" else (x % 2 + \"1\")).mkString\n        binary.reverse.foldRight(\"\
    \")((acc, x) => acc + x)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcy28za_8.scala:24)\n\tat Problem.main(tmpcy28za_8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)(_ + _)\n        val binSumString\
    \ = binSum.toBinaryString\n        binSumString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7skb9hwz.scala:25)\n\tat Problem.main(tmp7skb9hwz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(Map[Int, Int]()){\n            case (acc,\
    \ digit) =>\n                val sum = digit._1 + digit._2\n                acc\
    \ + (sum -> (sum + digit._1))\n        }\n        val result = sums.filter(_._2\
    \ > 0).map(_._2).sum.toString\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprqz4oj6h.scala:21:32 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mval\e[0m \e[36msum\e[0m = digit._1\
    \ + digit._2\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          value _1 is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") { (s, d) => s + d }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp54l2ikti.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val result = mutable.Stack[String]()\n        val sum = 0\n        val\
    \ maxDigit = digits.length\n        val maxDigits = digits.length\n        val\
    \ maxDigitSum = digits.length\n        val maxDigitSums = digits.length\n    \
    \    val maxDigitSumsOfDigits = digits.length\n        val maxDigitSumsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigits = digits.length\n\
    \        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigits = digits.length\n  \
    \      val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = digits.length\n\
    \        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits = digits.length\n\
    \        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ = digits.length\n        val maxDigitSumsOfDigitsOfDigitsOf\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg8bjzfph.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg8bjzfph.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\e\
    [0m = digits.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpg8bjzfph.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmaxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\e\
    [0m = digits.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxDigitSumsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigitsOfDigits\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpg8bjzfph.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.toCharArray\n        binary.foreach(x => {\n\
    \            sum += x\n        })\n        binary.toString.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_od4trw8.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_od4trw8.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += x\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        val binLen = bin.length\n      \
    \  val binLen2 = binLen/2\n        val binLen3 = binLen2/2\n        val binLen4\
    \ = binLen3/2\n        val binLen5 = binLen4/2\n        val binLen6 = binLen5/2\n\
    \        val binLen7 = binLen6/2\n        val binLen8 = binLen7/2\n        val\
    \ binLen9 = binLen8/2\n        val binLen10 = binLen9/2\n        val binLen11\
    \ = binLen10/2\n        val binLen12 = binLen11/2\n        val binLen13 = binLen12/2\n\
    \        val binLen14 = binLen13/2\n        val binLen15 = binLen14/2\n      \
    \  val binLen16 = binLen15/2\n        val binLen17 = binLen16/2\n        val binLen18\
    \ = binLen17/2\n        val binLen19 = binLen18/2\n        val binLen20 = binLen19/2\n\
    \        val binLen21 = binLen20/2\n        val binLen22 = binLen21/2\n      \
    \  val binLen23 = binLen22/2\n        val binLen24 = binLen23/2\n        val binLen25\
    \ = binLen24/2\n        val binLen26 = binLen25/2\n        val binLen27 = binLen26/2\n\
    \        val binLen28 = binLen27/2\n        val binLen29 = binLen28/2\n      \
    \  val binLen30 = binLen29/2\n        val binLen31 = binLen30/2\n        val binLen32\
    \ = binLen31/2\n        val binLen33 = binLen32/2\n        val binLen34 = binLen33/2\n\
    \        val binLen35 = binLen34/2\n        val binLen36 = binLen35/2\n      \
    \  val binLen37 = binLen36/2\n        val binLen38 = binLen37/2\n        val binLen39\
    \ = binLen38/2\n        val binLen40 = binLen39/2\n        val binLen41 = binLen40/2\n\
    \        val binLen42 = binLen41/2\n        val binLen43 = binLen42/2\n      \
    \  val binLen44 = binLen43/2\n        val binLen45 = binLen44/2\n        val binLen46\
    \ = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyqa1vd4q.scala:67:5\
    \ ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.split(\"\")\n        val sum = 0\n        bins.foreach(x => {\n   \
    \         val y = x.toInt\n            sum += y\n        })\n        binary.reverse.split(\"\
    \").map(x => x.toInt + sum).mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcqfsamew.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += y\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary.charAt(i)\n\
    \        }\n        binary.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp628r4kzj.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(_.toBinaryString).mkString(\"\")\n        val\
    \ result = binary.reverse.grouped(2).map(_.mkString).reverse\n        result match\
    \ {\n            case Nil => \"\"\n            case _ => result\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplzm80k1g.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.toCharArray\n        val binary = binary.filter(_\
    \ != '0')\n        val binary = binary.filter(_ != '1')\n        binary.foreach(x\
    \ => sum += x)\n        binary.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu0oq9sq7.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.toCharArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu0oq9sq7.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.filter(_ != \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu0oq9sq7.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.filter(_ != \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu0oq9sq7.scala:23:32\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        binary.foreach(\e\
    [36mx\e[0m => sum += x)\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  value += is not a member of Int - did you\
    \ mean sum.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 to binary.length-1){\n            val temp = binary.charAt(i)\n\
    \            val digit = temp.charAt(0)\n            val bin = digit.toInt\n \
    \           sum += bin\n        }\n        binary.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvoqk1_en.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mdigit\e[0m = temp.charAt(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        value charAt is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpvoqk1_en.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum += bin\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            val bin = binary.substring(i)\n\
    \            val num = bin.toInt\n            sum += num\n        }\n        binary.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp37tpyggq.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += num\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") { (acc, digit) =>\n            acc\
    \ + (if (digit.length > 1) \"1\" + digit else \"0\" + digit)\n        }\n    \
    \    binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnc0u6kpd.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary(i)\n      \
    \  }\n        binary.reverse.foldLeft(\"\") {\n            (a,b) => a + b.toInt\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1i3jb0hp.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary(i)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val m = l / 2\n        val r = s.substring(m, l)\n        val x = s.substring(0,\
    \ m)\n        val y = x.reverse\n        val z = y.reverse\n        val w = z.reverse\n\
    \        val a = w.reverse\n        val b = a.reverse\n        val c = b.reverse\n\
    \        val d = c.reverse\n        val e = d.reverse\n        val f = e.reverse\n\
    \        val g = f.reverse\n        val h = g.reverse\n        val i = h.reverse\n\
    \        val j = i.reverse\n        val k = j.reverse\n        val l = k.reverse\n\
    \        val m = l.reverse\n        val n = m.reverse\n        val o = n.reverse\n\
    \        val p = o.reverse\n        val q = p.reverse\n        val r = q.reverse\n\
    \        val s = r.reverse\n        val t = s.reverse\n        val u = t.reverse\n\
    \        val v = u.reverse\n        val w = v.reverse\n        val x = w.reverse\n\
    \        val y = x.reverse\n        val z = y.reverse\n        val a = z.reverse\n\
    \        val b = a.reverse\n        val c = b.reverse\n        val d = c.reverse\n\
    \        val e = d.reverse\n        val f = e.reverse\n        val g = f.reverse\n\
    \        val h = g.reverse\n        val i = h.reverse\n        val j = i.reverse\n\
    \        val k = j.reverse\n        val l = k.reverse\n        val m = l.reverse\n\
    \        val n = m.reverse\n        val o = n.reverse\n        val p = o.reverse\n\
    \        val q = p.reverse\n        val r = q.reverse\n        val s = r.reverse\n\
    \        val t = s.reverse\n        val u = t.reverse\n        val v = u.reverse\n\
    \        val w = v.reverse\n        val x = w.reverse\n        val y = x.reverse\n\
    \        val z = y.reverse\n        val a = z.reverse\n        val b = a.reverse\n\
    \        val c = b.reverse\n        val d = c.reverse\n        val e = d.reverse\n\
    \        val f = e.reverse\n        val g = f.reverse\n        val h = g.reverse\n\
    \        val i = h.reverse\n        val j = i.reverse\n        val k = j.reverse\n\
    \        val l = k.reverse\n        val m = l.reverse\n        val n = m.reverse\n\
    \        val o = n.reverse\n        val p = o.reverse\n        val q = p.reverse\n\
    \        val r = q.reverse\n        val s = r.reverse\n        val t = s.reverse\n\
    \        val u = t.reverse\n        val v = u.reverse\n        val w = v.reverse\n\
    \        val x = w.reverse\n        val y = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7nbbe_46.scala:102:15 --------------------------\e\
    [0m\e[0m\n\e[31m102 |\e[0m        \e[33mval\e[0m \e[36my\e[0m = \n\e[31m\e[31m\
    \    |\e[0m               ^\e[0m\n\e[31m    |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7nbbe_46.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = k.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e\
    [0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp7nbbe_46.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nbbe_46.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = q.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nbbe_46.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = r.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nbbe_46.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = v.reverse\n\e["
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n \
    \       val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp99z5npa6.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp99z5npa6.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99z5npa6.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp99z5npa6.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99z5npa6.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp99z5npa6.scala:23:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = \"\"\n        var sum = 0\n        var i\
    \ = N\n        while (i > 0) {\n            sum += i % 2\n            i /= 2\n\
    \        }\n        s += sum.toString\n        return s\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgtuo1nu7.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += i % \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgtuo1nu7.scala:25:10\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        s += sum.toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^\e[0m\n\e[31m   |\e[0m        value += is not\
    \ a member of String - did you mean s.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = 0\n        val result = new mutable.ListBuffer[String]\n\
    \        for (i <- 0 until digits.size) {\n            val digit = digits(i)\n\
    \            sum += digit.toLong\n            val bin = sum.toBinaryString\n \
    \           val binDigits = bin.toList\n            val binSum = 0\n         \
    \   for (j <- 0 until binDigits.size) {\n                val binDigit = binDigits(j)\n\
    \                binSum += binDigit.toLong\n            }\n            val binSumStr\
    \ = binSum.toBinaryString\n            if (binSumStr.length == 1) {\n        \
    \        result.append((binSumStr))\n            } else {\n                result.append((binSumStr.substring(0,\
    \ binSumStr.length - 1))).append(\"0\")\n            }\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4hf8jnr8.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4hf8jnr8.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum += digit.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp4hf8jnr8.scala:30:23 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m                binSum += binDigit.toLong\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               value += is not\
    \ a member of Int - did you mean binSum.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        for (digit <- digits) {\n            val value = digit.toInt\n      \
    \      val bin = math.pow(10, value).toInt\n            val binStr = binary.take(binary.size\
    \ - 1).mkString(\"\")\n            val binStr2 = binStr + binStr\n           \
    \ binary.append(binStr2)\n            sum += bin\n        }\n        binary.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptfdytnqg.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptfdytnqg.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = N.toBinaryString\n        val numsArray\
    \ = nums.toCharArray\n        val numsArrayLen = numsArray.length\n        val\
    \ numsArraySum = numsArray.sum\n        val numsArraySumLen = numsArraySum.length\n\
    \        val numsArraySumLen2 = numsArraySumLen * numsArraySumLen\n        val\
    \ numsArraySumLen3 = numsArraySumLen2 * numsArraySumLen\n        val numsArraySumLen4\
    \ = numsArraySumLen3 * numsArraySumLen\n        val numsArraySumLen5 = numsArraySumLen4\
    \ * numsArraySumLen\n        val numsArraySumLen6 = numsArraySumLen5 * numsArraySumLen\n\
    \        val numsArraySumLen7 = numsArraySumLen6 * numsArraySumLen\n        val\
    \ numsArraySumLen8 = numsArraySumLen7 * numsArraySumLen\n        val numsArraySumLen9\
    \ = numsArraySumLen8 * numsArraySumLen\n        val numsArraySumLen10 = numsArraySumLen9\
    \ * numsArraySumLen\n        val numsArraySumLen11 = numsArraySumLen10 * numsArraySumLen\n\
    \        val numsArraySumLen12 = numsArraySumLen11 * numsArraySumLen\n       \
    \ val numsArraySumLen13 = numsArraySumLen12 * numsArraySumLen\n        val numsArraySumLen14\
    \ = numsArraySumLen13 * numsArraySumLen\n        val numsArraySumLen15 = numsArraySumLen14\
    \ * numsArraySumLen\n        val numsArraySumLen16 = numsArraySumLen15 * numsArraySumLen\n\
    \        val numsArraySumLen17 = numsArraySumLen16 * numsArraySumLen\n       \
    \ val numsArraySumLen18 = numsArraySumLen17 * numsArraySumLen\n        val numsArraySumLen19\
    \ = numsArraySumLen18 * numsArraySumLen\n        val numsArraySumLen20 = numsArraySumLen19\
    \ * numsArraySumLen\n        val numsArraySumLen21 = numsArraySumLen20 * numsArraySumLen\n\
    \        val numsArraySumLen22 = numsArraySumLen21 * numsArraySumLen\n       \
    \ val numsArraySumLen23 = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_g_o3fbm.scala:44:31 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mnumsArraySumLen23\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_g_o3fbm.scala:22:43\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mnumsArraySumLen\e[0m = numsArraySum.length\n\e[31m\e[31m   |\e[0m        \
    \                      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                 value length is not a member of Char\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_g_o3fbm.scala:45:5 ---------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(Map[String, Int]())((map, digit) => {\n  \
    \          val key = digit + map.getOrElse(digit, 0)\n            map + (key ->\
    \ map.getOrElse(key, 0) + 1)\n        })\n        val result = sums.foldLeft(Map[String,\
    \ String]())((map, sum) => {\n            val key = sum + map.getOrElse(sum, 0)\n\
    \            map + (key -> map.getOrElse(key, 0).toString + key)\n        }).values.toList.sortBy(_.length).reverse.mkString\n\
    \        val result = result.substring(0, result.length - 1)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmi0lamt5.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.substring(\e\
    [31m0\e[0m, result.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpmi0lamt5.scala:18:67 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804464
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val r = new Array[String](l)\n        var i = 0\n        var j = 0\n\
    \        while (i < l) {\n            val c = s(i)\n            if (c == '1')\
    \ {\n                r(j) = \"1\"\n                i += 1\n                j +=\
    \ 1\n            } else {\n                r(j) = \"0\"\n                i +=\
    \ 1\n                j += 1\n            }\n        }\n        r.mkString\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp26h3_79x.scala:38)\n\tat Problem.main(tmp26h3_79x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyb0js5tn.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyb0js5tn.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary(i)\n      \
    \  }\n        binary.reverse.foldLeft(\"\") {\n            case(acc, x) => acc\
    \ + (if (x == '1') 1 else 0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpehx6xwtb.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary(i)\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") { (result, digit) =>\n            val index\
    \ = result.length - 1\n            if (digit == \"1\") result + (\"0\" * (index\
    \ - 1))\n            else result + (\"1\" * (index - 1))\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjfdcjnic.scala:21:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (digit == \e[31m\"1\"\e[0m)\
    \ result + (\e[31m\"0\"\e[0m * (index - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types Char\
    \ and String cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = N.toBinaryString\n        val numsArray\
    \ = nums.toCharArray\n        val numsArrayLen = numsArray.length\n        val\
    \ numsArraySum = numsArray.foldLeft(0)((sum, digit) => sum + digit.toInt)\n  \
    \      val numsArraySumString = numsArraySum.toString\n        val numsArraySumStringLen\
    \ = numsArraySumString.length\n        val numsArraySumStringLenMinusOne = numsArraySumStringLen\
    \ - 1\n        val numsArraySumStringLenMinusOneString = numsArraySumStringLen\
    \ - 1\n        val numsArraySumStringLenMinusOneStringChars = numsArraySumStringLen\
    \ - 1\n        val numsArraySumStringLenMinusOneStringCharsArray = numsArraySumStringLen\
    \ - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLen = numsArraySumStringLen\
    \ - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOne =\
    \ numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneString\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneStringChars\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneStringCharsArray\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneStringCharsArrayLen\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneStringCharsArrayLenMinusOne\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneStringCharsArrayLenMinusOneString\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneStringCharsArrayLenMinusOneStringChars\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOneStringCharsArrayLenMinusOneStringCharsArrayLenMinusOneStringCharsArray\
    \ = numsArraySumStringLen - 1\n        val numsArraySumStringLenMinusOne\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2udhs_h2.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2udhs_h2.scala:39:5 ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        val binary = bin.map(x => if (x\
    \ == '1') 1 else 0)\n        binary.foreach(x => sum += x)\n        binary.toBinaryString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3m91ma5q.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = bin.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m'1'\e[0m) \e[31m1\e[0m \e[33melse\e[0m\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp3m91ma5q.scala:22:32 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m        binary.foreach(\e[36mx\e[0m => sum += x)\n\e[31m\e[31m\
    \   |\e[0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \       value += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3m91ma5q.scala:23:15 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        binary.toBinaryString\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value toBinaryString\
    \ is not a member of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n \
    \       val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp99z5npa6.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp99z5npa6.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99z5npa6.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp99z5npa6.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99z5npa6.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp99z5npa6.scala:23:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1659804465
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val binary = digits.map(x\
    \ => if (x == 1) \"1\" else \"0\").mkString\n        binary.reverse.grouped(2).map(_.toInt).sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwqv91_1e.scala:24)\n\tat Problem.main(tmpwqv91_1e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        var i = 0\n        while (i < binary.length) {\n            val c\
    \ = binary.charAt(i)\n            val d = c.toInt\n            sum += d\n    \
    \        i += 1\n        }\n        val result = sum.toBinaryString\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo8ifhjca.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum += d\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x.isEmpty) \"\" else x.reverse).mkString(\"\
    \")\n        val result = binary.reverse.foldLeft(\"\") {\n            (acc, x)\
    \ => acc + (if (x.isEmpty) \"\" else x.reverse)\n        }\n        return result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm31pxmoi.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.asInstanceOf[Int])\n\
    \        binSum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp89do11qv.scala:24)\n\tat Problem.main(tmp89do11qv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (d <- digits) {\n            sum += d.toInt\n\
    \        }\n        val binary = digits.length.toString + sum.toString\n     \
    \   binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpijw5_6ln.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)((sum, digit) => sum + digit.toInt)\n   \
    \     val result = if (sum > 0) \"1\" + sum.toString else \"\"\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe949o2qj.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") {\n            (acc, x) => acc + (if (x == '1')\
    \ \"1\" else \"0\") + x\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxejpze17.scala:25)\n\tat Problem.main(tmpxejpze17.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val result = new mutable.ListBuffer[String]()\n        val sum = 0\n\
    \        var i = 0\n        while (i < l) {\n            val c = s(i)\n      \
    \      val d = c.toInt\n            sum += d\n            i += 1\n           \
    \ if (sum > 9) {\n                result.append((sum / 10).toString)\n       \
    \         sum -= (sum / 10).toInt\n            }\n        }\n        if (sum >\
    \ 0) {\n            result.append((sum / 10).toString)\n        }\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmuwehue5.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmuwehue5.scala:26:16\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            sum += d\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpmuwehue5.scala:30:20 ------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                sum -= (sum / \e[31m10\e[0m).toInt\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value -= is not\
    \ a member of Int - did you mean sum.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val result = digits.map(x\
    \ => if (x == 1) \"1\" else x.toString.reverse).mkString\n        val result =\
    \ if (sum == 0) \"0\" else result\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy2e61h31.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (sum == \e[31m0\e[0m) \e[31m\"0\"\e[0m \e[33melse\e[0m result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy2e61h31.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804473
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val result = sums.foldLeft(\"\
    \")(_ + _)\n        result + (if (sums.sum == 0) \"\" else \"\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0cs1q5s8.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") { (acc, digit) =>\n            acc\
    \ + (if (digit.length > 1) \"1\" + digit else \"0\" + digit)\n        }\n    \
    \    binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnc0u6kpd.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val m = s.toLong\n\
    \        val l = s.length\n        val r = new Array[String](l)\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        while (i < l) {\n       \
    \     if (s(i) == '1') {\n                r(j) = \"1\"\n                j++\n\
    \            } else {\n                r(j) = \"0\"\n                j++\n   \
    \         }\n            i += 1\n        }\n        var sum = 0\n        var sum2\
    \ = 0\n        var sum3 = 0\n        var sum4 = 0\n        var sum5 = 0\n    \
    \    var sum6 = 0\n        var sum7 = 0\n        var sum8 = 0\n        var sum9\
    \ = 0\n        var sum10 = 0\n        var sum11 = 0\n        var sum12 = 0\n \
    \       var sum13 = 0\n        var sum14 = 0\n        var sum15 = 0\n        var\
    \ sum16 = 0\n        var sum17 = 0\n        var sum18 = 0\n        var sum19 =\
    \ 0\n        var sum20 = 0\n        var sum21 = 0\n        var sum22 = 0\n   \
    \     var sum23 = 0\n        var sum24 = 0\n        var sum25 = 0\n        var\
    \ sum26 = 0\n        var sum27 = 0\n        var sum28 = 0\n        var sum29 =\
    \ 0\n        var sum30 = 0\n        var sum31 = 0\n        var sum32 = 0\n   \
    \     var sum33 = 0\n        var sum34 = 0\n        var sum35 = 0\n        var\
    \ sum36 = 0\n        var sum37 = 0\n        var sum38 = 0\n        var sum39 =\
    \ 0\n        var sum40 = 0\n        var sum41 = 0\n        var sum42 = 0\n   \
    \     var sum43 = 0\n        var sum44 = 0\n        var sum45 = 0\n        var\
    \ sum46 = 0\n        var sum47 = 0\n        var sum48 = 0\n        var sum49 =\
    \ 0\n        var sum50 = 0\n        var sum51 = 0\n        var sum52 = 0\n   \
    \     var sum53 = 0\n        var sum54 = 0\n        var sum55 = 0\n        var\
    \ sum56 = 0\n        var sum57 = 0\n        var sum58 = 0\n        var sum59 =\
    \ 0\n        var sum60 = 0\n        var sum61 = 0\n        var sum62 = 0\n   \
    \     var sum63 = 0\n        var sum64 = 0\n        var sum65 = 0\n        var\
    \ sum66 = 0\n        var sum67 = 0\n        var sum68 = 0\n        var sum69 =\
    \ 0\n        var sum70 = 0\n        var sum71 = 0\n        var sum72 = 0\n   \
    \     var sum73 = 0\n        var sum74 = 0\n        var sum75 = 0\n        var\
    \ sum76 = 0\n        var sum77 = 0\n        var sum78 = 0\n        var sum79 =\
    \ 0\n        var sum80 = 0\n        var sum81 = 0\n        var sum82 = 0\n   \
    \     var sum83 = 0\n        var sum84 = 0\n        var sum85 = 0\n        var\
    \ sum86 = 0\n        var sum\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmv5126we.scala:28:19 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmv5126we.scala:31:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                j++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpmv5126we.scala:122:4 ---------------------------\e\
    [0m\e[0m\n\e[31m122 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpmv5126we.scala:122:5 --------------------\e[0m\e[0m\n\e[31m122 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: String\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)(_ + _)\n        binary.toList.foldLeft(\"\
    \")((acc, x) => acc + (if (x == '1') 1 else 0).toString + x.toString.padToLength(4,\
    \ \"0\"))\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp99tgvnq4.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        binary.toList.foldLeft(\e[31m\"\"\e[0m)((\e[36macc\e\
    [0m, \e[36mx\e[0m) => acc + (\e[33mif\e[0m (x == \e[31m'1'\e[0m) \e[31m1\e[0m\
    \ \e[33melse\e[0m \e[31m0\e[0m).toString + x.toString.padToLength(\e[31m4\e[0m,\
    \ \e[31m\"0\"\e[0m))\n\e[31m\e[31m   |\e[0m                                  \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n1 error found\n"
  stdout: ''
  timestamp: 1659804475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.map(_.sum)\n        val result = sums.foldLeft(\"\"\
    ) { (result, sum) => result + sum.toString }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2bhqjd9f.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.map(_.sum)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              value sum is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659804475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val sum = 0\n        val result = new mutable.ListBuffer[String]\n\
    \        for(i <- 0 until bin.length){\n            val binStr = bin(i)\n    \
    \        val binStrLen = binStr.length\n            val binStrLen2 = binStrLen\
    \ / 2\n            val binStrLen3 = binStrLen / 3\n            val binStrLen4\
    \ = binStrLen / 4\n            val binStrLen5 = binStrLen / 5\n            val\
    \ binStrLen6 = binStrLen / 6\n            val binStrLen7 = binStrLen / 7\n   \
    \         val binStrLen8 = binStrLen / 8\n            val binStrLen9 = binStrLen\
    \ / 9\n            val binStrLen10 = binStrLen / 10\n            val binStrLen11\
    \ = binStrLen / 11\n            val binStrLen12 = binStrLen / 12\n           \
    \ val binStrLen13 = binStrLen / 13\n            val binStrLen14 = binStrLen /\
    \ 14\n            val binStrLen15 = binStrLen / 15\n            val binStrLen16\
    \ = binStrLen / 16\n            val binStrLen17 = binStrLen / 17\n           \
    \ val binStrLen18 = binStrLen / 18\n            val binStrLen19 = binStrLen /\
    \ 19\n            val binStrLen20 = binStrLen / 20\n            val binStrLen21\
    \ = binStrLen / 21\n            val binStrLen22 = binStrLen / 22\n           \
    \ val binStrLen23 = binStrLen / 23\n            val binStrLen24 = binStrLen /\
    \ 24\n            val binStrLen25 = binStrLen / 25\n            val binStrLen26\
    \ = binStrLen / 26\n            val binStrLen27 = binStrLen / 27\n           \
    \ val binStrLen28 = binStrLen / 28\n            val binStrLen29 = binStrLen /\
    \ 29\n            val binStrLen30 = binStrLen / 30\n            val binStrLen31\
    \ = binStrLen / 31\n            val binStrLen32 = binStrLen / 32\n           \
    \ val binStrLen33 = binStrLen / 33\n            val binStrLen34 = binStrLen /\
    \ 34\n            val binStrLen35 = binStrLen / 35\n            val binStrLen36\
    \ = binStrLen / 36\n            val binStrLen37\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn9hf4eh0.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn9hf4eh0.scala:71:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpn9hf4eh0.scala:21:25 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpn9hf4eh0.scala:24:35 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mbinStrLen\e[0m = binStr.length\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                            value length is not a member of Char\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpn9hf4eh0.scala:70:1 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpn9hf4eh0.scala:62:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m62 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        var remainder2 = 0\n        var remainder3 = 0\n\
    \        var remainder4 = 0\n        var remainder5 = 0\n        var remainder6\
    \ = 0\n        var remainder7 = 0\n        var remainder8 = 0\n        var remainder9\
    \ = 0\n        var remainder10 = 0\n        var remainder11 = 0\n        var remainder12\
    \ = 0\n        var remainder13 = 0\n        var remainder14 = 0\n        var remainder15\
    \ = 0\n        var remainder16 = 0\n        var remainder17 = 0\n        var remainder18\
    \ = 0\n        var remainder19 = 0\n        var remainder20 = 0\n        var remainder21\
    \ = 0\n        var remainder22 = 0\n        var remainder23 = 0\n        var remainder24\
    \ = 0\n        var remainder25 = 0\n        var remainder26 = 0\n        var remainder27\
    \ = 0\n        var remainder28 = 0\n        var remainder29 = 0\n        var remainder30\
    \ = 0\n        var remainder31 = 0\n        var remainder32 = 0\n        var remainder33\
    \ = 0\n        var remainder34 = 0\n        var remainder35 = 0\n        var remainder36\
    \ = 0\n        var remainder37 = 0\n        var remainder38 = 0\n        var remainder39\
    \ = 0\n        var remainder40 = 0\n        var remainder41 = 0\n        var remainder42\
    \ = 0\n        var remainder43 = 0\n        var remainder44 = 0\n        var remainder45\
    \ = 0\n        var remainder46 = 0\n        var remainder47 = 0\n        var remainder48\
    \ = 0\n        var remainder49 = 0\n        var remainder50 = 0\n        var remainder51\
    \ = 0\n        var remainder52 = 0\n        var remainder53 = 0\n        var remainder54\
    \ = 0\n        var remainder55 = 0\n        var remainder56 = 0\n        var remainder57\
    \ = 0\n        var remainder58 = 0\n        var remainder59 = 0\n        var remainder60\
    \ = 0\n        var remainder61 = 0\n        var remainder62 = 0\n        var remainder63\
    \ = 0\n        var remainder64 = 0\n        var remainder65 = 0\n        var remainder66\
    \ = 0\n        var remainder67 = 0\n        var remainder68 = 0\n        var remainder69\
    \ = 0\n        var remainder70 = 0\n        var remainder71 = 0\n        var remainder72\
    \ = 0\n        var remainder73 = 0\n        var remainder74 = 0\n        var remainder75\
    \ = 0\n        var remainder76 = 0\n        var remainder77 = 0\n        var remainder78\
    \ = 0\n        var remainder79 = 0\n        var remainder80 = 0\n        var remainder81\
    \ = 0\n        var remainder82 = 0\n        var remainder83 = 0\n        var remainder84\
    \ = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ath0xr2.scala:105:5\
    \ --------------------\e[0m\e[0m\n\e[31m105 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ String\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.map(_.sum)\n        val result = sums.foldLeft(\"\"\
    )(_ + _)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpus66q94l.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.map(_.sum)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              value sum is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sum = sums.sum\n        val\
    \ binary = digits.map(_.toBinaryString).mkString(\"\")\n        val result = if\
    \ (sum == 0) \"0\" else binary.padTo(sum, \"\")\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_995rhak.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ == '1').reverse\n        binary.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpongonwxc.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpongonwxc.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpongonwxc.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804450
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") {\n            (result, digit) => result + digit\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp524o7mfm.scala:25)\n\tat Problem.main(tmp524o7mfm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.reverse\n        binary.foreach(x => {\n    \
    \        sum += x.toInt\n        })\n        binary.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkvivxwa2.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkvivxwa2.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += x.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length) sum += binary(i).toInt\n        binary.reverse.foldLeft(\"\
    \")(_ + _ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc6n1wet8.scala:20:44 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until binary.length)\
    \ sum += binary(i).toInt\n\e[31m\e[31m   |\e[0m                              \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not a member\
    \ of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpc6n1wet8.scala:21:36\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        binary.reverse.foldLeft(\e\
    [31m\"\"\e[0m)(_ + _ + _)\n\e[31m\e[31m   |\e[0m                             \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Wrong\
    \ number of parameters, expected: 2\n2 errors found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        var lastDigit = 0\n        var lastDigitCount = 0\n\
    \        var lastDigitCount2 = 0\n        var lastDigitCount3 = 0\n        var\
    \ lastDigitCount4 = 0\n        var lastDigitCount5 = 0\n        var lastDigitCount6\
    \ = 0\n        var lastDigitCount7 = 0\n        var lastDigitCount8 = 0\n    \
    \    var lastDigitCount9 = 0\n        var lastDigitCount10 = 0\n        var lastDigitCount11\
    \ = 0\n        var lastDigitCount12 = 0\n        var lastDigitCount13 = 0\n  \
    \      var lastDigitCount14 = 0\n        var lastDigitCount15 = 0\n        var\
    \ lastDigitCount16 = 0\n        var lastDigitCount17 = 0\n        var lastDigitCount18\
    \ = 0\n        var lastDigitCount19 = 0\n        var lastDigitCount20 = 0\n  \
    \      var lastDigitCount21 = 0\n        var lastDigitCount22 = 0\n        var\
    \ lastDigitCount23 = 0\n        var lastDigitCount24 = 0\n        var lastDigitCount25\
    \ = 0\n        var lastDigitCount26 = 0\n        var lastDigitCount27 = 0\n  \
    \      var lastDigitCount28 = 0\n        var lastDigitCount29 = 0\n        var\
    \ lastDigitCount30 = 0\n        var lastDigitCount31 = 0\n        var lastDigitCount32\
    \ = 0\n        var lastDigitCount33 = 0\n        var lastDigitCount34 = 0\n  \
    \      var lastDigitCount35 = 0\n        var lastDigitCount36 = 0\n        var\
    \ lastDigitCount37 = 0\n        var lastDigitCount38 = 0\n        var lastDigitCount39\
    \ = 0\n        var lastDigitCount40 = 0\n        var lastDigitCount41 = 0\n  \
    \      var lastDigitCount42 = 0\n        var lastDigitCount43 = 0\n        var\
    \ lastDigitCount44 = 0\n        var lastDigitCount45 = 0\n        var lastDigitCount46\
    \ = 0\n        var lastDigitCount47 = 0\n        var lastDigitCount48 = 0\n  \
    \      var lastDigitCount49 = 0\n        var lastDigitCount50 = 0\n        var\
    \ lastDigitCount51 = 0\n        var lastDigitCount52 = 0\n        var lastDigitCount53\
    \ = 0\n        var lastDigitCount54 = 0\n        var lastDigitCount55 = 0\n  \
    \      var lastDigitCount56 = 0\n        var lastDigitCount57 = 0\n        var\
    \ lastDigitCount58 = 0\n        var lastDigitCount59 = 0\n        var lastDigitCount60\
    \ = 0\n        var lastDigitCount61 = 0\n        var lastDigitCount62 = 0\n  \
    \      var lastDigitCount63 = 0\n        var lastDigitCount64 = 0\n        var\
    \ lastDigitCount65 = 0\n        var lastDigitCount66 = 0\n        var lastDigitCount67\
    \ = 0\n        var lastDigitCount68 = 0\n        var lastDigitCount69 = 0\n  \
    \      var lastDigitCount70 = 0\n        var lastDigitCount\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf34o2hms.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpf34o2hms.scala:93:5 ---------------------\e[0m\e[0m\n\e[31m93 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val result = new mutable.ListBuffer[String]()\n        val m = s.reverse.indexOf(\"\
    1\")\n        val n = s.reverse.indexOf(\"0\")\n        val x = s.reverse.indexOf(\"\
    10\")\n        val y = s.reverse.indexOf(\"11\")\n        val z = s.reverse.indexOf(\"\
    100\")\n        val a = s.reverse.indexOf(\"1000\")\n        val b = s.reverse.indexOf(\"\
    10000\")\n        val c = s.reverse.indexOf(\"100000\")\n        val d = s.reverse.indexOf(\"\
    1000000\")\n        val e = s.reverse.indexOf(\"10000000\")\n        val f = s.reverse.indexOf(\"\
    100000000\")\n        val g = s.reverse.indexOf(\"1000000000\")\n        val h\
    \ = s.reverse.indexOf(\"10000000000\")\n        val i = s.reverse.indexOf(\"100000000000\"\
    )\n        val j = s.reverse.indexOf(\"1000000000000\")\n        val k = s.reverse.indexOf(\"\
    10000000000000\")\n        val l = s.reverse.indexOf(\"100000000000000\")\n  \
    \      val m = s.reverse.indexOf(\"1000000000000000\")\n        val n = s.reverse.indexOf(\"\
    10000000000000000\")\n        val o = s.reverse.indexOf(\"100000000000000000\"\
    )\n        val p = s.reverse.indexOf(\"1000000000000000000\")\n        val q =\
    \ s.reverse.indexOf(\"10000000000000000000\")\n        val r = s.reverse.indexOf(\"\
    100000000000000000000\")\n        val s = s.reverse.indexOf(\"1000000000000000000000\"\
    )\n        val t = s.reverse.indexOf(\"10000000000000000000000\")\n        val\
    \ u = s.reverse.indexOf(\"100000000000000000000000\")\n        val v = s.reverse.indexOf(\"\
    1000000000000000000000000\")\n        val w = s.reverse.indexOf(\"10000000000000000000000000\"\
    )\n        val x = s.reverse.indexOf(\"10000000000000000000000000000000000\")\n\
    \        val y = s.reverse.indexOf(\"100000000000000000000000000000000000\")\n\
    \        val z = s.reverse.indexOf(\"1000000000000000000000000000000000000\")\n\
    \        val a = s.reverse.indexOf(\"10000000000000000000000000000000000000\"\
    )\n        val b = s.reverse.indexOf(\"100000000000000000000000000000000000000\"\
    )\n        val c = s.reverse.indexOf(\"1000000000000000000000000000000000000000\"\
    )\n        val d = s.reverse.indexOf(\"10000000000000000000000000000000000000000\"\
    )\n        val e = s.reverse.indexOf(\"100000000000000000000000000000000000000000\"\
    )\n        val f = s.reverse.indexOf(\"1000000000000000000000000000000000000000000\"\
    )\n        val g = s.reverse.indexOf(\"10000000000000000000000000000000000000000000\"\
    )\n        val h = s.reverse.indexOf(\"100000000000000000000000000000000000000000000\"\
    )\n        val i = s.reverse.indexOf\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcvbrx2_1.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = s.reverse.indexOf(\e\
    [31m\"100000000000000\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e[0m \e[35ml\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcvbrx2_1.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = s.reverse.indexOf(\e[31m\"1000000000000000\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcvbrx2_1.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = s.reverse.indexOf(\e[31m\"10000000000000000\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcvbrx2_1.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = s.reverse.indexOf(\e[31m\"1000000000000000000000\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ms is already defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcvbrx2_1.scala:49:12 ---------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        \e[33mval\e[0m \e[36mx\e[0m = s.reverse.indexOf(\e[31m\"10000000000000000000000000000000000\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m      "
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = N.toBinaryString\n        val sums =\
    \ nums.split(\"1\").map(_.toInt).sum\n        val result = nums.reverse.takeWhile(_\
    \ != '0').mkString(\"\")\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mkString(\"\
    \") + result\n        val result = nums.reverse.takeWhile(_ != '0').mk\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqdh9pb17.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = nums.reverse.takeWhile(_\
    \ != \e[31m'0'\e[0m).mkString(\e[31m\"\"\e[0m) + result\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqdh9pb17.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = nums.reverse.takeWhile(_\
    \ != \e[31m'0'\e[0m).mkString(\e[31m\"\"\e[0m) + result\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqdh9pb17.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = nums.reverse.takeWhile(_\
    \ != \e[31m'0'\e[0m).mkString(\e[31m\"\"\e[0m) + result\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqdh9pb17.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = nums.reverse.takeWhile(_\
    \ != \e[31m'0'\e[0m).mkString(\e[31m\"\"\e[0m) + result\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definiti"
  stdout: ''
  timestamp: 1659804478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0')\n        val\
    \ binary = binary.reverse\n        val binary = binary.dropWhile(_ == '1')\n \
    \       binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphbqfgy1e.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphbqfgy1e.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphbqfgy1e.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphbqfgy1e.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ ==\
    \ \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1659804474
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt).sum\n        val result = sums.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4ya_3s_t.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(Map[String, Int]())((m, d) => m + (d -> (m.getOrElse(d,\
    \ 0) + d.toInt)))\n        val result = sums.filter(_._2 > 0).map(_._1).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnw861bse.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val result = mutable.StringBuilder()\n        val n = digits.length\n\
    \        digits.foreach(x => result.append(x.reverse))\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr37v9lya.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr37v9lya.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.StringBuilder()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") {\n            (res, digit) => res + digit\n\
    \        }\n        binary.reverse.foldLeft(\"\") {\n            (res, digit)\
    \ => res + digit\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi05jvxrk.scala:27)\n\tat Problem.main(tmpi05jvxrk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary.charAt(i)\n\
    \        }\n        binary.reverse.foldLeft(\"\") {\n            (a,b) => a +\
    \ b\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprk9xt2hq.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.map(_.sum)\n        val sumsString = sums.mkString(\"\
    \")\n        val result = sumsString.reverse.grouped(2).map(_.mkString(\"\")).mkString(\"\
    \")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9h3_kr4p.scala:19:32 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.map(_.sum)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              value sum is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659804478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)(_ + _)\n        binSum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptjoyliaj.scala:24)\n\tat Problem.main(tmptjoyliaj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl5jqphaa.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpl5jqphaa.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl5jqphaa.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl5jqphaa.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl5jqphaa.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote th"
  stdout: ''
  timestamp: 1659804484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = N\n        while (remainder > 0) {\n            sum += remainder\
    \ % 2\n            binary = remainder + binary\n            remainder = remainder\
    \ / 2\n        }\n        binary = binary + sum.toString\n        return binary\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzfdwz9k3.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += remainder % \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            sum += binary(i).toLong\n\
    \        }\n        sum.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwx805bgs.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary(i).toLong\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = N.toBinaryString\n        val sums =\
    \ nums.split(\"1\").map(_.toInt).sum\n        val bins = nums.split(\"1\").map(_.toInt).map(_.toBinaryString).mkString(\"\
    0\")\n        bins.padTo(nums.length, \"0\") + (sums.toBinaryString).padTo(nums.length,\
    \ \"0\")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3bfzuxl4.scala:21:37 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        bins.padTo(nums.length, \e[31m\"0\"\e[0m) + (sums.toBinaryString).padTo(nums.length,\
    \ \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of IndexedSeq[Matchable], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(new mutable.HashMap[Int, Int]()) { (acc, digit)\
    \ =>\n            acc + (digit._1 -> (acc._1 + digit._2))\n        }\n       \
    \ val result = sums.foldLeft(\"\") { (acc, digit) =>\n            acc + (digit._1\
    \ -> digit._2.toString)\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7s0v61t0.scala:19:39 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.foldLeft(\e\
    [33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()) { (\e[36macc\e\
    [0m, \e[36mdigit\e[0m) =>\n\e[31m\e[31m   |\e[0m                             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7s0v61t0.scala:20:16\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            acc + (digit._1\
    \ -> (acc._1 + digit._2))\n\e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue + is not a member of Any, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7s0v61t0.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            acc + (digit._1\
    \ -> (acc._1 + digit._2))\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value _1 is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp7s0v61t0.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = sums.foldLeft(\e\
    [31m\"\"\e[0m) { (\e[36macc\e[0m, \e[36mdigit\e[0m) =>\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \ value foldLeft is not a member of Any\n4 errors found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = N\n        while (remainder > 0) {\n            sum += remainder\
    \ % 2\n            remainder = remainder / 2\n        }\n        binary = binary(sum)\n\
    \        binary = binary(N - sum)\n        binary\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph3mowpac.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += remainder % \e[31m2\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmph3mowpac.scala:25:23 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        binary = binary(sum)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    Char\n\e[31m   |\e[0m         \
    \        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmph3mowpac.scala:26:24 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        binary = binary(N - sum)\n\e[31m\e[31m   |\e[0m              \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Found:    Long\n\
    \e[31m   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length) sum += binary.charAt(i).toInt\n \
    \       binary.reverse.foldLeft(\"\") {\n            case (acc, c) => acc + (if\
    \ (c == '1') 1 else 0)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp89ck9ugt.scala:20:44 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until binary.length)\
    \ sum += binary.charAt(i).toInt\n\e[31m\e[31m   |\e[0m                       \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary.charAt(i).toInt\n\
    \        }\n        binary.reverse.foldLeft(\"\") {\n            (a,b) => a +\
    \ b.toInt\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpua7qkxcb.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i).toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.map(x => if (x.isEmpty) \"\" else x.reverse).mkString(\"\
    \")\n        binary.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5sb7fwyh.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprz_g85hi.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val binary = digits.map(_.toBinaryString).mkString\n\
    \        binary.padTo(binary.length, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz75j5pcw.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val binary = digits.foldLeft(\"\") { (acc, digit) =>\n            acc\
    \ + (if (digit._1 == 0) \"0\" else digit._1.toString(2))\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsjf8nu28.scala:20:29 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            acc + (\e[33mif\e[0m (digit._1 == \e[31m0\e\
    [0m) \e[31m\"0\"\e[0m \e[33melse\e[0m digit._1.toString(\e[31m2\e[0m))\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \            value _1 is not a member of Int\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpsjf8nu28.scala:20:53 ------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            acc + (\e[33mif\e[0m (digit._1 == \e[31m0\e[0m) \e[31m\"0\"\
    \e[0m \e[33melse\e[0m digit._1.toString(\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                                               ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         value _1 is not a member of Int\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804490
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary.charAt(i).toInt\n\
    \        }\n        binary.reverse.foldLeft(\"\") {\n            (a,b) => a +\
    \ b.toInt\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpua7qkxcb.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i).toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.reverse\n        val binary = binary.dropWhile(_\
    \ == '0').reverse\n        val binary = binary.dropWhile(_ == '1').reverse\n \
    \       val binary = binary.reverse\n        val binary = binary.dropWhile(_ ==\
    \ '0').reverse\n        val binary = binary.dropWhile(_ == '1').reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n  \
    \      val binary = binary.dropWhile(_ == '1').reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.dropWhile(_ == '0').reverse\n        val binary =\
    \ binary.dropWhile(_ == '1').reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.dropWhile(_ == '0').reverse\n        val binary = binary.dropWhile(_\
    \ == '1').reverse\n        val binary = binary.reverse\n        val binary = binary.dropWhile(_\
    \ == '0').reverse\n        val binary = binary.dropWhile(_ == '1').reverse\n \
    \       val binary = binary.reverse\n        val binary = binary.dropWhile(_ ==\
    \ '0').reverse\n        val binary = binary.dropWhile(_ == '1').reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n  \
    \      val binary = binary.dropWhile(_ == '1').reverse\n        val binary = binary.reverse\n\
    \        val binary = binary.dropWhile(_ == '0').reverse\n        val binary =\
    \ binary.dropWhile(_ == '1').reverse\n        val binary = binary.reverse\n  \
    \      val binary = binary.dropWhile(_ == '0').reverse\n        val binary = binary.dropWhile(_\
    \ == '1').reverse\n        val binary = binary.reverse\n        val binary = binary.dropWhile(_\
    \ == '0').reverse\n        val binary = binary.dropWhile(_ == '1').reverse\n \
    \       val binary = binary.reverse\n        val binary = binary.dropWhile(_ ==\
    \ '0').reverse\n        val binary = binary.dropWhile(_ == '1').reverse\n    \
    \    val binary = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6l5zhq7x.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6l5zhq7x.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6l5zhq7x.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6l5zhq7x.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6l5zhq7x.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbina"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ == '1').reverse\n        binary.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpongonwxc.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpongonwxc.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpongonwxc.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val result = mutable.StringBuilder()\n        val digitCount = digits.count(_\
    \ != \"\")\n        val digitSum = digits.sum\n        val digitSumInBinary =\
    \ digitSum.toBinaryString\n        val digitSumInBinaryLength = digitSumInBinary.length\n\
    \        val digitSumInBinaryDigitCount = digitSumInBinaryLength / 2\n       \
    \ val digitSumInBinaryDigits = digitSumInBinary.substring(digitSumInBinaryDigitCount\
    \ * 2, digitSumInBinaryDigitCount * 2 + digitSumInBinaryDigitCount)\n        val\
    \ digitSumInBinaryDigitCount = digitSumInBinaryDigits.length\n        val digitSumInBinaryDigits\
    \ = digitSumInBinary.substring(digitSumInBinaryDigitCount * 2, digitSumInBinaryDigitCount\
    \ * 2 + digitSumInBinaryDigitCount)\n        val digitSumInBinaryDigitCount =\
    \ digitSumInBinaryDigits.length\n        val digitSumInBinaryDigits = digitSumInBinary.substring(digitSumInBinaryDigitCount\
    \ * 2, digitSumInBinaryDigitCount * 2 + digitSumInBinaryDigitCount)\n        val\
    \ digitSumInBinaryDigitCount = digitSumInBinaryDigits.length\n        val digitSumInBinaryDigits\
    \ = digitSumInBinary.substring(digitSumInBinaryDigitCount * 2, digitSumInBinaryDigitCount\
    \ * 2 + digitSumInBinaryDigitCount)\n        val digitSumInBinaryDigitCount =\
    \ digitSumInBinaryDigits.length\n        val digitSumInBinaryDigits = digitSumInBinary.substring(digitSumInBinaryDigitCount\
    \ * 2, digitSumInBinaryDigitCount * 2 + digitSumInBinaryDigitCount)\n        val\
    \ digitSumInBinaryDigitCount = digitSumInBinaryDigits.length\n        val digitSumInBinaryDigits\
    \ = digitSumInBinary.substring(digitSumInBinaryDigitCount * 2, digitSumInBinaryDigitCount\
    \ * 2 + digitSumInBinaryDigitCount)\n        val digitSumInBinaryDigitCount =\
    \ digitSumInBinaryDigits.length\n        val digitSumInBinaryDigits = digitSumInBinary.substring(digitSumInBinaryDigitCount\
    \ * 2, digitSumInBinaryDigitCount * 2 + digitSumInBinaryDigitCount)\n        val\
    \ digitSumInBinaryDigitCount = digitSumInBinaryDigits.length\n        val digitSumInBinaryDigits\
    \ = digitSumInBinary.substring(digitSumInBinaryDigitCount * 2, digitSumInBinaryDigitCount\
    \ * 2 + digitSumInBinaryDigitCount)\n        val digitSumInBinaryDigitCount =\
    \ digitSumInBinaryDigit\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbb9c_3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdigitSumInBinaryDigitCount\e\
    [0m = digitSumInBinaryDigits.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdigitSumInBinaryDigitCount is already defined as \e[33mvalue\e\
    [0m \e[35mdigitSumInBinaryDigitCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbb9c_3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mdigitSumInBinaryDigits\e\
    [0m = digitSumInBinary.substring(digitSumInBinaryDigitCount * \e[31m2\e[0m, digitSumInBinaryDigitCount\
    \ * \e[31m2\e[0m + digitSumInBinaryDigitCount)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdigitSumInBinaryDigits is already defined as \e[33mvalue\e\
    [0m \e[35mdigitSumInBinaryDigits\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbb9c_3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mdigitSumInBinaryDigitCount\e\
    [0m = digitSumInBinaryDigits.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdigitSumInBinaryDigitCount is already defined as \e[33mvalue\e\
    [0m \e[35mdigitSumInBinaryDigitCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hbb9c_3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mdigitSumInBinaryDigits\e\
    [0m = digitSumInBinary.substring(digitSumInBinaryDigitCount * \e[31m2\e[0m, digitSumInBinaryDigitCount\
    \ * \e[31m2\e[0m + digitSumInBina"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        digits.foreach(x => sum += x)\n        val result\
    \ = sum.toString.reverse.grouped(2).map(_.toInt).mkString\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgd4ty_45.scala:20:32 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        digits.foreach(\e[36mx\e[0m => sum += x)\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                value += is not a member of Int - did you mean sum.!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.split(\"0\")\n        val sum = 0\n        bins.foreach(x => sum +=\
    \ x.toInt)\n        bins.toList.map(x => x.toString + x.toString.reverse).mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmponqq2z1v.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        bins.foreach(\e[36mx\e[0m => sum += x.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                value += is not a member of Int - did you mean sum.!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        bin.foreach(x => sum += x)\n   \
    \     binary.toString.reverse.foldLeft(binary.toString.reverse.tail.foldLeft(binary.toString.reverse.tail.head)(_\
    \ + _))((x, y) => x + y)\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppe1boay0.scala:21:29 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        bin.foreach(\e[36mx\e[0m => sum += x)\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \       value += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmppe1boay0.scala:22:114 -------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        binary.toString.reverse.foldLeft(binary.toString.reverse.tail.foldLeft(binary.toString.reverse.tail.head)(_\
    \ + _))((\e[36mx\e[0m, \e[36my\e[0m) => x + y)\n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                              ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                                       Found:    Int\n\e[31m   |\e[0m       \
    \                                                   Required: Char\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppe1boay0.scala:22:132 -------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        binary.toString.reverse.foldLeft(binary.toString.reverse.tail.foldLeft(binary.toString.reverse.tail.head)(_\
    \ + _))((\e[36mx\e[0m, \e[36my\e[0m) => x + y)\n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                                                ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                                         Found:    Int\n\e[31m\
    \   |\e[0m                                                          Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val result = new mutable.ListBuffer[String]\n        var i = 0\n    \
    \    while (i < l) {\n            val c = s(i)\n            if (c == '1') {\n\
    \                result.add(\"1\")\n            } else {\n                result.add(\"\
    0\")\n            }\n            i += 1\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdp3v6_5r.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val r = s.reverse\n        val m = r.length\n        val d = r.drop(m)\n\
    \        val a = d.toInt\n        val b = d.take(m)\n        val c = b.toBinaryString\n\
    \        val d = c.reverse\n        val e = d.toInt\n        val f = d.take(m)\n\
    \        val g = f.toBinaryString\n        val h = g.reverse\n        val i =\
    \ h.toInt\n        val j = h.take(m)\n        val k = i.toBinaryString\n     \
    \   val l = j.reverse\n        val m = l.toInt\n        val n = l.take(m)\n  \
    \      val o = n.toBinaryString\n        val p = o.reverse\n        val q = p.toInt\n\
    \        val r = p.take(m)\n        val s = r.toBinaryString\n        val t =\
    \ s.reverse\n        val u = t.toInt\n        val v = t.take(m)\n        val w\
    \ = u.toBinaryString\n        val x = w.reverse\n        val y = x.toInt\n   \
    \     val z = x.take(m)\n        val a = z.toBinaryString\n        val b = y.reverse\n\
    \        val c = b.toInt\n        val d = b.take(m)\n        val e = c.toBinaryString\n\
    \        val f = d.reverse\n        val g = f.toInt\n        val h = f.take(m)\n\
    \        val i = g.toBinaryString\n        val j = h.reverse\n        val k =\
    \ j.toInt\n        val l = j.take(m)\n        val m = l.toBinaryString\n     \
    \   val n = m.reverse\n        val o = n.toInt\n        val p = n.take(m)\n  \
    \      val q = p.toBinaryString\n        val r = q.reverse\n        val s = r.toInt\n\
    \        val t = r.take(m)\n        val u = t.toBinaryString\n        val v =\
    \ u.take(m)\n        val w = v.toInt\n        val x = w.reverse\n        val y\
    \ = x.toInt\n        val z = x.take(m)\n        val a = z.toBinaryString\n   \
    \     val b = y.reverse\n        val c = b.toInt\n        val d = b.take(m)\n\
    \        val e = c.toBinaryString\n        val f = d.reverse\n        val g =\
    \ f.toInt\n        val h = f.take(m)\n        val i = g.toBinaryString\n     \
    \   val j = h.reverse\n        val k = j.toInt\n        val l = j.take(m)\n  \
    \      val m = l.toBinaryString\n        val n = m.reverse\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp12btuka_.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = c.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp12btuka_.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = j.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvalue\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp12btuka_.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp12btuka_.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = p.take(m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp12btuka_.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = r.toBinaryString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is\
    \ already defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp12btuka_.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m "
  stdout: ''
  timestamp: 1659804492
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val sum = 0\n        val binSum = bin.map(x => sum +\
    \ x.toInt)\n        val binSumString = binSum.mkString(\"\")\n        binSumString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1t65aknc.scala:26)\n\tat Problem.main(tmp1t65aknc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804492
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyb0js5tn.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyb0js5tn.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1659804454
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") {\n            (acc, x) => acc + (if (x == '1')\
    \ \"1\" else \"0\") + x\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxejpze17.scala:25)\n\tat Problem.main(tmpxejpze17.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ while(N /= 10) {\n            sum += N % 10\n            N /= 10\n        }\n\
    \        while(sum > 0) {\n            binary += (sum % 2 == 0 ? \"1\" : \"0\"\
    )\n            sum /= 2\n        }\n        binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgyg8a9h6.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpgyg8a9h6.scala:21:16 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            sum += N % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgyg8a9h6.scala:22:14\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            N /= \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ /= is not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpgyg8a9h6.scala:25:19 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            binary += (sum % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m\"1\"\
    \e[0m : \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgyg8a9h6.scala:25:36 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            binary += (sum % \e[31m2\e[0m == \e[31m0\e\
    [0m ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                      ^^^\e[0m\n\e[31m   |\e[0m                             \
    \     value ? is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1659804493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprz_g85hi.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val sum = 0\n        var i = 0\n        while (i <\
    \ binary.length) {\n            val c = binary(i)\n            val d = c.toInt\n\
    \            sum += d\n            i += 1\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpivu5nnws.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpivu5nnws.scala:25:16\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            sum += d\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val result = digits.map(x\
    \ => if (x == 1) \"1\" else x.toString.reverse.take(x.length).reverse.toInt).mkString(\"\
    \")\n        val result = if (sum == 0) \"0\" else result\n        result + sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnmeixlgb.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (sum == \e[31m0\e[0m) \e[31m\"0\"\e[0m \e[33melse\e[0m result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnmeixlgb.scala:20:84\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = digits.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m1\e[0m)\
    \ \e[31m\"1\"\e[0m \e[33melse\e[0m x.toString.reverse.take(x.length).reverse.toInt).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                        \
    \                                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 value length is not a member of Int\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val result = mutable.ListBuffer[String]()\n        val sum = 0\n    \
    \    for (i <- 0 until digits.length) {\n            val digit = digits(i)\n \
    \           val bin = digit.charAt(0).toString + digit.charAt(1).toString\n  \
    \          sum += bin.charAt(0).toInt * Math.pow(2,bin.length-1)\n        }\n\
    \        result += sum.toString\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpftln8tk9.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpftln8tk9.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpftln8tk9.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum += bin.charAt(\e[31m0\e[0m).toInt * Math.pow(\e\
    [31m2\e[0m,bin.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ sum.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659804497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(mutable.HashMap[Int, Int]())((sums, digit)\
    \ => {\n            val sum = sums.get(digit.getOrElse(0)).getOrElse(0) + digit.getOrElse(1)\n\
    \            sums.put(digit.getOrElse(0), sum)\n            sums\n        })\n\
    \        val result = sums.foldLeft(\"\")(_ + _)\n        result + sums.values.sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsa68e5_9.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(0)((sum, digit) => sum + digit)\n        val\
    \ result = sums.toBinaryString\n        val length = result.length\n        val\
    \ result = result.substring(0, length / 2)\n        val result = result + result.substring(length\
    \ - length / 2)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb9w7k3id.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.substring(\e\
    [31m0\e[0m, length / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb9w7k3id.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result + result.substring(length\
    \ - length / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1659804495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\")(_ + _)\n        binary.reverse\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp23ih3jr1.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            sum += binary(i).toInt\n\
    \        }\n        binary.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0x2dizyz.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary(i).toInt\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ while(N !=0){\n            sum = sum + N % 2\n            N = N / 2\n      \
    \  }\n        while(sum > 0){\n            binary = binary + sum % 2\n       \
    \     sum = sum / 2\n        }\n        return binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnlgb5epf.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            sum = sum + N % \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Found:    Long\n\e[31m   |\e[0m                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpnlgb5epf.scala:22:14\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            N = N /\
    \ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804500
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(Map[Int, Int]())((m, d) => m + (d -> (m.getOrElse(d,\
    \ 0) + d.toInt)))\n        val binary = sums.map{case (d, n) => d.toString + n.toString.reverse}.mkString\n\
    \        binary.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph9zy84hv.scala:24)\n\tat Problem.main(tmph9zy84hv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804502
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") { (result, digit) =>\n            val index\
    \ = result.length - 1\n            if (digit == \"1\") {\n                result\
    \ + result.toCharArray\n            } else {\n                val newResult =\
    \ result.substring(0, index) + result.toCharArray\n                val newDigit\
    \ = digit.toCharArray\n                newResult + newDigit\n            }\n \
    \       }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbmeuckvw.scala:21:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (digit == \e[31m\"1\"\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Values of types Char and String cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbmeuckvw.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mnewDigit\e[0m =\
    \ digit.toCharArray\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toCharArray is not a\
    \ member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sumsString = sums.mkString(\"\
    \")\n        val result = sumsString.takeWhile(_ != \"0\").mkString(\"\")\n  \
    \      result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3pv5v2wh.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)(_ + _)\n        val binSumStr\
    \ = binSum.toBinaryString\n        val binSumStrLen = binSumStr.length\n     \
    \   val binSumStrLenMinusOne = binSumStrLen - 1\n        val binSumStrLenMinusOneBin\
    \ = binSumStrLen - 2\n        val binSumStrLenMinusOneBinBin = binSumStrLen -\
    \ 3\n        val binSumStrLenMinusOneBinBinBin = binSumStrLen - 4\n        val\
    \ binSumStrLenMinusOneBinBinBinBin = binSumStrLen - 5\n        val binSumStrLenMinusOneBinBinBinBinBin\
    \ = binSumStrLen - 6\n        val binSumStrLenMinusOneBinBinBinBinBinBin = binSumStrLen\
    \ - 7\n        val binSumStrLenMinusOneBinBinBinBinBinBinBin = binSumStrLen -\
    \ 8\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBin = binSumStrLen -\
    \ 9\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBin = binSumStrLen\
    \ - 10\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBin = binSumStrLen\
    \ - 11\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBin = binSumStrLen\
    \ - 12\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBin = binSumStrLen\
    \ - 13\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBin =\
    \ binSumStrLen - 14\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBin\
    \ = binSumStrLen - 15\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBinBin\
    \ = binSumStrLen - 16\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBinBin\
    \ = binSumStrLen - 17\n        val binSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBinBinBin\
    \ = binSumStrLen - 18\n        val binSumStrLenMinus\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphg2tjr_1.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphg2tjr_1.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBin\e[0m = binSumStrLen\
    \ - \e[31m13\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBin is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphg2tjr_1.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBin\e\
    [0m = binSumStrLen - \e[31m15\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBin is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphg2tjr_1.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBinBin\e\
    [0m = binSumStrLen - \e[31m17\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBinBin\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinSumStrLenMinusOneBinBinBinBinBinBinBinBinBinBinBinBinBin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the sa"
  stdout: ''
  timestamp: 1659804499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        var remainder2 = N\n        while(remainder2 > 0)\
    \ {\n            sum += (remainder2 % 2)\n            remainder2 = (remainder2\
    \ / 2)\n        }\n        while(sum > 0) {\n            binary += (sum % 2)\n\
    \            sum = (sum / 2)\n        }\n        binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp510_9t7t.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += (remainder2 % \e[31m2\e[0m)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (i <- 0 until digits.length) sum += digits(i).toLong\n\
    \        sum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn6cmyqsd.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn6cmyqsd.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until digits.length)\
    \ sum += digits(i).toLong\n\e[31m\e[31m   |\e[0m                             \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not a member\
    \ of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (i <- 0 until digits.length) {\n           \
    \ sum += digits(i).toLong\n        }\n        sum.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps8s4f_va.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps8s4f_va.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += digits(i).toLong\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        digits.foreach(x => {\n            val y = x.toInt\n            val z\
    \ = math.pow(10, y.toInt)\n            val bin = math.pow(10, y.toInt)\n     \
    \       val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n   \
    \         val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n \
    \           val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \            val binary = binary.filter(_ != x).filter(_ != y).filter(_ != z)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3x2d8r_n.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp3x2d8r_n.scala:58:0 ----------------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3x2d8r_n.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3x2d8r_n.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val sum = 0\n        val result = new StringBuilder\n\
    \        for(i <- 0 until binary.length){\n            val digit = binary.charAt(i)\n\
    \            sum += digit.toInt\n            if(sum > 9){\n                result.append((sum\
    \ % 10).toString)\n                sum = 0\n            }\n        }\n       \
    \ if(sum > 0){\n            result.append((sum % 10).toString)\n        }\n  \
    \      return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnolkdoux.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnolkdoux.scala:24:16\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            sum += digit.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n\e[31m\e[31m-- [E052] Type\
    \ Error: /tmp/tmpnolkdoux.scala:27:20 -----------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m                sum = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val sum\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val s = N.toBinaryString\n        val l = s.length\n\
    \        val m = l / 2\n        val r = s.substring(m, l)\n        val x = s.substring(0,\
    \ m)\n        val y = x.reverse\n        val z = y.reverse\n        val w = z.reverse\n\
    \        val a = w.reverse\n        val b = a.reverse\n        val c = b.reverse\n\
    \        val d = c.reverse\n        val e = d.reverse\n        val f = e.reverse\n\
    \        val g = f.reverse\n        val h = g.reverse\n        val i = h.reverse\n\
    \        val j = i.reverse\n        val k = j.reverse\n        val l = k.reverse\n\
    \        val m = l.reverse\n        val n = m.reverse\n        val o = n.reverse\n\
    \        val p = o.reverse\n        val q = p.reverse\n        val r = q.reverse\n\
    \        val s = r.reverse\n        val t = s.reverse\n        val u = t.reverse\n\
    \        val v = u.reverse\n        val w = v.reverse\n        val x = w.reverse\n\
    \        val y = x.reverse\n        val z = y.reverse\n        val a = z.reverse\n\
    \        val b = a.reverse\n        val c = b.reverse\n        val d = c.reverse\n\
    \        val e = d.reverse\n        val f = e.reverse\n        val g = f.reverse\n\
    \        val h = g.reverse\n        val i = h.reverse\n        val j = i.reverse\n\
    \        val k = j.reverse\n        val l = k.reverse\n        val m = l.reverse\n\
    \        val n = m.reverse\n        val o = n.reverse\n        val p = o.reverse\n\
    \        val q = p.reverse\n        val r = q.reverse\n        val s = r.reverse\n\
    \        val t = s.reverse\n        val u = t.reverse\n        val v = u.reverse\n\
    \        val w = v.reverse\n        val x = w.reverse\n        val y = x.reverse\n\
    \        val z = y.reverse\n        val a = z.reverse\n        val b = a.reverse\n\
    \        val c = b.reverse\n        val d = c.reverse\n        val e = d.reverse\n\
    \        val f = e.reverse\n        val g = f.reverse\n        val h = g.reverse\n\
    \        val i = h.reverse\n        val j = i.reverse\n        val k = j.reverse\n\
    \        val l = k.reverse\n        val m = l.reverse\n        val n = m.reverse\n\
    \        val o = n.reverse\n        val p = o.reverse\n        val q = p.reverse\n\
    \        val r = q.reverse\n        val s = r.reverse\n        val t = s.reverse\n\
    \        val u = t.reverse\n        val v = u.reverse\n        val w = v.reverse\n\
    \        val x = w.reverse\n        val y = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7nbbe_46.scala:102:15 --------------------------\e\
    [0m\e[0m\n\e[31m102 |\e[0m        \e[33mval\e[0m \e[36my\e[0m = \n\e[31m\e[31m\
    \    |\e[0m               ^\e[0m\n\e[31m    |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7nbbe_46.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = k.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined as \e[33mvalue\e\
    [0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp7nbbe_46.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = l.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nbbe_46.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = q.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nbbe_46.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = r.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7nbbe_46.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = v.reverse\n\e["
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") {\n            (acc, digit) => acc\
    \ + digit.charAt(0) + \"0\"\n        }\n        binary.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfh_43aye.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.takeWhile(x => x != '1')\n       \
    \ val binary = binary.reverse\n        val binary = binary.dropWhile(x => x !=\
    \ '0')\n        val binary = binary.takeWhile(x => x != '1')\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(x => x != '0')\n   \
    \     val binary = binary.takeWhile(x => x != '1')\n        val binary = binary.reverse\n\
    \        val binary = binary.dropWhile(x => x != '0')\n        val binary = binary.takeWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.takeWhile(x => x != '1')\n       \
    \ val binary = binary.reverse\n        val binary = binary.dropWhile(x => x !=\
    \ '0')\n        val binary = binary.takeWhile(x => x != '1')\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(x => x != '0')\n   \
    \     val binary = binary.takeWhile(x => x != '1')\n        val binary = binary.reverse\n\
    \        val binary = binary.dropWhile(x => x != '0')\n        val binary = binary.takeWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.takeWhile(x => x != '1')\n       \
    \ val binary = binary.reverse\n        val binary = binary.dropWhile(x => x !=\
    \ '0')\n        val binary = binary.takeWhile(x => x != '1')\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(x => x != '0')\n   \
    \     val binary = binary.takeWhile(x => x != '1')\n        val binary = binary.reverse\n\
    \        val binary = binary.dropWhile(x => x != '0')\n        val binary = binary.takeWhile(x\
    \ => x != '1')\n        val binary = binary.reverse\n        val binary = binary.dropWhile(x\
    \ => x != '0')\n        val binary = binary.takeWhile(x => x != '1')\n       \
    \ val binary = \n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpc_sholet.scala:59:20 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc_sholet.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc_sholet.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(\e[36mx\e[0m => x != \e[31m'0'\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc_sholet.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(\e[36mx\e\
    [0m => x != \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc_sholet.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overl"
  stdout: ''
  timestamp: 1659804502
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0')\n        val\
    \ binary = binary.takeWhile(_ == '1').reverse\n        binary.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpflcd4kwj.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpflcd4kwj.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpflcd4kwj.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt).sum\n        val result = sums.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4ya_3s_t.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyb0js5tn.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyb0js5tn.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val sum = 0\n        bins.foreach(x => sum += x.toInt)\n\
    \        bins.toList.map(x => x.toBinaryString).mkString(\"\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd1fl_6q5.scala:21:30 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        bins.foreach(\e[36mx\e[0m => sum += x.toInt)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                value += is not a member of Int - did you mean sum.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpd1fl_6q5.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        bins.toList.map(\e[36mx\e[0m => x.toBinaryString).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      value toBinaryString is not a member of Char.\n\e[31m\
    \   |\e[0m      An extension method was tried, but could not be fully constructed:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m          longWrapper(x)\n2 errors found\n"
  stdout: ''
  timestamp: 1659804504
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.toInt)\n\
    \        val binSumStr = binSum.toBinaryString\n        binSumStr.substring(0,\
    \ binSumStr.length - binSumStr.length % 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp51gkts5f.scala:25)\n\tat Problem.main(tmp51gkts5f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        for (i <- 0 until digits.length) sum += digits(i).toLong\n\
    \        sum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn6cmyqsd.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn6cmyqsd.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until digits.length)\
    \ sum += digits(i).toLong\n\e[31m\e[31m   |\e[0m                             \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is not a member\
    \ of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprz_g85hi.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 to binary.length-1){\n            sum += binary.charAt(i).toInt\n\
    \        }\n        binary.reverse\n        binary.dropRight(sum).reverse\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3cd4js6b.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i).toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)(_ + _)\n        val result = digits.map(x\
    \ => if (x == 1) \"1\" else x.toString.reverse).mkString\n        val result =\
    \ if (sum > 9) result + result.substring(0, result.length - 1) else result\n \
    \       val result = if (sum < 10) result + \"0\" + result else result\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8suye8lc.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (sum > \e[31m9\e[0m) result + result.substring(\e[31m0\e[0m, result.length\
    \ - \e[31m1\e[0m) \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8suye8lc.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e[0m (sum < \e\
    [31m10\e[0m) result + \e[31m\"0\"\e[0m + result \e[33melse\e[0m result\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp8suye8lc.scala:18:67 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0')\n        val\
    \ binary = binary.takeWhile(_ == '1')\n        binary.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0opg7lkh.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0opg7lkh.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0opg7lkh.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.takeWhile(_ == \e[31m'1'\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") {\n            case (acc, x) => acc + (if (x\
    \ == '1') \"1\" else \"0\") + x\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpib1leskg.scala:25)\n\tat Problem.main(tmpib1leskg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ while(N /= 10) {\n            sum += N % 10\n            N = (N / 10).toLong\n\
    \        }\n        while(sum > 0) {\n            binary += sum % 2\n        \
    \    sum = (sum / 2).toLong\n        }\n        binary\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkchp7x5i.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkchp7x5i.scala:21:16 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            sum += N % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkchp7x5i.scala:22:14 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            N = (N / \e[31m10\e[0m).toLong\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Reassignment to val N\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkchp7x5i.scala:26:28\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            sum = (sum / \e[31m2\e\
    [0m).toLong\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                  Found:    Long\n\e[31m   |\e[0m               \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyb0js5tn.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyb0js5tn.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        val bin2 = bin.map(x => if (x ==\
    \ '1') 1 else 0)\n        val bin3 = bin2.map(x => if (x == '1') 1 else 0)\n \
    \       val bin4 = bin3.map(x => if (x == '1') 1 else 0)\n        val bin5 = bin4.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin6 = bin5.map(x => if (x == '1') 1\
    \ else 0)\n        val bin7 = bin6.map(x => if (x == '1') 1 else 0)\n        val\
    \ bin8 = bin7.map(x => if (x == '1') 1 else 0)\n        val bin9 = bin8.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin10 = bin9.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin11 = bin10.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin12 = bin11.map(x => if (x == '1') 1 else 0)\n        val bin13 = bin12.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin14 = bin13.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin15 = bin14.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin16 = bin15.map(x => if (x == '1') 1 else 0)\n        val bin17 = bin16.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin18 = bin17.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin19 = bin18.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin20 = bin19.map(x => if (x == '1') 1 else 0)\n        val bin21 = bin20.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin22 = bin21.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin23 = bin22.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin24 = bin23.map(x => if (x == '1') 1 else 0)\n        val bin25 = bin24.map(x\
    \ => if (x == '1') 1 else 0)\n        val bin26 = bin25.map(x => if (x == '1')\
    \ 1 else 0)\n        val bin27 = bin26.map(x => if (x == '1') 1 else 0)\n    \
    \    val bin28 = bin27.map(x => if (x == '1') 1 else 0)\n        val bin29 = bin28.map(x\
    \ => if (x == '1\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5f0x9nuj.scala:48:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mbin29\e[0m = bin28.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == '1\n\e[31m\e[31m   |\e[0m                  \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \                 unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmp5f0x9nuj.scala:50:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m50 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5f0x9nuj.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5f0x9nuj.scala:50:4 -------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    Not found: 1def\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- [E129] Potential Issue\
    \ Warning: /tmp/tmp5f0x9nuj.scala:49:4 -----------------\e[0m\e[0m\n\e[33m48 |\e\
    [0m        \e[33mval\e[0m \e[36mbin29\e[0m = bin28.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == '1\n\e[33m49 |\e[0m    }\n\e[33m\e[33m   |\e[0m                    \
    \                          ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprz_g85hi.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprz_g85hi.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ var remainder = 0\n        while(N !=0){\n            remainder = N % 2\n  \
    \          N = N / 2\n            sum = sum + remainder\n            binary =\
    \ binary + remainder\n        }\n        if(sum == 0){\n            binary = binary\
    \ + \"0\"\n        }\n        else{\n            binary = binary + sum.toString\n\
    \        }\n        return binary\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfvi1zyae.scala:22:24\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            remainder = N % \e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                        Found:    Long\n\e[31m   |\e[0m              \
    \          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpfvi1zyae.scala:23:14 -----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            N = N / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val N\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(binary.length - 1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length\
    \ - 1)\n        val binary = binary.reverse\n        val binary = binary.dropRight(binary.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpykr2p73a.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpykr2p73a.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpykr2p73a.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpykr2p73a.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpykr2p73a.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpykr2p73a.scala:23:12 ----------------------"
  stdout: ''
  timestamp: 1659804510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyb0js5tn.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyb0js5tn.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val digits\
    \ = binary.toList\n        val sum = digits.foldLeft(0)(_ + _)\n        val result\
    \ = binary.reverse.foldLeft(\"\")(_ + _ + _)\n        result + sum.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpzyu88w7h.scala:21:49 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = binary.reverse.foldLeft(\e\
    [31m\"\"\e[0m)(_ + _ + _)\n\e[31m\e[31m   |\e[0m                             \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \        Wrong number of parameters, expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1659804507
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl5jqphaa.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpl5jqphaa.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl5jqphaa.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl5jqphaa.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl5jqphaa.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote th"
  stdout: ''
  timestamp: 1659804484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") { (s, d) =>\n            s + \"0\"\
    \ * (d.length + 1) + d\n        }\n        binary.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzupztsvi.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.toInt)\n\
    \        val binSumString = binSum.toBinaryString\n        binSumString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk62iota3.scala:25)\n\tat Problem.main(tmpk62iota3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val sum = 0\n        val binSum = bin.foldLeft(0)((sum,\
    \ digit) => sum + digit.toInt)\n        val binSumStr = binSum.toString\n    \
    \    val binSumStrLen = binSumStr.length\n        val binSumStrLenLen = binSumStrLen\
    \ + 1\n        val binSumStrLenLenLen = binSumStrLenLen + 1\n        val binSumStrLenLenLenLen\
    \ = binSumStrLenLenLen + 1\n        val binSumStrLenLenLenLenLen = binSumStrLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLen = binSumStrLenLenLenLenLen + 1\n\
    \        val binSumStrLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLen + 1\n\
    \        val binSumStrLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLen\
    \ + 1\n        val binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen =\
    \ binSumStrLenLenLenLenLen\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8yj2536t.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mbinSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m = binSumStrLenLenLenLenLenLenLenLenLenLenLenLenLen + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLen is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinSumStrLenLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp8yj2536t.scala:40:5 ---------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sumsString = sums.map(_.toString).mkString(\"\
    \")\n        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sumsStringLength = sumsString.length\n    \
    \    val sumsStringLength = sumsString.length\n        val sumsStringLength =\
    \ sumsString.length\n        val sumsStringLength = sumsString.length\n      \
    \  val sumsStringLength = sumsString.length\n        val sumsStringLength = sumsString.length\n\
    \        val sumsStringLength = sumsString.length\n        val sumsStringLength\
    \ = sumsString.length\n        val sums\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb0ufyfxo.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb0ufyfxo.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36msumsStringLength\e[0m = sumsString.length\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msumsStringLength\
    \ is already defined as \e[33mvalue\e[0m \e[35msumsStringLength\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpb0ufyfxo.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m = sumsString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msumsStringLength is already defined as \e[33mvalue\e[0m \e[35msumsStringLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb0ufyfxo.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m = sumsString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msumsStringLength is already defined as \e[33mvalue\e[0m \e[35msumsStringLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb0ufyfxo.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36msumsStringLength\e[0m = sumsString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msumsStringLength is already defined as \e[33mvalue\e[0m \e[35msumsStringLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1659804513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val result\
    \ = binary.reverse.foldLeft(\"\") { (result, digit) =>\n            val index\
    \ = result + digit\n            if (index.length < binary.length) {\n        \
    \        index\n            } else {\n                val remainder = index %\
    \ 2\n                val newIndex = index / 2\n                val newDigit =\
    \ if (remainder == 0) 1 else 0\n                val newResult = result + newDigit\
    \ + newIndex\n                newResult\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi8asrw1g.scala:24:38 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mremainder\e[0m =\
    \ index % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue % is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpi8asrw1g.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mnewIndex\e[0m =\
    \ index / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue / is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(mutable.Map[Int, Int]())((map, digit) => map\
    \ + (digit -> (digit._1 + digit._2)))\n        val result = sums.foldLeft(\"\"\
    )( (acc, digit) => acc + digit._1 + digit._2)\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n\
    \    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpin_9lg7y.scala:19:35 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.foldLeft(mutable.Map[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]())((\e[36mmap\e[0m, \e[36mdigit\e[0m) => map + (digit\
    \ -> (digit._1 + digit._2)))\n\e[31m\e[31m   |\e[0m                          \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                                   Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpin_9lg7y.scala:19:80\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36msums\e[0m = digits.foldLeft(mutable.Map[\e[35mInt\e[0m, \e[35mInt\e[0m]())((\e\
    [36mmap\e[0m, \e[36mdigit\e[0m) => map + (digit -> (digit._1 + digit._2)))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Any,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpin_9lg7y.scala:19:99 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = digits.foldLeft(mutable.Map[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]())((\e[36mmap\e[0m, \e[36mdigit\e[0m) => map + (digit\
    \ -> (digit._1 + digit._2)))\n\e[31m\e[31m   |\e[0m                          \
    \                                                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         value _1 is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpin_9lg7y.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = sums.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mdigit\e\
    [0m) => acc + digit._1 + digit._2)\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659804514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        digits.foreach { digit =>\n            val bin = digit.toInt\n      \
    \      val binStr = bin.toString\n            val binLen = binStr.length\n   \
    \         val binNum = binLen / 2\n            val binDigit = binStr.substring(0,\
    \ binNum)\n            val binRest = binStr.substring(binNum, binStr.length)\n\
    \            val binSum = binDigit + binRest\n            sum += binSum.toInt\n\
    \            binary.append(binSum)\n        }\n        binary.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu2a5f_lf.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu2a5f_lf.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = 0\n        digits.foreach(sum ++= _)\n        sum.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8piwmjb0.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.toList\n        val binary = binary.filter(_ != '0')\n\
    \        val binary = binary.foldLeft(\"\") {\n            (acc, x) => acc + (x.toInt*2).toBinaryString\n\
    \        }\n        binary.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpytxlvlyw.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpytxlvlyw.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpytxlvlyw.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpytxlvlyw.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.filter(_ != \e\
    [31m'0'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpytxlvlyw.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.foldLeft(\e[31m\"\
    \"\e[0m) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNo"
  stdout: ''
  timestamp: 1659804510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val bin = binary.toList\n        val binLen = bin.length\n      \
    \  val binSum = bin.map(x => if (x != '0') x else 0).sum\n        val binSumLen\
    \ = binSum.length\n        val binSumLenLen = binSumLen * 2\n        val binSumLenLenLen\
    \ = binSumLenLen * 2\n        val binSumLenLenLenLen = binSumLenLenLen * 2\n \
    \       val binSumLenLenLenLenLen = binSumLenLenLenLen * 2\n        val binSumLenLenLenLenLenLen\
    \ = binSumLenLenLenLenLen * 2\n        val binSumLenLenLenLenLenLenLen = binSumLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = binSumLenLenLenLenLenLenLenLenLenLenLenLenLen\
    \ * 2\n        val binSumLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = binSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsh25s24p.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mbinSumLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m = binSumLenLenLenLenLenLenLenLenLenLenLen * \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumLenLenLenLenLenLenLenLenLenLenLenLen is already defined\
    \ as \e[33mvalue\e[0m \e[35mbinSumLenLenLenLenLenLenLenLenLenLenLenLen\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsh25s24p.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinSumLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m = binSumLenLenLenLenLenLenLenLenLenLenLenLen * \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumLenLenLenLenLenLenLenLenLenLenLenLenLen is already defined\
    \ as \e[33mvalue\e[0m \e[35mbinSumLenLenLenLenLenLenLenLenLenLenLenLenLen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsh25s24p.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinSumLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m = binSum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinSumLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpsh25s24p.scala:23:31 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mbinSumLen\e[0m = binSum.length\n\e\
    [31m\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1659804514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sum = digits.foldLeft(0)((sum, digit) => sum + digit.toInt)\n   \
    \     val result = if (sum > 0) \"1\" + sum.toString else \"\"\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe949o2qj.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binNum = binary.toList\n        binNum.foreach(x => {\n     \
    \       val y = x.toInt\n            sum += y\n        })\n        binNum.foreach(x\
    \ => {\n            val y = x.toInt\n            val bin = Integer.toBinaryString(y)\n\
    \            val binNum = bin.mkString\n            binNum = binNum.substring(binNum.length\
    \ - 1)\n            binNum = binNum.substring(0, binNum.length - 1)\n        \
    \    binNum = binNum + bin\n            binNum = binNum.substring(0, binNum.length\
    \ - 1)\n            binNum = binNum + bin\n            binNum = binNum.substring(0,\
    \ binNum.length - 1)\n            binNum = binNum + bin\n            binNum =\
    \ binNum.substring(0, binNum.length - 1)\n            binNum = binNum + bin\n\
    \            binNum = binNum.substring(0, binNum.length - 1)\n            binNum\
    \ = binNum + bin\n            binNum = binNum.substring(0, binNum.length - 1)\n\
    \            binNum = binNum + bin\n            binNum = binNum.substring(0, binNum.length\
    \ - 1)\n            binNum = binNum + bin\n            binNum = binNum.substring(0,\
    \ binNum.length - 1)\n            binNum = binNum + bin\n            binNum =\
    \ binNum.substring(0, binNum.length - 1)\n            binNum = binNum + bin\n\
    \            binNum = binNum.substring(0, binNum.length - 1)\n            binNum\
    \ = binNum + bin\n            binNum = binNum.substring(0, binNum.length - 1)\n\
    \            binNum = binNum + bin\n            binNum = binNum.substring(0, binNum.length\
    \ - 1)\n            binNum = binNum + bin\n            binNum = binNum.substring(0,\
    \ binNum.length - 1)\n            binNum = binNum + bin\n            binNum =\
    \ binNum.substring(0, binNum.length - 1)\n            binNum = binNum + bin\n\
    \            binNum = binNum.substring(0, binNum.length - 1)\n            binNum\
    \ = binNum + bin\n            binNum = binNum.substring(0, binNum.length - 1)\n\
    \            binNum = binNum + bin\n            binNum = binNum.substring(0, binNum.length\
    \ - 1)\n            binNum = binNum + bin\n            binNum = binNum.substring(0,\
    \ binNum.length - 1)\n            binNum = binNum + bin\n            binNum =\
    \ binNum.substring(0, binNum.length - 1)\n            binNum = binNum + bin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4lsw7nhr.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp4lsw7nhr.scala:78:0 ----------------------------\e[0m\e[0m\n\e[31m78\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4lsw7nhr.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += y\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4lsw7nhr.scala:29:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            binNum =\
    \ binNum.substring(binNum.length - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \        Reassignment to val binNum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp4lsw7nhr.scala:30:19 -----------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            binNum = binNum.substring(\e[31m0\e[0m, binNum.length - \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val binNum\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp4lsw7nhr.scala:31:19 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            binNum = binNum + bin\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val binNum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4lsw7nhr.scala:32:19\
    \ -----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            binNum =\
    \ binNum.substring(\e[31m0\e[0m, binNum.length - \e[31m1\e[0m)\n\e[3"
  stdout: ''
  timestamp: 1659804513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- 0 until binary.length){\n            sum += binary.charAt(i).toInt\n\
    \        }\n        binary.reverse\n        binary.reverse.takeWhile(x => x !=\
    \ 0).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp13x0bs7d.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i).toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(0)((sum, digit) => sum + digit.toInt)\n  \
    \      val result = sums.toBinaryString\n        val length = result.length\n\
    \        val zeros = Array(0 until length).map(i => if (i == 0) \"0\" else \"\
    1\")\n        val result = zeros ++ result\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyt_2poo0.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = zeros ++ result\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mresult\
    \ is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyt_2poo0.scala:18:67\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mdigits\e[0m = N.toString.reverse.grouped(\e[31m2\e[0m).map(_.mkString).reverse\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue reverse is not a member of Iterator[String] - did you\
    \ mean Iterator[String].reversed?\n\e[31m\e[31m-- Error: /tmp/tmpyt_2poo0.scala:22:55\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mzeros\e[0m = Array(\e[31m0\e[0m until length).map(\e[36mi\e\
    [0m => \e[33mif\e[0m (i == \e[31m0\e[0m) \e[31m\"0\"\e[0m \e[33melse\e[0m \e[31m\"\
    1\"\e[0m)\n\e[31m\e[31m   |\e[0m                                             \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m          Values of types Range and Int\
    \ cannot be compared with == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1659804515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        val binNum = binary.toList\n        binNum.foreach(x => {\n     \
    \       val y = x.toInt\n            sum += y\n        })\n        binNum.map(x\
    \ => x.toString + sum.toString).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeg2cuqk6.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += y\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sumsString = sums.mkString(\"\
    \")\n        val result = sumsString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        result match {\n            case Nil => \"0\"\n            case _ =>\
    \ result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpanf3egar.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n        val\
    \ binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n   \
    \     val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = binary.dropRight(1)\n        val binary = binary.dropRight(1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm905k6ao.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.dropRight(binary.length-1)\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.dropRight(binary.length-1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa840qj87.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa840qj87.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e"
  stdout: ''
  timestamp: 1659804453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n \
    \       val binary = binary.dropRight(binary.length-1)\n        val binary = binary.reverse\n\
    \        val binary = binary.dropRight(binary.length-1)\n        val binary =\
    \ binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n   \
    \     val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = binary.reverse\n        val binary = binary.dropRight(binary.length-1)\n\
    \        val binary = bin\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(binary.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyb0js5tn.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is\
    \ already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyb0js5tn.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyb0js5tn.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(binary.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is "
  stdout: ''
  timestamp: 1659804454
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sums = digits.foldLeft(Map[Int, Int]())((m, d) => m + (d -> (m.getOrElse(d,\
    \ 0) + d.toInt)))\n        val result = sums.filter(_._2 > 0).map(_._1).mkString(\"\
    \")\n        result + sums.filter(_._2 == 0).map(_._1).mkString(\"\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzcnogpb5.scala:24)\n\tat Problem.main(tmpzcnogpb5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.takeWhile(_ != '0')\n        binary.reverse\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmz0q2j6k.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmz0q2j6k.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmz0q2j6k.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.takeWhile(_ != \e[31m'0'\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val binary = digits.foldLeft(\"\") {\n            (acc, digit) => acc\
    \ + (if (digit.length > 1) digit else \"0\")\n        }\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplb3by3w1.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            val digit = binary.charAt(i)\n\
    \            sum += digit.toInt\n        }\n        binary.reverse\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphaala6hf.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            sum += digit.toInt\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        for(i <- binary.indices) {\n            sum += binary.charAt(i)\n\
    \        }\n        sum.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplbkpnput.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sum += binary.charAt(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bins\
    \ = binary.toList\n        val sum = 0\n        bins.foreach(x => {\n        \
    \    val y = x.toInt\n            sum += y\n        })\n        bins.reverse.mkString(\"\
    \") + sum.toString\n    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7ansk757.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += y\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val sum = 0\n        val binary = new mutable.ListBuffer[String]()\n\
    \        digits.foreach { digit =>\n            val bin = digit.toBinaryString\n\
    \            val binary = binary.filterNot(_ == bin)\n            binary.append(bin)\n\
    \            sum += digit\n        }\n        binary.reverse.mkString(\"\")\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6wxpnis4.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6wxpnis4.scala:25:16\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            sum += digit\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean sum.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val sum =\
    \ 0\n        var i = 0\n        while (i < binary.length) {\n            val c\
    \ = binary.charAt(i)\n            val d = c.toInt\n            sum += d\n    \
    \        i += 1\n        }\n        val result = sum.toBinaryString\n        result\
    \ + (if (result.length < binary.length) \"\" else \"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeafojzgy.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            sum += d\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659804519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.foldLeft(Map[String, Int]())((sums, digit) => {\n \
    \           val digitStr = digit._1 + digit._2\n            val sum = sums.getOrElse(digitStr,\
    \ 0) + 1\n            sums + (digitStr -> sum)\n        })\n        val result\
    \ = sums.toList.sortBy(_._2).reverse.map(x => x._1 + \"(\" + x._2 + \")\").mkString\n\
    \        result match {\n            case x if x.contains(\"(0)\") => x\n    \
    \        case x if x.contains(\"(1)\") => x\n            case x if x.contains(\"\
    (2)\") => x\n            case x if x.contains(\"(3)\") => x\n            case\
    \ x if x.contains(\"(4)\") => x\n            case x if x.contains(\"(5)\") =>\
    \ x\n            case x if x.contains(\"(6)\") => x\n            case x if x.contains(\"\
    (7)\") => x\n            case x if x.contains(\"(8)\") => x\n            case\
    \ x if x.contains(\"(9)\") => x\n            case x => x\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpga5xlqfr.scala:18:67 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = N.toString.reverse.grouped(\e\
    [31m2\e[0m).map(_.mkString).reverse\n\e[31m\e[31m   |\e[0m                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ reverse is not a member of Iterator[String] - did you mean Iterator[String].reversed?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        var sum = 0\n        var binary = \"\"\n       \
    \ while(N /= 10) {\n            sum += N % 10\n            N /= 10\n        }\n\
    \        while(sum > 0) {\n            binary += (sum % 2)\n            sum /=\
    \ 2\n        }\n        binary\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpszbrz017.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mwhile\e[0m(N /= \e[31m10\e[0m) {\n\e[31m\e\
    [31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m              value /= is\
    \ not a member of Long - did you mean N.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpszbrz017.scala:21:16 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            sum += N % \e[31m10\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpszbrz017.scala:22:14\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            N /= \e[31m10\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ /= is not a member of Long - did you mean N.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659804519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val bin =\
    \ binary.toList\n        val binSum = bin.foldLeft(0)((sum, digit) => sum + digit.toInt)\n\
    \        val binSumString = binSum.toString\n        val binSumStringLength =\
    \ binSumString.length\n        val binSumStringLength = binSumStringLength + binSumStringLength\n\
    \        val binSumStringLength = binSumStringLength + binSumStringLength\n  \
    \      val binSumStringLength = binSumStringLength + binSumStringLength\n    \
    \    val binSumStringLength = binSumStringLength + binSumStringLength\n      \
    \  val binSumStringLength = binSumStringLength + binSumStringLength\n        val\
    \ binSumStringLength = binSumStringLength + binSumStringLength\n        val binSumStringLength\
    \ = binSumStringLength + binSumStringLength\n        val binSumStringLength =\
    \ binSumStringLength + binSumStringLength\n        val binSumStringLength = binSumStringLength\
    \ + binSumStringLength\n        val binSumStringLength = binSumStringLength +\
    \ binSumStringLength\n        val binSumStringLength = binSumStringLength + binSumStringLength\n\
    \        val binSumStringLength = binSumStringLength + binSumStringLength\n  \
    \      val binSumStringLength = binSumStringLength + binSumStringLength\n    \
    \    val binSumStringLength = binSumStringLength + binSumStringLength\n      \
    \  val binSumStringLength = binSumStringLength + binSumStringLength\n        val\
    \ binSumStringLength = binSumStringLength + binSumStringLength\n        val binSumStringLength\
    \ = binSumStringLength + binSumStringLength\n        val binSumStringLength =\
    \ binSumStringLength + binSumStringLength\n        val binSumStringLength = binSumStringLength\
    \ + binSumStringLength\n        val binSumStringLength = binSumStringLength +\
    \ binSumStringLength\n        val binSumStringLength = binSumStringLength + binSumStringLength\n\
    \        val binSumStringLength = binSumStringLength + binSumStringLength\n  \
    \      val binSumStringLength = binSumStringLength + binSumStringLength\n    \
    \    val binSumStringLength = binSumStringLength + binSumStringLength\n      \
    \  val binSumStringLength = binSumStringLength + binSumStringLength\n        val\
    \ binSumStringLength = binSumStringLength + binSumStringLength\n        val binSumStringLength\
    \ = binSumStringLength + binSumStringLength\n        val binSumStringLength =\
    \ binSumStringLength + binSumStringLength\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0spj9zi3.scala:51:11 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0spj9zi3.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumStringLength + binSumStringLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0spj9zi3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumStringLength + binSumStringLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0spj9zi3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumStringLength + binSumStringLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mbinSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0spj9zi3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mbinSumStringLength\e[0m\
    \ = binSumStringLength + binSumStringLength\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659804519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropRight(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(solve((1000l)).equals((\"1\")));\n    assert(solve((150l)).equals((\"\
    110\")));\n    assert(solve((147l)).equals((\"1100\")));\n    assert(solve((333l)).equals((\"\
    1001\")));\n    assert(solve((963l)).equals((\"10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv4bwn94b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4bwn94b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv4bwn94b.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary is already\
    \ defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded metho"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val digits = N.toString.reverse.grouped(2).map(_.mkString).reverse\n\
    \        val sums = digits.map(_.toInt)\n        val sumsSum = sums.sum\n    \
    \    val sumsSumString = sumsSum.toString\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSumStringLength\
    \ = sumsSumString.length\n        val sumsSumStringLength = sumsSumString.length\n\
    \        val sumsSumStringLength = sumsSumString.length\n        val sumsSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5q9zrkbm.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5q9zrkbm.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36msumsSumStringLength\e[0m = sumsSumString.length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msumsSumStringLength\
    \ is already defined as \e[33mvalue\e[0m \e[35msumsSumStringLength\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5q9zrkbm.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36msumsSumStringLength\e[0m = sumsSumString.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35msumsSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5q9zrkbm.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msumsSumStringLength\e[0m\
    \ = sumsSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35msumsSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5q9zrkbm.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msumsSumStringLength\e[0m\
    \ = sumsSumString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumsSumStringLength is already defined as \e[33mvalue\e[0m\
    \ \e[35msumsSumStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods mus"
  stdout: ''
  timestamp: 1659804520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val nums = scala.collection.mutable.ListBuffer.empty[String]\n\
    \        val binary = scala.collection.mutable.ListBuffer.empty[String]\n    \
    \    val digits = scala.collection.mutable.ListBuffer.empty[Int]\n        val\
    \ remainder = scala.collection.mutable.ListBuffer.empty[Int]\n        val remainders\
    \ = scala.collection.mutable.ListBuffer.empty[Int]\n        val sum = 0\n    \
    \    val digit = scala.math.pow(10, math.log10(N))\n        val digits = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val remainders = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val remainder = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val nums = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val binary = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val sum = scala.math.pow(10, math.log10(N))\n        val nums = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val binary = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val sum = scala.math.pow(10, math.log10(N))\n        val nums = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val binary = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val sum = scala.math.pow(10, math.log10(N))\n        val nums = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val binary = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val sum = scala.math.pow(10, math.log10(N))\n        val nums = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val binary = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val sum = scala.math.pow(10, math.log10(N))\n        val nums = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val binary = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val sum = scala.math.pow(10, math.log10(N))\n        val nums = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(0)\n\
    \        val binary = scala.collection.mutable.ListBuffer.fill(math.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"1\"\
    )));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo6yr3s4n.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpo6yr3s4n.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mdigits\e[0m = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdigits is already defined as \e[33mvalue\e[0m \e[35mdigits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo6yr3s4n.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mremainders\e[0m = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremainders is already defined as \e[33mvalue\e[0m \e[35mremainders\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo6yr3s4n.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mremainder\e[0m = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremainder is already defined as \e[33mvalue\e[0m \e[35mremainder\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo6yr3s4n.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = scala.collection.mutable.ListBuffer.fill(math.log10(N).toInt)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m      "
  stdout: ''
  timestamp: 1659804520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a positive integer N, return the total sum of its digits in\
    \ binary.\n    // Example\n    // >>> solve((1000l))\n    // (\"1\")\n    // >>>\
    \ solve((150l))\n    // (\"110\")\n    // >>> solve((147l))\n    // (\"1100\"\
    )\n    // Variables:\n    // @N integer\n    // Constraints: 0 \u2264 N \u2264\
    \ 10000.\n    // Output:\n    // a string of binary number\n    def solve(N :\
    \ Long) : String = {\n        val binary = N.toBinaryString\n        val binary\
    \ = binary.reverse\n        val binary = binary.dropWhile(_ == '0').reverse\n\
    \        val binary = binary.dropWhile(_ == '1').reverse\n        binary.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(solve((1000l)).equals((\"\
    1\")));\n    assert(solve((150l)).equals((\"110\")));\n    assert(solve((147l)).equals((\"\
    1100\")));\n    assert(solve((333l)).equals((\"1001\")));\n    assert(solve((963l)).equals((\"\
    10010\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbinary\
    \ is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa9hpkm55.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'0'\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa9hpkm55.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mbinary\e[0m = binary.dropWhile(_ == \e[31m'1'\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbinary is already defined as \e[33mvalue\e[0m \e[35mbinary\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n3 errors found\n"
  stdout: ''
  timestamp: 1659804483
