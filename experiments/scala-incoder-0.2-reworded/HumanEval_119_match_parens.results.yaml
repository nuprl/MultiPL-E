language: scala
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") open.append(x))\n        lst.foreach(x\
    \ => if (x == \")\") close.append(x))\n        val openCount = open.count\n  \
    \      val closeCount = close.count\n        if (openCount == closeCount) {\n\
    \            val openStr = open.toList\n            val closeStr = close.toList\n\
    \            val openStrSize = openStr.size\n            val closeStrSize = closeStr.size\n\
    \            val openStrSet = openStr.distinct\n            val closeStrSet =\
    \ closeStr.distinct\n            val openStrSetSize = openStrSet.size\n      \
    \      val closeStrSetSize = closeStrSet.size\n            if (openStrSetSize\
    \ == closeStrSetSize) {\n                val openStrSetIterator = openStrSet.iterator\n\
    \                val closeStrSetIterator = closeStrSet.iterator\n            \
    \    while (openStrSetIterator.hasNext && closeStrSetIterator.hasNext) {\n   \
    \                 val openStr = openStrSetIterator.next\n                    val\
    \ closeStr = closeStrSetIterator.next\n                    val openCount = openStr.count\n\
    \                    val closeCount = closeStr.count\n                    if (openCount\
    \ == closeCount) {\n                        val openStr = openStr.toList\n   \
    \                     val closeStr = closeStr.toList\n                       \
    \ val openStrSize = openStr.size\n                        val closeStrSize = closeStr.size\n\
    \                        val openStrSet = openStr.distinct\n                 \
    \       val closeStrSet = closeStr.distinct\n                        val openStrSetSize\
    \ = openStrSet.size\n                        val closeStrSetSize = closeStrSet.size\n\
    \                        if (openStrSetSize == closeStrSetSize) {\n          \
    \                  val openStrSetIterator = openStrSet.iterator\n            \
    \                val closeStrSetIterator = closeStrSet.iterator\n            \
    \                while (openStrSetIterator.hasNext && closeStrSetIterator.hasNext)\
    \ {\n                                val openStr = openStrSetIterator.next\n \
    \                               val closeStr = closeStrSetIterator.next\n    \
    \                            val openCount = openStr.count\n                 \
    \               val closeCount = closeStr.count\n                            \
    \    if (openCount == closeCount) {\n                                    val openStr\
    \ = openStr.toList\n                                    val closeStr = closeStr.toList\n\
    \                                    val openStrSize = openStr.size\n        \
    \                            val closeStrSize = closeStr.size\n              \
    \                      val openStrSet = openStr.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyjxrqfza.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpyjxrqfza.scala:83:0 ----------------------------\e[0m\e[0m\n\e[31m83\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyjxrqfza.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpyjxrqfza.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpyjxrqfza.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpyjxrqfza.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpyjxrqfza.scala:44:38 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1659794992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        lst.foreach { x =>\n            x match {\n                case \")\"\
    \ =>\n                    stackSize -= 1\n                case \")()\" =>\n  \
    \                  stackSize -= 1\n                case \")()()\" =>\n       \
    \             stackSize -= 1\n                case \")()()()\" =>\n          \
    \          stackSize -= 1\n                case \")()()()()\" =>\n           \
    \         stackSize -= 1\n                case \")()()()()()\" =>\n          \
    \          stackSize -= 1\n                case \")()()()()()()\" =>\n       \
    \             stackSize -= 1\n                case \")()()()()()()()\" =>\n  \
    \                  stackSize -= 1\n                case \")()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()()()()()()()()()()()()()()\"\
    \ =>\n                    stackSize -= 1\n                case \")()()()\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp9jit76ys.scala:70:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m                \e[33mcase\e[0m \")()()()\n\e[31m\e[31m\
    \   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmp9jit76ys.scala:72:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9jit76ys.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp9jit76ys.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp9jit76ys.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9jit76ys.scala:25:30 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9jit76ys.scala:27:30 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659795002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    open.push(x)\n                }\n   \
    \             case \")(\" => {\n                    stack.push(x)\n          \
    \      }\n                case \")(\" => {\n                    val x = stack.pop()\n\
    \                    val y = stack.pop()\n                    val z = x + y\n\
    \                    stack.push(z)\n                }\n                case \"\
    )\" => {\n                    val x = stack.pop()\n                    val y =\
    \ stack.pop()\n                    val z = x + y\n                    stack.push(z)\n\
    \                }\n                case \")\" => {\n                    val x\
    \ = stack.pop()\n                    val y = stack.pop()\n                   \
    \ val z = x + y\n                    stack.push(z)\n                }\n      \
    \          case \")(\" => {\n                    val x = stack.pop()\n       \
    \             val y = stack.pop()\n                    val z = x + y\n       \
    \             stack.push(z)\n                }\n                case \")(\" =>\
    \ {\n                    val x = stack.pop()\n                    val y = stack.pop()\n\
    \                    val z = x + y\n                    stack.push(z)\n      \
    \          }\n                case \")(\" => {\n                    val x = stack.pop()\n\
    \                    val y = stack.pop()\n                    val z = x + y\n\
    \                    stack.push(z)\n                }\n                case \"\
    )(\" => {\n                    val x = stack.pop()\n                    val y\
    \ = stack.pop()\n                    val z = x + y\n                    stack.push(z)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ x = stack.pop()\n                    val y = stack.pop()\n                 \
    \   val z = x + y\n                    stack.push(z)\n                }\n    \
    \            case \")(\" => {\n                    val x = stack.pop()\n     \
    \               val y = stack.pop()\n                    val z = x + y\n     \
    \               stack.push(z)\n                }\n                case \")(\"\
    \ => {\n                    val x = stack.pop()\n                    val y = stack.pop()\n\
    \                    val z = x + y\n                    stack.push(z)\n      \
    \          }\n                case \")(\" => {\n                    val x = stack.pop()\n\
    \                    val y = stack.pop()\n                    val z = x + y\n\
    \                    stack.push(z)\n                }\n                case \"\
    )(\" => {\n                    val x = stack.pop()\n                    val y\
    \ = stack.pop()\n                    val z = x + y\n                    stack.push(z)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ x = stack.pop()\n                    val y = stack.pop()\n                 \
    \   val z = x + y\n                    stack.push(z)\n                }\n    \
    \            case \")(\" => {\n                    val x = stack.pop()\n\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsaccbhbf.scala:131:0 ---------------------------\e\
    [0m\e[0m\n\e[31m131 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsaccbhbf.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsaccbhbf.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsaccbhbf.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsaccbhbf.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsaccbhbf.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m => {\n\e[31m 25 "
  stdout: ''
  timestamp: 1659794999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case \"\" => result.synchronized {\n  \
    \                              result.append(x)\n                            \
    \    result.synchronized {\n                                    result.append(stack.pop())\n\
    \                                }\n                            }\n          \
    \                  case x => result.synchronized {\n                         \
    \       result.append(x)\n                            }\n                    \
    \    }\n                    }\n                }\n                case \"(\" =>\
    \ {\n                    open.synchronized {\n                        stack.push(x)\n\
    \                    }\n                }\n                case x => result.synchronized\
    \ {\n                    result.append(x)\n                }\n            }\n\
    \        })\n        if (close.size == 0 && open.size == 0) \"No\"\n        else\
    \ if (close.size == 0 && open.size == 1) \"Yes\"\n        else matchParens(result)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgptwx5i8.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgptwx5i8.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgptwx5i8.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgptwx5i8.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x.contains(\"(\")) {\n          \
    \      stack += x\n            } else {\n                queue += x\n        \
    \    }\n        })\n        val goodCount = queue.size\n        val badCount =\
    \ stack.size\n        if (goodCount == badCount) {\n            if (goodCount\
    \ == 0) {\n                return \"No\"\n            } else {\n             \
    \   return \"Yes\"\n            }\n        }\n        val good = queue.take(goodCount)\n\
    \        val bad = stack.take(badCount)\n        val goodCount = good.size\n \
    \       val badCount = bad.size\n        if (goodCount == badCount) {\n      \
    \      if (goodCount == 0) {\n                return \"No\"\n            } else\
    \ {\n                return \"Yes\"\n            }\n        }\n        val good\
    \ = good.toList\n        val bad = bad.toList\n        val goodCount = good.size\n\
    \        val badCount = bad.size\n        if (goodCount == badCount) {\n     \
    \       if (goodCount == 0) {\n                return \"No\"\n            } else\
    \ {\n                return \"Yes\"\n            }\n        }\n        val good\
    \ = good.toList\n        val bad = bad.toList\n        val goodCount = good.size\n\
    \        val badCount = bad.size\n        if (goodCount == badCount) {\n     \
    \       if (goodCount == 0) {\n                return \"No\"\n            } else\
    \ {\n                return \"Yes\"\n            }\n        }\n        val good\
    \ = good.toList\n        val bad = bad.toList\n        val goodCount = good.size\n\
    \        val badCount = bad.size\n        if (goodCount == badCount) {\n     \
    \       if (goodCount == 0) {\n                return \"No\"\n            } else\
    \ {\n                return \"Yes\"\n            }\n        }\n        val good\
    \ = good.toList\n        val bad = bad.toList\n        val goodCount = good.size\n\
    \        val badCount = bad.size\n        if (goodCount == badCount) {\n     \
    \       if (goodCount == 0) {\n                return \"No\"\n            } else\
    \ {\n                return \"Yes\"\n            }\n        }\n        val good\
    \ = good.toList\n        val bad = bad.toList\n        val goodCount = good.size\n\
    \        val badCount = bad.size\n        if (goodCount == badCount) {\n     \
    \       if (goodCount == 0) {\n                return \"No\"\n            } else\
    \ {\n                return \"Yes\"\n            }\n        }\n        val good\
    \ = good.toList\n        val bad = bad\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpodudric3.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = queue.take(goodCount)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mgood is already defined as \e[33mvalue\e[0m \e[35mgood\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpodudric3.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbad\e[0m = stack.take(badCount)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbad is already defined as \e[33mvalue\e[0m \e[35mbad\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpodudric3.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = good.size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodCount is\
    \ already defined as \e[33mvalue\e[0m \e[35mgoodCount\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpodudric3.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadCount\e[0m = bad.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpodudric3.scala:49:12 ---------------------------\e[0m\e[0m\n\e\
    [31m49 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = good.toList\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgood is already\
    \ defined as \e[33mvalue\e[0m \e[35mgood\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of topl"
  stdout: ''
  timestamp: 1659794998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val openCount = if (open < 0) 0 else open + 1\n            val\
    \ closeCount = if (close < 0) 0 else close + 1\n            val openParen = if\
    \ (openCount > closeCount) closeCount else openCount\n            val closeParen\
    \ = if (closeCount > openCount) openCount else closeCount\n            val openParenCount\
    \ = if (openParen == 0) 0 else openParen\n            val closeParenCount = if\
    \ (closeParen == 0) 0 else closeParen\n            val openParenParen = if (openParenParen\
    \ == 0) 0 else openParenParen\n            val closeParenParen = if (closeParenParen\
    \ == 0) 0 else closeParenParen\n            val openParenParenCount = if (openParenParen\
    \ == 0) 0 else openParenParen\n            val closeParenParenCount = if (closeParenParen\
    \ == 0) 0 else closeParenParen\n            val openParenCount = if (openParenCount\
    \ == 0) 0 else openParenCount\n            val closeParenCount = if (closeParenCount\
    \ == 0) 0 else closeParenCount\n            val openParenParenCount = if (openParenParenCount\
    \ == 0) 0 else openParenParenCount\n            val closeParenParenCount = if\
    \ (closeParenParenCount == 0) 0 else closeParenParenCount\n            val openParenCount\
    \ = if (openParenCount == 0) 0 else openParenCount\n            val closeParenCount\
    \ = if (closeParenCount == 0) 0 else closeParenCount\n            val openParenParenCount\
    \ = if (openParenParenCount == 0) 0 else openParenParenCount\n            val\
    \ closeParenParenCount = if (closeParenParenCount == 0) 0 else closeParenParenCount\n\
    \            val openParenCount = if (openParenCount == 0) 0 else openParenCount\n\
    \            val closeParenCount = if (closeParenCount == 0) 0 else closeParenCount\n\
    \            val openParenParenCount = if (openParenParenCount == 0) 0 else openParenParenCount\n\
    \            val closeParenParenCount = if (closeParenParenCount == 0) 0 else\
    \ closeParenParenCount\n            val openParenCount = if (openParenCount ==\
    \ 0) 0 else openParenCount\n            val closeParenCount = if (closeParenCount\
    \ == 0) 0 else closeParenCount\n            val openParenParenCount = if (openParenParenCount\
    \ == 0) 0 else openParenParenCount\n            val closeParenParenCount = if\
    \ (closeParenParenCount == 0) 0 else closeParenParenCount\n            val openParenCount\
    \ = if (openParenCount == 0) 0 else openParenCount\n            val close\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ec5guzl.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ec5guzl.scala:69:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp9ec5guzl.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp9ec5guzl.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp9ec5guzl.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mopenParenCount\e[0m\
    \ = \e[33mif\e[0m (openParenCount == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m\
    \ openParenCount\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenParenCount is already defined as \e[33mvalue\e[0m \e[35mopenParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9ec5guzl.scala:35:16 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m            \e[33mval\e[0m \e[36mcloseParenCount\e[0m = \e[33mif\e\
    [0m (closeParenCount == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m closeParenCount\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659795000
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxSize = stackMax * 2\n        val stackMaxMax = stackMaxSize -\
    \ 1\n        val stackMaxMaxSize = stackMaxMax * 2\n        val stackMaxMaxMax\
    \ = stackMaxMaxSize - 1\n        val stackMaxMaxMaxSize = stackMaxMaxMax * 2\n\
    \        val stackMaxMaxMaxMax = stackMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMax = stackMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMax * 2\n     \
    \   val stackMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvk_orbx.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwvk_orbx.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwvk_orbx.scala:40:54 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\e\
    [0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax * \e[31m2\e[0m\n\e[31m\e[31m \
    \  |\e[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvk_orbx.scala:41:53\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\e[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m          Not found: stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvk_orbx.scala:42:60\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\e[0m = stackMaxMaxMaxMaxMaxMaxM"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.List\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv88qvlbh.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv88qvlbh.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv88qvlbh.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv88qvlbh.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv88qvlbh.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^"
  stdout: ''
  timestamp: 1659794998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    val s = stack.pop()\n                    result +=\
    \ (s + \"(\")\n                }\n                case \")(\"  => {\n        \
    \            val s = stack.pop()\n                    result += (s + \"(\")\n\
    \                    open += (s + \"(\")\n                }\n                case\
    \ \")(\" => {\n                    val s = stack.pop()\n                    result\
    \ += (s + \"(\")\n                    open += (s + \"(\")\n                  \
    \  close += (s + \"(\")\n                }\n                case \")(\" => {\n\
    \                    val s = stack.pop()\n                    result += (s + \"\
    (\")\n                    open += (s + \"(\")\n                    close += (s\
    \ + \"(\")\n                }\n                case \")(\" => {\n            \
    \        val s = stack.pop()\n                    result += (s + \"(\")\n    \
    \                open += (s + \"(\")\n                    close += (s + \"(\"\
    )\n                }\n                case \")(\" => {\n                    val\
    \ s = stack.pop()\n                    result += (s + \"(\")\n               \
    \     open += (s + \"(\")\n                    close += (s + \"(\")\n        \
    \        }\n                case \")(\" => {\n                    val s = stack.pop()\n\
    \                    result += (s + \"(\")\n                    open += (s + \"\
    (\")\n                    close += (s + \"(\")\n                }\n          \
    \      case \")(\" => {\n                    val s = stack.pop()\n           \
    \         result += (s + \"(\")\n                    open += (s + \"(\")\n   \
    \                 close += (s + \"(\")\n                }\n                case\
    \ \")(\" => {\n                    val s = stack.pop()\n                    result\
    \ += (s + \"(\")\n                    open += (s + \"(\")\n                  \
    \  close += (s + \"(\")\n                }\n                case \")(\" => {\n\
    \                    val s = stack.pop()\n                    result += (s + \"\
    (\")\n                    open += (s + \"(\")\n                    close += (s\
    \ + \"(\")\n                }\n                case \")(\" => {\n            \
    \        val s = stack.pop()\n                    result += (s + \"(\")\n    \
    \                open += (s + \"(\")\n                    close += (s + \"(\"\
    )\n                }\n                case \")(\" => {\n                    val\
    \ s = stack.pop()\n                    result += (s + \"(\")\n               \
    \     open += (s + \"(\")\n                    close += (s + \"(\")\n        \
    \        }\n                case \")(\" => {\n                    val s = stack.pop()\n\
    \                    result += (s + \"(\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7o6ayvwj.scala:113:0 ---------------------------\e\
    [0m\e[0m\n\e[31m113 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o6ayvwj.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o6ayvwj.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o6ayvwj.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o6ayvwj.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7o6ayvwj.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m "
  stdout: ''
  timestamp: 1659795000
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(x => stack += x)\n                   \
    \ result ++= stack\n                    stack.toList.reverse.foreach(x => stack\
    \ += x)\n                    stack.toList.reverse.foreach(x => stack.pop())\n\
    \                case \")(\" =>\n                    open += x\n             \
    \   case \")(\" =>\n                    open += x\n                case \")(\"\
    \ =>\n                    open += x\n                case \")(\" =>\n        \
    \            open += x\n                case \")(\" =>\n                    open\
    \ += x\n                case \")(\" =>\n                    open += x\n      \
    \          case \")(\" =>\n                    open += x\n                case\
    \ \")(\" =>\n                    open += x\n                case \")(\" =>\n \
    \                   open += x\n                case \")(\" =>\n              \
    \      open += x\n                case \")(\" =>\n                    open +=\
    \ x\n                case \")(\" =>\n                    open += x\n         \
    \       case \")(\" =>\n                    open += x\n                case \"\
    )(\" =>\n                    open += x\n                case \")(\" =>\n     \
    \               open += x\n                case \")(\" =>\n                  \
    \  open += x\n                case \")(\" =>\n                    open += x\n\
    \                case \")(\" =>\n                    open += x\n             \
    \   case \")(\" =>\n                    open += x\n                case \")(\"\
    \ =>\n                    open += x\n                case \")(\" =>\n        \
    \            open += x\n                case \")(\" =>\n                    open\
    \ += x\n                case \")(\" =>\n                    open += x\n      \
    \          case \")(\" =>\n                    open += x\n                case\
    \ \")(\" =>\n                    open += x\n                case \")(\" =>\n \
    \                   open += x\n                case \")(\" =>\n              \
    \      open += x\n                case \")(\" =>\n                    open +=\
    \ x\n                case \")(\" =>\n                    open += x\n         \
    \       case \")(\" =>\n                    open += x\n                case \"\
    )(\" =>\n                    open += x\n                case \")(\" =>\n     \
    \               open += x\n                case \")(\" =>\n                  \
    \  open += x\n                case \")(\" =>\n                    open += x\n\
    \                case \")(\" =>\n                    open += x\n             \
    \   case \")(\" =>\n                    open += x\n                case \")(\"\
    \ =>\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3ra4bb2v.scala:120:0 ---------------------------\e\
    [0m\e[0m\n\e[31m120 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ra4bb2v.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ra4bb2v.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ra4bb2v.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ra4bb2v.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3ra4bb2v.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m =>\n\e[31m 25 |\e"
  stdout: ''
  timestamp: 1659794999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n     \
    \   val stackIndex = stackMax\n        val resultIndex = resultMax\n        val\
    \ stackIsEmpty = stackMax == 0\n        val resultIsEmpty = resultMax == 0\n \
    \       while(stackIsEmpty || resultIsEmpty) {\n            val stackIsFull =\
    \ stackIndex == stackMax\n            val resultIsFull = resultIndex == resultMax\n\
    \            if(!stackIsFull && !resultIsFull) {\n                val stackSize\
    \ = lst.size\n                val resultSize = lst.size\n                val stackMax\
    \ = stackSize - 1\n                val resultMax = resultSize - 1\n          \
    \      val stackIndex = stackMax\n                val resultIndex = resultMax\n\
    \                val stackIsEmpty = stackMax == 0\n                val resultIsEmpty\
    \ = resultMax == 0\n            }\n            if(!stackIsEmpty && !resultIsEmpty)\
    \ {\n                val stackSize = lst.size\n                val resultSize\
    \ = lst.size\n                val stackMax = stackSize - 1\n                val\
    \ resultMax = resultSize - 1\n                val stackIndex = stackMax\n    \
    \            val resultIndex = resultMax\n                val stackIsEmpty = stackMax\
    \ == 0\n                val resultIsEmpty = resultMax == 0\n            }\n  \
    \          if(!stackIsEmpty && resultIsEmpty) {\n                val stackSize\
    \ = lst.size\n                val resultSize = lst.size\n                val stackMax\
    \ = stackSize - 1\n                val resultMax = resultSize - 1\n          \
    \      val stackIndex = stackMax\n                val resultIndex = resultMax\n\
    \                val stackIsEmpty = stackMax == 0\n                val resultIsEmpty\
    \ = resultMax == 0\n            }\n            if(!stackIsEmpty && !resultIsEmpty)\
    \ {\n                val stackSize = lst.size\n                val resultSize\
    \ = lst.size\n                val stackMax = stackSize - 1\n                val\
    \ resultMax = resultSize - 1\n                val stackIndex = stackMax\n    \
    \            val resultIndex = resultMax\n                val stackIsEmpty = stackMax\
    \ == 0\n                val resultIsEmpty = resultMax == 0\n            }\n  \
    \          if(!stackIsEmpty && resultIsEmpty) {\n                val stackSize\
    \ = lst.size\n                val resultSize = lst.size\n                val stackMax\
    \ = stackSize - 1\n                val resultMax = resultSize - 1\n          \
    \      val stackIndex = stackMax\n                val resultIndex = resultMax\n\
    \                val stack\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpau5rxa1q.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpau5rxa1q.scala:96:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m96 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpau5rxa1q.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpau5rxa1q.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpau5rxa1q.scala:80:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m80 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659794992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphddme9y7.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphddme9y7.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphddme9y7.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphddme9y7.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphddme9y7.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^"
  stdout: ''
  timestamp: 1659794998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodString = mutable.Set[String]()\n        val badString = mutable.Set[String]()\n\
    \        val goodParens = mutable.Set[String]()\n        val badParens = mutable.Set[String]()\n\
    \        val goodParensCount = mutable.Set[Int]()\n        val badParensCount\
    \ = mutable.Set[Int]()\n        val goodParensCount2 = mutable.Set[Int]()\n  \
    \      val badParensCount2 = mutable.Set[Int]()\n        val goodParensCount3\
    \ = mutable.Set[Int]()\n        val badParensCount3 = mutable.Set[Int]()\n   \
    \     val goodParensCount4 = mutable.Set[Int]()\n        val badParensCount4 =\
    \ mutable.Set[Int]()\n        val goodParensCount5 = mutable.Set[Int]()\n    \
    \    val badParensCount5 = mutable.Set[Int]()\n        val goodParensCount6 =\
    \ mutable.Set[Int]()\n        val badParensCount6 = mutable.Set[Int]()\n     \
    \   val goodParensCount7 = mutable.Set[Int]()\n        val badParensCount7 = mutable.Set[Int]()\n\
    \        val goodParensCount8 = mutable.Set[Int]()\n        val badParensCount8\
    \ = mutable.Set[Int]()\n        val goodParensCount9 = mutable.Set[Int]()\n  \
    \      val badParensCount9 = mutable.Set[Int]()\n        val goodParensCount10\
    \ = mutable.Set[Int]()\n        val badParensCount10 = mutable.Set[Int]()\n  \
    \      val goodParensCount11 = mutable.Set[Int]()\n        val badParensCount11\
    \ = mutable.Set[Int]()\n        val goodParensCount12 = mutable.Set[Int]()\n \
    \       val badParensCount12 = mutable.Set[Int]()\n        val goodParensCount13\
    \ = mutable.Set[Int]()\n        val badParensCount13 = mutable.Set[Int]()\n  \
    \      val goodParensCount14 = mutable.Set[Int]()\n        val badParensCount14\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7f3y9pxq.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7f3y9pxq.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7f3y9pxq.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7f3y9pxq.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7f3y9pxq.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodString\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp7f3y9pxq.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mbadString\e[0m = mutable.Set[\e\
    [35mString\e[0m]("
  stdout: ''
  timestamp: 1659794998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer(\"(\")\n        val close = mutable.ListBuffer(\"\
    )\")\n        val openCount = mutable.ListBuffer[Int]()\n        val closeCount\
    \ = mutable.ListBuffer[Int]()\n        lst.foreach(x => {\n            x match\
    \ {\n                case x if x == \")\" => closeCount += 1 \n              \
    \  case x if x == \")\" => closeCount -= 1\n                case x if x == \"\
    (\" => openCount += 1 \n                case x if x == \"(\" => openCount -= 1\n\
    \                case _ => stack += x\n            }\n        })\n        val\
    \ openCount = openCount.sum\n        val closeCount = closeCount.sum\n       \
    \ if (openCount == 0 && closeCount == 0) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_nw33wd1.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_nw33wd1.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcloseCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_nw33wd1.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_nw33wd1.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_nw33wd1.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer(\e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_nw33wd1.scala:21:2"
  stdout: ''
  timestamp: 1659794992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            if (s.contains(\"(\")) {\n          \
    \      open += s\n            } else {\n                close += s\n         \
    \   }\n        }\n        val openCount = open.size\n        val closeCount =\
    \ close.size\n        if (openCount == closeCount) {\n            val openStack\
    \ = mutable.Stack[String]()\n            val closeStack = mutable.Stack[String]()\n\
    \            open.foreach { s =>\n                openStack += s\n           \
    \ }\n            close.foreach { s =>\n                closeStack += s\n     \
    \       }\n            while (openStack.nonEmpty && closeStack.nonEmpty) {\n \
    \               val open = openStack.pop()\n                val close = closeStack.pop()\n\
    \                if (open == close) {\n                    result += (open)\n\
    \                } else {\n                    result += \"No\"\n            \
    \    }\n            }\n            if (result.nonEmpty) {\n                return\
    \ result.toString()\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9non28w0.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9non28w0.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9non28w0.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9non28w0.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9non28w0.scala:32:28 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mopenStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9non28w0.scala:33:29 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mcloseStack\e[0m ="
  stdout: ''
  timestamp: 1659794991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop()\n                case \")(\"  => stack.append(x)\n          \
    \      case \")(\"  => stack.append(x)\n                case \")\" => stack.append(x)\n\
    \                case _ => stack.append(x)\n            }\n        })\n      \
    \  stack.foreach(x => result.append(x))\n        result.mkString(\"(\", \", \"\
    , \")\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl_ekxrfd.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl_ekxrfd.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stackIsEmpty = stack.isEmpty\n\
    \        val queueIsEmpty = queue.isEmpty\n        val stackIsFull = stackSize\
    \ == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n     \
    \   val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize\
    \ == queueIsEmpty\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty\
    \ = queue.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n     \
    \   val queueIsFull = queueSize == queueIsEmpty\n        val stackIsFull = stackSize\
    \ == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n     \
    \   val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n\
    \        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull\
    \ = queueSize == queueIsEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n\
    \        val queueIsFull = queueSize == queueIsEmpty\n        val stackIsEmpty\
    \ = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n        val stackIsFull\
    \ = stackSize == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n\
    \        val stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull\
    \ = queueSize == queueIsEmpty\n        val stackIsEmpty = stack.isEmpty\n    \
    \    val queueIsEmpty = queue.isEmpty\n        val stackIsFull = stackSize ==\
    \ stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n        val\
    \ stackIsFull = stackSize == stackIsEmpty\n        val queueIsFull = queueSize\
    \ == queueIsEmpty\n        val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty\
    \ = queue.isEmpty\n        val stackIsFull = stackSize == stackIsEmpty\n     \
    \   val queueIsFull = queueSize == queueIsEmpty\n        val stackIsFull = stackSize\
    \ == stackIsEmpty\n        val queueIsFull = queueSize == queueIsEmpty\n     \
    \   val stackIsEmpty = stack.isEmpty\n        val queueIsEmpty = queue.isEmpty\n\
    \        val stackIsFull = stackSize == stack\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1puomdt6.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mstackIsFull\e[0m = stackSize\
    \ == stackIsEmpty\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackIsFull is already defined as \e[33mvalue\e[0m \e[35mstackIsFull\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1puomdt6.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mqueueIsFull\e[0m = queueSize == queueIsEmpty\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mqueueIsFull is already defined as \e[33mvalue\e[0m \e[35mqueueIsFull\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1puomdt6.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mstackIsEmpty\e[0m = stack.isEmpty\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mstackIsEmpty is already defined as \e[33mvalue\e[0m \e[35mstackIsEmpty\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1puomdt6.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mqueueIsEmpty\e[0m = queue.isEmpty\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mqueueIsEmpty\
    \ is already defined as \e[33mvalue\e[0m \e[35mqueueIsEmpty\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1puomdt6.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackIsFull\e[0m = stackSize == stackIsEmpty\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach(x => {\n            if (x.equals(\"(\")) {\n                stack.push(x)\n\
    \            } else if (x.equals(\")\")) {\n                if (stack.size ==\
    \ stackMax) {\n                    result += \"No\"\n                } else {\n\
    \                    result += \"Yes\"\n                }\n                stack.pop()\n\
    \            }\n        })\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpirim1kxj.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpirim1kxj.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659794991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(c => stack += c)\n                   \
    \ result ++= stack\n                    stack = mutable.Stack[String]()\n    \
    \            case \")(\"  =>\n                    open += x\n                case\
    \ \")(\"  =>\n                    open -= x\n                case \")\" =>\n \
    \                   close.foreach(c => stack += c)\n                    result\
    \ ++= stack\n                    stack = mutable.Stack[String]()\n           \
    \     case \")\" =>\n                    close.foreach(c => stack += c)\n    \
    \                result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")\" =>\n                    close.foreach(c => stack +=\
    \ c)\n                    result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp2729wfi1.scala:80:20 ---------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m                \e[33mcase\e[0m \n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    pattern expected\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2729wfi1.scala:98:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m98 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp2729wfi1.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp2729wfi1.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2729wfi1.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp2729wfi1.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2729wfi"
  stdout: ''
  timestamp: 1659794993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop() match {\n                    case \")\" => queue.enqueue(x)\n\
    \                    case x => bad.add(x)\n                }\n               \
    \ case \"(\" => stack.push(x)\n                case x => queue.add(x)\n      \
    \      }\n        })\n        if (stack.size == 0 && queue.size == 0) \"Yes\"\n\
    \        else if (stack.size == 0 && queue.size == 1) \"No\"\n        else matchParens(stack)\
    \ + matchParens(queue)\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0rbjllm9.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0rbjllm9.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0rbjllm9.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0rbjllm9.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659794991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") queue.push(x) else stack.push(x))\n\
    \        while(!queue.isEmpty && !stack.isEmpty) {\n            val x = queue.poll\n\
    \            val y = stack.pop()\n            if (x == \"(\") queue.push(y) else\
    \ stack.push(y)\n            if (good.contains(y)) \"Yes\" else \"No\"\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6mus037x.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6mus037x.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6mus037x.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6mus037x.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp6mus037x.scala:23:8 ---------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mwhile\e[0m(!queue.isEmpty && !stack.isEmpty)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: String\n\e[31m24 |\e[0m            \e[33mval\e\
    [0m \e[36mx\e[0m = queue.poll\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36my\e\
    [0m = stack.pop()\n\e[31m26 |\e[0m            \e[33mif\e[0m (x == \e[31m\"(\"\e\
    [0m) queue.push(y) \e[33melse\e[0m stack.push(y)\n\e[31m27 |\e[0m            \e\
    [33mif\e[0m (good.contains(y)) \e[31m\"Yes\"\e["
  stdout: ''
  timestamp: 1659794998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.synchronized {\n                        stack.pop\n\
    \                    }\n                }\n                case \")(\"  => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n                        stack += x\n\
    \                    }\n                }\n                case \")(\" => {\n\
    \                    open.synchronized {\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk1co86n9.scala:149:0 ---------------------------\e\
    [0m\e[0m\n\e[31m149 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk1co86n9.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk1co86n9.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk1co86n9.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk1co86n9.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk1co86n9.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m => {\n\e[31m 25 "
  stdout: ''
  timestamp: 1659795000
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach { s =>\n            val openCount = openCount.updated(0,\
    \ 0)\n            val closeCount = closeCount.updated(0, 0)\n            val open\
    \ = open.updated(0, \"\")\n            val close = close.updated(0, \"\")\n  \
    \          val stack = stack.updated(0, \"\")\n            if (s == \"(\") {\n\
    \                openCount.updated(1, openCount.getOrElse(1).toInt + 1)\n    \
    \            stack.updated(1, s)\n            } else if (s == \")\") {\n     \
    \           closeCount.updated(1, closeCount.getOrElse(1).toInt + 1)\n       \
    \         if (closeCount.getOrElse(1).toInt == openCount.getOrElse(1).toInt) {\n\
    \                    result += (stack.toString + close.toString + \"Yes\")\n \
    \               } else {\n                    result += (stack.toString + close.toString\
    \ + \"No\")\n                }\n                stack.updated(1, \"\")\n     \
    \       } else {\n                openCount.updated(1, openCount.getOrElse(1).toInt\
    \ + 1)\n                stack.updated(1, s)\n            }\n        }\n      \
    \  if (openCount.getOrElse(1).toInt == closeCount.getOrElse(1).toInt) {\n    \
    \        result += (stack.toString + \"Yes\")\n        } else {\n            result\
    \ += (stack.toString + \"No\")\n        }\n        result.toString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwhr0plfu.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwhr0plfu.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwhr0plfu.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwhr0plfu.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwhr0plfu.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwhr0plfu.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m ="
  stdout: ''
  timestamp: 1659795004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    queue.enqueue(x)\n                }\n            \
    \    case \")(\"  => {\n                    stack.push(x)\n                }\n\
    \                case \")(\" => {\n                    val s = stack.pop()\n \
    \                   val q = queue.poll()\n                    if (s == q) {\n\
    \                        good.append(x)\n                    } else {\n      \
    \                  bad.append(x)\n                    }\n                }\n \
    \               case \")\" => {\n                    queue.enqueue(x)\n      \
    \          }\n                case _ => {\n                    queue.enqueue(x)\n\
    \                }\n            }\n        })\n        if (good.size == 0) {\n\
    \            \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8qsswhjf.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8qsswhjf.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8qsswhjf.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8qsswhjf.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.foreach(c => stack += c)\n                   \
    \ result ++= stack\n                    stack = mutable.Stack[String]()\n    \
    \            case \")(\"  =>\n                    open += s\n                case\
    \ \")(\"  =>\n                    open += s\n                case \")(\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n                    open += s\n                case \")\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n                    open += s\n                case \")\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n                    open += s\n                case \")\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n                    open += s\n                case \")\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n                    open += s\n                case \")\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n                    open += s\n                case \")\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n                    open += s\n                case \")\" =>\n\
    \                    open += s\n                case \")\" =>\n              \
    \      open += s\n                case \")\" =>\n                    open += s\n\
    \                case \")\" =>\n                    open += s\n              \
    \  case \")\" =>\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbmpw16z8.scala:129:0 ---------------------------\e\
    [0m\e[0m\n\e[31m129 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbmpw16z8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbmpw16z8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbmpw16z8.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbmpw16z8.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbmpw16z8.scala:27:28\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    stack\
    \ = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-expl"
  stdout: ''
  timestamp: 1659795007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.foreach(y => stack += y)\n                 \
    \   close.clear()\n                }\n                case \")(\"  => {\n    \
    \                open.foreach(y => stack += y)\n                    open.clear()\n\
    \                }\n                case \")(\"  => {\n                    open.foreach(y\
    \ => stack += y)\n                    open.clear()\n                }\n      \
    \          case \")\" => {\n                    close.foreach(y => stack += y)\n\
    \                    close.clear()\n                }\n                case \"\
    )\" => {\n                    close.foreach(y => stack += y)\n               \
    \     close.clear()\n                }\n                case \")\" => {\n    \
    \                close.foreach(y => stack += y)\n                    close.clear()\n\
    \                }\n                case \")\" => {\n                    close.foreach(y\
    \ => stack += y)\n                    close.clear()\n                }\n     \
    \           case \")\" => {\n                    close.foreach(y => stack += y)\n\
    \                    close.clear()\n                }\n                case \"\
    )\" => {\n                    close.foreach(y => stack += y)\n               \
    \     close.clear()\n                }\n                case \")\" => {\n    \
    \                close.foreach(y => stack += y)\n                    close.clear()\n\
    \                }\n                case \")\" => {\n                    close.foreach(y\
    \ => stack += y)\n                    close.clear()\n                }\n     \
    \           case \")\" => {\n                    close.foreach(y => stack += y)\n\
    \                    close.clear()\n                }\n                case \"\
    )\" => {\n                    close.foreach(y => stack += y)\n               \
    \     close.clear()\n                }\n                case \")\" => {\n    \
    \                close.foreach(y => stack += y)\n                    close.clear()\n\
    \                }\n                case \")\" => {\n                    close.foreach(y\
    \ => stack += y)\n                    close.clear()\n                }\n     \
    \           case \")\" => {\n                    close.foreach(y => stack += y)\n\
    \                    close.clear()\n                }\n                case \"\
    )\" => {\n                    close.foreach(y => stack += y)\n               \
    \     close.clear()\n                }\n                case \")\" => {\n    \
    \                close.foreach(y => stack += y)\n                    close.clear()\n\
    \                }\n                case \")\" => {\n                    close.foreach(y\
    \ => stack += y)\n                    close.clear()\n                }\n     \
    \           case \")\" => {\n                    close.foreach(y => stack += y)\n\
    \                    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9zt0__yf.scala:120:0 ---------------------------\e\
    [0m\e[0m\n\e[31m120 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9zt0__yf.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9zt0__yf.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9zt0__yf.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9zt0__yf.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zt0__yf.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m => {\n\e[31m 25 "
  stdout: ''
  timestamp: 1659795013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        val openCount = mutable.ListBuffer.empty[Int]\n        val closeCount\
    \ = mutable.ListBuffer.empty[Int]\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" => {\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += close\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr09rh_4d.scala:91:0 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr09rh_4d.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr09rh_4d.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr09rh_4d.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr09rh_4d.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr09rh_4d.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.ListBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ a"
  stdout: ''
  timestamp: 1659795013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            val openCount = if (s.startsWith(\"(\"\
    )) 1 else 0\n            val closeCount = if (s.endsWith(\")\")) 1 else 0\n  \
    \          if (openCount == closeCount) {\n                result += (s + \"\\\
    n\")\n            } else {\n                open += (s + \"\\n\")\n          \
    \  }\n        }\n        val openCount = if (open.isEmpty) 0 else open.length\n\
    \        val closeCount = if (close.isEmpty) 0 else close.length\n        if (openCount\
    \ == closeCount) {\n            val stackStr = stack.toList\n            if (stackStr.size\
    \ == 0) {\n                return \"No\"\n            } else {\n             \
    \   val stackStr = stack.toList\n                val stackStr = stackStr.sortBy(_.length)\n\
    \                val stackStr = stackStr.take(stackStr.size - 1).mkString(\"\\\
    n\")\n                val stackStr = stackStr.substring(0, stackStr.size - 1)\n\
    \                val stackStr = stackStr.substring(0, stackStr.size - 1)\n   \
    \             val stackStr = stackStr.substring(0, stackStr.size - 1)\n      \
    \          val stackStr = stackStr.substring(0, stackStr.size - 1)\n         \
    \       val stackStr = stackStr.substring(0, stackStr.size - 1)\n            \
    \    val stackStr = stackStr.substring(0, stackStr.size - 1)\n               \
    \ val stackStr = stackStr.substring(0, stackStr.size - 1)\n                val\
    \ stackStr = stackStr.substring(0, stackStr.size - 1)\n                val stackStr\
    \ = stackStr.substring(0, stackStr.size - 1)\n                val stackStr = stackStr.substring(0,\
    \ stackStr.size - 1)\n                val stackStr = stackStr.substring(0, stackStr.size\
    \ - 1)\n                val stackStr = stackStr.substring(0, stackStr.size - 1)\n\
    \                val stackStr = stackStr.substring(0, stackStr.size - 1)\n   \
    \             val stackStr = stackStr.substring(0, stackStr.size - 1)\n      \
    \          val stackStr = stackStr.substring(0, stackStr.size - 1)\n         \
    \       val stackStr = stackStr.substring(0, stackStr.size - 1)\n            \
    \    val stackStr = stackStr.substring(0, stackStr.size - 1)\n               \
    \ val stackStr = stackStr.substring(0, stackStr.size - 1)\n                val\
    \ stackStr = stackStr.substring(0, stackStr.size - 1)\n                val stackStr\
    \ = stackStr.substring(0, stackStr.size - 1)\n                val stackStr = stackStr.substring(0,\
    \ stackStr.size - 1)\n                val stackStr = stackStr.substring(0, stackStr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq05l45rf.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq05l45rf.scala:80:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpq05l45rf.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpq05l45rf.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq05l45rf.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpq05l45rf.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpq05l45rf.scala:39:20 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m =\
    \ stackStr.so"
  stdout: ''
  timestamp: 1659795007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val len = open - close\n            if(len > 0) {\n           \
    \     stack.push(str)\n                while(stack.nonEmpty) {\n             \
    \       val top = stack.pop()\n                    if(top == close) {\n      \
    \                  result += \"Yes\"\n                        break\n        \
    \            }\n                    if(top == open) {\n                      \
    \  result += \"No\"\n                        break\n                    }\n  \
    \                  result += \"No\"\n                }\n            }\n      \
    \  }\n        result.mkString(\",\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_yvoocoh.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_yvoocoh.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_yvoocoh.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_yvoocoh.scala:35:24\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()\" => stack.push(x)\n                case \")\" =>\
    \ close.push(x)\n                case \")()\" => stack.push(x)\n             \
    \   case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")()()\" => stack.push(x)\n        \
    \        case \")()()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")()()\" => stack.push(x)\n                case \")()()\"\
    \ => \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnr7yfb_6.scala:87:0 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnr7yfb_6.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnr7yfb_6.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnr7yfb_6.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnr7yfb_6.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnr7yfb_6.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Unit\n\e[31m   |\e[0m        Required: String\n\e[31m23 |\e[0m           \
    \ x \e[33mmatch\e[0m {\n\e[31m24 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m => close."
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach(x => {\n            x match {\n                case \")\" =>\
    \ {\n                    stackSize -= 1\n                    stack.toList.reverse.foreach(y\
    \ => {\n                        y match {\n                            case \"\
    )\" => {\n                                stackSize -= 1\n                   \
    \             stack.toList.reverse.foreach(z => {\n                          \
    \          z match {\n                                        case \")\" => {\n\
    \                                            stackSize -= 1\n                \
    \                            stack.toList.reverse.foreach(w => {\n           \
    \                                     w match {\n                            \
    \                        case \")\" => {\n                                   \
    \                     stackSize -= 1\n                                       \
    \                 stack.toList.reverse.foreach(x => {\n                      \
    \                                      x match {\n                           \
    \                                     case \")\" => {\n                      \
    \                                              stackSize -= 1\n              \
    \                                                      stack.toList.reverse.foreach(y\
    \ => {\n                                                                     \
    \   y match {\n                                                              \
    \              case \")\" => {\n                                             \
    \                                   stackSize -= 1\n                         \
    \                                                       stack.toList.reverse.foreach(z\
    \ => {\n                                                                     \
    \               z match {\n                                                  \
    \                                      case \")\" => {\n                     \
    \                                                                       stackSize\
    \ -= 1\n                                                                     \
    \                       stack.toList.reverse.foreach(w => {\n                \
    \                                                                            \
    \    w match {\n                                                             \
    \                                       case \")\" => {\n                    \
    \                                                                            \
    \        stackSize -= 1\n                                                    \
    \                                                    stack.toList.reverse.foreach(x\
    \ => {\n                                                                     \
    \                                       x match {\n                          \
    \                                                                            \
    \          case \")\" => {\n                                                 \
    \                                                                   stackSize\
    \ -= 1\n                                                                     \
    \                                               stack.toList.reverse.foreach(y\
    \ => {\n                                                                     \
    \                                                   y match {\n              \
    \                                                                            \
    \                                  case \")\" => {\n                         \
    \                                                                            \
    \                           stackSize -= 1\n                                 \
    \                                                                            \
    \                   stack.toList.reverse.foreach(z => {\n                    \
    \                                                                            \
    \                                    z match {\n                             \
    \                                                                            \
    \                               case \")\" => {\n                            \
    \                                                                            \
    \                                    stackSize -= 1\n                        \
    \                                                                            \
    \                                        stack.toList.reverse.foreach(w => {\n\
    \                                                                            \
    \                                                                    w match {\n\
    \                                                                            \
    \                                                                    case \")\"\
    \ => {\n                                                                     \
    \                                                                            \
    \   stackSize -= 1\n                                                         \
    \                                                                            \
    \               stack.toList.reverse.foreach(x => {\n                        \
    \                                                                            \
    \                                                    x match {\n             \
    \                                                                            \
    \                                                                   case \")\"\
    \ => {\n                                                                     \
    \                                                                            \
    \               stackSize -= 1\n                                             \
    \                                                                            \
    \                                       stack.toList.reverse.foreach(y => {\n\
    \                                                                            \
    \                                                                            \
    \            y match {\n                                                     \
    \                                                                            \
    \                                       case \")\" => {\n                    \
    \                                                                            \
    \                                                                            stackSize\
    \ -= 1\n                                                                     \
    \                                                                            \
    \                           stack.toList.reverse.foreach(z => {\n            \
    \                                                                            \
    \                                                                            \
    \            z match {\n                                                     \
    \                                                                            \
    \                                                   case \")\" => {\n        \
    \                                                                            \
    \                                                                            \
    \                        stackSize -= 1\n                                    \
    \                                                                            \
    \                                                                        stack.toList.reverse.foreach(w\
    \ => {\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptd5xwll4.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmptd5xwll4.scala:101:0 ---------------------------\e[0m\e[0m\n\e[31m101\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptd5xwll4.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptd5xwll4.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmptd5xwll4.scala:25:30 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659795011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val queueMax = queueSize - 1\n        val stackIndex = stackMax\n       \
    \ val queueIndex = queueMax\n        val stackIsEmpty = stackMax == -1\n     \
    \   val queueIsEmpty = queueMax == -1\n        val stackIsFull = stackMax == stackSize\n\
    \        val queueIsFull = queueMax == queueSize\n        while(stackIsEmpty ||\
    \ queueIsEmpty) {\n            val stackIsFull = stackMax == stackSize\n     \
    \       val queueIsFull = queueMax == queueSize\n            val stackIsEmpty\
    \ = stackMax == -1\n            val queueIsEmpty = queueMax == -1\n          \
    \  if(stackIsEmpty && queueIsEmpty) {\n                val stackIsEmpty = stackMax\
    \ == -1\n                val queueIsEmpty = queueMax == -1\n            }\n  \
    \          if(stackIsFull) {\n                val stackIsEmpty = stackMax == -1\n\
    \            }\n            if(queueIsFull) {\n                val queueIsEmpty\
    \ = queueMax == -1\n            }\n            val stackSize = lst.size\n    \
    \        val queueSize = lst.size\n            val stackMax = stackSize - 1\n\
    \            val queueMax = queueSize - 1\n            val stackIndex = stackMax\n\
    \            val queueIndex = queueMax\n            val stackIsEmpty = stackMax\
    \ == -1\n            val queueIsEmpty = queueMax == -1\n            val stackIsFull\
    \ = stackMax == stackSize\n            val queueIsFull = queueMax == queueSize\n\
    \        }\n        while(stackIndex < stackSize && queueIndex < queueSize) {\n\
    \            val stack = lst.take(stackIndex).mkString\n            val queue\
    \ = lst.take(queueIndex).mkString\n            val stackSize = lst.size\n    \
    \        val queueSize = lst.size\n            val stackMax = stackSize - 1\n\
    \            val queueMax = queueSize - 1\n            val stackIndex = stackMax\n\
    \            val queueIndex = queueMax\n            val stackIsEmpty = stackMax\
    \ == -1\n            val queueIsEmpty = queueMax == -1\n            val stackIsFull\
    \ = stackMax == stackSize\n            val queueIsFull = queueMax == queueSize\n\
    \            while(stackIsEmpty || queueIsEmpty) {\n                val stackIsFull\
    \ = stackMax == stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjwo8rbu2.scala:89:0 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjwo8rbu2.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjwo8rbu2.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjwo8rbu2.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjwo8rbu2.scala:52:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m            \e[33mval\e\
    [0m \e[36mstackIsEmpty\e[0m = stackMax == -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackIsEmpty\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackIsEmpty\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjwo8rbu2.scala:53:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m            \e[33mval\e\
    [0m \e[36mqueueIsEmpty\e[0m = queueMax == -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mqueueIsEmpty\
    \ is alrea"
  stdout: ''
  timestamp: 1659795018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n            } else if (x == \")\") {\n                close += x\n   \
    \         } else {\n                stack += x\n            }\n        })\n  \
    \      val openCount = open.size\n        val closeCount = close.size\n      \
    \  if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n\
    \            val closeStack = stack.drop(closeCount)\n            val openStackStr\
    \ = openStack.mkString\n            val closeStackStr = closeStack.mkString\n\
    \            if (openStackStr == closeStackStr) {\n                result += \"\
    Yes\"\n            } else {\n                result += \"No\"\n            }\n\
    \        } else {\n            result += \"No\"\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfj6l2612.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfj6l2612.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfj6l2612.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfj6l2612.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val good = mutable.Queue[String]()\n\
    \        val bad = mutable.Queue[String]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4betp4u5.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Queue[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4betp4u5.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Queue[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4betp4u5.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Queue[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4betp4u5.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Queue[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4betp4u5.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Queue[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659795016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \        val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val stackSize = lst.size\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuzmjxec0.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuzmjxec0.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuzmjxec0.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuzmjxec0.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstack is already\
    \ defined as \e[33mvalue\e[0m \e[35mstack\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuzmjxec0.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mresult\
    \ is already defined as \e["
  stdout: ''
  timestamp: 1659795017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => if (open(x) ) stack += x else close.add(x))\n      \
    \  while(!stack.isEmpty) {\n            val curr = stack.pop()\n            if\
    \ (close.contains(curr)) {\n                result += curr\n            } else\
    \ {\n                val open1 = open.toList\n                val close1 = close.toList\n\
    \                val open2 = open1.filterNot(x => close1.contains(x))\n      \
    \          val close2 = close1.filterNot(x => open1.contains(x))\n           \
    \     if (open2.isEmpty) result += \"(\" + curr\n                else if (close2.isEmpty)\
    \ result += curr + \")\"\n                else {\n                    val open3\
    \ = open2.filterNot(x => close2.contains(x))\n                    val close3 =\
    \ close2.filterNot(x => open2.contains(x))\n                    if (open3.isEmpty)\
    \ result += \"(\" + curr + \")\"\n                    else if (close3.isEmpty)\
    \ result += curr + \")\"\n                    else {\n                       \
    \ val open4 = open3.filterNot(x => close3.contains(x))\n                     \
    \   val close4 = close3.filterNot(x => open3.contains(x))\n                  \
    \      if (open4.isEmpty) result += \"(\" + curr + \")\"\n                   \
    \     else if (close4.isEmpty) result += curr + \")\"\n                      \
    \  else {\n                            val open5 = open4.filterNot(x => close4.contains(x))\n\
    \                            val close5 = close4.filterNot(x => open4.contains(x))\n\
    \                            if (open5.isEmpty) result += \"(\" + curr + \")\"\
    \n                            else if (close5.isEmpty) result += curr + \")\"\n\
    \                            else {\n                                val open6\
    \ = open5.filterNot(x => close5.contains(x))\n                               \
    \ val close6 = close5.filterNot(x => open5.contains(x))\n                    \
    \            if (open6.isEmpty) result += \"(\" + curr + \")\"\n             \
    \                   else if (close6.isEmpty) result += curr + \")\"\n        \
    \                        else {\n                                    val open7\
    \ = open6.filterNot(x => close6.contains(x))\n                               \
    \     val close7 = close6.filterNot(x => open6.contains(x))\n                \
    \                    if (open7.isEmpty) result += \"(\" + curr + \")\"\n     \
    \                               else if (close7.isEmpty) result += curr + \")\"\
    \n                                    else {\n                               \
    \         val open8 = open7.filterNot(x => close7.contains(x))\n             \
    \                           val close8 = close7.filterNot(x => open7.contains(x))\n\
    \                                \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7o3ikegt.scala:80:0 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o3ikegt.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o3ikegt.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o3ikegt.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7o3ikegt.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7o3ikegt.scala:23:8\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mwhile\e[0m(!stack.isEmpty)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: String\n\e[31m24 |\e[0m            \e[33mval\e\
    [0m \e[36mcurr\e[0m = stack.pop()\n\e[31m25 |\e[0m            \e[33mif\e[0m (close.contains"
  stdout: ''
  timestamp: 1659795018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStrings = mutable.Set[String]()\n        val badStrings = mutable.Set[String]()\n\
    \        val goodStringsSize = mutable.Set[Int]()\n        val badStringsSize\
    \ = mutable.Set[Int]()\n        val goodStringsSize = mutable.Set[Int]()\n   \
    \     val badStringsSize = mutable.Set[Int]()\n        val goodStringsSize = mutable.Set[Int]()\n\
    \        val badStringsSize = mutable.Set[Int]()\n        val goodStringsSize\
    \ = mutable.Set[Int]()\n        val badStringsSize = mutable.Set[Int]()\n    \
    \    val goodStringsSize = mutable.Set[Int]()\n        val badStringsSize = mutable.Set[Int]()\n\
    \        val goodStringsSize = mutable.Set[Int]()\n        val badStringsSize\
    \ = mutable.Set[Int]()\n        val goodStringsSize = mutable.Set[Int]()\n   \
    \     val badStringsSize = mutable.Set[Int]()\n        val goodStringsSize = mutable.Set[Int]()\n\
    \        val badStringsSize = mutable.Set[Int]()\n        val goodStringsSize\
    \ = mutable.Set[Int]()\n        val badStringsSize = mutable.Set[Int]()\n    \
    \    val goodStringsSize = mutable.Set[Int]()\n        val badStringsSize = mutable.Set[Int]()\n\
    \        val goodStringsSize = mutable.Set[Int]()\n        val badStringsSize\
    \ = mutable.Set[Int]()\n        val goodStringsSize = mutable.Set[Int]()\n   \
    \     val badStringsSize = mutable.Set[Int]()\n        val goodStringsSize = mutable.Set[Int]()\n\
    \        val badStringsSize = mutable.Set[Int]()\n        val goodStringsSize\
    \ = mutable.Set[Int]()\n        val badStringsSize = mutable.Set[Int]()\n    \
    \    val goodStringsSize = mutable.Set[Int]()\n        val badStringsSize = mutable.Set[Int]()\n\
    \        val goodStringsSize = mutable.Set[Int]()\n        val badStrings\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkttx5r80.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkttx5r80.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodStringsSize\e[0m = mutable.Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodStringsSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mgoodStringsSize\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkttx5r80.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadStringsSize\e[0m = mutable.Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadStringsSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mbadStringsSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkttx5r80.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodStringsSize\e[0m = mutable.Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodStringsSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mgoodStringsSize\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkttx5r80.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadStringsSize\e[0m = mutable.Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadStringsSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mbadStringsSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel defin"
  stdout: ''
  timestamp: 1659795019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val openCount = mutable.Map[String, Int]()\n        val closeCount =\
    \ mutable.Map[String, Int]()\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" =>\n                    closeCount += x -> 1\n\
    \                case \")(\"  =>\n                    openCount += x -> 1\n  \
    \              case \")(\"  =>\n                    openCount += x -> 1\n    \
    \            case \")\" =>\n                    closeCount += x -> 1\n       \
    \         case \")\" =>\n                    closeCount += x -> 1\n          \
    \      case \")\" =>\n                    closeCount += x -> 1\n             \
    \   case \")\" =>\n                    closeCount += x -> 1\n                case\
    \ \")\" =>\n                    closeCount += x -> 1\n                case \"\
    )\" =>\n                    closeCount += x -> 1\n                case \")\" =>\n\
    \                    closeCount += x -> 1\n                case \")\" =>\n   \
    \                 closeCount += x -> 1\n                case \")\" =>\n      \
    \              closeCount += x -> 1\n                case \")\" =>\n         \
    \           closeCount += x -> 1\n                case \")\" =>\n            \
    \        closeCount += x -> 1\n                case \")\" =>\n               \
    \     closeCount += x -> 1\n                case \")\" =>\n                  \
    \  closeCount += x -> 1\n                case \")\" =>\n                    closeCount\
    \ += x -> 1\n                case \")\" =>\n                    closeCount +=\
    \ x -> 1\n                case \")\" =>\n                    closeCount += x ->\
    \ 1\n                case \")\" =>\n                    closeCount += x -> 1\n\
    \                case \")\" =>\n                    closeCount += x -> 1\n   \
    \             case \")\" =>\n                    closeCount += x -> 1\n      \
    \          case \")\" =>\n                    closeCount += x -> 1\n         \
    \       case \")\" =>\n                    closeCount += x -> 1\n            \
    \    case \")\" =>\n                    closeCount += x -> 1\n               \
    \ case \")\" =>\n                    closeCount += x -> 1\n                case\
    \ \")\" =>\n                    closeCount += x -> 1\n                case \"\
    )\" =>\n                    closeCount += x -> 1\n                case \")\" =>\n\
    \                    closeCount += x -> 1\n                case \")\" =>\n   \
    \                 closeCount += x -> 1\n                case \")\" =>\n      \
    \              closeCount += x -> 1\n                case \")\" =>\n         \
    \           closeCount += x -> 1\n                case \")\" =>\n            \
    \        closeCount += x \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphvtnkli0.scala:109:0 ---------------------------\e\
    [0m\e[0m\n\e[31m109 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphvtnkli0.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphvtnkli0.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphvtnkli0.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphvtnkli0.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphvtnkli0.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.Map[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when com"
  stdout: ''
  timestamp: 1659795019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.add(x)\n                    stack.push(x)\n\
    \                }\n                case \"(\" => {\n                    open.add(x)\n\
    \                    stack.push(x)\n                }\n                case _\
    \ => {\n                    val openCount = open.count(x => x == x)\n        \
    \            val closeCount = close.count(x => x == x)\n                    val\
    \ openParens = stack.count(x => x == \")\")\n                    val closeParens\
    \ = stack.count(x => x == \")\")\n                    val openParensCount = stack.count(x\
    \ => x == \"(\")\n                    val closeParensCount = stack.count(x =>\
    \ x == \"(\")\n                    if (openCount == closeCount && openParensCount\
    \ == closeParensCount) {\n                        result.add(x)\n            \
    \        }\n                }\n            }\n        })\n        if (result.size\
    \ == lst.size) {\n            return \"Yes\"\n        }\n        return \"No\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjcv64d_k.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjcv64d_k.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjcv64d_k.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjcv64d_k.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val stackSize = lst.size\n\
    \        val queueSize = lst.size\n        val stack = mutable.Stack[String]()\n\
    \        val queue = mutable.Queue[String]()\n        val result = mutable.Queue[String]()\n\
    \        val stackSize = lst.size\n        val queueSize = lst.size\n        val\
    \ stack = mutable.Stack[String]()\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjge_9aeb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mqueue is already defined as \e[33mvalue\e[0m \e[35mqueue\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjge_9aeb.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjge_9aeb.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjge_9aeb.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mqueueSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mqueueSize is already defined as \e[33mvalue\e[0m \e[35mqueueSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659795018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val openCount = mutable.Map[String, Int]()\n        val closeCount =\
    \ mutable.Map[String, Int]()\n        lst.foreach(x => {\n            if (openCount.get(x)\
    \ == null) {\n                openCount.get(x) = 1\n                open(x)\n\
    \            }\n            if (closeCount.get(x) == null) {\n               \
    \ closeCount.get(x) = 1\n                close(x)\n            }\n        })\n\
    \        while(stack.nonEmpty) {\n            val s = stack.pop()\n          \
    \  if (openCount.get(s) == null) {\n                openCount.get(s) = 1\n   \
    \             open(s)\n            }\n            if (closeCount.get(s) == null)\
    \ {\n                closeCount.get(s) = 1\n                close(s)\n       \
    \     }\n            if (openCount.get(s) == closeCount.get(s)) {\n          \
    \      result += s\n            }\n        }\n        if (result.nonEmpty) {\n\
    \            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppbm3qyes.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppbm3qyes.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppbm3qyes.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppbm3qyes.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppbm3qyes.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = mutable.Map[\e\
    [35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppbm3qyes.scala:23:25\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcloseCount\e[0m = mut"
  stdout: ''
  timestamp: 1659795013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    stack.push(x)\n                }\n  \
    \              case \")(\" => {\n                    val open = stack.pop()\n\
    \                    val close = stack.pop()\n                    val open1 =\
    \ open.reverse\n                    val close1 = close.reverse\n             \
    \       val open2 = open1.reverse\n                    val close2 = close1.reverse\n\
    \                    val open3 = open2.reverse\n                    val close3\
    \ = close2.reverse\n                    val open4 = open3.reverse\n          \
    \          val close4 = close3.reverse\n                    val open5 = open4.reverse\n\
    \                    val close5 = close4.reverse\n                    val open6\
    \ = open5.reverse\n                    val close6 = close5.reverse\n         \
    \           val open7 = open6.reverse\n                    val close7 = close6.reverse\n\
    \                    val open8 = open7.reverse\n                    val close8\
    \ = close7.reverse\n                    val open9 = open8.reverse\n          \
    \          val close9 = close8.reverse\n                    val open10 = open9.reverse\n\
    \                    val close10 = close9.reverse\n                    val open11\
    \ = open10.reverse\n                    val close11 = close10.reverse\n      \
    \              val open12 = open11.reverse\n                    val close12 =\
    \ close11.reverse\n                    val open13 = open12.reverse\n         \
    \           val close13 = close12.reverse\n                    val open14 = open13.reverse\n\
    \                    val close14 = close13.reverse\n                    val open15\
    \ = open14.reverse\n                    val close15 = close14.reverse\n      \
    \              val open16 = open15.reverse\n                    val close16 =\
    \ close15.reverse\n                    val open17 = open16.reverse\n         \
    \           val close17 = close16.reverse\n                    val open18 = open17.reverse\n\
    \                    val close18 = close17.reverse\n                    val open19\
    \ = open18.reverse\n                    val close19 = close18.reverse\n      \
    \              val open20 = open19.reverse\n                    val close20 =\
    \ close19.reverse\n                    val open21 = open20.reverse\n         \
    \           val close21 = close20.reverse\n                    val open22 = open21.reverse\n\
    \                    val close22 = close21.reverse\n                    val open23\
    \ = open22.reverse\n                    val close23 = close22.reverse\n      \
    \              val open24 = open23.reverse\n                    val close24 =\
    \ close23.\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphgdl0arp.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmphgdl0arp.scala:98:0 ----------------------------\e[0m\e[0m\n\e[31m98\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphgdl0arp.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphgdl0arp.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphgdl0arp.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphgdl0arp.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmphgdl0arp.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35"
  stdout: ''
  timestamp: 1659795014
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        val openCount = mutable.ListBuffer.empty[Int]\n        val closeCount\
    \ = mutable.ListBuffer.empty[Int]\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" =>\n                    closeCount += closeCount.length\n\
    \                    close.push(x)\n                case \")(\"  =>\n        \
    \            openCount += openCount.length\n                    open.push(x)\n\
    \                case \")()\" =>\n                    closeCount += closeCount.length\n\
    \                    close.push(x)\n                case \")()()\" =>\n      \
    \              openCount += openCount.length\n                    open.push(x)\n\
    \                case \")()()()\" =>\n                    openCount += openCount.length\n\
    \                    open.push(x)\n                case \")()()()()\" =>\n   \
    \                 openCount += openCount.length\n                    open.push(x)\n\
    \                case \")()()()()()\" =>\n                    openCount += openCount.length\n\
    \                    open.push(x)\n                case \")()()()()()()\" =>\n\
    \                    openCount += openCount.length\n                    open.push(x)\n\
    \                case \")()()()()()()()\" =>\n                    openCount +=\
    \ openCount.length\n                    open.push(x)\n                case \"\
    )()()()()()()()()\" =>\n                    openCount += openCount.length\n  \
    \                  open.push(x)\n                case \")()()()()()()()()()\"\
    \ =>\n                    openCount += openCount.length\n                    open.push(x)\n\
    \                case \")()()()()()()()()()\" =>\n                    openCount\
    \ += openCount.length\n                    open.push(x)\n                case\
    \ \")()()()()()()()()()()\" =>\n                    openCount += openCount.length\n\
    \                    open.push(x)\n                case \")()()()()()()()()()()\"\
    \ =>\n                    openCount += openCount.length\n                    open.push(x)\n\
    \                case \")()()()()()()()()()()()\" =>\n                    openCount\
    \ += openCount.length\n                    open.push(x)\n                case\
    \ \")()()()()()()()()()()()\" =>\n                    openCount += openCount.length\n\
    \                    open.push(x)\n                case \")()()()()()()()()()()()\"\
    \ =>\n                    openCount += open\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6rusyfnc.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rusyfnc.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rusyfnc.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rusyfnc.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rusyfnc.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rusyfnc.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.ListBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ a"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val openCount = mutable.Map[String, Int]()\n        val closeCount =\
    \ mutable.Map[String, Int]()\n        lst.foreach(x => {\n            if (openCount.get(x)\
    \ == null) {\n                openCount.get(x) = 1\n                open(x) +=\
    \ 1\n            } else {\n                openCount.get(x) += 1\n           \
    \ }\n            if (closeCount.get(x) == null) {\n                closeCount.get(x)\
    \ = 1\n                close(x) += 1\n            } else {\n                closeCount.get(x)\
    \ += 1\n            }\n        })\n        val openCount = openCount.toSeq.sortBy(_._2).reverse\n\
    \        val closeCount = closeCount.toSeq.sortBy(_._2).reverse\n        val openCount\
    \ = openCount.toSeq.sortBy(_._1).reverse\n        val closeCount = closeCount.toSeq.sortBy(_._1).reverse\n\
    \        val open = open.toSeq.sortBy(_._1).reverse\n        val close = close.toSeq.sortBy(_._1).reverse\n\
    \        val openCount = openCount.toSeq.sortBy(_._2).reverse\n        val closeCount\
    \ = closeCount.toSeq.sortBy(_._2).reverse\n        val openCount = openCount.toSeq.sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.toSeq.sortBy(_._1).reverse\n        val open\
    \ = open.toSeq.sortBy(_._1).reverse\n        val close = close.toSeq.sortBy(_._1).reverse\n\
    \        val openCount = openCount.toSeq.sortBy(_._2).reverse\n        val closeCount\
    \ = closeCount.toSeq.sortBy(_._2).reverse\n        val openCount = openCount.toSeq.sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.toSeq.sortBy(_._1).reverse\n        val open\
    \ = open.toSeq.sortBy(_._1).reverse\n        val close = close.toSeq.sortBy(_._1).reverse\n\
    \        val openCount = openCount.toSeq.sortBy(_._2).reverse\n        val closeCount\
    \ = closeCount.toSeq.sortBy(_._2).reverse\n        val openCount = openCount.toSeq.sortBy(_._1).reverse\n\
    \        val closeCount = closeCount.toSeq.sortBy(_._1).reverse\n        val open\
    \ = open.toSeq\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcmir6xu7.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.toSeq.sortBy(_._2).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmir6xu7.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.toSeq.sortBy(_._2).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmir6xu7.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.toSeq.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmir6xu7.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.toSeq.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmir6xu7.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = ope"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mut\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp19h9vx6w.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp19h9vx6w.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp19h9vx6w.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp19h9vx6w.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresultSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresultSize is already defined as \e[33mvalue\e[0m \e[35mresultSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp19h9vx6w.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e[0m\n\
    \e[31m   |\e[0m\n"
  stdout: ''
  timestamp: 1659795022
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                openCount += 1 \n            } else if (x == \")\") {\n\
    \                close += x\n                closeCount += 1\n            }\n\
    \        })\n        val openCount = openCount.sum\n        val closeCount = closeCount.sum\n\
    \        if (openCount == closeCount) {\n            val open = open.mkString\n\
    \            val close = close.mkString\n            val stack = stack.mkString\n\
    \            val result = result.mkString\n            if (open == close && stack\
    \ == result) {\n                return \"Yes\"\n            }\n        }\n   \
    \     return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoudsstnh.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoudsstnh.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcloseCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoudsstnh.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoudsstnh.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoudsstnh.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoudsstnh.scala:21:"
  stdout: ''
  timestamp: 1659795019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:74:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmpqvlgfgda.scala:76:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqvlgfgda.scala:92:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpqvlgfgda.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpqvlgfgda.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqvlgfgda.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659795020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue\
    \ += x else if (!x == \")\") bad += x else if (!x == \")\") good += x)\n     \
    \   if (good.size == lst.size && bad.size == lst.size) \"Yes\" else \"No\"\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc2m8majg.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc2m8majg.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc2m8majg.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc2m8majg.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpc2m8majg.scala:22:59 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) bad\
    \ += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) good += x)\n\e[31m\e\
    [31m   |\e[0m                                                           ^^\e[0m\n\
    \e[31m   |\e[0m                                 value unary_! is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /"
  stdout: ''
  timestamp: 1659795030
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                result += \"Yes\"\n                stack.push(str)\n\
    \                while(open < close && stack.nonEmpty) {\n                   \
    \ val str = stack.pop()\n                    val open = str.indexOf(\"(\")\n \
    \                   val close = str.indexOf(\")\")\n                    if(open\
    \ < 0 || close < 0) {\n                        result += \"No\"\n            \
    \        } else {\n                        result += \"Yes\"\n               \
    \         stack.push(str)\n                    }\n                }\n        \
    \    }\n        }\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5b194z1j.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5b194z1j.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795023
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case \")()\" => open.add(x)\n                case \")()()\" => close.add(x)\n\
    \                case \")()\" => open.add(x)\n                case \")\" => close.add(x)\n\
    \                case _ => stack += x\n            }\n        })\n        val\
    \ openCount = open.size\n        val closeCount = close.size\n        val openStack\
    \ = stack.take(openCount)\n        val closeStack = stack.drop(closeCount)\n \
    \       val openStackCount = openStack.size\n        val closeStackCount = closeStack.size\n\
    \        val openStack = openStack.take(openStackCount)\n        val closeStack\
    \ = closeStack.drop(closeStackCount)\n        val openStackCount = openStack.size\n\
    \        val closeStackCount = closeStack.size\n        val openStack = openStack.take(openStackCount)\n\
    \        val closeStack = closeStack.drop(closeStackCount)\n        val openStackCount\
    \ = openStack.size\n        val closeStackCount = closeStack.size\n        val\
    \ openStack = openStack.take(openStackCount)\n        val closeStack = closeStack.drop(closeStackCount)\n\
    \        val openStackCount = openStack.size\n        val closeStackCount = closeStack.size\n\
    \        val openStack = openStack.take(openStackCount)\n        val closeStack\
    \ = closeStack.drop(closeStackCount)\n        val openStackCount = openStack.size\n\
    \        val closeStackCount = closeStack.size\n        val openStack = openStack.take(openStackCount)\n\
    \        val closeStack = closeStack.drop(closeStackCount)\n        val openStackCount\
    \ = openStack.size\n        val closeStackCount = closeStack.size\n        val\
    \ openStack = openStack.take(openStackCount)\n        val closeStack = closeStack.drop(closeStackCount)\n\
    \        val openStackCount = openStack.size\n        val closeStackCount = closeStack.size\n\
    \        val openStack = openStack.take(openStackCount)\n        val closeStack\
    \ = closeStack.drop(closeStackCount)\n        val openStackCount = openStack.size\n\
    \        val closeStackCount = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp175wqe_a.scala:66:29 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \e[36mcloseStackCount\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp175wqe_a.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mopenStack\e[0m = openStack.take(openStackCount)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenStack is already defined as \e[33mvalue\e[0m \e[35mopenStack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp175wqe_a.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcloseStack\e[0m = closeStack.drop(closeStackCount)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcloseStack is already defined as \e[33mvalue\e[0m \e[35mcloseStack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp175wqe_a.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mopenStackCount\e[0m = openStack.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopenStackCount is already defined as \e[33mvalue\e[0m \e[35mopenStackCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp175wqe_a.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mcloseStackCount\e[0m = closeStack.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcloseStackCount is already defi"
  stdout: ''
  timestamp: 1659795029
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack\
    \ += x\n            } else if (x == \")\") {\n                while (!stack.isEmpty\
    \ && stack.head != \"(\") {\n                    good += stack.head\n        \
    \            stack.pop\n                }\n                bad += x\n        \
    \    } else {\n                queue += x\n            }\n        })\n       \
    \ if (good.size == lst.size) {\n            return \"Yes\"\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxtod8eph.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxtod8eph.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxtod8eph.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpxtod8eph.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795024
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val\
    \ stackMinIndex = stackSize - 1\n        val stackMinSize = stackSize - 1\n  \
    \      val stackMaxSize = stackSize - 1\n        val stackMinSizeIndex = stackSize\
    \ - 1\n        val stackMaxSizeIndex = stackSize - 1\n        val stackMinIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMinSize\
    \ = stackSize - 1\n        val stackMaxSize = stackSize - 1\n        val stackMinSizeIndex\
    \ = stackSize - 1\n        val stackMaxSizeIndex = stackSize - 1\n        val\
    \ stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n \
    \       val stackMinSize = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMinSizeIndex = stackSize - 1\n        val stackMaxSizeIndex\
    \ = stackSize - 1\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMinSize = stackSize - 1\n        val stackMaxSize\
    \ = stackSize - 1\n        val stackMinSizeIndex = stackSize - 1\n        val\
    \ stackMaxSizeIndex = stackSize - 1\n        val stackMinIndex = stackSize - 1\n\
    \        val stackMaxIndex = stackSize - 1\n        val stackMinSize = stackSize\
    \ - 1\n        val stackMaxSize = stackSize - 1\n        val stackMinSizeIndex\
    \ = stackSize - 1\n        val stackMaxSizeIndex = stackSize - 1\n        val\
    \ stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n \
    \       val stackMinSize = stackSize - 1\n        val stackMaxSize = stackSize\
    \ - 1\n        val stackMinSizeIndex = stackSize - 1\n        val stackMaxSizeIndex\
    \ = stackSize - 1\n        val stackMinIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMinSize = stackSize - 1\n        val stackMaxSize\
    \ = stackSize - 1\n        val stackMinSizeIndex = stackSize - 1\n        val\
    \ stackMaxSizeIndex = stackSize - 1\n        val stackMinIndex = stackSize - 1\n\
    \        val stackMaxIndex = stackSize - 1\n        val stackMinSize = stackSize\
    \ - 1\n        val stackMaxSize = stackSize - 1\n        val stackMinSizeIndex\
    \ = stackSize - 1\n        val stackMaxSizeIndex = stackSize - 1\n        val\
    \ stackMinIndex = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyocjptx8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstackMinIndex\e[0m = stackSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMinIndex is already defined as \e[33mvalue\e[0m \e[35mstackMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyocjptx8.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = stackSize - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyocjptx8.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mstackMinSize\e[0m = stackSize - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mstackMinSize is already defined as \e[33mvalue\e[0m \e[35mstackMinSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyocjptx8.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mstackMaxSize\e[0m = stackSize - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mstackMaxSize is already defined as \e[33mvalue\e[0m \e[35mstackMaxSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyocjptx8.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mstackMinSizeIndex\e[0m = stackSize -\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[3"
  stdout: ''
  timestamp: 1659795031
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x != \"(\") close.add(x)\n      \
    \      if (x == \"(\") open.add(x)\n            if (x == \")\") stack.add(x)\n\
    \            if (stack.size == 0) result.add(x)\n        })\n        if (close.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdbim9r3k.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdbim9r3k.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdbim9r3k.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdbim9r3k.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795025
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp63zhqdy9.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp63zhqdy9.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel d"
  stdout: ''
  timestamp: 1659795033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                val top = stack.pop()\n\
    \                if (top == \"(\") {\n                    result.append(\"Yes\"\
    )\n                } else {\n                    result.append(\"No\")\n     \
    \           }\n            }\n        })\n        if (result.size == stackMax)\
    \ {\n            result.append(\"Yes\")\n        } else {\n            result.append(\"\
    No\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwq560xcj.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwq560xcj.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case \")()\" => open.add(x)\n                case \")()()\" => open.add(x)\n\
    \                case \")()()()\" => open.add(x)\n                case \")()()()()\"\
    \ => open.add(x)\n                case \")()()()()()\" => open.add(x)\n      \
    \          case \")()()()()()()\" => open.add(x)\n                case \")()()()()()()()\"\
    \ => open.add(x)\n                case \")()()()()()()()()\" => open.add(x)\n\
    \                case \")()()()()()()()()()\" => open.add(x)\n               \
    \ case \")()()()()()()()()()()\" => open.add(x)\n                case \")()()()()()()()()()()\"\
    \ => open.add(x)\n                case \")()()()()()()()()()()\" => open.add(x)\n\
    \                case \")()()()()()()()()()()()\" => open.add(x)\n           \
    \     case \")()()()()()()()()()()()()\" => open.add(x)\n                case\
    \ \")()()()()()()()()()()()()()\" => open.add(x)\n                case \")()()()()()()()()()()()()()\"\
    \ => open.add(x)\n                case \")()()()()()()()()()()()()()\" => open.add(x)\n\
    \                case \")()()()()()()()()()()()()()\" => open.add(x)\n       \
    \         case \")()()()()()()()()()()()()()()\" => open.add(x)\n            \
    \    case \")()()()()()()()()()()()()()()\" => open.add(x)\n                case\
    \ \")()()()()()()()()()()()()()()\" => open.add(x)\n                case \")()()()()()()()()()()()()()()()\"\
    \ => open.add(x)\n                case \")()()()()()()()()()()()()()()()\" =>\
    \ open.add(x)\n                case \")()()()()()()()()()()()()()()()\" => open.add(x)\n\
    \                case \")()()()()\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwvymmc8s.scala:50:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                \e[33mcase\e[0m \")()()()()\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmpwvymmc8s.scala:52:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m52 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpwvymmc8s.scala:68:0 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvymmc8s.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvymmc8s.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvymmc8s.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwvymmc8s.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mut"
  stdout: ''
  timestamp: 1659795027
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach { x =>\n            if (x.equals(\"(\")) {\n                stack.push(x)\n\
    \            } else if (x.equals(\")\")) {\n                val top = stack.pop()\n\
    \                if (top.equals(\"(\")) {\n                    stack.push(top)\n\
    \                } else {\n                    result.add(\"No\")\n          \
    \      }\n            }\n        }\n        if (stack.size == stackMax) {\n  \
    \          result.add(\"Yes\")\n        } else {\n            result.add(\"No\"\
    )\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe2b21fab.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe2b21fab.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    stack.pop()\n                case \")(\"  =>\n     \
    \               stack += s\n                case \")()\" =>\n                \
    \    stack += s\n                case \")()()\" =>\n                    stack\
    \ += s\n                case _ =>\n                    result += (s +: stack.mkString(\"\
    (\", \")\"))\n            }\n        }\n        if (stack.size == 0)\n       \
    \     \"No\"\n        else\n            \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpod0hwp5z.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpod0hwp5z.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795028
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue\
    \ += x else if (!x == \")\") bad += x)\n        val len = stack.length\n     \
    \   val goodLen = good.length\n        val badLen = bad.length\n        if (len\
    \ == 0 || goodLen == 0 || badLen == 0) \"No\"\n        else if (len == goodLen\
    \ && goodLen == badLen) \"Yes\"\n        else if (len == goodLen || len == badLen)\
    \ \"Yes\"\n        else matchParens(stack.take(len), queue.take(len), good.take(len),\
    \ bad.take(len))\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiras7nr6.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpiras7nr6.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpiras7nr6.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpiras7nr6.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpiras7nr6.scala:22:59 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) bad\
    \ += x)\n\e[31m\e[31m   |\e[0m                                               \
    \            ^^\e[0m\n\e[31m   |\e[0m                                 value unary_!\
    \ is not a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiras7nr6.scala:22:90\
    \ ---------------"
  stdout: ''
  timestamp: 1659795037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodStr = mutable.Set[String]()\n        val badStr = mutable.Set[String]()\n\
    \        val goodParen = mutable.Set[String]()\n        val badParen = mutable.Set[String]()\n\
    \        val goodParenCount = mutable.Set[String]()\n        val badParenCount\
    \ = mutable.Set[String]()\n        val goodParenCount = mutable.Set[String]()\n\
    \        val badParenCount = mutable.Set[String]()\n        val goodParenCount\
    \ = mutable.Set[String]()\n        val badParenCount = mutable.Set[String]()\n\
    \        val goodParenCount = mutable.Set[String]()\n        val badParenCount\
    \ = mutable.Set[String]()\n        val goodParenCount = mutable.Set[String]()\n\
    \        val badParenCount = mutable.Set[String]()\n        val goodParenCount\
    \ = mutable.Set[String]()\n        val badParenCount = mutable.Set[String]()\n\
    \        val goodParenCount = mutable.Set[String]()\n        val badParenCount\
    \ = mutable.Set[String]()\n        val goodParenCount = mutable.Set[String]()\n\
    \        val badParenCount = mutable.Set[String]()\n        val goodParenCount\
    \ = mutable.Set[String]()\n        val badParenCount = mutable.Set[String]()\n\
    \        val goodParenCount = mutable.Set[String]()\n        val badParenCount\
    \ = mutable.Set[String]()\n        val goodParenCount = mutable.Set[String]()\n\
    \        val badParenCount = mutable.Set[String]()\n        val goodParenCount\
    \ = mutable.Set[String]()\n        val badParenCount = mutable.Set[String]()\n\
    \        val goodParenCount = mutable.Set[String]()\n        val badParenCount\
    \ = mutable.Set[String]()\n        val goodParenCount = mutable.Set[String]()\n\
    \        val badParenCount = mutable.Set[String]()\n        val goodParenCount\
    \ = mutable.Set[String]()\n        val badParenCount = mutable.Set[String]()\n\
    \        val goodParenCount = mutable.Set[String]()\n        val badParenCount\
    \ = mutable.Set[String]()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi2xvnzjq.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mgoodParenCount\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodParenCount is already defined as \e[33mvalue\e[0m \e[35mgoodParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi2xvnzjq.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mbadParenCount\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadParenCount is already defined as \e[33mvalue\e[0m \e[35mbadParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi2xvnzjq.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mgoodParenCount\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodParenCount is already defined as \e[33mvalue\e[0m \e[35mgoodParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi2xvnzjq.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mbadParenCount\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadParenCount is already defined as \e[33mvalue\e[0m \e[35mbadParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi2xvnzjq.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mgoodParenCount\e[0m = mutable.Set[\e\
    [35m"
  stdout: ''
  timestamp: 1659795035
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    closeCount += closeCount.length\n                \
    \    closeCount -= 1\n                    close.toStack foreach { x => stack +=\
    \ x }\n                    stack.toStack foreach { x => result += x }\n      \
    \          }\n                case \")(\" => {\n                    openCount\
    \ += openCount.length\n                    openCount -= 1\n                  \
    \  open.toStack foreach { x => stack += x }\n                    stack.toStack\
    \ foreach { x => result += x }\n                }\n                case \")(\"\
    \ => {\n                    openCount += openCount.length\n                  \
    \  openCount -= 1\n                    open.toStack foreach { x => stack += x\
    \ }\n                    stack.toStack foreach { x => result += x }\n        \
    \        }\n                case \")(\" => {\n                    openCount +=\
    \ openCount.length\n                    openCount -= 1\n                    open.toStack\
    \ foreach { x => stack += x }\n                    stack.toStack foreach { x =>\
    \ result += x }\n                }\n                case \")(\" => {\n       \
    \             openCount += openCount.length\n                    openCount -=\
    \ 1\n                    open.toStack foreach { x => stack += x }\n          \
    \          stack.toStack foreach { x => result += x }\n                }\n   \
    \             case \")(\" => {\n                    openCount += openCount.length\n\
    \                    openCount -= 1\n                    open.toStack foreach\
    \ { x => stack += x }\n                    stack.toStack foreach { x => result\
    \ += x }\n                }\n                case \")(\" => {\n              \
    \      openCount += openCount.length\n                    openCount -= 1\n   \
    \                 open.toStack foreach { x => stack += x }\n                 \
    \   stack.toStack foreach { x => result += x }\n                }\n          \
    \      case \")(\" => {\n                    openCount += openCount.length\n \
    \                   openCount -= 1\n                    open.toStack foreach {\
    \ x => stack += x }\n                    stack.toStack foreach { x => result +=\
    \ x }\n                }\n                case \")(\" => {\n                 \
    \   openCount += openCount.length\n                    open\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvaqwufmh.scala:94:0 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvaqwufmh.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvaqwufmh.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvaqwufmh.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvaqwufmh.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvaqwufmh.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when co"
  stdout: ''
  timestamp: 1659795039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case \")(\"  => stack += x\n                case \")\" => stack += x\n   \
    \             case \")\" => close.add(x)\n                case _ => stack += x\n\
    \            }\n        })\n        val openCount = open.size\n        val closeCount\
    \ = close.size\n        if (openCount == closeCount) {\n            val openList\
    \ = open.iterator\n            val closeList = close.iterator\n            while\
    \ (openList.hasNext && closeList.hasNext) {\n                val open = openList.next()\n\
    \                val close = closeList.next()\n                if (open == close)\
    \ {\n                    result += \"Yes\"\n                } else {\n       \
    \             result += \"No\"\n                }\n            }\n        }\n\
    \        result.toString()\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm_vb7zgm.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm_vb7zgm.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm_vb7zgm.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpm_vb7zgm.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795032
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = 0\n        val\
    \ stackMinIndex = stackSize - 1\n        val stackMaxStack = mutable.Stack[String]()\n\
    \        val stackMinStack = mutable.Stack[String]()\n        val stackMaxStackSize\
    \ = stackMaxStack.size\n        val stackMinStackSize = stackMinStack.size\n \
    \       val stackMaxStackIndex = stackMaxStackSize - 1\n        val stackMinStackIndex\
    \ = stackMinStackSize - 1\n        val stackMaxStackMinStack = mutable.Stack[String]()\n\
    \        val stackMinStackMaxStack = mutable.Stack[String]()\n        val stackMaxStackMinStackSize\
    \ = stackMaxStackMinStack.size\n        val stackMinStackMaxStackSize = stackMinStackMaxStack.size\n\
    \        val stackMaxStackMinStackIndex = stackMaxStackMinStackSize - 1\n    \
    \    val stackMinStackMaxStackIndex = stackMinStackMaxStackSize - 1\n        val\
    \ stackMaxStackMinStackIndex2 = stackMaxStackMinStackIndex - 1\n        val stackMinStackMaxStackIndex2\
    \ = stackMinStackMaxStackIndex - 1\n        val stackMaxStackMinStackIndex3 =\
    \ stackMaxStackMinStackIndex2 - 1\n        val stackMinStackMaxStackIndex3 = stackMinStackMaxStackIndex2\
    \ - 1\n        val stackMaxStackMinStackIndex4 = stackMaxStackMinStackIndex3 -\
    \ 1\n        val stackMinStackMaxStackIndex4 = stackMinStackMaxStackIndex3 - 1\n\
    \        val stackMaxStackMinStackIndex5 = stackMaxStackMinStackIndex4 - 1\n \
    \       val stackMinStackMaxStackIndex5 = stackMinStackMaxStackIndex4 - 1\n  \
    \      val stackMaxStackMinStackIndex6 = stackMaxStackMinStackIndex5 - 1\n   \
    \     val stackMinStackMaxStackIndex6 = stackMinStackMaxStackIndex5 - 1\n    \
    \    val stackMaxStackMinStackIndex7 = stackMaxStackMinStackIndex6 - 1\n     \
    \   val stackMinStackMaxStackIndex7 = stackMinStackMaxStackIndex6 - 1\n      \
    \  val stackMaxStackMinStackIndex8 = stackMaxStackMinStackIndex7 - 1\n       \
    \ val stackMinStackMaxStackIndex8 = stackMinStackMaxStackIndex7 - 1\n        val\
    \ stackMaxStackMinStackIndex9 = stackMaxStackMinStackIndex8 - 1\n        val stackMinStackMaxStackIndex9\
    \ = stackMin\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0r352kh.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf0r352kh.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf0r352kh.scala:25:28 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mstackMaxStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0r352kh.scala:26:28 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mstackMinStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0r352kh.scala:31:36 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mstackMaxStackMinStack\e\
    [0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpf0r352kh.scala:32:36 -------------"
  stdout: ''
  timestamp: 1659795037
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        for(i <- 0 until lst.size)\
    \ {\n            if(i == lst.size - 1) {\n                result += \"Yes\"\n\
    \                return result.toString\n            }\n            if(i == 0)\
    \ {\n                result += \"No\"\n                return result.toString\n\
    \            }\n            if((lst(i).charAt(0) == '(') && (lst(i).charAt(lst(i).length\
    \ - 1) == ')')) {\n                stack += lst(i)\n                queue += lst(i\
    \ + 1)\n            }\n            if((lst(i).charAt(0) == ')') && (lst(i).charAt(lst(i).length\
    \ - 1) == '(')) {\n                stack -= lst(i)\n                queue -= lst(i\
    \ + 1)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvvnuall1.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvvnuall1.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvvnuall1.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpvvnuall1.scala:21:8 ---------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until lst.size)\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Unit\n\
    \e[31m   |\e[0m        Required: String\n\e[31m22 |\e[0m            \e[33mif\e\
    [0m(i == lst.size - \e[31m1\e[0m) {\n\e[31m23 |\e[0m                result +=\
    \ \e[31m\"Yes\"\e[0m\n\e[31m24 |\e[0m                \e[33mreturn\e[0m result.toString\n\
    \e[31m25 |\e[0m            }\n\e[31m26 |\e[0m            \e[33mif\e[0m(i == \e\
    [31m0\e[0m) {\n\e[31m27 |\e[0m                result += \e[31m\"No\"\e[0m\n\e\
    [31m28 |\e[0m                \e[33mreturn\e[0m result.toString\n\e[31m29 |\e[0m\
    \            }\n\e[31m30 |\e[0m            \e[33mif\e[0m((lst(i).charAt(\e[31m0\e\
    [0m) == \e[31m'('\e[0m) && (lst(i).charAt(lst(i).length - \e[31m1\e[0m) == \e\
    [31m')'\e[0m)) {\n\e[31m31 |\e[0m                stack += lst(i)\n\e[31m32 |\e\
    [0m                queue += lst(i + \e[31"
  stdout: ''
  timestamp: 1659795038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.contains(x)) stack += x\n\
    \            if (close.contains(x)) stack -= x\n        })\n        if (stack.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp25x84bkx.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp25x84bkx.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp25x84bkx.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp25x84bkx.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                stack.push(x)\n            } else if (x == \")\") {\n\
    \                close += x\n                stack.pop()\n            }\n    \
    \    })\n        if (open.size == 0 && close.size == 0) {\n            result.append(\"\
    Yes\")\n        } else {\n            result.append(\"No\")\n        }\n     \
    \   return result.toString()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp32j9yx2h.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp32j9yx2h.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp32j9yx2h.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp32j9yx2h.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        for(i <- 0 until stackSize) {\n   \
    \         val str = lst(i)\n            val open = str.indexOf(\"(\")\n      \
    \      val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n\
    \                result.append(\"No\")\n            } else {\n               \
    \ val openCount = stackSize - stack.size\n                val closeCount = openCount\
    \ - close\n                if(openCount > closeCount) {\n                    stack\
    \ += str\n                } else {\n                    stack -= str\n       \
    \         }\n                result.append(\"Yes\")\n            }\n        }\n\
    \        result.toString()\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk6mszfq5.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpk6mszfq5.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795034
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMaxValue = lst(stackMaxIndex)\n\
    \        val stackMinValue = lst(0)\n        val stackMinIndex = stackSize - 1\n\
    \        val stackMinValue = lst(stackMinIndex)\n        val stackMinIndexValue\
    \ = lst(stackMinIndex - 1)\n        val stackMaxIndexValue = lst(stackMaxIndex\
    \ - 1)\n        val stackMinIndexValueValue = lst(stackMinIndex - 1)\n       \
    \ val stackMaxIndexValueValue = lst(stackMaxIndex - 1)\n        val stackMinIndexValueValueValue\
    \ = lst(stackMinIndex - 1)\n        val stackMaxIndexValueValueValue = lst(stackMaxIndex\
    \ - 1)\n        val stackMinIndexValueValueValueValue = lst(stackMinIndex - 1)\n\
    \        val stackMaxIndexValueValueValueValue = lst(stackMaxIndex - 1)\n    \
    \    val stackMinIndexValueValueValueValueValue = lst(stackMinIndex - 1)\n   \
    \     val stackMaxIndexValueValueValueValueValue = lst(stackMaxIndex - 1)\n  \
    \      val stackMinIndexValueValueValueValueValueValue = lst(stackMinIndex - 1)\n\
    \        val stackMaxIndexValueValueValueValueValueValue = lst(stackMaxIndex -\
    \ 1)\n        val stackMinIndexValueValueValueValueValueValueValue = lst(stackMinIndex\
    \ - 1)\n        val stackMaxIndexValueValueValueValueValueValueValue = lst(stackMaxIndex\
    \ - 1)\n        val stackMinIndexValueValueValueValueValueValueValueValue = lst(stackMinIndex\
    \ - 1)\n        val stackMaxIndexValueValueValueValueValueValueValueValue = lst(stackMaxIndex\
    \ - 1)\n        val stackMinIndexValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMinIndex - 1)\n        val stackMaxIndexValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMaxIndex - 1)\n        val stackMinIndexValueValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMinIndex - 1)\n        val stackMaxIndexValueValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMaxIndex - 1)\n        val stackMinIndexValueValueValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMinIndex - 1)\n        val stackMaxIndexValueValueValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMaxIndex - 1)\n        val stackMinIndexValueValueValueValueValueValueValueValueValueValueValueValue\
    \ = lst(stackMinIndex - 1)\n        val stack\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf6fme6du.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf6fme6du.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMinValue\e[0m = lst(stackMinIndex)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackMinValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackMinValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf6fme6du.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf6fme6du.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf6fme6du.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackIndex = 0\n        val\
    \ stackMaxValue = lst(stackMaxIndex)\n        val stackValue = lst(stackIndex)\n\
    \        val stackMaxValueIndex = stackSize - 1\n        val stackMaxValueIndex2\
    \ = stackSize - 1\n        val stackValueIndex = 0\n        val stackValueIndex2\
    \ = stackSize - 1\n        val stackValueIndex3 = stackSize - 1\n        val stackValueIndex4\
    \ = stackSize - 1\n        val stackValueIndex5 = stackSize - 1\n        val stackValueIndex6\
    \ = stackSize - 1\n        val stackValueIndex7 = stackSize - 1\n        val stackValueIndex8\
    \ = stackSize - 1\n        val stackValueIndex9 = stackSize - 1\n        val stackValueIndex10\
    \ = stackSize - 1\n        val stackValueIndex11 = stackSize - 1\n        val\
    \ stackValueIndex12 = stackSize - 1\n        val stackValueIndex13 = stackSize\
    \ - 1\n        val stackValueIndex14 = stackSize - 1\n        val stackValueIndex15\
    \ = stackSize - 1\n        val stackValueIndex16 = stackSize - 1\n        val\
    \ stackValueIndex17 = stackSize - 1\n        val stackValueIndex18 = stackSize\
    \ - 1\n        val stackValueIndex19 = stackSize - 1\n        val stackValueIndex20\
    \ = stackSize - 1\n        val stackValueIndex21 = stackSize - 1\n        val\
    \ stackValueIndex22 = stackSize - 1\n        val stackValueIndex23 = stackSize\
    \ - 1\n        val stackValueIndex24 = stackSize - 1\n        val stackValueIndex25\
    \ = stackSize - 1\n        val stackValueIndex26 = stackSize - 1\n        val\
    \ stackValueIndex27 = stackSize - 1\n        val stackValueIndex28 = stackSize\
    \ - 1\n        val stackValueIndex29 = stackSize - 1\n        val stackValueIndex30\
    \ = stackSize - 1\n        val stackValueIndex31 = stackSize - 1\n        val\
    \ stackValueIndex32 = stackSize - 1\n        val stackValueIndex33 = stackSize\
    \ - 1\n        val stackValueIndex34 = stackSize - 1\n        val stackValueIndex35\
    \ = stackSize - 1\n        val stackValueIndex36 = stackSize - 1\n        val\
    \ stackValueIndex37 = stackSize - 1\n        val stackValueIndex38 = stackSize\
    \ - 1\n        val stackValueIndex39 = stackSize - 1\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkl0hwgrv.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkl0hwgrv.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpkl0hwgrv.scala:68:5 ---------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val open = mutable.Set[String]()\n\
    \        val close = mutable.Set[String]()\n        lst.foreach(x => if (x contains\
    \ \"(\") open += x)\n        lst.foreach(x => if (x contains \")\") close += x)\n\
    \        open foreach { x => stack push x }\n        close foreach { x => queue\
    \ push x }\n        while(stack.nonEmpty || queue.nonEmpty) {\n            val\
    \ x = stack.pop\n            val y = queue.pop\n            if (x contains \"\
    (\") stack push y\n            if (x contains \")\") queue push y\n          \
    \  if (x contains \"(\") open += y\n            if (x contains \")\") close +=\
    \ y\n        }\n        if (open contains \"()\" && close contains \"()\") \"\
    Yes\"\n        else if (!open contains \"()\" && close contains \"()\") \"No\"\
    \n        else matchParens(lst)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfwsoxbao.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfwsoxbao.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfwsoxbao.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfwsoxbao.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfwsoxbao.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795036
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach(x => {\n            x match {\n                case \")\" =>\
    \ {\n                    stackSize -= 1\n                    stack.toList.reverse.foreach(y\
    \ => {\n                        y match {\n                            case \"\
    )\" => {\n                                stackSize -= 1\n                   \
    \             stack.toList.reverse.foreach(z => {\n                          \
    \          z match {\n                                        case \")\" => {\n\
    \                                            stackSize -= 1\n                \
    \                            stack.toList.reverse.foreach(w => {\n           \
    \                                     w match {\n                            \
    \                        case \")\" => {\n                                   \
    \                     stackSize -= 1\n                                       \
    \                 stack.toList.reverse.foreach(x => {\n                      \
    \                                      x match {\n                           \
    \                                     case \")\" => {\n                      \
    \                                              stackSize -= 1\n              \
    \                                                      stack.toList.reverse.foreach(y\
    \ => {\n                                                                     \
    \   y match {\n                                                              \
    \              case \")\" => {\n                                             \
    \                                   stackSize -= 1\n                         \
    \                                                       stack.toList.reverse.foreach(z\
    \ => {\n                                                                     \
    \               z match {\n                                                  \
    \                                      case \")\" => {\n                     \
    \                                                                       stackSize\
    \ -= 1\n                                                                     \
    \                       stack.toList.reverse.foreach(w => {\n                \
    \                                                                            \
    \    w match {\n                                                             \
    \                                       case \")\" => {\n                    \
    \                                                                            \
    \        stackSize -= 1\n                                                    \
    \                                                    stack.toList.reverse.foreach(x\
    \ => {\n                                                                     \
    \                                       x match {\n                          \
    \                                                                            \
    \          case \")\" => {\n                                                 \
    \                                                                   stackSize\
    \ -= 1\n                                                                     \
    \                                               stack.toList.reverse.foreach(y\
    \ => {\n                                                                     \
    \                                                   y match {\n              \
    \                                                                            \
    \                                  case \")\" => {\n                         \
    \                                                                            \
    \                           stackSize -= 1\n                                 \
    \                                                                            \
    \                   stack.toList.reverse.foreach(z => {\n                    \
    \                                                                            \
    \                                    z match {\n                             \
    \                                                                            \
    \                               case \")\" => {\n                            \
    \                                                                            \
    \                                    stackSize -= 1\n                        \
    \                                                                            \
    \                                        stack.toList.reverse.foreach(w => {\n\
    \                                                                            \
    \                                                                    w match {\n\
    \                                                                            \
    \                                                                    case \")\"\
    \ => {\n                                                                     \
    \                                                                            \
    \   stackSize -= 1\n                                                         \
    \                                                                            \
    \               stack.toList.reverse.foreach(x => {\n                        \
    \                                                                            \
    \                                                    x match {\n             \
    \                                                                            \
    \                                                                   case \")\"\
    \ => {\n                                                                     \
    \                                                                            \
    \               stackSize -= 1\n                                             \
    \                                                                            \
    \                                       stack.toList.reverse.foreach(y => {\n\
    \                                                                            \
    \                                                                            \
    \            y match {\n                                                     \
    \                                                                            \
    \                                       case \")\" => {\n                    \
    \                                                                            \
    \                                                                            stackSize\
    \ -= 1\n                                                                     \
    \                                                                            \
    \                           stack.toList.reverse.foreach(z => {\n            \
    \                                                                            \
    \                                                                            \
    \            z match {\n                                                     \
    \                                                                            \
    \                                                   case \")\" => {\n        \
    \                                                                            \
    \                                                                            \
    \                        stackSize -= 1\n                                    \
    \                                                                            \
    \                                                                        stack.toList.reverse.foreach(w\
    \ => {\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptd5xwll4.scala:85:4 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmptd5xwll4.scala:101:0 ---------------------------\e[0m\e[0m\n\e[31m101\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptd5xwll4.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptd5xwll4.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmptd5xwll4.scala:25:30 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659795011
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        val openSet = mutable.Set[String]()\n        val closeSet = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                openCount += 1\n                openSet += x\n       \
    \     } else if (x == \")\") {\n                close += x\n                closeCount\
    \ += 1\n                closeSet += x\n            } else {\n                stack\
    \ += x\n            }\n        })\n        if (openCount.sum == closeCount.sum)\
    \ {\n            val openSetStr = openSet.mkString(\"(\", \")\")\n           \
    \ val closeSetStr = closeSet.mkString(\"(\", \")\")\n            val openStr =\
    \ (open mkString \"(\", \")\")\n            val closeStr = (close mkString \"\
    (\", \")\")\n            val openStrLen = openStr.length\n            val closeStrLen\
    \ = closeStr.length\n            if (openStrLen > closeStrLen) {\n           \
    \     result += \"Yes\"\n            } else {\n                result += \"No\"\
    \n            }\n        } else {\n            result += \"No\"\n        }\n \
    \       result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpibi1ed0z.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpibi1ed0z.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpibi1ed0z.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpibi1ed0z.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpibi1ed0z.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpibi1ed0z.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m ="
  stdout: ''
  timestamp: 1659795044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    stack.pop\n                    queue.enqueue(x)\n  \
    \              case \")(\"  =>\n                    stack.push(x)\n          \
    \      case \")(\"  =>\n                    stack.push(x)\n                case\
    \ \")\" =>\n                    queue.enqueue(x)\n                case \")\" =>\n\
    \                    queue.enqueue(x)\n                case \")\" =>\n       \
    \             queue.enqueue(x)\n                case \")\" =>\n              \
    \      queue.enqueue(x)\n                case \")\" =>\n                    queue.enqueue(x)\n\
    \                case \")\" =>\n                    queue.enqueue(x)\n       \
    \         case \")\" =>\n                    queue.enqueue(x)\n              \
    \  case \")\" =>\n                    queue.enqueue(x)\n                case \"\
    )\" =>\n                    queue.enqueue(x)\n                case \")\" =>\n\
    \                    queue.enqueue(x)\n                case \")\" =>\n       \
    \             queue.enqueue(x)\n                case \")\" =>\n              \
    \      queue.enqueue(x)\n                case \")\" =>\n                    queue.enqueue(x)\n\
    \                case \")\" =>\n                    queue.enqueue(x)\n       \
    \         case \")\" =>\n                    queue.enqueue(x)\n              \
    \  case \")\" =>\n                    queue.enqueue(x)\n                case \"\
    )\" =>\n                    queue.enqueue(x)\n                case \")\" =>\n\
    \                    queue.enqueue(x)\n                case \")\" =>\n       \
    \             queue.enqueue(x)\n                case \")\" =>\n              \
    \      queue.enqueue(x)\n                case \")\" =>\n                    queue.enqueue(x)\n\
    \                case \")\" =>\n                    queue.enqueue(x)\n       \
    \         case \")\" =>\n                    queue.enqueue(x)\n              \
    \  case \")\" =>\n                    queue.enqueue(x)\n                case \"\
    )\" =>\n                    queue.enqueue(x)\n                case \")\" =>\n\
    \                    queue.enqueue(x)\n                case \")\" =>\n       \
    \             queue.enqueue(x)\n                case \")\" =>\n              \
    \      queue.enqueue(x)\n                case \")\" =>\n                    queue.enqueue(x)\n\
    \                case \")\" =>\n                    queue.enqueue(x)\n       \
    \         case \")\" =>\n                    queue.enqueue(x)\n              \
    \  case \")\" =>\n                    queue.enqueue(x)\n                case \"\
    )\" =>\n                    queue.enqueue(x)\n                case \")\" =>\n\
    \                    queue.enqueue(x)\n                case \")\" =>\n       \
    \             queue.enqueue(x)\n                case \")\" =>\n              \
    \      queue.enqueue(x)\n                case \")\" =>\n                    queue.enqueue(x)\n\
    \                case \")\" =>\n                    queue.enqueue\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvm8idu_a.scala:124:0 ---------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvm8idu_a.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvm8idu_a.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvm8idu_a.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvm8idu_a.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvm8idu_a.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m =>\n\e[31m 25 |\e[0m           "
  stdout: ''
  timestamp: 1659795045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.add(x)\n\
    \            case x if x == \"(\" => open.add(x)\n            case _ => stack\
    \ += x\n        })\n        val openCount = open.size\n        val closeCount\
    \ = close.size\n        if (openCount == closeCount) {\n            val openList\
    \ = open.iterator\n            while (openList.hasNext) {\n                val\
    \ open = openList.next\n                val closeList = close.iterator\n     \
    \           while (closeList.hasNext) {\n                    val close = closeList.next\n\
    \                    if (open == close) {\n                        result += \"\
    Yes\"\n                        break\n                    }\n                }\n\
    \            }\n        } else {\n            result += \"No\"\n        }\n  \
    \      result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp714dwm1y.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp714dwm1y.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp714dwm1y.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp714dwm1y.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp714dwm1y.scala:38:24 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795039
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxSize = stackMax * 2\n        val stackMaxMax = stackMaxSize -\
    \ 1\n        val stackMaxMaxSize = stackMaxMax * 2\n        val stackMaxMaxMax\
    \ = stackMaxMaxSize - 1\n        val stackMaxMaxMaxSize = stackMaxMaxMax * 2\n\
    \        val stackMaxMaxMaxMax = stackMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMax = stackMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMax * 2\n     \
    \   val stackMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxSize - 1\n        val stackMaxMaxMaxMaxMaxMaxSize\
    \ = stackMaxMaxMaxMaxMaxMax * 2\n        val stackMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - 1\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\
    \ * 2\n        val stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkmvh78dd.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkmvh78dd.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpkmvh78dd.scala:34:45 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mstackMaxMaxMaxMaxMaxMaxMaxSize\e\
    [0m = stackMaxMaxMaxMaxMaxMaxMax * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                      ^\e[0m\n\e[31m   |\e[0m               \
    \    Recursive \e[33mvalue\e[0m \e[35mstackMaxMaxMaxMaxMaxMaxMax\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkmvh78dd.scala:37:47\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxMaxMaxMaxMaxMaxMaxMaxMax\e[0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                Not found: stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkmvh78dd.scala:41:53 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mstackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMax\e\
    [0m = stackMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxMaxSize - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                                 "
  stdout: ''
  timestamp: 1659795047
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack += x else if (!x == \"(\") queue += x else ())\n        while (!stack.isEmpty\
    \ && !queue.isEmpty) {\n            val first = stack.pop()\n            val second\
    \ = queue.pop()\n            if (first == second) {\n                good += first\n\
    \            } else {\n                good += first\n                good +=\
    \ second\n            }\n        }\n        if (good.size == lst.length) \"Yes\"\
    \ else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphv236dzb.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphv236dzb.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphv236dzb.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmphv236dzb.scala:21:59 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m ())\n\e[31m\e[31m   |\e[0m              \
    \                                             ^^\e[0m\n\e[31m   |\e[0m       \
    \                          value unary_! is not a member of String\n4 errors found\n"
  stdout: ''
  timestamp: 1659795047
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach { s =>\n      \
    \      s match {\n                case \")\" =>\n                    close.foreach(c\
    \ => stack += c)\n                    result ++= stack.reverse\n             \
    \       stack.remove\n                case \")(\"  =>\n                    open\
    \ += s\n                case \")(\" =>\n                    open -= s\n      \
    \          case \")()\" =>\n                    open -= s\n                  \
    \  result ++= stack.reverse\n                    stack.remove\n              \
    \  case \")()\" =>\n                    open -= s\n                    result\
    \ ++= stack.reverse\n                    stack.remove\n                case \"\
    )(\" =>\n                    open += s\n                case \")\" =>\n      \
    \              open -= s\n                    result ++= stack.reverse\n     \
    \               stack.remove\n                case \")\" =>\n                \
    \    open -= s\n                    result ++= stack.reverse\n               \
    \     stack.remove\n                case _ =>\n                    good += s\n\
    \            }\n        }\n        if (good.size == 0) {\n            \"No\"\n\
    \        } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn5hu5uwi.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn5hu5uwi.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn5hu5uwi.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpn5hu5uwi.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn5hu5uwi.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach(x => {\n            x match {\n                case \")\" =>\
    \ {\n                    stackSize -= 1\n                    stack.toList.reverse.foreach(y\
    \ => result += y)\n                    stack.toList.reverse.foreach(y => stack\
    \ += y)\n                }\n                case \"(\" => {\n                \
    \    stackSize += 1\n                    stack.toList.reverse.foreach(y => stack\
    \ += y)\n                }\n                case _ => stack.toList.reverse.foreach(y\
    \ => stack += y)\n            }\n        })\n        if (stackSize == 0) {\n \
    \           result.mkString(\"(\", \")\")\n        } else {\n            \"No\"\
    \n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2ubwf94f.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2ubwf94f.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2ubwf94f.scala:25:30 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2ubwf94f.scala:30:30 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    stackSize += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value += is not a member of Int - did you mean stackSize.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659795050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    stack.pop() match {\n                        case Some(\"\
    (\") => queue.add(x)\n                        case _ => bad.add(x)\n         \
    \           }\n                case \")(\"  =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => queue.add(x)\n        \
    \                case _ => bad.add(x)\n                    }\n               \
    \ case \")()\" =>\n                    stack.pop() match {\n                 \
    \       case Some(\"(\") => queue.add(x)\n                        case _ => bad.add(x)\n\
    \                    }\n                case \")()()\" =>\n                  \
    \  stack.pop() match {\n                        case Some(\"(\") => queue.add(x)\n\
    \                        case _ => bad.add(x)\n                    }\n       \
    \         case \")()()()\" =>\n                    stack.pop() match {\n     \
    \                   case Some(\"(\") => queue.add(x)\n                       \
    \ case _ => bad.add(x)\n                    }\n                case \")()()()()\"\
    \ =>\n                    stack.pop() match {\n                        case Some(\"\
    (\") => queue.add(x)\n                        case _ => bad.add(x)\n         \
    \           }\n                case \")()()()()()\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => queue.add(x)\n        \
    \                case _ => bad.add(x)\n                    }\n               \
    \ case \")()()()()()()\" =>\n                    stack.pop() match {\n       \
    \                 case Some(\"(\") => queue.add(x)\n                        case\
    \ _ => bad.add(x)\n                    }\n                case \")()()()()()()()\"\
    \ =>\n                    stack.pop() match {\n                        case Some(\"\
    (\") => queue.add(x)\n                        case _ => bad.add(x)\n         \
    \           }\n                case \")()()()()()()()\" =>\n                 \
    \   stack.pop() match {\n                        case Some(\"(\") => queue.add(x)\n\
    \                        case _ => bad.add(x)\n                    }\n       \
    \         case \")()()()()()()()()\" =>\n                    stack.pop() match\
    \ {\n                        case Some(\"(\") => queue.add(x)\n              \
    \          case _ => bad.add(x)\n                    }\n                case \"\
    )()()()()()()()()()\" =>\n                    stack.pop() match {\n          \
    \              case Some(\"(\") => queue.add(x)\n                        case\
    \ _ => bad.add(x)\n                    }\n                case \")()()()()()()()()()\"\
    \ =>\n                    stack\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpef2bh5zq.scala:103:0 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpef2bh5zq.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpef2bh5zq.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpef2bh5zq.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpef2bh5zq.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpef2bh5zq.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m =>\n\e[31m 25 |\e[0m           "
  stdout: ''
  timestamp: 1659795051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open.add(x)\n       \
    \     if (x == \")\") close.add(x)\n            if (open.isEmpty && close.isEmpty)\
    \ stack += x\n            if (open.isEmpty && !close.isEmpty) {\n            \
    \    if (stack.size == 0) result += \"No\"\n                else if (stack.size\
    \ == 1) result += \"Yes\"\n                else if (stack.size > 1) result +=\
    \ \"Yes\"\n            }\n            if (close.isEmpty && !open.isEmpty) {\n\
    \                if (stack.size == 0) result += \"No\"\n                else if\
    \ (stack.size == 1) result += \"Yes\"\n                else if (stack.size > 1)\
    \ result += \"Yes\"\n            }\n        })\n        stack.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkv_fkwms.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkv_fkwms.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkv_fkwms.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkv_fkwms.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                openCount += 1 \n            } else if (x == \")\") {\n\
    \                close += x\n                closeCount += 1 \n            } else\
    \ if (openCount.sum == closeCount.sum) {\n                stack += x\n       \
    \     } else {\n                result += \"No\"\n            }\n        })\n\
    \        if (openCount.sum == closeCount.sum) {\n            result += \"Yes\"\
    \n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz1n3xfhw.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz1n3xfhw.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz1n3xfhw.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpz1n3xfhw.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz1n3xfhw.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz1n3xfhw.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m ="
  stdout: ''
  timestamp: 1659795046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    if (!stack.isEmpty) {\n                        val\
    \ top = stack.pop()\n                        if (top.equals(\"(\")) {\n      \
    \                      queue.enqueue(top)\n                        } else {\n\
    \                            bad.add(top)\n                        }\n       \
    \             }\n                }\n                case \")(\"  => {\n      \
    \              if (!queue.isEmpty) {\n                        val top = queue.pop()\n\
    \                        if (top.equals(\"(\")) {\n                          \
    \  stack.enqueue(top)\n                        } else {\n                    \
    \        bad.add(top)\n                        }\n                    }\n    \
    \            }\n                case \")()\" => {\n                    if (!queue.isEmpty)\
    \ {\n                        val top = queue.pop()\n                        if\
    \ (top.equals(\"(\")) {\n                            stack.enqueue(top)\n    \
    \                    } else {\n                            bad.add(top)\n    \
    \                    }\n                    }\n                }\n           \
    \     case \")()()\" => {\n                    if (!queue.isEmpty) {\n       \
    \                 val top = queue.pop()\n                        if (top.equals(\"\
    (\")) {\n                            stack.enqueue(top)\n                    \
    \    } else {\n                            bad.add(top)\n                    \
    \    }\n                    }\n                }\n                case \")()()()\"\
    \ => {\n                    if (!queue.isEmpty) {\n                        val\
    \ top = queue.pop()\n                        if (top.equals(\"(\")) {\n      \
    \                      stack.enqueue(top)\n                        } else {\n\
    \                            bad.add(top)\n                        }\n       \
    \             }\n                }\n                case \")()()()()\" => {\n\
    \                    if (!queue.isEmpty) {\n                        val top =\
    \ queue.pop()\n                        if (top.equals(\"(\")) {\n            \
    \                stack.enqueue(top)\n                        } else {\n      \
    \                      bad.add(top)\n                        }\n             \
    \       }\n                }\n                case \")()()()()()\" => {\n    \
    \                if (!queue.isEmpty) {\n                        val top = queue.pop()\n\
    \                        if (top.equals(\"(\")) {\n                          \
    \  stack.enqueue(top)\n                        } else {\n                    \
    \        bad.add(top)\n                        }\n                    }\n    \
    \            }\n                case \")()()()()()()\" => {\n                \
    \    if (!queue.isEmpty) {\n                        val top = queue.pop()\n  \
    \                      if (top.equals(\"(\")) {\n                            stack.enqueue(top)\n\
    \                        } else {\n                            bad.add(top)\n\
    \                        }\n                    }\n                }\n       \
    \         case \")()()()()()()()\" => {\n                    if (!queue.isEmpty)\
    \ {\n                        val top = queue.pop()\n                        if\
    \ (top.equals(\"(\")) {\n                            stack.enqueue(top)\n    \
    \                    } else {\n                            bad.add(top\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl2bc145s.scala:111:4 ---------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl2bc145s.scala:128:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m128 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpl2bc145s.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl2bc145s.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl2bc145s.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpl2bc145s.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpl2bc145s.scala:112:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m112 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = "
  stdout: ''
  timestamp: 1659795048
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(x => stack += x)\n                   \
    \ result ++= stack\n                    stack = mutable.Stack[String]()\n    \
    \            case \")(\"  =>\n                    open += x\n                case\
    \ \")\" =>\n                    close.foreach(x => stack += x)\n             \
    \       result ++= stack\n                    stack = mutable.Stack[String]()\n\
    \                case \")(\"  =>\n                    open += x\n            \
    \    case _ =>\n                    stack += x\n            }\n        })\n  \
    \      if (stack.size == 0)\n            \"No\"\n        else\n            \"\
    Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk0r8lm3x.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpk0r8lm3x.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpk0r8lm3x.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpk0r8lm3x.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpk0r8lm3x.scala:27:28 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    stack = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpk0r8lm3x.scala:33:28 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    stack = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[3"
  stdout: ''
  timestamp: 1659795048
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    closeCount += closeCount.length\n                \
    \    closeCount += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += closeCount.length\n                    closeCount += closeCount.length\n\
    \                    closeCount += closeCount.length\n                    closeCount\
    \ += close\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo0_1exzl.scala:91:0 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo0_1exzl.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo0_1exzl.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo0_1exzl.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo0_1exzl.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo0_1exzl.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when co"
  stdout: ''
  timestamp: 1659795054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    open.push(x)\n                }\n   \
    \             case \")(\" => {\n                    stack.push(x)\n          \
    \      }\n                case \")()\" => {\n                    val s = stack.pop()\n\
    \                    val c = close.pop()\n                    val o = open.pop()\n\
    \                    if (s == o) {\n                        result.append(\"Yes\"\
    )\n                    } else {\n                        result.append(\"No\"\
    )\n                    }\n                }\n            }\n        })\n     \
    \   result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsu18n8cr.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsu18n8cr.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsu18n8cr.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsu18n8cr.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795048
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \"(\"\
    \ => stack.push(s)\n                case \")\" =>\n                    val top\
    \ = stack.pop()\n                    result += (s\"$top$s\")\n            }\n\
    \        }\n        if (stack.size == 0)\n            \"No\"\n        else\n \
    \           \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphs5zh51t.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphs5zh51t.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val good = mutable.Queue[String]()\n\
    \        val bad = mutable.Queue[String]()\n        lst.foreach(x => {\n     \
    \       if (x == \"(\") {\n                stack.push(x)\n            } else if\
    \ (x == \")\") {\n                val top = stack.pop()\n                if (top\
    \ == \"(\") {\n                    queue.enqueue(x)\n                } else {\n\
    \                    bad.enqueue(x)\n                }\n            } else {\n\
    \                bad.enqueue(x)\n            }\n        })\n        val n = queue.size\n\
    \        if (n == 0) {\n            result.enqueue(\"Yes\")\n        } else if\
    \ (n == 1) {\n            result.enqueue(\"No\")\n        } else {\n         \
    \   while (!bad.isEmpty) {\n                val top = bad.poll()\n           \
    \     val next = queue.poll()\n                val newTop = stack.pop()\n    \
    \            val newNext = stack.pop()\n                val newTop2 = stack.pop()\n\
    \                val newNext2 = stack.pop()\n                val newTop3 = stack.pop()\n\
    \                val newNext3 = stack.pop()\n                val newTop4 = stack.pop()\n\
    \                val newNext4 = stack.pop()\n                val newTop5 = stack.pop()\n\
    \                val newNext5 = stack.pop()\n                val newTop6 = stack.pop()\n\
    \                val newNext6 = stack.pop()\n                val newTop7 = stack.pop()\n\
    \                val newNext7 = stack.pop()\n                val newTop8 = stack.pop()\n\
    \                val newNext8 = stack.pop()\n                val newTop9 = stack.pop()\n\
    \                val newNext9 = stack.pop()\n                val newTop10 = stack.pop()\n\
    \                val newNext10 = stack.pop()\n                val newTop11 = stack.pop()\n\
    \                val newNext11 = stack.pop()\n                val newTop12 = stack.pop()\n\
    \                val newNext12 = stack.pop()\n                val newTop13 = stack.pop()\n\
    \                val newNext13 = stack.pop()\n                val newTop14 = stack.pop()\n\
    \                val newNext14 = stack.pop()\n                val newTop15 = stack.pop()\n\
    \                val newNext15 = stack.pop()\n                val newTop16 = stack.pop()\n\
    \                val newNext16 = stack.pop()\n                val newTop17 = stack.pop()\n\
    \                val newNext17 = stack.pop()\n                val newTop18 = stack.pop()\n\
    \                val newNext18 = stack.pop()\n                val newTop19 = stack.pop()\n\
    \                val newNext19 = stack.pop()\n                val newTop20 = stack.pop()\n\
    \                val newNext20 = \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa_ei1_ag.scala:85:31 ---------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m                \e[33mval\e[0m \e[36mnewNext20\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa_ei1_ag.scala:103:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m103 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpa_ei1_ag.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa_ei1_ag.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa_ei1_ag.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa_ei1_ag.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compilin"
  stdout: ''
  timestamp: 1659795056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        lst.foreach { s =>\n  \
    \          if (s.startsWith(\"(\")) {\n                stack.push(s)\n       \
    \     } else {\n                val top = stack.pop()\n                if (top\
    \ == s) {\n                    queue.enqueue(s)\n                } else {\n  \
    \                  result.enqueue(top)\n                    result.enqueue(s)\n\
    \                }\n            }\n        }\n        if (stack.size == 0) \"\
    No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8_0i27ei.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8_0i27ei.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8_0i27ei.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.foreach(y => stack += y)\n                   \
    \ stack.toList.reverse.foreach(y => result += y)\n                    stack.toList.reverse.clear()\n\
    \                case \")(\"  =>\n                    open += x\n            \
    \    case \")(\" =>\n                    open -= x\n                case \")()\"\
    \ =>\n                    open += x\n                case \")()()\" =>\n     \
    \               open -= x\n                case \")(\" =>\n                  \
    \  open -= x\n                case \")()\" =>\n                    open += x\n\
    \                case \")()()\" =>\n                    open -= x\n          \
    \      case \")(\" =>\n                    open -= x\n                case \"\
    )()()\" =>\n                    open += x\n                case \")(\" =>\n  \
    \                  open -= x\n                case \")()()\" =>\n            \
    \        open -= x\n                case \")(\" =>\n                    open -=\
    \ x\n                case \")()()\" =>\n                    open += x\n      \
    \          case \")(\" =>\n                    open -= x\n                case\
    \ \")()()\" =>\n                    open -= x\n                case \")(\" =>\n\
    \                    open -= x\n                case \")()()\" =>\n          \
    \          open += x\n                case \")(\" =>\n                    open\
    \ -= x\n                case \")()()\" =>\n                    open -= x\n   \
    \             case \")(\" =>\n                    open -= x\n                case\
    \ \")()()\" =>\n                    open += x\n                case \")(\" =>\n\
    \                    open -= x\n                case \")()()\" =>\n          \
    \          open -= x\n                case \")(\" =>\n                    open\
    \ -= x\n                case \")()()\" =>\n                    open += x\n   \
    \             case \")(\" =>\n                    open -= x\n                case\
    \ \")()()\" =>\n                    open -= x\n                case \")(\" =>\n\
    \                    open -= x\n                case \")()()\" =>\n          \
    \          open += x\n                case \")(\" =>\n                    open\
    \ -= x\n                case \")()()\" =>\n                    open -= x\n   \
    \             case \")(\" =>\n                    open -= x\n                case\
    \ \")()()\" =>\n                    open += x\n                case \")(\" =>\n\
    \                    open -= x\n                case \")()()\" =>\n          \
    \          open -= x\n                case \")(\" =>\n                    open\
    \ -= x\n                case \")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpskj7pujy.scala:100:21 ----------------------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m  \
    \  |\e[0m                     ^\e[0m\n\e[31m    |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpskj7pujy.scala:102:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m102 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpskj7pujy.scala:118:0 ---------------------------\e[0m\e[0m\n\e[31m118\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpskj7pujy.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpskj7pujy.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpskj7pujy.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpskj7pujy.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = muta"
  stdout: ''
  timestamp: 1659795051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") stack.push(x)\n     \
    \       if (x == \")\") stack.pop() match {\n                case Some(x) => result\
    \ += x\n                case None => result += \"No\"\n            }\n       \
    \ })\n        if (stack.size == 0) \"Yes\" else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2ay15jw5.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2ay15jw5.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprdr94pzo.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprdr94pzo.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n                stack.push(s)\n            } else if (s.endsWith(\"\
    )\")) {\n                close += s\n                result += (s\"${stack.pop}${s}\"\
    )\n            }\n        }\n        if (open.isEmpty && close.isEmpty) {\n  \
    \          \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn2prl5mc.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn2prl5mc.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn2prl5mc.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpn2prl5mc.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x contains \"(\") open += x\n   \
    \         if (x contains \")\") close += x\n            if (x contains \"(\")\
    \ stack += x\n            if (x contains \")\") stack += x\n        })\n     \
    \   val openCount = open.size\n        val closeCount = close.size\n        if\
    \ (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n\
    \            val closeStack = stack.drop(closeCount)\n            val openStackCount\
    \ = openStack.size\n            val closeStackCount = closeStack.size\n      \
    \      if (openStackCount == closeStackCount) {\n                val stackStr\
    \ = openStack.mkString(\"(\", \")\", \", \")\")\n                val stackStr2\
    \ = closeStack.mkString(\"(\", \")\", \", \")\")\n                if (stackStr\
    \ == stackStr2) {\n                    result += \"Yes\"\n                } else\
    \ {\n                    result += \"No\"\n                }\n            } else\
    \ {\n                result += \"No\"\n            }\n        } else {\n     \
    \       result += \"No\"\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8edd5yoc.scala:36:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m =\
    \ openStack.mkString(\e[31m\"(\"\e[0m, \e[31m\")\"\e[0m, \e[31m\", \"\e[0m)\"\
    )\n\e[31m\e[31m   |\e[0m                                                     \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \        unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmp8edd5yoc.scala:37:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m37 |\e[0m       \
    \         \e[33mval\e[0m \e[36mstackStr2\e[0m = closeStack.mkString(\e[31m\"(\"\
    \e[0m, \e[31m\")\"\e[0m, \e[31m\", \"\e[0m)\")\n\e[31m\e[31m   |\e[0m        \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                                 unclosed string literal\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp8edd5yoc.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8edd5yoc.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8edd5yoc.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8edd5yoc.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e["
  stdout: ''
  timestamp: 1659795053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp63zhqdy9.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp63zhqdy9.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel d"
  stdout: ''
  timestamp: 1659795033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    if(stack.isEmpty) result += \"No\"\n             \
    \       else result += \"Yes\"\n                }\n                case \")(\"\
    \  => {\n                    open += x\n                }\n                case\
    \ \")(\" => {\n                    close += x\n                }\n           \
    \     case \")(\" => {\n                    stack += x\n                }\n  \
    \              case \")\" => {\n                    if(stack.isEmpty) result +=\
    \ \"No\"\n                    else result += \"Yes\"\n                }\n    \
    \            case \")\" => {\n                    if(stack.isEmpty) result +=\
    \ \"No\"\n                    else result += \"Yes\"\n                }\n    \
    \            case \")(\" => {\n                    stack += x\n              \
    \  }\n                case \")(\" => {\n                    open += x\n      \
    \          }\n                case \")(\" => {\n                    close += x\n\
    \                }\n                case \")(\" => {\n                    stack\
    \ += x\n                }\n                case \")(\" => {\n                \
    \    open += x\n                }\n                case \")(\" => {\n        \
    \            close += x\n                }\n                case \")(\" => {\n\
    \                    stack += x\n                }\n                case \")(\"\
    \ => {\n                    open += x\n                }\n                case\
    \ \")(\" => {\n                    close += x\n                }\n           \
    \     case \")(\" => {\n                    stack += x\n                }\n  \
    \              case \")(\" => {\n                    open += x\n             \
    \   }\n                case \")(\" => {\n                    close += x\n    \
    \            }\n                case \")(\" => {\n                    stack +=\
    \ x\n                }\n                case \")(\" => {\n                   \
    \ open += x\n                }\n                case \")(\" => {\n           \
    \         close += x\n                }\n                case \")(\" => {\n  \
    \                  stack += x\n                }\n                case \")(\"\
    \ => {\n                    open += x\n                }\n                case\
    \ \")(\" => {\n                    close += x\n                }\n           \
    \     case \")(\" => {\n                    stack += x\n                }\n  \
    \              case \")(\" => {\n                    open += x\n             \
    \   }\n                case \")(\" => {\n                    close += x\n    \
    \            }\n                case \")(\" => {\n                    stack +=\
    \ x\n                }\n                case \")(\" => {\n                   \
    \ open += x\n                }\n                case \")(\" => {\n           \
    \         close += x\n                }\n                case \")(\" => {\n  \
    \                  stack += x\n                }\n                case \")(\"\
    \ => {\n                    open += x\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdv0_4kmz.scala:140:0 ---------------------------\e\
    [0m\e[0m\n\e[31m140 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdv0_4kmz.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdv0_4kmz.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdv0_4kmz.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdv0_4kmz.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdv0_4kmz.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m "
  stdout: ''
  timestamp: 1659795060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val good = mutable.Queue[String]()\n\
    \        val bad = mutable.Queue[String]()\n        val goodCount = mutable.Queue[Int]()\n\
    \        val badCount = mutable.Queue[Int]()\n        val goodCount2 = mutable.Queue[Int]()\n\
    \        val badCount2 = mutable.Queue[Int]()\n        val goodCount3 = mutable.Queue[Int]()\n\
    \        val badCount3 = mutable.Queue[Int]()\n        val goodCount4 = mutable.Queue[Int]()\n\
    \        val badCount4 = mutable.Queue[Int]()\n        val goodCount5 = mutable.Queue[Int]()\n\
    \        val badCount5 = mutable.Queue[Int]()\n        val goodCount6 = mutable.Queue[Int]()\n\
    \        val badCount6 = mutable.Queue[Int]()\n        val goodCount7 = mutable.Queue[Int]()\n\
    \        val badCount7 = mutable.Queue[Int]()\n        val goodCount8 = mutable.Queue[Int]()\n\
    \        val badCount8 = mutable.Queue[Int]()\n        val goodCount9 = mutable.Queue[Int]()\n\
    \        val badCount9 = mutable.Queue[Int]()\n        val goodCount10 = mutable.Queue[Int]()\n\
    \        val badCount10 = mutable.Queue[Int]()\n        val goodCount11 = mutable.Queue[Int]()\n\
    \        val badCount11 = mutable.Queue[Int]()\n        val goodCount12 = mutable.Queue[Int]()\n\
    \        val badCount12 = mutable.Queue[Int]()\n        val goodCount13 = mutable.Queue[Int]()\n\
    \        val badCount13 = mutable.Queue[Int]()\n        val goodCount14 = mutable.Queue[Int]()\n\
    \        val badCount14 = mutable.Queue[Int]()\n        val goodCount15 = mutable.Queue[Int]()\n\
    \        val badCount15 = mutable.Queue[Int]()\n        val goodCount16 = mutable.Queue[Int]()\n\
    \        val badCount16 = mutable.Queue[Int]()\n        val goodCount17 = mutable.Queue[Int]()\n\
    \        val badCount17 = mutable.Queue[Int]()\n        val goodCount\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2s_xa3v1.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2s_xa3v1.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2s_xa3v1.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2s_xa3v1.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2s_xa3v1.scala:21:19\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2s_xa3v1.scala:22:18\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain"
  stdout: ''
  timestamp: 1659795059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.add(x)\n\
    \            case x if x == \")\" => stack.toList.reverse.foreach(y => result\
    \ += (y + \"(\"))\n            case x if x == \"(\" => open.add(x)\n         \
    \   case x if x == \")\" => stack.toList.reverse.foreach(y => result += (y + \"\
    (\"))\n            case x => stack.toList.reverse.foreach(y => result += (y +\
    \ \"(\"))\n        })\n        if (close.size == 0 && open.size == 0) \"Yes\"\
    \ else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpayd3lkfc.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpayd3lkfc.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpayd3lkfc.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpayd3lkfc.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (close.isEmpty && !open.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && !close.isEmpty) result += \"Yes\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n     \
    \       if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr74h68ur.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr74h68ur.scala:58:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m58 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpr74h68ur.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr74h68ur.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr74h68ur.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr74h68ur.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr74h68ur.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e["
  stdout: ''
  timestamp: 1659795057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    open.push(x)\n                }\n   \
    \             case \")(\" => {\n                    stack.push(x)\n          \
    \      }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8jgqcjag.scala:128:4 ---------------------------\e\
    [0m\e[0m\n\e[31m128 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp8jgqcjag.scala:145:0 ---------------------------\e[0m\e[0m\n\e[31m145\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8jgqcjag.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmp8jgqcjag.scala:129:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m129 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0"
  stdout: ''
  timestamp: 1659795059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.length){\n            val str = lst(i)\n       \
    \     val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0){\n                result += \"No\"\n\
    \                return result.toString()\n            }\n            val openCount\
    \ = stack.length\n            val closeCount = stack.length\n            val openParen\
    \ = open\n            val closeParen = close\n            while(openCount > 0\
    \ && closeCount > 0){\n                val openParenCount = stack.length\n   \
    \             val closeParenCount = stack.length\n                val openParenStr\
    \ = stack.pop()\n                val closeParenStr = stack.pop()\n           \
    \     if(openParenStr == closeParenStr){\n                    openCount -= 1\n\
    \                    closeCount -= 1\n                }else if(openParenStr <\
    \ closeParenStr){\n                    openCount -= 1\n                }else{\n\
    \                    closeCount -= 1\n                }\n            }\n     \
    \       if(openCount > closeCount){\n                result += \"No\"\n      \
    \          return result.toString()\n            }\n            result += \"Yes\"\
    \n            while(openCount > 0){\n                result += \"(\"\n       \
    \         openCount -= 1\n            }\n            while(closeCount > 0){\n\
    \                result += \")\"\n                closeCount -= 1\n          \
    \  }\n        }\n        return result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz7pukz98.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz7pukz98.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                stack += x\n            } else if (x == \")\") {\n   \
    \             close += x\n                stack -= x\n            }\n        })\n\
    \        if (stack.size == 0) {\n            result.append(\"Yes\")\n        }\
    \ else {\n            val openCount = open.size\n            val closeCount =\
    \ close.size\n            val openStack = stack.take(openCount)\n            val\
    \ closeStack = stack.drop(closeCount)\n            val openStackCount = openStack.size\n\
    \            val closeStackCount = closeStack.size\n            val openStackStack\
    \ = openStack.take(openStackCount)\n            val closeStackStack = closeStack.drop(closeStackCount)\n\
    \            val openStackStackCount = openStackStack.size\n            val closeStackStackCount\
    \ = closeStackStack.size\n            val openStackStackStack = openStackStack.take(openStackStackCount)\n\
    \            val closeStackStackStack = closeStackStack.drop(closeStackStackCount)\n\
    \            val openStackStackStackCount = openStackStackStack.size\n       \
    \     val closeStackStackStackCount = closeStackStackStack.size\n            val\
    \ openStackStackStackStack = openStackStackStack.take(openStackStackStackCount)\n\
    \            val closeStackStackStackStack = closeStackStackStack.drop(closeStackStackStackCount)\n\
    \            val openStackStackStackStackCount = openStackStackStackStack.size\n\
    \            val closeStackStackStackStackCount = closeStackStackStackStack.size\n\
    \            val openStackStackStackStackStack = openStackStackStackStack.take(openStackStackStackStackCount)\n\
    \            val closeStackStackStackStackStack = closeStackStackStackStack.drop(closeStackStackStackStackCount)\n\
    \            val openStackStackStackStackStackCount = openStackStackStackStackStack.size\n\
    \            val closeStackStackStackStackStackCount = closeStackStackStackStackStack.size\n\
    \            val openStackStackStackStackStackStack = openStackStackStackStackStack.take(openStackStackStackStackStackCount)\n\
    \            val closeStackStackStackStackStackStack = closeStackStackStackStackStack.drop(closeStackStackStackStackStackCount)\n\
    \            val openStackStackStackStackStackStackCount = openStackStackStackStackStackStack.size\n\
    \            val close\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpauu0tebv.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpauu0tebv.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpauu0tebv.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpauu0tebv.scala:19:21 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpauu0tebv.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpauu0tebv.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpauu0tebv.scala:35:35 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mcloseCount\e[0m = close.size\n\
    \e[31m\e[31m   |\e["
  stdout: ''
  timestamp: 1659795069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String, Int]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        val goodCount = mutable.Map[String, Int]()\n        val badCount\
    \ = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String, Int]()\n\
    \        val badCount = mutable.Map[String, Int]()\n        val goodCount = mutable.Map[String,\
    \ Int]()\n        val badCount = mutable.Map[String, Int]()\n        val goodCount\
    \ = mutable.Map[String, Int\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp63zhqdy9.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp63zhqdy9.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp63zhqdy9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.Map[\e[35mString\e\
    [0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel d"
  stdout: ''
  timestamp: 1659795033
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x contains \"(\") {\n           \
    \     open += x\n                stack.push(x)\n            } else {\n       \
    \         close += x\n            }\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        if (openCount == closeCount) {\n\
    \            val openStack = stack.take(openCount)\n            val closeStack\
    \ = stack.drop(openCount)\n            val openStackSize = openStack.size\n  \
    \          val closeStackSize = closeStack.size\n            val openStackLast\
    \ = openStack.last\n            val closeStackLast = closeStack.last\n       \
    \     if (openStackLast == closeStackLast) {\n                result += \"Yes\"\
    \n            } else {\n                result += \"No\"\n            }\n    \
    \    } else {\n            result += \"No\"\n        }\n        result.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb81_fh05.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb81_fh05.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb81_fh05.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpb81_fh05.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(\"(\") => open.remove(stack.pop())\n\
    \                            case _ => result.synchronized {\n               \
    \                 result += stack.pop()\n                            }\n     \
    \                   }\n                    }\n                case \")(\" =>\n\
    \                    stack.synchronized {\n                        open.add(stack.pop())\n\
    \                    }\n                case \")(\" =>\n                    stack.synchronized\
    \ {\n                        open.add(stack.pop())\n                    }\n  \
    \              case \")(\" =>\n                    stack.synchronized {\n    \
    \                    open.add(stack.pop())\n                    }\n          \
    \      case \")(\" =>\n                    stack.synchronized {\n            \
    \            open.add(stack.pop())\n                    }\n                case\
    \ \")(\" =>\n                    stack.synchronized {\n                      \
    \  open.add(stack.pop())\n                    }\n                case \")(\" =>\n\
    \                    stack.synchronized {\n                        open.add(stack.pop())\n\
    \                    }\n                case \")(\" =>\n                    stack.synchronized\
    \ {\n                        open.add(stack.pop())\n                    }\n  \
    \              case \")(\" =>\n                    stack.synchronized {\n    \
    \                    open.add(stack.pop())\n                    }\n          \
    \      case \")(\" =>\n                    stack.synchronized {\n            \
    \            open.add(stack.pop())\n                    }\n                case\
    \ \")(\" =>\n                    stack.synchronized {\n                      \
    \  open.add(stack.pop())\n                    }\n                case \")(\" =>\n\
    \                    stack.synchronized {\n                        open.add(stack.pop())\n\
    \                    }\n                case \")(\" =>\n                    stack.synchronized\
    \ {\n                        open.add(stack.pop())\n                    }\n  \
    \              case \")(\" =>\n                    stack.synchronized {\n    \
    \                    open.add(stack.pop())\n                    }\n          \
    \      case \")(\" =>\n                    stack.synchronized {\n            \
    \            open.add(stack.pop())\n                    }\n                case\
    \ \")(\" =>\n                    stack.synchronized {\n                      \
    \  open.add(stack.pop())\n                    }\n                case \")(\" =>\n\
    \                    stack.synchronized {\n                        open.add(stack.pop())\n\
    \                    }\n                case \")(\" =>\n                    stack.synchronized\
    \ {\n                        open.add(stack.pop())\n                    }\n  \
    \              case \")(\" =>\n                    stack.synchronized {\n    \
    \                    open.add(stack.pop())\n                    }\n          \
    \      case \")(\" =>\n                    stack.synchronized {\n            \
    \            open.add(stack.pop())\n                    }\n                case\
    \ \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6ewxi22i.scala:109:21 ----------------------------------------\e\
    [0m\e[0m\n\e[31m109 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m  \
    \  |\e[0m                     ^\e[0m\n\e[31m    |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmp6ewxi22i.scala:111:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp6ewxi22i.scala:127:0 ---------------------------\e[0m\e[0m\n\e[31m127\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ewxi22i.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6ewxi22i.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6ewxi22i.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6ewxi22i.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = muta"
  stdout: ''
  timestamp: 1659795061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            val\
    \ z = (x + \"(\" + y + \")\")\n            if(z.contains(\"(\") && z.contains(\"\
    )\")) {\n                result += \"Yes\"\n            } else {\n           \
    \     result += \"No\"\n            }\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1l53rmbg.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1l53rmbg.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n     \
    \   val stackIndex = 0\n        val resultIndex = 0\n        val stackIsEmpty\
    \ = stack.isEmpty\n        val resultIsEmpty = result.isEmpty\n        while(stackIsEmpty\
    \ || resultIsEmpty) {\n            if(stackIsEmpty) {\n                stackIndex\
    \ += 1\n                stackMax = stackIndex\n                stackIsEmpty =\
    \ stack.isEmpty\n            }\n            if(resultIsEmpty) {\n            \
    \    resultIndex += 1\n                resultMax = resultIndex\n             \
    \   resultIsEmpty = result.isEmpty\n            }\n            val stackElement\
    \ = lst(stackIndex)\n            val resultElement = lst(resultIndex)\n      \
    \      if(stackElement == \"(\" && resultElement == \")\") {\n               \
    \ stack.push(stackElement)\n                result.push(resultElement)\n     \
    \           stackIndex += 1\n                resultIndex += 1\n            }\n\
    \            else if(stackElement == \")\" && resultElement == \"(\") {\n    \
    \            stackIndex -= 1\n                stackMax = stackIndex\n        \
    \        stackIsEmpty = stack.isEmpty\n            }\n            else if(stackElement\
    \ == \"(\" && resultElement == \"(\") {\n                result.push(resultElement)\n\
    \                stackIndex += 1\n                resultIndex += 1\n         \
    \   }\n            else if(stackElement == \")\" && resultElement == \")\") {\n\
    \                stackIndex -= 1\n                stackMax = stackIndex\n    \
    \            stackIsEmpty = stack.isEmpty\n            }\n            else if(stackElement\
    \ == \"(\" && resultElement == \"(\") {\n                stack.push(stackElement)\n\
    \                stackIndex += 1\n                stackIsEmpty = stack.isEmpty\n\
    \            }\n            else if(stackElement == \")\" && resultElement ==\
    \ \")\") {\n                stackIndex -= 1\n                stackMax = stackIndex\n\
    \                stackIsEmpty = stack.isEmpty\n            }\n            else\
    \ {\n                stackIndex += 1\n                stackMax = stackIndex\n\
    \                stackIsEmpty = stack.isEmpty\n                resultIndex +=\
    \ 1\n                resultMax = resultIndex\n                resultIsEmpty =\
    \ result.isEmpty\n            }\n        }\n        if(stackMax == resultMax)\
    \ {\n            val stackElement = lst(stackIndex)\n            val resultElement\
    \ = lst(resultIndex)\n            if(stackElement == \"(\" && resultElement ==\
    \ \")\") {\n                stack.push(stackElement)\n                result.push(resultElement)\n\
    \                stackIndex += 1\n                resultIndex += 1\n         \
    \   }\n            else if(stackElement == \")\" && resultElement == \"(\") {\n\
    \                stackIndex -= 1\n                stack\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvi3_0quw.scala:110:0 ---------------------------\e\
    [0m\e[0m\n\e[31m110 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvi3_0quw.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvi3_0quw.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvi3_0quw.scala:30:27\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                stackIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m           value += is not a member of Int - did you mean stackIndex.!=?\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpvi3_0quw.scala:31:25 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                stackMax = stackIndex\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Reassignment to val stackMax\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpvi3_0quw.scala:32:29 -----------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                stackIsEmpty = stack.isEmpty\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \               Reassignment to val stackIsEmpty\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpvi3_0quw.scala:35:28 ------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1659795071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String]()\n        val badCount = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodCount = mutable.Set[String\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3r7fa6tx.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3r7fa6tx.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodSize\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mgoodSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3r7fa6tx.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadSize\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mbadSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3r7fa6tx.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgoodCount\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgoodCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3r7fa6tx.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mbadCount\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbadCount is\
    \ already defined as \e[33mvalue\e[0m \e[35mbadCount\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3r7fa6tx.scala:30:12\
    \ ----------"
  stdout: ''
  timestamp: 1659795067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        lst.foreach(x => {\n            val\
    \ index = stack.indexOf(x)\n            if (index == -1) {\n                stack\
    \ += x\n            } else {\n                val stackSize = stack.size\n   \
    \             if (stackSize == 0) {\n                    result += \"No\"\n  \
    \              } else {\n                    result += \"Yes\"\n             \
    \   }\n            }\n        })\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb187p_e8.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb187p_e8.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            if (open.isEmpty && close.isEmpty) {\n\
    \                result ++= s\n            } else if (open.isEmpty && close.contains(s))\
    \ {\n                result ++= s\n            } else if (close.isEmpty && open.contains(s))\
    \ {\n                result ++= s\n            } else if (close.contains(s) &&\
    \ open.contains(s)) {\n                result ++= s\n            } else if (close.contains(s)\
    \ && open.contains(s)) {\n                result ++= s\n            } else if\
    \ (close.isEmpty && open.contains(s)) {\n                result ++= s\n      \
    \      } else if (close.contains(s) && open.contains(s)) {\n                result\
    \ ++= s\n            } else {\n                stack += s\n            }\n   \
    \     }\n        if (stack.size == 1) {\n            stack.toList\n        } else\
    \ {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmm7xvrn1.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmm7xvrn1.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmm7xvrn1.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmm7xvrn1.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph31ws3q3.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph31ws3q3.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph31ws3q3.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph31ws3q3.scala:60:5\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackIndex = stackMax\n        val stackElement = lst(stackIndex)\n \
    \       val stackElementSize = stackElement.length\n        val stackElementMax\
    \ = stackElementSize - 1\n        val stackElementIndex = stackElementMax\n  \
    \      val stackElementElement = lst(stackElementIndex)\n        val stackElementElementSize\
    \ = stackElementElement.length\n        val stackElementElementMax = stackElementElementSize\
    \ - 1\n        val stackElementElementIndex = stackElementElementMax\n       \
    \ val stackElementElementElement = lst(stackElementElementIndex)\n        val\
    \ stackElementElementElementSize = stackElementElementElement.length\n       \
    \ val stackElementElementElementMax = stackElementElementElementSize - 1\n   \
    \     val stackElementElementElementIndex = stackElementElementElementMax\n  \
    \      val stackElementElementElementElement = lst(stackElementElementElementIndex)\n\
    \        val stackElementElementElementElementSize = stackElementElementElementElement.length\n\
    \        val stackElementElementElementElementMax = stackElementElementElementElementSize\
    \ - 1\n        val stackElementElementElementElementIndex = stackElementElementElementElementMax\n\
    \        val stackElementElementElementElementElement = lst(stackElementElementElementElementIndex)\n\
    \        val stackElementElementElementElementElementSize = stackElementElementElementElementElement.length\n\
    \        val stackElementElementElementElementElementMax = stackElementElementElementElementElementSize\
    \ - 1\n        val stackElementElementElementElementElementIndex = stackElementElementElementElementElementMax\n\
    \        val stackElementElementElementElementElementElement = lst(stackElementElementElementElementElementIndex)\n\
    \        val stackElementElementElementElementElementElementSize = stackElementElementElementElementElementElement.length\n\
    \        val stackElementElementElementElementElementElementMax = stackElementElementElementElementElementElementSize\
    \ - 1\n        val stackElementElementElementElementElementElementIndex = stackElementElementElementElementElementElementElementMax\n\
    \        val stackElementElementElementElementElementElementElement = lst(stackElementElementElementElementElementElementIndex)\n\
    \        val stackElementElementElementElementElementElementElementSize = stackElementElementElementElementElementElementElement.length\n\
    \        val stackElementElementElementElementElementElementElementMax = stackElementElementElementElementElementElementElementElementSize\
    \ - 1\n        val stackElementElementElementElementElementElementElementIndex\
    \ = stackElementElementElementElementElementElementElementElementMax\n       \
    \ val stackElementElementElementElementElementElementElementElement = lst(stackElementElementElementElementElement\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvnqugr1_.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvnqugr1_.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvnqugr1_.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvnqugr1_.scala:49:72\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e\
    [36mstackElementElementElementElementElementElementElementMax\e[0m = stackElementElementElementElementElementElementElementElementSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: stackElementElementElementElementElementElementElementElementSize\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvnqugr1_.scala:50:74\
    \ ------------------------\e[0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e\
    [36mstackElementElementElementElementElementElementElementIndex\e[0m = stackElementElementElementElementElementElementElementElementMax\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: stackElementElementElementElem"
  stdout: ''
  timestamp: 1659795070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.push(x)\n                case \")(\"  =>\n   \
    \                 stack.push(x)\n                case \")(\"  =>\n           \
    \         stack.push(x)\n                case \")\" =>\n                    stack.push(x)\n\
    \                case \")\" =>\n                    stack.push(x)\n          \
    \      case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpkukbd3z1.scala:106:21 ----------------------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m  \
    \  |\e[0m                     ^\e[0m\n\e[31m    |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpkukbd3z1.scala:108:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m108 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpkukbd3z1.scala:124:0 ---------------------------\e[0m\e[0m\n\e[31m124\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkukbd3z1.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkukbd3z1.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkukbd3z1.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkukbd3z1.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutab"
  stdout: ''
  timestamp: 1659795065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val len = lst.size\n  \
    \      for(i <- 0 until len){\n            val str = lst(i)\n            val len\
    \ = str.length\n            val open = str.indexOf(\"(\")\n            val close\
    \ = str.indexOf(\")\")\n            val isOpen = open != -1\n            val isClose\
    \ = close != -1\n            val isOpenClose = open != -1 && close != -1\n   \
    \         if(isOpen && isClose){\n                val str = str.substring(0, open)\n\
    \                val str2 = str.substring(open + 1, close)\n                val\
    \ str3 = str.substring(close + 1)\n                val str4 = str2 + str3\n  \
    \              val str5 = str4 + str\n                val str6 = str5 + str\n\
    \                val str7 = str6 + str\n                val str8 = str7 + str\n\
    \                val str9 = str8 + str\n                val str10 = str9 + str\n\
    \                val str11 = str10 + str\n                val str12 = str11 +\
    \ str\n                val str13 = str12 + str\n                val str14 = str13\
    \ + str\n                val str15 = str14 + str\n                val str16 =\
    \ str15 + str\n                val str17 = str16 + str\n                val str18\
    \ = str17 + str\n                val str19 = str18 + str\n                val\
    \ str20 = str19 + str\n                val str21 = str20 + str\n             \
    \   val str22 = str21 + str\n                val str23 = str22 + str\n       \
    \         val str24 = str23 + str\n                val str25 = str24 + str\n \
    \               val str26 = str25 + str\n                val str27 = str26 + str\n\
    \                val str28 = str27 + str\n                val str29 = str28 +\
    \ str\n                val str30 = str29 + str\n                val str31 = str30\
    \ + str\n                val str32 = str31 + str\n                val str33 =\
    \ str32 + str\n                val str34 = str33 + str\n                val str35\
    \ = str34 + str\n                val str36 = str35 + str\n                val\
    \ str37 = str36 + str\n                val str38 = str37 + str\n             \
    \   val str39 = str38 + str\n                val str40 = str39 + str\n       \
    \         val str4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzy6ld6fy.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzy6ld6fy.scala:89:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m89 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpzy6ld6fy.scala:18:20 ------------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpzy6ld6fy.scala:19:20 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzy6ld6fy.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpzy6ld6fy.scala:73:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m73 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659795066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty || close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty || close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ || close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty || close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n      \
    \      if (open.isEmpty || close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty || close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty || close.isEmpty) result += \"No\"\n      \
    \      if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ || close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty || close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n      \
    \      if (open.isEmpty || close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty || close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty || close.isEmpty) result += \"No\"\n      \
    \      if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ || close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty || close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n      \
    \      if (open.isEmpty || close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty || close\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfx9_zb0w.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfx9_zb0w.scala:58:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m58 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpfx9_zb0w.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfx9_zb0w.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfx9_zb0w.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfx9_zb0w.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfx9_zb0w.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e["
  stdout: ''
  timestamp: 1659795064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack += str\n            }\n       \
    \     else if(str == \")\") {\n                if(stack.size == 0) {\n       \
    \             result += \"No\"\n                }\n                else if(stack.last\
    \ == \"(\") {\n                    result += \"Yes\"\n                }\n    \
    \            else {\n                    result += \"No\"\n                }\n\
    \                stack.pop()\n            }\n        }\n        if(result.size\
    \ == lst.size) {\n            result match {\n                case Nil => \"Yes\"\
    \n                case x => x\n            }\n        }\n        else {\n    \
    \        \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpokm66ji6.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpokm66ji6.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.push(x)\n                }\n               \
    \ case \")\" => {\n                    val last = stack.pop()\n              \
    \      result += (last + x)\n                }\n                case \")()\" =>\
    \ {\n                    val last = stack.pop()\n                    result +=\
    \ (last + x)\n                }\n                case \")()\" => {\n         \
    \           val last = stack.pop()\n                    result += (last + x)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ last = stack.pop()\n                    result += (last + x)\n             \
    \   }\n                case \")(\" => {\n                    val last = stack.pop()\n\
    \                    result += (last + x)\n                }\n               \
    \ case \")(\" => {\n                    val last = stack.pop()\n             \
    \       result += (last + x)\n                }\n                case \")(\" =>\
    \ {\n                    val last = stack.pop()\n                    result +=\
    \ (last + x)\n                }\n                case \")(\" => {\n          \
    \          val last = stack.pop()\n                    result += (last + x)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ last = stack.pop()\n                    result += (last + x)\n             \
    \   }\n                case \")(\" => {\n                    val last = stack.pop()\n\
    \                    result += (last + x)\n                }\n               \
    \ case \")(\" => {\n                    val last = stack.pop()\n             \
    \       result += (last + x)\n                }\n                case \")(\" =>\
    \ {\n                    val last = stack.pop()\n                    result +=\
    \ (last + x)\n                }\n                case \")(\" => {\n          \
    \          val last = stack.pop()\n                    result += (last + x)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ last = stack.pop()\n                    result += (last + x)\n             \
    \   }\n                case \")(\" => {\n                    val last = stack.pop()\n\
    \                    result += (last + x)\n                }\n               \
    \ case \")(\" => {\n                    val last = stack.pop()\n             \
    \       result += (last + x)\n                }\n                case \")(\" =>\
    \ {\n                    val last = stack.pop()\n                    result +=\
    \ (last + x)\n                }\n                case \")(\" => {\n          \
    \          val last = stack.pop()\n                    result += (last + x)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ last = stack.pop()\n                    result += (last + x)\n             \
    \   }\n                case \")(\" => {\n                    val last = stack.pop()\n\
    \                    result += (last + x)\n                }\n               \
    \ case \")(\" => {\n                    val last = stack.pop()\n             \
    \       result += (last + x)\n                }\n                case \")(\" =>\
    \ {\n                    val last = stack.pop()\n                    result +=\
    \ (last + x)\n                }\n                case \")(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpcus8kftp.scala:113:21 ----------------------------------------\e\
    [0m\e[0m\n\e[31m113 |\e[0m                \e[33mcase\e[0m \")(\n\e[31m\e[31m \
    \   |\e[0m                     ^\e[0m\n\e[31m    |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpcus8kftp.scala:115:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpcus8kftp.scala:131:0 ---------------------------\e[0m\e[0m\n\e[31m131\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcus8kftp.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcus8kftp.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcus8kftp.scala:115:4 ------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m    ^^^\e[0m\n\
    \e[31m    |\e[0m    Not found: )(def\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1659795067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.foreach(c => stack += c)\n                   \
    \ result ++= stack\n                    stack = mutable.Stack[String]()\n    \
    \            case \")(\"  =>\n                    open += s\n                case\
    \ \")(\"  =>\n                    open += s\n                case \")\" =>\n \
    \                   close += s\n                case \")\" =>\n              \
    \      close += s\n                case _ =>\n                    stack += s\n\
    \            }\n        }\n        result match {\n            case Nil => \"\
    No\"\n            case _ => \"Yes\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdhzse5bc.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdhzse5bc.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdhzse5bc.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdhzse5bc.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdhzse5bc.scala:27:28 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    stack = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    stack.push(x)\n                }\n  \
    \              case \")(\" => {\n                    val x = stack.pop()\n   \
    \                 val y = close.pop()\n                    val z = x + y\n   \
    \                 result.push(z)\n                    open.push(x)\n         \
    \       }\n                case \")\" => {\n                    val x = stack.pop()\n\
    \                    val y = close.pop()\n                    val z = x + y\n\
    \                    result.push(z)\n                }\n                case \"\
    )(\" => {\n                    val x = stack.pop()\n                    val y\
    \ = close.pop()\n                    val z = x + y\n                    result.push(z)\n\
    \                }\n                case \")\" => {\n                    val x\
    \ = stack.pop()\n                    val y = close.pop()\n                   \
    \ val z = x + y\n                    result.push(z)\n                }\n     \
    \           case \")(\" => {\n                    val x = stack.pop()\n      \
    \              val y = close.pop()\n                    val z = x + y\n      \
    \              result.push(z)\n                }\n                case \")(\"\
    \ => {\n                    val x = stack.pop()\n                    val y = close.pop()\n\
    \                    val z = x + y\n                    result.push(z)\n     \
    \           }\n                case \")(\" => {\n                    val x = stack.pop()\n\
    \                    val y = close.pop()\n                    val z = x + y\n\
    \                    result.push(z)\n                }\n                case \"\
    )(\" => {\n                    val x = stack.pop()\n                    val y\
    \ = close.pop()\n                    val z = x + y\n                    result.push(z)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ x = stack.pop()\n                    val y = close.pop()\n                 \
    \   val z = x + y\n                    result.push(z)\n                }\n   \
    \             case \")(\" => {\n                    val x = stack.pop()\n    \
    \                val y = close.pop()\n                    val z = x + y\n    \
    \                result.push(z)\n                }\n                case \")(\"\
    \ => {\n                    val x = stack.pop()\n                    val y = close.pop()\n\
    \                    val z = x + y\n                    result.push(z)\n     \
    \           }\n                case \")(\" => {\n                    val x = stack.pop()\n\
    \                    val y = close.pop()\n                    val z = x + y\n\
    \                    result.push(z)\n                }\n                case \"\
    )(\" => {\n                    val x = stack.pop()\n                    val y\
    \ = close.pop()\n                    val z = x + y\n                    result.push(z)\n\
    \                }\n                case \")(\" => {\n                    val\
    \ x = stack.pop()\n                    val y = close.pop()\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjhw9nx_1.scala:130:0 ---------------------------\e\
    [0m\e[0m\n\e[31m130 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhw9nx_1.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhw9nx_1.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhw9nx_1.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhw9nx_1.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjhw9nx_1.scala:22:19\
    \ --------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 23 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 24 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m "
  stdout: ''
  timestamp: 1659795077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val len = lst.size\n\
    \        for(i <- 0 until len){\n            val str = lst(i)\n            if(str\
    \ == \"(\"){\n                stack += str\n                queue += str\n   \
    \         }else if(str == \")\"){\n                val top = stack.pop()\n   \
    \             val next = queue.pop()\n                if(top == next){\n     \
    \               result += \"Yes\"\n                }else{\n                  \
    \  result += \"No\"\n                }\n            }\n        }\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj_5onvsk.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj_5onvsk.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj_5onvsk.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodCount = mutable.Map[String, Int]()\n        val badCount = mutable.Map[String,\
    \ Int]()\n        lst.foreach(x => {\n            x match {\n                case\
    \ \")\" => {\n                    val s = stack.pop()\n                    if\
    \ (!s.isEmpty) {\n                        queue.enqueue(s)\n                 \
    \   }\n                }\n                case \")(\" => {\n                 \
    \   val s = stack.pop()\n                    if (!s.isEmpty) {\n             \
    \           queue.enqueue(s)\n                    }\n                    val s\
    \ = stack.pop()\n                    if (!s.isEmpty) {\n                     \
    \   queue.enqueue(s)\n                    }\n                }\n             \
    \   case \")(\" => {\n                    val s = stack.pop()\n              \
    \      if (!s.isEmpty) {\n                        queue.enqueue(s)\n         \
    \           }\n                    val s = stack.pop()\n                    if\
    \ (!s.isEmpty) {\n                        queue.enqueue(s)\n                 \
    \   }\n                    val s = stack.pop()\n                    if (!s.isEmpty)\
    \ {\n                        queue.enqueue(s)\n                    }\n       \
    \         }\n                case \")(\" => {\n                    val s = stack.pop()\n\
    \                    if (!s.isEmpty) {\n                        queue.enqueue(s)\n\
    \                    }\n                    val s = stack.pop()\n            \
    \        if (!s.isEmpty) {\n                        queue.enqueue(s)\n       \
    \             }\n                    val s = stack.pop()\n                   \
    \ if (!s.isEmpty) {\n                        queue.enqueue(s)\n              \
    \      }\n                    val s = stack.pop()\n                    if (!s.isEmpty)\
    \ {\n                        queue.enqueue(s)\n                    }\n       \
    \         }\n                case \")(\" => {\n                    val s = stack.pop()\n\
    \                    if (!s.isEmpty) {\n                        queue.enqueue(s)\n\
    \                    }\n                    val s = stack.pop()\n            \
    \        if (!s.isEmpty) {\n                        queue.enqueue(s)\n       \
    \             }\n                    val s = stack.pop()\n                   \
    \ if (!s.isEmpty) {\n                        queue.enqueue(s)\n              \
    \      }\n                    val s = stack.pop()\n                    if (!s.isEmpty)\
    \ {\n                        queue.enqueue(s)\n                    }\n       \
    \             val s = stack.pop()\n                    if (!s.isEmpty) {\n   \
    \                     queue.enqueue(s)\n                    }\n              \
    \  }\n                case \")(\" => {\n                    val s = stack.pop()\n\
    \                    if (!s.isEmpty) {\n                        queue.enqueue(s)\n\
    \                    }\n                    val s = stack.pop()\n            \
    \        if (!s.isEmpty) {\n                        queue.enqueue(s)\n       \
    \             }\n                    val s = stack.pop()\n                   \
    \ if (!s.isEmpty) {\n                        queue.enqueue(s)\n              \
    \      }\n                    val s = stack.pop()\n                    if (!s.isEmpty)\
    \ {\n                        queue.enqueue(s)\n                    }\n       \
    \             val s = stack\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5bpji_to.scala:131:0 ---------------------------\e\
    [0m\e[0m\n\e[31m131 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5bpji_to.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5bpji_to.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5bpji_to.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5bpji_to.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5bpji_to.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodCount\e[0m = mutable.Map[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-"
  stdout: ''
  timestamp: 1659795077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize / 2\n  \
    \      val stackSize3 = stackSize / 3\n        val stackSize4 = stackSize / 4\n\
    \        val stackSize5 = stackSize / 5\n        val stackSize6 = stackSize /\
    \ 6\n        val stackSize7 = stackSize / 7\n        val stackSize8 = stackSize\
    \ / 8\n        val stackSize9 = stackSize / 9\n        val stackSize10 = stackSize\
    \ / 10\n        val stackSize11 = stackSize / 11\n        val stackSize12 = stackSize\
    \ / 12\n        val stackSize13 = stackSize / 13\n        val stackSize14 = stackSize\
    \ / 14\n        val stackSize15 = stackSize / 15\n        val stackSize16 = stackSize\
    \ / 16\n        val stackSize17 = stackSize / 17\n        val stackSize18 = stackSize\
    \ / 18\n        val stackSize19 = stackSize / 19\n        val stackSize20 = stackSize\
    \ / 20\n        val stackSize21 = stackSize / 21\n        val stackSize22 = stackSize\
    \ / 22\n        val stackSize23 = stackSize / 23\n        val stackSize24 = stackSize\
    \ / 24\n        val stackSize25 = stackSize / 25\n        val stackSize26 = stackSize\
    \ / 26\n        val stackSize27 = stackSize / 27\n        val stackSize28 = stackSize\
    \ / 28\n        val stackSize29 = stackSize / 29\n        val stackSize30 = stackSize\
    \ / 30\n        val stackSize31 = stackSize / 31\n        val stackSize32 = stackSize\
    \ / 32\n        val stackSize33 = stackSize / 33\n        val stackSize34 = stackSize\
    \ / 34\n        val stackSize35 = stackSize / 35\n        val stackSize36 = stackSize\
    \ / 36\n        val stackSize37 = stackSize / 37\n        val stackSize38 = stackSize\
    \ / 38\n        val stackSize39 = stackSize / 39\n        val stackSize40 = stackSize\
    \ / 40\n        val stackSize41 = stackSize / 41\n        val stackSize42 = stackSize\
    \ / 42\n        val stackSize43 = stackSize / 43\n        val stackSize44 = stackSize\
    \ / 44\n        val stackSize45 = stackSize / 45\n        val stackSize46 = stack\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp765w85mb.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp765w85mb.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp765w85mb.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackIndex = stackSize - 1\n\
    \        val stackMaxValue = lst.last\n        val stackMaxValueIndex = stackSize\
    \ - 1\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValueIndex\
    \ = lst.last\n        val stackMaxValueIndex = lst.last\n        val stackMaxValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpld51435f.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpld51435f.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackMaxValueIndex\e[0m = lst.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValueIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mstackMaxValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpld51435f.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mstackMaxValueIndex\e[0m\
    \ = lst.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValueIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mstackMaxValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpld51435f.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mstackMaxValueIndex\e[0m\
    \ = lst.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValueIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mstackMaxValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpld51435f.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstackMaxValueIndex\e[0m\
    \ = lst.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxValueIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mstackMaxValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpld51435f.sc"
  stdout: ''
  timestamp: 1659795078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMaxSize = stackSize - 1\n\
    \        val stackMax = stackMaxSize - 1\n        val stackMaxIndex = stackSize\
    \ - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex =\
    \ stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val stackMaxIndex = stackSize - 1\n        val stackMaxIndex\
    \ = stackSize - 1\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0u3rblr9.scala:74:11 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0u3rblr9.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = stackSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0u3rblr9.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = stackSize - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0u3rblr9.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = stackSize - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0u3rblr9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndex\e[0m = stackSize - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstackMaxIndex is already defined as \e[33mvalue\e[0m \e[35mstackMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be "
  stdout: ''
  timestamp: 1659795079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n     \
    \   if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyyeojkwe.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpyyeojkwe.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n           \
    \ val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) {\n   \
    \             result.append(\"No\")\n            } else {\n                val\
    \ openCount = stackSize - stack.size\n                val closeCount = stackSize\
    \ - open\n                if (openCount > closeCount) {\n                    stack\
    \ += s\n                } else {\n                    stack += s\n           \
    \         result.append(\"Yes\")\n                }\n            }\n        }\n\
    \        result.mkString(\",\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8cznnkak.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8cznnkak.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.Stack[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => if (open(x) ) stack += x else close.add(x))\n      \
    \  while(!stack.isEmpty) {\n            val s = stack.pop()\n            if (close(s))\
    \ {\n                result += s\n            } else {\n                val openCount\
    \ = open.count(_ == s)\n                if (openCount > 0) {\n               \
    \     result += s\n                    open.remove(s)\n                }\n   \
    \         }\n        }\n        if (result.isEmpty) \"No\" else \"Yes\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbbca9u31.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbbca9u31.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbbca9u31.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpbbca9u31.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach {\n            s =>\n                val l = s.toList\n \
    \               l.foreach {\n                    c =>\n                      \
    \  c match {\n                            case '(' | ')' =>\n                \
    \                if (stack.nonEmpty && stack.peek() == '(') {\n              \
    \                      stack.pop\n                                    if (stack.nonEmpty\
    \ && stack.peek() == ')') {\n                                        stack.pop\n\
    \                                        stack.pop\n                         \
    \               queue.enqueue(stack.peek())\n                                \
    \        queue.enqueue(c)\n                                        queue.enqueue(stack.peek())\n\
    \                                        queue.enqueue(stack.peek())\n       \
    \                                 queue.enqueue(stack.peek())\n              \
    \                          queue.enqueue(stack.peek())\n                     \
    \                   queue.enqueue(stack.peek())\n                            \
    \            queue.enqueue(stack.peek())\n                                   \
    \     queue.enqueue(stack.peek())\n                                        queue.enqueue(stack.peek())\n\
    \                                        queue.enqueue(stack.peek())\n       \
    \                                 queue.enqueue(stack.peek())\n              \
    \                          queue.enqueue(stack.peek())\n                     \
    \                   queue.enqueue(stack.peek())\n                            \
    \            queue.enqueue(stack.peek())\n                                   \
    \     queue.enqueue(stack.peek())\n                                        queue.enqueue(stack.peek())\n\
    \                                        queue.enqueue(stack.peek())\n       \
    \                                 queue.enqueue(stack.peek())\n              \
    \                          queue.enqueue(stack.peek())\n                     \
    \                   queue.enqueue(stack.peek())\n                            \
    \            queue.enqueue(stack.peek())\n                                   \
    \     queue.enqueue(stack.peek())\n                                        queue.enqueue(stack.peek())\n\
    \                                        queue.enqueue(stack.peek())\n       \
    \                                 queue.enqueue(stack.peek())\n              \
    \                          queue.enqueue(stack.peek())\n                     \
    \                   queue.enqueue(stack.peek())\n                            \
    \            queue.enqueue(stack.peek())\n                                   \
    \     queue.enqueue(stack.peek())\n                                        queue.enqueue(stack.peek())\n\
    \                                        queue.enqueue(stack.peek())\n       \
    \                                 queue.enqueue(stack.peek())\n              \
    \                          queue.enqueue(stack.peek())\n                     \
    \                   queue.enqueue(stack.peek())\n                            \
    \            queue.enqueue(stack.peek())\n                                   \
    \     queue.enqueue(stack.peek())\n                                        queue.enqueue(stack.peek())\n\
    \                                        queue.enqueue(stack.peek())\n       \
    \                                 queue.enqueue(stack.peek())\n              \
    \                          queue.enqueue(stack.peek())\n                     \
    \                   queue.enqueue(stack.peek())\n                            \
    \            queue.enqueue(stack.peek())\n                                   \
    \     queue.enqueue(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf12c7dha.scala:77:54 ---------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m                                        queue.enqueue(\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpf12c7dha.scala:95:0 ----------------------------\e[0m\e[0m\n\e[31m95\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf12c7dha.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf12c7dha.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf12c7dha.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpf12c7dha.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation avai"
  stdout: ''
  timestamp: 1659795075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack.push(x) else if (x == \")\") queue.push(x)\
    \ else if (stack.isEmpty && queue.isEmpty) good.add(x) else {\n            val\
    \ top = stack.pop()\n            val next = queue.pop()\n            if (top ==\
    \ next) good.add(x)\n            else bad.add(x)\n        })\n        if (good.size\
    \ == lst.size) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ey2sf99.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3ey2sf99.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3ey2sf99.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp3ey2sf99.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        val goodSize = mutable.Set[String]()\n        val badSize = mutable.Set[String]()\n\
    \        val goodParens = mutable.Set[String]()\n        val badParens = mutable.Set[String]()\n\
    \        val goodParensSize = mutable.Set[String]()\n        val badParensSize\
    \ = mutable.Set[String]()\n        val goodParensParens = mutable.Set[String]()\n\
    \        val badParensParens = mutable.Set[String]()\n        val goodParensParensSize\
    \ = mutable.Set[String]()\n        val badParensParensSize = mutable.Set[String]()\n\
    \        val goodParensParensParens = mutable.Set[String]()\n        val badParensParensParens\
    \ = mutable.Set[String]()\n        val goodParensParensParensSize = mutable.Set[String]()\n\
    \        val badParensParensParensSize = mutable.Set[String]()\n        val goodParensParensParensParens\
    \ = mutable.Set[String]()\n        val badParensParensParensParens = mutable.Set[String]()\n\
    \        val goodParensParensParensParensSize = mutable.Set[String]()\n      \
    \  val badParensParensParensParensSize = mutable.Set[String]()\n        val goodParensParensParensParensParens\
    \ = mutable.Set[String]()\n        val badParensParensParensParensParens = mutable.Set[String]()\n\
    \        val goodParensParensParensParensParensSize = mutable.Set[String]()\n\
    \        val badParensParensParensParensParensSize = mutable.Set[String]()\n \
    \       val goodParensParensParensParensParensParens = mutable.Set[String]()\n\
    \        val badParensParensParensParensParensParens = mutable.Set[String]()\n\
    \        val goodParensParensParensParensParensParensSize = mutable.Set[String]()\n\
    \        val badParensParensParensParensParensParensSize = mutable.Set[String\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpivfsnelv.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivfsnelv.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivfsnelv.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivfsnelv.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivfsnelv.scala:21:18\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpivfsnelv.scala:22:23\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mgoodSize\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain"
  stdout: ''
  timestamp: 1659795079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.add(x)\n                case \")(\"  =>\n    \
    \                stack += x\n                case \")(\"  =>\n               \
    \     stack += x\n                case \")\" =>\n                    close.add(x)\n\
    \                case \")\" =>\n                    close.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8rs_ul3g.scala:107:4 ---------------------------\e\
    [0m\e[0m\n\e[31m107 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8rs_ul3g.scala:124:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m124 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp8rs_ul3g.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8rs_ul3g.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8rs_ul3g.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8rs_ul3g.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmp8rs_ul3g.scala:108:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m108 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35m"
  stdout: ''
  timestamp: 1659795079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\"  =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")(\" =>\n                  \
    \  close.clear()\n                    stack.clear()\n                case \")()\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\" =>\n                    close.clear()\n          \
    \          stack.clear()\n                case \")\" =>\n                    close.clear()\n\
    \                    stack.clear()\n                case \")()\" =>\n        \
    \            close.clear()\n                    stack.clear()\n              \
    \  case \")(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")()\" =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")()\" =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")()\" =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")()\" =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")()\" =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")()\" =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")()\" =>\n                 \
    \   close.clear()\n                    stack.clear()\n                case \"\
    )(\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(\" =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpx26flzpf.scala:114:20 --------------------------\e\
    [0m\e[0m\n\e[31m114 |\e[0m                \e[33mcase\e[0m \n\e[31m\e[31m    |\e\
    [0m                    ^\e[0m\n\e[31m    |\e[0m                    pattern expected\n\
    \e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx26flzpf.scala:132:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m132 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpx26flzpf.scala:18:20 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpx26flzpf.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpx26flzpf.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpx26flzpf.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmp"
  stdout: ''
  timestamp: 1659795079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackIndex = 0\n        val\
    \ stackMaxIndexStack = mutable.ListBuffer[Int]()\n        val stackMaxIndexStackSize\
    \ = stackMaxIndexStack.size + 1 // +1 for the last element\n        val stackMaxIndexStackMax\
    \ = stackMaxIndexStackSize - 1\n        val stackMaxIndexStackIndex = 0\n    \
    \    val stackMaxIndexStackMaxIndex = 0\n        val stackMaxIndexStackMaxIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndex = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex = 0\n\
    \        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackIndex =\
    \ 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndexStackMaxIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkuk_kuy8.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkuk_kuy8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkuk_kuy8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkuk_kuy8.scala:24:33\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxIndexStack\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpkuk_kuy8.scala:46:5 ---------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659795081
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val len = lst.size\n  \
    \      for(i <- 0 until len) {\n            val str = lst(i)\n            if(str\
    \ == \"(\") {\n                stack.push(str)\n            }\n            else\
    \ if(str == \")\") {\n                val top = stack.pop()\n                if(top\
    \ == \"(\") {\n                    queue.enqueue(str)\n                }\n   \
    \             else {\n                    result.enqueue(top)\n              \
    \  }\n            }\n            else {\n                result.enqueue(str)\n\
    \            }\n        }\n        if(stack.size == len) {\n            val str\
    \ = stack.toList\n            val len = str.size\n            for(i <- 0 until\
    \ len) {\n                val str = str(i)\n                if(str == \"(\") {\n\
    \                    queue.enqueue(str)\n                }\n                else\
    \ if(str == \")\") {\n                    val top = queue.pop()\n            \
    \        if(top == \"(\") {\n                        stack.push(str)\n       \
    \             }\n                    else {\n                        result.enqueue(top)\n\
    \                    }\n                }\n                else {\n          \
    \          result.enqueue(str)\n                }\n            }\n           \
    \ val str = queue.toList\n            val len = str.size\n            for(i <-\
    \ 0 until len) {\n                val str = str(i)\n                if(str ==\
    \ \"(\") {\n                    queue.enqueue(str)\n                }\n      \
    \          else if(str == \")\") {\n                    val top = queue.pop()\n\
    \                    if(top == \"(\") {\n                        stack.push(str)\n\
    \                    }\n                    else {\n                        result.enqueue(top)\n\
    \                    }\n                }\n                else {\n          \
    \          result.enqueue(str)\n                }\n            }\n           \
    \ val str = stack.toList\n            val len = str.size\n            for(i <-\
    \ 0 until len) {\n                val str = str(i)\n                if(str ==\
    \ \"(\") {\n                    queue.enqueue(str)\n                }\n      \
    \          else if(str == \")\") {\n                    val top = queue.pop()\n\
    \                    if(top == \"(\") {\n                        stack.push(str)\n\
    \                    }\n                    else {\n                        result.enqueue(top)\n\
    \                    }\n                }\n                else {\n          \
    \          result.enqueue(str)\n                }\n            }\n           \
    \ val str = queue.toList\n            val len = str.size\n            for(i <-\
    \ 0 until len) {\n                val str = str(i)\n                if(str ==\
    \ \"(\") {\n                    queue.enqueue(str)\n                }\n      \
    \          else if(str == \")\") {\n                    val top = queue.pop()\n\
    \                    if(top == \"(\") {\n                        stack.push(str)\n\
    \                    }\n                    else {\n                        result.enqueue(top)\n\
    \                    }\n                }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfb_oh75_.scala:134:0 ---------------------------\e\
    [0m\e[0m\n\e[31m134 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfb_oh75_.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfb_oh75_.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfb_oh75_.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfb_oh75_.scala:61:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m61 |\e[0m            \e[33mval\e\
    [0m \e[36mstr\e[0m = queue.toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstr is already defined as \e[33mvalue\e[0m \e[35mstr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfb_oh75_.scala:62:16 ---------------------------\e[0m\e[0m\n\e[31m62\
    \ |\e[0m            \e[33mval\e[0m \e[36mlen\e[0m = str.size\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already defined\
    \ as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods m"
  stdout: ''
  timestamp: 1659795080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        lst.foreach(x => stack += x)\n    \
    \    while(stack.size > 0) {\n            val top = stack.pop()\n            result\
    \ += top\n            val nextStackSize = stack.size\n            for(i <- 0 until\
    \ stackSize - 1) {\n                if(top == lst(i)) {\n                    stack\
    \ += lst(i + 1)\n                    stackSize += 1\n                }\n     \
    \       }\n            if(nextStackSize == stackSize) {\n                result\
    \ += \"Yes\"\n                break\n            }\n        }\n        if(result.size\
    \ == stackSize) {\n            \"No\"\n        } else {\n            result.mkString(\"\
    ,\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6fwfophu.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6fwfophu.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6fwfophu.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    stackSize += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value += is not a member of Int - did you mean stackSize.!=?\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6fwfophu.scala:34:16 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795081
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackIndex = 0\n        val\
    \ stackMaxIndexStack = mutable.Stack[Int]()\n        val stackMaxIndexStackSize\
    \ = stackMaxIndexStack.size()\n        val stackMaxIndexStackMax = stackMaxIndexStackSize\
    \ - 1\n        val stackMaxIndexStackIndex = 0\n        val stackMaxIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackIndexStack = mutable.Stack[Int]()\n     \
    \   val stackMaxIndexStackIndexStackSize = stackMaxIndexStackIndexStack.size()\n\
    \        val stackMaxIndexStackIndexStackMax = stackMaxIndexStackIndexStackSize\
    \ - 1\n        val stackMaxIndexStackIndexStackIndex = 0\n        val stackMaxIndexStackIndexStackMaxIndex\
    \ = 0\n        val stackMaxIndexStackIndexStackIndexStack = mutable.Stack[Int]()\n\
    \        val stackMaxIndexStackIndexStackIndexStackSize = stackMaxIndexStackIndexStackIndexStack.size()\n\
    \        val stackMaxIndexStackIndexStackIndexStackMax = stackMaxIndexStackIndexStackIndexStackSize\
    \ - 1\n        val stackMaxIndexStackIndexStackIndexStackIndex = 0\n        val\
    \ stackMaxIndexStackIndexStackIndexStackMaxIndex = 0\n        val stackMaxIndexStackIndexStackIndexStackIndexStack\
    \ = mutable.Stack[Int]()\n        val stackMaxIndexStackIndexStackIndexStackIndexStackSize\
    \ = stackMaxIndexStackIndexStackIndexStackIndexStack.size()\n        val stackMaxIndexStackIndexStackIndexStackIndexStackMax\
    \ = stackMaxIndexStackIndexStackIndexStackIndexStackSize - 1\n        val stackMaxIndexStackIndexStackIndexStackIndexStackIndex\
    \ = 0\n        val stackMaxIndexStackIndexStackIndexStackIndexStackMaxIndex =\
    \ 0\n        val stackMaxIndexStackIndexStackIndexStackIndexStackIndexStack =\
    \ mutable.Stack[Int]()\n        val stackMaxIndexStackIndexStackIndexStackIndexStackIndexStackSize\
    \ = stackMaxIndexStackIndexStackIndexStackIndexStack.size()\n        val stackMaxIndexStackIndexStackIndexStackIndexStackIndexStackMax\
    \ = stackMaxIndexStackIndexStackIndexStackIndexStackIndexStackSize - 1\n     \
    \   val stackMaxIndexStackIndexStackIndexStackIndexStackIndexStackIndex = 0\n\
    \        val stackMaxIndexStackIndexStackIndexStackIndexStackIndexStackMaxIndex\
    \ = 0\n        val stack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnk8vyw8v.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnk8vyw8v.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnk8vyw8v.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnk8vyw8v.scala:24:33\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mstackMaxIndexStack\e[0m = mutable.Stack[\e[35mInt\e[0m]()\n\e[31m\e[31m  \
    \ |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpnk8vyw8v.scala:29:43 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndexStackIndexStack\e\
    [0m = mutable.Stack[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpnk8vyw8v.scala:34:53 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mstackMaxIndexStackIndexStackIndexStack\e\
    [0m = mutable.Stack[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \       "
  stdout: ''
  timestamp: 1659795081
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackStr = str.substring(open + 1,\
    \ close)\n                stack += stackStr\n            }\n        }\n      \
    \  if(stack.size == 0) result.append(\"Yes\")\n        else result.append(\"No\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm5t1fqj_.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpm5t1fqj_.scala:19:21 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        val openSet = mutable.Set[String]()\n        val closeSet = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => closeCount += 1 \n                case \")(\"  => openCount += 1 \n     \
    \           case \")(\"  => openCount += 1 \n                case \")(\"  => openCount\
    \ += 1 \n                case \")(\"  => openCount += 1 \n                case\
    \ \")(\"  => openCount += 1 \n                case \")(\"  => openCount += 1 \n\
    \                case \")(\"  => openCount += 1 \n                case \")(\"\
    \  => openCount += 1 \n                case \")(\"  => openCount += 1 \n     \
    \           case \")(\"  => openCount += 1 \n                case \")(\"  => openCount\
    \ += 1 \n                case \")(\"  => openCount += 1 \n                case\
    \ \")(\"  => openCount += 1 \n                case \")(\"  => openCount += 1 \n\
    \                case \")(\"  => openCount += 1 \n                case \")(\"\
    \  => openCount += 1 \n                case \")(\"  => openCount += 1 \n     \
    \           case \")(\"  => openCount += 1 \n                case \")(\"  => openCount\
    \ += 1 \n                case \")(\"  => openCount += 1 \n                case\
    \ \")(\"  => openCount += 1 \n                case \")(\"  => openCount += 1 \n\
    \                case \")(\"  => openCount += 1 \n                case \")(\"\
    \  => openCount += 1 \n                case \")(\"  => openCount += 1 \n     \
    \           case \")(\"  => openCount += 1 \n                case \")(\"  => openCount\
    \ += 1 \n                case \")(\"  => openCount += 1 \n                case\
    \ \")(\"  => openCount += 1 \n                case \")(\"  => openCount += 1 \n\
    \                case \")(\"  => openCount += 1 \n                case \")(\"\
    \  => openCount += 1 \n                case \")(\"  => openCount += 1 \n     \
    \           case \")(\"  => openCount += 1 \n                case \")(\"  => openCount\
    \ += 1 \n                case \")(\"  => openCount += 1 \n                case\
    \ \")(\"  => openCount += 1 \n                case \")(\"  => openCount += 1 \n\
    \                case \")(\"  => openCount += 1 \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa0h2i9oc.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa0h2i9oc.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa0h2i9oc.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa0h2i9oc.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa0h2i9oc.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa0h2i9oc.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when co"
  stdout: ''
  timestamp: 1659795082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue\
    \ += x else if (!x == \")\") bad += x)\n        val goodString = stack.toList\
    \ mkString \"\"\n        val badString = queue.toList mkString \"\"\n        if\
    \ (goodString.length == badString.length) good else bad\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5woljw9d.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5woljw9d.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5woljw9d.scala:20:19 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5woljw9d.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp5woljw9d.scala:22:59 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) bad\
    \ += x)\n\e[31m\e[31m   |\e[0m                                               \
    \            ^^\e[0m\n\e[31m   |\e[0m                                 value unary_!\
    \ is not a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5woljw9d.scala:22:90\
    \ ------------------------\e[0m\e"
  stdout: ''
  timestamp: 1659795082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // >>> matchParens((List[String](\"()(\", \")\")))\n  \
    \  // (\"Yes\")\n    // >>> matchParens((List[String](\")\", \")\")))\n    //\
    \ (\"No\")\n    def matchParens(lst : List[String]) : String = {\n        val\
    \ stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm0b1s3r8.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:18:20\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0b1s3r8.scala:22:21\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659794997
