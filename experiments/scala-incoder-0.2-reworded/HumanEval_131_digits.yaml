name: HumanEval_131_digits
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the product of the odd digits.\n    //\
  \ Return 0 if all digits are even.\n    // For example:\n    // >>> digits((1l))\n\
  \    // (1l)\n    // >>> digits((4l))\n    // (0l)\n    // >>> digits((235l))\n\
  \    // (15l)\n    def digits(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n\
  \    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l))\
  \ == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l))\
  \ == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"
completions: ["        val digits = mutable.ListBuffer[Long]()\n        val remainder\
    \ = n % 10\n        n /= 10\n        while (n>0) {\n            digits += n\n\
    \            n /= 10\n        }\n        if (remainder == 0) {\n            digits.reverse\n\
    \        } else {\n            digits += remainder\n        }\n        digits.reduceLeft(_\
    \ * 2)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(1L)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) =>\n            val product = acc\
    \ * digit\n            if (product % 2 == 0) product else 0\n        }", "   \
    \     var result : Long = 0\n        var remainder : Long = 0\n        var i :\
    \ Long = 0\n        while (n > 0){\n            remainder = n % 10\n         \
    \   result += remainder * i\n            n /= 10\n            i += 1\n       \
    \ }\n        result", "        val digits = n.toString.toInt\n        val odd\
    \ = digits.filter(_ % 2 != 0)\n        if (odd.isEmpty) 0\n        else odd.product",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 0\n    \
    \    while(n > 0){\n            val digit = n % 10\n            n /= 10\n    \
    \        digits += digit\n            product *= digit\n        }\n        if(digits.isEmpty)\
    \ 0\n        else product", "        var sum = 0\n        var digits = n.toString.reverse\n\
    \        for(i <- 0 until digits.length){\n            sum = sum * 10 + digits(i)\n\
    \        }\n        if(sum % 2 == 0){\n            return 0\n        }\n     \
    \   return sum", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l)((acc, x) => acc * x)", "        var result : Long\
    \ = 0\n        var remainder : Long = n % 10\n        n /= 10\n        while(n\
    \ > 0) {\n            result *= 10\n            result += n % 10\n           \
    \ n /= 10\n        }\n        if(remainder == 0) {\n            result\n     \
    \   } else {\n            result\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l) { (acc, digit) =>\n            acc * digit\n    \
    \    }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n  \
    \      digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0l) {\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val evens = digits.filter(x => x % 2 == 0)\n        val odds = digits.filter(x\
    \ => x % 2 != 0)\n        val product = evens.foldLeft(1l)(_ * _)\n        product\
    \ * odds.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.forall(_.toString.toLong % 2 != 0)\n            ? 0\n        \
    \    : digits.reduceLeft((x, y) => x * y)", "        var product = 1\n       \
    \ var digits = n.toString.toInt\n        while(digits > 0) {\n            product\
    \ *= digits\n            digits /= 10\n        }\n        if (digits == 0) {\n\
    \            product = 0\n        }\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.toList.map(_.toInt)\n        val odd = digits.filter(x => x % 2\
    \ != 0)\n        if (odd.isEmpty) 0\n        else odd.product", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) => acc * digit }", "        var product = 1\n        var digits\
    \ = n.toString.reverse.grouped(2).map(_ + \"\").toList\n        digits.foreach(x\
    \ => product *= x.toLong)\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0\n        else digits.foldLeft(1L) { (acc,\
    \ digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        var result : Long = 1\n        val\
    \ digits = n.toString.reverse\n        for(i <- 0 until digits.length)\n     \
    \       result *= digits(i)\n        result", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val even = digits.filter(_.isEven)\n        val odd = digits.filter(_.isOdd)\n\
    \        if (even.isEmpty) 0\n        else odd.reduce(_ * _)", "        val digits\
    \ = n.toString.toList.map(_.toInt)\n        val odd = digits.filter(x => x % 2\
    \ != 0)\n        if (odd.isEmpty) 0\n        else odd.reduceLeft(_ * _)", "  \
    \      val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)\
    \ { (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        if (digits.forall(_.toString.toInt == 0)) 0\n        else digits.foldLeft(1l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.forall(_.isEven)\n\
    \            ? 0\n            : digits.foldLeft(1L) {\n                case (acc,\
    \ digit) => acc * digit\n            }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.toInt\n \
    \       val odd = digits.filter(_ % 2 != 0)\n        if (odd.isEmpty) 0\n    \
    \    else odd.product", "        val digits = n.toString.toList.map(_.toInt)\n\
    \        val odd = digits.filter(_ % 2 == 1)\n        if (odd.isEmpty) 0\n   \
    \     else odd.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.forall(_.toString.toLong % 2 != 0)\n            ? 0\n        \
    \    : digits.foldLeft(1l)(_ * _)", "        var sum = 0\n        var product\
    \ = 1\n        for(i <- 0 until n.toInt) {\n            sum += n.toInt((i).toLong)\n\
    \            product *= n.toInt((i).toLong)\n        }\n        if(sum % 2 ==\
    \ 0) product *= 0\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1L) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) =>\n            acc * digit\n        }", "        var product =\
    \ 1\n        var digits = n.toString.toLong\n        while (digits > 0) {\n  \
    \          product *= digits\n            digits -= 1\n        }\n        if (product\
    \ % 2 == 0) product else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val remainder = n % 10\n        n /= 10\n        while (n>0) {\n    \
    \        digits += n\n            n /= 10\n        }\n        if (remainder ==\
    \ 0) {\n            digits.reverse\n        } else {\n            digits += remainder\n\
    \        }\n        digits.reduceLeft(_ * 2)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0\n        else digits.foldLeft(1L) { (a,\
    \ b) => a * b}", "        val digits = mutable.ListBuffer.empty[Long]\n      \
    \  val i = n.toInt\n        while (i > 0) {\n            digits += i % 10\n  \
    \          i /= 10\n        }\n        if (digits.isEmpty) 0\n        else digits.reduceLeft(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val odd = digits.filter(x => x % 2 != 0)\n        val even = digits.filter(x\
    \ => x % 2 == 0)\n        if (odd.isEmpty) 0\n        else odd.head * even.head",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = mutable.ListBuffer[Long]()\n        var\
    \ product = 1\n        while(n > 0){\n            digits += n % 10\n         \
    \   product *= n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(product){\
    \ (product, digit) => product * digit}", "        val digits = n.toString.toInt\n\
    \        val product = digits.filter(_ % 2 != 0).foldLeft(1l)(_ * _)\n       \
    \ product % 2 == 0 ? product : product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        while(n > 0){\n            digits += n\
    \ % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(0l){ (acc,\
    \ digit) => acc * digit }", "        var sum = 0\n        var product = 1\n  \
    \      while(n > 0){\n            sum += n % 10\n            product *= n % 10\n\
    \            n /= 10\n        }\n        if(sum % 2 == 0){\n            0\n  \
    \      } else {\n            product\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        var product\
    \ = 1\n        var digits = n.toString.reverse\n        for(i <- 0 until digits.length)\n\
    \            product *= digits(i)\n        if(product % 2 == 0)\n            0\n\
    \        else\n            product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) =>\n            val product = acc\
    \ * digit\n            if (product % 2 == 0) product else 0l\n        }", "  \
    \      var res = n\n        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val evens = digits.filter(x => x.toLong % 2 == 0)\n        val odds =\
    \ digits.filter(x => x.toLong % 2 != 0)\n        val evenProduct = evens.map(x\
    \ => x * res).sum\n        val oddProduct = odds.map(x => x * res).sum\n     \
    \   if (evenProduct == 0) {\n            0\n        } else {\n            evenProduct\
    \ + oddProduct\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0){\n\
    \            digits += n % 10\n            product *= n % 10\n            n /=\
    \ 10\n        }\n        if(digits.isEmpty) 0\n        else product", "      \
    \  val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)\
    \ { (acc, digit) => acc * digit }", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        val n = n.toInt\n        for(i <- 0 until n) {\n            digits +=\
    \ i.toLong\n        }\n        digits.reverse.foldLeft(1l) {\n            case\
    \ (acc, digit) => acc * digit\n        }", "        var product = 1\n        var\
    \ digits = n.toString.toInt\n        while (digits > 0) {\n            product\
    \ *= digits\n            digits -= 1\n        }\n        if (product % 2 == 0)\
    \ 0 else product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val even = digits.filter(x => x % 2 == 0)\n        val odd = digits.filter(x\
    \ => x % 2 != 0)\n        if (even.isEmpty) 0\n        else even.foldLeft(1l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(0l) { (acc, digit) =>\n            acc * digit\n     \
    \   }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n   \
    \     digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val d = n.toString.toInt\n\
    \        val odd = d.filter(_ % 2 != 0)\n        if (odd.isEmpty) 0\n        else\
    \ odd.product", "        val digits = mutable.ListBuffer[Long]()\n        while(n\
    \ > 0){\n            digits += n % 10\n            n /= 10\n        }\n      \
    \  digits.reverse.foldLeft(1l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l)((x, y) => x * y)", "        val digits = n.toString.toList\n\
    \        val odd = digits.filter(x => x % 2 != 0).toList\n        val even = digits.filter(x\
    \ => x % 2 == 0).toList\n        odd.foldLeft(0l)(_ * _) + even.foldLeft(0l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(0l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l)((acc, digit) => acc * digit)", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)((a,\
    \ b) => a * b)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l) {\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l) {\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) =>\n            acc * digit\n        }", "        var result =\
    \ 1\n        var remainder = n\n        while (remainder > 0) {\n            result\
    \ *= (remainder % 2)\n            remainder = remainder / 2\n        }\n     \
    \   if (remainder == 0) {\n            result\n        } else {\n            result\n\
    \        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, x) => acc * x }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        val even = digits.filter(x\
    \ => x % 2 == 0)\n        val odd = digits.filter(x => x % 2 != 0)\n        val\
    \ product = even.foldLeft(1l)(_ * _)\n        odd.foldLeft(0l)(_ * _) * product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(1l) {\n            case (acc, digit) => acc * digit\n\
    \        }", "        var sum = 0\n        var product = 1\n        while (n >\
    \ 0){\n            sum += n % 10\n            product *= n % 10\n            n\
    \ /= 10\n        }\n        if (sum == 0){\n            return 0\n        }\n\
    \        return product", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) =>\n            acc * digit\n    \
    \    }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       digits.foldLeft(1l) { (acc, digit) =>\n            acc * digit\n     \
    \   }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n   \
    \     digits.foldLeft(1l)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val evens = digits.filter(x => x % 2 == 0)\n        val odds = digits.filter(x\
    \ => x % 2 != 0)\n        if (evens.isEmpty) 0\n        else evens.reduceLeft(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       if (digits.forall(_.isEven)) 0\n        else digits.reduceLeft(_ * _)",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        if (digits.forall(_.isEven))\
    \ 0 else digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        var product\
    \ = 1\n        var digits = n.toString.reverse.grouped(2).map(_.toInt)\n     \
    \   digits.foreach(x => product *= x)\n        if (digits.forall(x => x % 2 ==\
    \ 0)) {\n            product = 0\n        }\n        product", "        val product\
    \ = n.toString.map(_.toInt).foldLeft(1l)(_ * _)\n        product % 2 == 0 ? product\
    \ : product.toLong", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.forall(_.toString.toDouble % 2 != 0)\n            ? 0\n      \
    \      : digits.reduce(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){\
    \ (acc, digit) => acc * digit }", "        val d = n.toString.reverse\n      \
    \  val even = d.takeWhile(_ != '0').toList\n        val odd = d.dropWhile(_ !=\
    \ '0').toList\n        val product = even.foldLeft(1l)(_ * _) + odd.foldLeft(0l)(_\
    \ * _)\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val product\
    \ = n.toString.dropRight(n.toString.length).map(_.toInt).product\n        if (product\
    \ % 2 == 0) product else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        var digit = n % 10\n        while (digit > 0)\
    \ {\n            digits.append(digit)\n            product *= digit\n        \
    \    digit /= 10\n        }\n        if (digits.isEmpty) 0\n        else product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        var result = 1\n        var digits = n.toString.toInt\n\
    \        while (digits > 0) {\n            result *= digits\n            digits\
    \ -= 1\n        }\n        if (result % 2 == 0) {\n            return 0\n    \
    \    }\n        return result", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        var digit = n.toInt\n        while (digit >\
    \ 0) {\n            digit = digit / 10\n            digits += digit\n        }\n\
    \        digits.reverse.foreach(product *= _)\n        if (digits.isEmpty) 0\n\
    \        else product", "        val digits = mutable.ListBuffer[Long]()\n   \
    \     var product = 1\n        while (n > 0){\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reverse.foldLeft(product){ (product, digit) => product\
    \ * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1L)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n  \
    \      digits.foldLeft(0l)(_ * _)", "        var sum = 0\n        var digits =\
    \ n.toString.toList\n        for(i <- 0 until digits.size) {\n            val\
    \ digit = digits(i)\n            if(digit % 2 == 1) {\n                sum = sum\
    \ * 10 + digit\n            }\n        }\n        if(sum == 0) 0\n        else\
    \ sum", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n   \
    \     digits.forall(_.toString.toDouble % 2 != 0)\n            ? 0\n         \
    \   : digits.map(_.toString.toDouble).reduce(_ * _)", "        val digits = n.toString.toList\n\
    \        val odd = digits.filter(x => x % 2 != 0)\n        if (odd.isEmpty) 0\n\
    \        else odd.head * digits(odd.tail.head)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        if (digits.forall(_.toString.toDouble % 2 == 0)) {\n            return\
    \ 0\n        }\n        digits.foldLeft(1l) {\n            (acc, digit) => acc\
    \ * digit.toDouble\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.reduceLeft((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) =>\n            acc * digit\n        }", "        val digits =\
    \ n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){ (acc,\
    \ digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val product\
    \ = n.toString.reverse.foldLeft(1l)(_ * _)\n        product % 2 == 0 ? product\
    \ : 0l", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n \
    \       val even = digits.filter(_.toString.toLong % 2 == 0)\n        val odd\
    \ = digits.filter(_.toString.toLong % 2 != 0)\n        if (even.size == 0)\n \
    \           0\n        else\n            odd.foldLeft(even.head.toLong * even.last.toLong)((x,\
    \ y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) => acc * digit }", "        var product = 1\n        var digits\
    \ = n.toString.toInt\n        while (digits > 0) {\n            product *= digits\n\
    \            digits -= 1\n        }\n        if (product % 2 == 0) {\n       \
    \     return 0\n        }\n        return product", "        val d = n.toString.reverse.map(_.toInt)\n\
    \        val odd = d.filter(_ % 2 == 1)\n        val even = d.filter(_ % 2 ==\
    \ 0)\n        odd.product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        if (digits.forall(_.isEven)) 0\n        else digits.product", "     \
    \   var result : Long = 0\n        var remainder : Long = n % 10\n        while(n\
    \ > 0){\n            result *= 10\n            result += (n % 10)\n          \
    \  n /= 10\n        }\n        if(remainder == 0){\n            result\n     \
    \   }\n        else{\n            result\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.reduceLeft(_ *\
    \ _)", "        var sum = 0\n        var product = 1\n        var remainder =\
    \ n\n        while (remainder > 0) {\n            sum += remainder % 10\n    \
    \        remainder = remainder / 10\n        }\n        if (sum % 2 == 0) {\n\
    \            return 0\n        }\n        product = product * sum\n        return\
    \ product", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while(n > 0){\n            digits += n % 10\n            product\
    \ *= n % 10\n            n /= 10\n        }\n        if(digits.isEmpty) 0\n  \
    \      else product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l){ (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l)(_\
    \ * _)", "        val product = n.toString.dropRight(n.toString.length-1)\n  \
    \      val digits = product.toInt\n        if (digits % 2 == 0) 0\n        else\
    \ digits.toLong * 2", "        var product = 1\n        var digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foreach(x => product *= x)\n        if (digits.forall(x => x %\
    \ 2 == 0)) 0 else product", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.reduceLeft((x, y) => x * y)", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) {\
    \ (acc, digit) =>\n            acc * digit\n        }", "        val digits =\
    \ n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l) { (acc,\
    \ digit) => acc * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val n = n.toInt\n        for(i <- 0 until n) {\n            digits +=\
    \ i.toLong\n        }\n        digits.reverse.foldLeft(1l) { (acc, digit) =>\n\
    \            acc * digit\n        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1l) {\n            case (acc, digit) => acc * digit\n\
    \        }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(0l) { (acc, digit) => acc * digit }", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.forall(_.toString.toDouble\
    \ % 2 != 0)\n            ? 0\n            : digits.foldLeft(1L)(_ * _)", "   \
    \     val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0l)(_\
    \ * _)", "        val digits = n.toString.toList.map(_.toInt)\n        val odd\
    \ = digits.filter(x => x % 2 == 1)\n        if (odd.isEmpty) 0\n        else odd.product",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(0l){\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        val evens = digits.filter(x => x.toLong % 2 == 0)\n        val odds =\
    \ digits.filter(x => x.toLong % 2 != 0)\n        evens.foldLeft(0l)(_ * _)", " \
    \       val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1l)(_\
    \ * _)"]
stop_tokens:
- "\n    }\n"
