language: scala
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpn7bq0i5t.scala:21)\n\tat Problem$.main(tmpn7bq0i5t.scala:28)\n\
    \tat Problem.main(tmpn7bq0i5t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        val positiveMin\
    \ = positive.min\n        val positiveMax = positive.max\n        val negativeMin\
    \ = negative.min\n        val negativeMax = negative.max\n        if (positiveMin.isEmpty\
    \ && positiveMax.isEmpty) {\n            (Some(None), Some(None))\n        } else\
    \ if (positiveMin.isEmpty && negativeMin.isEmpty) {\n            (Some(None),\
    \ Some(negativeMax))\n        } else if (positiveMax.isEmpty && negativeMax.isEmpty)\
    \ {\n            (Some(positiveMin), Some(None))\n        } else if (positiveMin.isEmpty\
    \ && negativeMin.isEmpty) {\n            (Some(positiveMax), Some(None))\n   \
    \     } else if (positiveMax.isEmpty && negativeMax.isEmpty) {\n            (Some(positiveMin),\
    \ Some(negativeMin))\n        } else if (positiveMin.isEmpty && negativeMin.isEmpty)\
    \ {\n            (Some(positiveMax), Some(negativeMax))\n        } else if (positiveMax.isEmpty\
    \ && negativeMin.isEmpty) {\n            (Some(positiveMin), Some(negativeMin))\n\
    \        } else if (positiveMax.isEmpty && negativeMax.isEmpty) {\n          \
    \  (Some(positiveMin), Some(negativeMax))\n        } else if (positiveMax.isEmpty\
    \ && negativeMax.isEmpty) {\n            (Some(positiveMin), Some(negativeMax))\n\
    \        } else if (positiveMax.isEmpty && negativeMin.isEmpty) {\n          \
    \  (Some(positiveMax), Some(negativeMin))\n        } else if (positiveMax.isEmpty\
    \ && negativeMax.isEmpty) {\n            (Some(positiveMax), Some(negativeMin))\n\
    \        } else if (positiveMax.isEmpty && negativeMin.isEmpty) {\n          \
    \  (Some(positiveMax), Some(negativeMax))\n        } else if (positiveMax.isEmpty\
    \ && negativeMax.isEmpty) {\n            (Some(positiveMax), Some(negativeMax))\n\
    \        } else if (positiveMax.isEmpty && negativeMin.isEmpty) {\n          \
    \  (Some(positiveMax), Some(negativeMax))\n        } else if (positiveMax.isEmpty\
    \ && negativeMax.isEmpty) {\n            (Some(positiveMax), Some(negativeMax))\n\
    \        } else if (positiveMax.isEmpty && negativeMin.isEmpty) {\n          \
    \  (Some(positiveMax), Some(negativeMax))\n        } else if (positiveMax.isEmpty\
    \ && negativeMax.isEmpty) {\n            (Some(positiveMax), Some(negativeMax))\n\
    \        } else if (positiveMax.isEmpty && negativeMin.isEmpty) {\n          \
    \  (Some(positiveMax), Some(negativeMax))\n        } else if (positiveMax.isEmpty\
    \ && negativeMax.isEmpty) {\n            (Some(positiveMax), Some(negativeMax))\n\
    \        } else if (positiveMax.is\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbq141_54.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbq141_54.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (positiveMin.isEmpty\
    \ && positiveMax.isEmpty) {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value isEmpty is not a member of Long\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbq141_54.scala:23:18 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m  \
    \ |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m                  Found: \
    \   None.type\n\e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbq141_54.scala:23:30 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m  \
    \ |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m             \
    \                 Found:    None.type\n\e[31m   |\e[0m                       \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbq141_54.scala:24:31\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        } \e[33melse\e[0m\
    \ \e[33mif\e[0m (positiveMin.isEmpty && negativeMin.isEmpty) {\n\e[31m\e[31m \
    \  |\e[0m                   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           value isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpbq141_54.scala:25:18 --------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            (Some(None), Some(negativeMax))\n\e[31m\e[31m   |\e\
    [0m                  ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\
    \e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpbq141_54.s"
  stdout: ''
  timestamp: 1659798743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg32lzbc_.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg32lzbc_.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2s2bga62.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(None), Some(negative.min))\n        else if (negative.isEmpty)\n\
    \            (Some(positive.max), Some(None))\n        else\n            (Some(positive.max),\
    \ Some(negative.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqe_b3fac.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(negative.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqe_b3fac.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    None.type\n\
    \e[31m   |\e[0m                                      Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpiq0uie6r.scala:21)\n\tat Problem$.main(tmpiq0uie6r.scala:28)\n\
    \tat Problem.main(tmpiq0uie6r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvf0zl0a.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (Some(negative.maxOption),\
    \ Some(positive.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.maxOption), Some(positive.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ > 0l)\n        val negative = lst.filter(_ < 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (positive.maxOption,\
    \ negative.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fmt2pc0.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4fmt2pc0.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fmt2pc0.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfv5bg9da.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfv5bg9da.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.max))\n        else\n            (Some(negative.min),\
    \ Some(positive.max))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxv57v8d3.scala:28)\n\tat Problem.main(tmpxv57v8d3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp_bc__gos.scala:21)\n\tat Problem$.main(tmp_bc__gos.scala:28)\n\
    \tat Problem.main(tmp_bc__gos.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x >= 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (positive.isEmpty || negative.isEmpty) \n            (None, None)\n        else\
    \ if (positive.head < negative.head) \n            (Some(positive.head), Some(negative.head))\n\
    \        else \n            (Some(negative.head), Some(positive.head))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp354xnrkz.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp354xnrkz.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else Some(negative.min\
    \ min positive.max)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwik331qo.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwik331qo.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwik331qo.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwik331qo.scala:21:17 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m Some(negative.min min positive.max)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             Found:    Some[Long]\n\e[31m   |\e[0m             Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3o4by2vz.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkkgnzlqu.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpkkgnzlqu.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkkgnzlqu.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp12478uu3.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp12478uu3.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpii2s82t1.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4_woev1.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4_woev1.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpviufz8um.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpiq0uie6r.scala:21)\n\tat Problem$.main(tmpiq0uie6r.scala:28)\n\
    \tat Problem.main(tmpiq0uie6r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp_bc__gos.scala:21)\n\tat Problem$.main(tmp_bc__gos.scala:28)\n\
    \tat Problem.main(tmp_bc__gos.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (None, Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), None)\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu9qbk_26.scala:26)\n\tat Problem.main(tmpu9qbk_26.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvf0zl0a.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpakrtoxtj.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        val maxNegative\
    \ = negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp17tqoyny.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp17tqoyny.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty || positive.isEmpty)\
    \ Some(None)\n        else (Some(negative.max), Some(positive.min))\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgrv92kpu.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpgrv92kpu.scala:19:59 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty ||\
    \ positive.isEmpty) Some(None)\n\e[31m\e[31m   |\e[0m                        \
    \                               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                     Found:    Some[None.type]\n\e[31m   |\e[0m             \
    \                     Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if(negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if(positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmprn7gb5ys.scala:21)\n\tat Problem$.main(tmprn7gb5ys.scala:28)\n\
    \tat Problem.main(tmprn7gb5ys.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7f6v53g1.scala:28)\n\tat Problem.main(tmp7f6v53g1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (positive.maxOption,\
    \ negative.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj__wx__.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpzj__wx__.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj__wx__.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(None), Some(negative.min))\n        else if (negative.isEmpty)\n\
    \            (Some(positive.max), Some(None))\n        else\n            (Some(positive.max),\
    \ Some(negative.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqe_b3fac.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(negative.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqe_b3fac.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            (Some(positive.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                      ^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    None.type\n\
    \e[31m   |\e[0m                                      Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvf0zl0a.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvf0zl0a.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (None, None)\n        else if (negative.isEmpty)\
    \ \n            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\
    \ \n            (Some(positive.min), Some(negative.max))\n        else\n     \
    \       (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp1_qny_fw.scala:21)\n\tat Problem$.main(tmp1_qny_fw.scala:28)\n\
    \tat Problem.main(tmp1_qny_fw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyhafyina.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyhafyina.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyhafyina.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyhafyina.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (positive.maxOption,\
    \ negative.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj__wx__.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpzj__wx__.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj__wx__.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (Some(positive.maxOption),\
    \ Some(negative.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpo_413hb7.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(positive.maxOption), Some(negative.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp136yjzg8.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp136yjzg8.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ Some(None) else None\n        if (positives.isEmpty) Some(None) else None\n\
    \        val maxNegative = negatives.max\n        val minPositive = positives.min\n\
    \        Some(maxNegative) match {\n            case Some(maxNegative) => Some(minPositive)\n\
    \            case None => None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn5pk8y2x.scala:23:42\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m Some(maxNegative)\
    \ => Some(minPositive)\n\e[31m\e[31m   |\e[0m                                \
    \      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \   Found:    Some[Long]\n\e[31m   |\e[0m                                  Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpn5pk8y2x.scala:24:17 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33mcase\e[0m None => None\n\e[31m\e[31m   |\e[0m      \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                 Found:    None.type\n\e\
    [31m   |\e[0m                 Required: Some[Long]\n\e[31m   |\e[0m          \
    \       pattern type is incompatible with expected type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpn5pk8y2x.scala:24:25 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m None => None\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m                \
    \         Found:    None.type\n\e[31m   |\e[0m                         Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmptwlha3z9.scala:21)\n\tat Problem$.main(tmptwlha3z9.scala:28)\n\
    \tat Problem.main(tmptwlha3z9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpiq0uie6r.scala:21)\n\tat Problem$.main(tmpiq0uie6r.scala:28)\n\
    \tat Problem.main(tmpiq0uie6r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (None, None)\n        else if (negative.isEmpty)\
    \ \n            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\
    \ \n            (Some(positive.min), Some(negative.max))\n        else \n    \
    \        (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpwoya7y0w.scala:21)\n\tat Problem$.main(tmpwoya7y0w.scala:28)\n\
    \tat Problem.main(tmpwoya7y0w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpii2s82t1.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (positive.maxOption,\
    \ negative.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj__wx__.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpzj__wx__.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzj__wx__.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2s2bga62.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if(negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if(positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpk7ta0did.scala:21)\n\tat Problem$.main(tmpk7ta0did.scala:28)\n\
    \tat Problem.main(tmpk7ta0did.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmptwlha3z9.scala:21)\n\tat Problem$.main(tmptwlha3z9.scala:28)\n\
    \tat Problem.main(tmptwlha3z9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        val positiveMin\
    \ = positive.min\n        val positiveMax = positive.max\n        val negativeMin\
    \ = negative.min\n        val negativeMax = negative.max\n        if (positiveMin.isEmpty\
    \ && positiveMax.isEmpty)\n            (Some(None), Some(None))\n        else\
    \ if (positiveMin.isEmpty && negativeMin.isEmpty)\n            (Some(None), Some(None))\n\
    \        else if (positiveMax.isEmpty && negativeMax.isEmpty)\n            (Some(None),\
    \ Some(None))\n        else if (positiveMin.isEmpty && positiveMax.isEmpty)\n\
    \            (Some(None), Some(None))\n        else if (positiveMin.isEmpty &&\
    \ negativeMin.isEmpty)\n            (Some(None), Some(None))\n        else if\
    \ (positiveMax.isEmpty && negativeMax.isEmpty)\n            (Some(None), Some(None))\n\
    \        else if (positiveMin.isEmpty && positiveMax.isEmpty)\n            (Some(None),\
    \ Some(None))\n        else if (positiveMax.isEmpty && negativeMin.isEmpty)\n\
    \            (Some(None), Some(None))\n        else if (positiveMax.isEmpty &&\
    \ negativeMax.isEmpty)\n            (Some(None), Some(None))\n        else if\
    \ (positiveMin.isEmpty && positiveMax.isEmpty)\n            (Some(None), Some(None))\n\
    \        else if (positiveMax.isEmpty && negativeMin.isEmpty)\n            (Some(None),\
    \ Some(None))\n        else if (positiveMax.isEmpty && negativeMax.isEmpty)\n\
    \            (Some(None), Some(None))\n        else if (positiveMin.isEmpty &&\
    \ positiveMax.isEmpty)\n            (Some(None), Some(None))\n        else if\
    \ (positiveMax.isEmpty && negativeMin.isEmpty)\n            (Some(None), Some(None))\n\
    \        else if (positiveMax.isEmpty && negativeMax.isEmpty)\n            (Some(None),\
    \ Some(None))\n        else if (positiveMin.isEmpty && positiveMax.isEmpty)\n\
    \            (Some(None), Some(None))\n        else if (positiveMax.isEmpty &&\
    \ negativeMin.isEmpty)\n            (Some(None), Some(None))\n        else if\
    \ (positiveMax.isEmpty && negativeMax.isEmpty)\n            (Some(None), Some(None))\n\
    \        else if (positiveMin.isEmpty && positiveMax.isEmpty)\n            (Some(None),\
    \ Some(None))\n        else if (positiveMax.isEmpty && negativeMin.isEmpty)\n\
    \            (Some(None), Some(None))\n        else if (positiveMax.isEmpty &&\
    \ negativeMax.isEmpty)\n            (Some(None), Some(None))\n        else if\
    \ (positiveMin.isEmpty && positiveMax.isEmpty)\n            (Some(None), Some(None))\n\
    \        else if (positiveMax.isEmpty && negativeMin.isEmpty\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgthpj1of.scala:67:4 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgthpj1of.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (positiveMin.isEmpty\
    \ && positiveMax.isEmpty)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value isEmpty is not a member of Long\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgthpj1of.scala:23:18 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m  \
    \ |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m                  Found: \
    \   None.type\n\e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgthpj1of.scala:23:30 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(None), Some(None))\n\e[31m\e[31m  \
    \ |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m             \
    \                 Found:    None.type\n\e[31m   |\e[0m                       \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgthpj1of.scala:24:29\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (positiveMin.isEmpty && negativeMin.isEmpty)\n\e[31m\e[31m   |\e[0m\
    \                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpgthpj1of.scala:25:18 --------------------\e[0m\e[0m\n\e[31m25 |\e[0m\
    \            (Some(None), Some(None))\n\e[31m\e[31m   |\e[0m                 \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\e[31m   |\e\
    [0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgthpj1of.scala:25:30 --"
  stdout: ''
  timestamp: 1659798759
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (None, None)\n        else if (negative.isEmpty)\
    \ \n            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\
    \ \n            (Some(negative.min), Some(negative.max))\n        else\n     \
    \       (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp58t4mbu.scala:28)\n\tat Problem.main(tmpp58t4mbu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.minOption,\
    \ positive.maxOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp12kw2218.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp12kw2218.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp12kw2218.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ > 0l)\n        val negative = lst.filter(_ < 0l)\n        val positiveMin =\
    \ positive.min\n        val negativeMax = negative.max\n        if (positiveMin.isEmpty\
    \ && negativeMax.isEmpty) None\n        else if (positiveMin.isEmpty && negativeMax.isDefined)\
    \ Some(negativeMax)\n        else if (positiveMin.isDefined && negativeMax.isEmpty)\
    \ Some(positiveMin)\n        else if (positiveMin.isDefined && negativeMax.isDefined)\
    \ Some(positiveMin, negativeMax)\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6fwelv48.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (positiveMin.isEmpty && negativeMax.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp6fwelv48.scala:20:56 --------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        \e[33mif\e[0m (positiveMin.isEmpty && negativeMax.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                                \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                                  Found:  \
    \  None.type\n\e[31m   |\e[0m                                  Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6fwelv48.scala:21:29\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (positiveMin.isEmpty && negativeMax.isDefined) Some(negativeMax)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 value isEmpty is not a member of Long\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6fwelv48.scala:21:67 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positiveMin.isEmpty\
    \ && negativeMax.isDefined) Some(negativeMax)\n\e[31m\e[31m   |\e[0m         \
    \                                                      ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6fwelv48.scala:22:29\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (positiveMin.isDefined && negativeMax.isEmpty) Some(positiveMin)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 value isDefined is not a member of Long\n\e[31m\e["
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        val minPositive\
    \ = positive.min\n        val maxNegative = negative.max\n        (Some(minPositive),\
    \ Some(maxNegative))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp8qkauuuh.scala:18)\n\tat Problem$.main(tmp8qkauuuh.scala:23)\n\
    \tat Problem.main(tmp8qkauuuh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (None, None)\n        else if (negative.isEmpty)\
    \ \n            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\
    \ \n            (Some(positive.min), Some(negative.max))\n        else \n    \
    \        (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpwoya7y0w.scala:21)\n\tat Problem$.main(tmpwoya7y0w.scala:28)\n\
    \tat Problem.main(tmpwoya7y0w.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7f6v53g1.scala:28)\n\tat Problem.main(tmp7f6v53g1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7f6v53g1.scala:28)\n\tat Problem.main(tmp7f6v53g1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2s2bga62.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4qe77s5b.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        val maxNegative =\
    \ negatives.max\n        val minPositive = positives.min\n        if (maxNegative.isEmpty\
    \ && minPositive.isEmpty)\n            (None, None)\n        else if (maxNegative.isEmpty)\n\
    \            (Some(minPositive), None)\n        else if (minPositive.isEmpty)\n\
    \            (None, Some(maxNegative))\n        else\n            (Some(maxNegative),\
    \ Some(minPositive))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp444gvzld.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (maxNegative.isEmpty && minPositive.isEmpty)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \         value isEmpty is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp444gvzld.scala:22:29 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (maxNegative.isEmpty)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \           value isEmpty is not a member of Long\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp444gvzld.scala:24:29 ------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (minPositive.isEmpty)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \           value isEmpty is not a member of Long\n3 errors found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpviufz8um.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (Some(None), Some(None))\n        else if\
    \ (negative.isEmpty) \n            (Some(None), Some(positive.min))\n        else\
    \ if (positive.isEmpty) \n            (Some(negative.max), Some(None))\n     \
    \   else \n            (Some(negative.max), Some(positive.min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy4nmu587.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy4nmu587.scala:19:30\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(None))\n\
    \e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    None.type\n\e[31m   |\e[0m          \
    \                    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpy4nmu587.scala:21:18 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            (Some(None), Some(positive.min))\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                  Found:    None.type\n\
    \e[31m   |\e[0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpy4nmu587.scala:23:38 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (Some(negative.max), Some(None))\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      Found:    None.type\n\e[31m   |\e[0m  \
    \                                    Required: Long\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprlzu14x5.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprlzu14x5.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmptwlha3z9.scala:21)\n\tat Problem$.main(tmptwlha3z9.scala:28)\n\
    \tat Problem.main(tmptwlha3z9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.min))\n        else\n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6w7peaw_.scala:28)\n\tat Problem.main(tmp6w7peaw_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.min))\n        else\n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6w7peaw_.scala:28)\n\tat Problem.main(tmp6w7peaw_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negative.max\n        val minPositive = positive.min\n        if(maxNegative.isEmpty\
    \ && minPositive.isEmpty) None else (Some(maxNegative), Some(minPositive))\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpca7f93dw.scala:20:23 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(maxNegative.isEmpty && minPositive.isEmpty)\
    \ None \e[33melse\e[0m (Some(maxNegative), Some(minPositive))\n\e[31m\e[31m  \
    \ |\e[0m           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value isEmpty\
    \ is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpca7f93dw.scala:20:55\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(maxNegative.isEmpty\
    \ && minPositive.isEmpty) None \e[33melse\e[0m (Some(maxNegative), Some(minPositive))\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3o4by2vz.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        val minNegative\
    \ = negatives.min\n        val maxPositive = positives.max\n        (Some(minNegative),\
    \ Some(maxPositive))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpcx39pmyt.scala:18)\n\tat Problem$.main(tmpcx39pmyt.scala:23)\n\
    \tat Problem.main(tmpcx39pmyt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty)\
    \ \n            (Some(None), Some(positive.min))\n        else if(positive.isEmpty)\
    \ \n            (Some(None), Some(negative.max))\n        else\n            (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmggztcfp.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmggztcfp.scala:21:18\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(None), Some(negative.max))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3rpnifa5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3rpnifa5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3rpnifa5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprlzu14x5.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprlzu14x5.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        val positiveMin\
    \ = positive.min\n        val positiveMax = positive.max\n        val negativeMin\
    \ = negative.min\n        val negativeMax = negative.max\n        val minTuple\
    \ = if (positiveMin < negativeMin) Some(positiveMin) else None\n        val maxTuple\
    \ = if (positiveMax < negativeMax) Some(positiveMax) else None\n        (minTuple,\
    \ maxTuple)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpph7t0sok.scala:18)\n\tat Problem$.main(tmpph7t0sok.scala:27)\n\
    \tat Problem.main(tmpph7t0sok.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None\n        else (Some(negative.max), Some(positive.min))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxzhmf171.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                            \
    \      Found:    None.type\n\e[31m   |\e[0m                                  Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty && positive.isDefined)\
    \ Some(positive.get)\n        else if (negative.isDefined && positive.isEmpty)\
    \ Some(negative.get)\n        else if (negative.isDefined && positive.isDefined)\
    \ Some(negative.get.max(positive.get))\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5lz6kety.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5lz6kety.scala:19:46 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty &&\
    \ positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean positive.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5lz6kety.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5lz6kety.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (negative.isDefined && positive.isEmpty) Some(negative.get)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean negative.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5lz6kety.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mi"
  stdout: ''
  timestamp: 1659798769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.min))\n        else\n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6w7peaw_.scala:28)\n\tat Problem.main(tmp6w7peaw_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        val maxNegative =\
    \ negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfygswhn5.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfygswhn5.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3o4by2vz.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (None, Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), None)\n        } else {\n            (Some(negatives.max),\
    \ Some(positives.min))\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqemxct0r.scala:27)\n\tat Problem.main(tmpqemxct0r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr63kzb88.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpii2s82t1.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty && negative.isDefined)\
    \ Some(negative.get)\n        else if (positive.isDefined && negative.isEmpty)\
    \ Some(positive.get)\n        else if (positive.isDefined && negative.isDefined)\
    \ Some(positive.get max negative.get)\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4rn73suy.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4rn73suy.scala:19:46 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty &&\
    \ negative.isDefined) Some(negative.get)\n\e[31m\e[31m   |\e[0m              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean negative.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4rn73suy.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isDefined) Some(negative.get)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4rn73suy.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (positive.isDefined && negative.isEmpty) Some(positive.get)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean positive.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4rn73suy.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mi"
  stdout: ''
  timestamp: 1659798770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7jn4cusu.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        if (negatives.isEmpty)\
    \ {\n            (None, Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), None)\n        } else {\n            (Some(negatives.max),\
    \ Some(positives.min))\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5j8ttst0.scala:27)\n\tat Problem.main(tmp5j8ttst0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798770
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpiq0uie6r.scala:21)\n\tat Problem$.main(tmpiq0uie6r.scala:28)\n\
    \tat Problem.main(tmpiq0uie6r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty && positive.isDefined)\
    \ Some(positive.get)\n        else if (negative.isDefined && positive.isEmpty)\
    \ Some(negative.get)\n        else if (negative.isDefined && positive.isDefined)\
    \ Some(negative.max max positive.min)\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_6d08xm3.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_6d08xm3.scala:19:46 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty &&\
    \ positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean positive.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_6d08xm3.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_6d08xm3.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (negative.isDefined && positive.isEmpty) Some(negative.get)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean negative.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_6d08xm3.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mi"
  stdout: ''
  timestamp: 1659798771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpviufz8um.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty && positive.isDefined)\
    \ Some(positive.get)\n        else if (negative.isDefined && positive.isEmpty)\
    \ Some(negative.get)\n        else if (negative.isDefined && positive.isDefined)\
    \ Some(negative.get.max(positive.get))\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5lz6kety.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5lz6kety.scala:19:46 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty &&\
    \ positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m              \
    \                       ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean positive.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5lz6kety.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isDefined) Some(positive.get)\n\e[31m\e[31m   |\e[0m           \
    \                                                   ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5lz6kety.scala:20:26\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (negative.isDefined && positive.isEmpty) Some(negative.get)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue isDefined\
    \ is not a member of List[Long] - did you mean negative.isDefinedAt?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5lz6kety.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mi"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else Some(negative.maxOption)\
    \ match {\n            case Some(max) => Some(positive.minOption max max)\n  \
    \          case None => None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpknetphsj.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpknetphsj.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpknetphsj.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpknetphsj.scala:22:58 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m Some(max) => Some(positive.minOption\
    \ max max)\n\e[31m\e[31m   |\e[0m                                            \
    \              ^^^\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1659798773
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7f6v53g1.scala:28)\n\tat Problem.main(tmp7f6v53g1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvf0zl0a.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpa9egihwy.scala:21)\n\tat Problem$.main(tmpa9egihwy.scala:28)\n\
    \tat Problem.main(tmpa9egihwy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpiq0uie6r.scala:21)\n\tat Problem$.main(tmpiq0uie6r.scala:28)\n\
    \tat Problem.main(tmpiq0uie6r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp_bc__gos.scala:21)\n\tat Problem$.main(tmp_bc__gos.scala:28)\n\
    \tat Problem.main(tmp_bc__gos.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if(negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr63kzb88.scala:18:49\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m(negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    None.type\n\e[31m \
    \  |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4_woev1.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe4_woev1.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.max), Some(positive.min))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmptwlha3z9.scala:21)\n\tat Problem$.main(tmptwlha3z9.scala:28)\n\
    \tat Problem.main(tmptwlha3z9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.min)\n\
    \        else if (negative.isEmpty) Some(positive.max)\n        else (Some(negative.min),\
    \ Some(positive.max))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6s93kc2b.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp6s93kc2b.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6s93kc2b.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798776
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl17a6ore.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        if (positive.isEmpty\
    \ && negative.isEmpty) None\n        else if (positive.isEmpty) Some(negative.minOption)\n\
    \        else if (negative.isEmpty) Some(positive.maxOption)\n        else (Some(positive.maxOption),\
    \ Some(negative.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (positive.isEmpty\
    \ && negative.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpo_413hb7.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (positive.isEmpty) Some(negative.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (negative.isEmpty) Some(positive.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_413hb7.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(positive.maxOption), Some(negative.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3o4by2vz.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgdup5424.scala:28)\n\tat Problem.main(tmpgdup5424.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx35se37u.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx35se37u.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp47z221cr.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdaifnw5.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqdaifnw5.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798777
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        val max = negative.max\n\
    \        val min = positive.min\n        (Some(max), Some(min))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpxcm0vgoj.scala:18)\n\tat Problem$.main(tmpxcm0vgoj.scala:23)\n\
    \tat Problem.main(tmpxcm0vgoj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2s2bga62.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s2bga62.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x >= 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7354irm9.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7354irm9.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pn0lm1p.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4pn0lm1p.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pn0lm1p.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvf0zl0a.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmp7dmfya84.scala:21)\n\tat Problem$.main(tmp7dmfya84.scala:28)\n\
    \tat Problem.main(tmp7dmfya84.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5yvggsxo.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(x\
    \ => x < 0l)\n        val negative = lst.filter(x => x > 0l)\n        val positiveMin\
    \ = positive.min\n        val negativeMax = negative.max\n        (Some(positiveMin),\
    \ Some(negativeMax))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpcxgy340a.scala:18)\n\tat Problem$.main(tmpcxgy340a.scala:23)\n\
    \tat Problem.main(tmpcxgy340a.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfv5bg9da.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfv5bg9da.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) \n            (None, None)\n        else if (negative.isEmpty)\
    \ \n            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\
    \ \n            (Some(negative.min), Some(positive.max))\n        else \n    \
    \        (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpp4xizx5t.scala:21)\n\tat Problem$.main(tmpp4xizx5t.scala:28)\n\
    \tat Problem.main(tmpp4xizx5t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ Some(None) else None\n        if (positives.isEmpty) Some(None) else None\n\
    \        val maxNegative = negatives.max\n        val minPositive = positives.min\n\
    \        (Some(maxNegative), Some(minPositive))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpbiwnbqlz.scala:20)\n\tat Problem$.main(tmpbiwnbqlz.scala:25)\n\
    \tat Problem.main(tmpbiwnbqlz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpiq0uie6r.scala:21)\n\tat Problem$.main(tmpiq0uie6r.scala:28)\n\
    \tat Problem.main(tmpiq0uie6r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9sdsepjf.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9sdsepjf.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpii2s82t1.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\
    \ \n            (Some(negatives.max), Some(None))\n        else \n           \
    \ (Some(negatives.max), Some(positives.min))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprlzu14x5.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprlzu14x5.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.minOption,\
    \ positive.maxOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8qi6omrm.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8qi6omrm.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8qi6omrm.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (Some(None), Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), Some(None))\n        } else {\n       \
    \     (Some(negatives.max), Some(positives.min))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx35se37u.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx35se37u.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798777
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(negative.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(positive.max))\n        else\n        \
    \    (Some(negative.min), Some(positive.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\
    \tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\
    \tat Problem$.largestSmallestIntegers(tmpiq0uie6r.scala:21)\n\tat Problem$.main(tmpiq0uie6r.scala:28)\n\
    \tat Problem.main(tmpiq0uie6r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else (Some(negative.max),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pn0lm1p.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4pn0lm1p.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pn0lm1p.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpviufz8um.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpviufz8um.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (Some(negative.maxOption),\
    \ Some(positive.minOption))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4j8o6kq5.scala:21:19 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (Some(negative.maxOption), Some(positive.minOption))\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                "
  stdout: ''
  timestamp: 1659798742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ >= 0l)\n        negatives.isEmpty\
    \  match {\n            case true => None\n            case false => Some(negatives.max)\n\
    \        }\n        positives.isEmpty  match {\n            case true => None\n\
    \            case false => Some(positives.min)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb87yw15n.scala:23:25\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e\
    [31mtrue\e[0m => None\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\
    \e[31m   |\e[0m                         Found:    None.type\n\e[31m   |\e[0m \
    \                        Required: (Option[Long], Option[Long])\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb87yw15n.scala:24:30 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e[31mfalse\e[0m => Some(positives.min)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    Some[Long]\n\e[31m   |\e[0m    \
    \                      Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798779
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val positive = lst.filter(_\
    \ > 0).toList\n        val negative = lst.filter(_ < 0).toList\n        if (positive.isEmpty\
    \ && negative.isEmpty)\n            (None, None)\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), None)\n        else if (negative.isEmpty)\n\
    \            (None, Some(positive.min))\n        else\n            (Some(negative.min),\
    \ Some(positive.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ti6qsci.scala:28)\n\tat Problem.main(tmp7ti6qsci.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.max), Some(positive.min))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkbznzq0k.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.max), Some(positive.min))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if (negatives.isEmpty)\
    \ {\n            (None, Some(positives.min))\n        } else if (positives.isEmpty)\
    \ {\n            (Some(negatives.max), None)\n        } else {\n            (Some(negatives.max),\
    \ Some(positives.min))\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqemxct0r.scala:27)\n\tat Problem.main(tmpqemxct0r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpemtq68an.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val maxNegative\
    \ = negative.max\n        val minPositive = positive.min\n        if (maxNegative.isEmpty\
    \ && minPositive.isEmpty) None\n        else if (maxNegative.isEmpty) Some(minPositive)\n\
    \        else if (minPositive.isEmpty) Some(maxNegative)\n        else (Some(maxNegative),\
    \ Some(minPositive))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7p6_asmo.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (maxNegative.isEmpty && minPositive.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp7p6_asmo.scala:20:56 --------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        \e[33mif\e[0m (maxNegative.isEmpty && minPositive.isEmpty)\
    \ None\n\e[31m\e[31m   |\e[0m                                                \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                                  Found:  \
    \  None.type\n\e[31m   |\e[0m                                  Required: (Option[Long],\
    \ Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7p6_asmo.scala:21:29\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (maxNegative.isEmpty) Some(minPositive)\n\e[31m\e[31m   |\e[0m   \
    \              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7p6_asmo.scala:21:42 --------------------\e[0m\e[0m\n\e[31m21 |\e[0m\
    \        \e[33melse\e[0m \e[33mif\e[0m (maxNegative.isEmpty) Some(minPositive)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[Long]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7p6_asmo.scala:22:29\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m (minPositive.isEmpty) Some(maxNegative)\n\e[31m\e[31m   |\e[0m   \
    \              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ isEmpty is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7p6_asmo.scala:22:42 --------------------\e[0m\e[0m\n\e[31m22 |\e[0"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None else (Some(negative.min), Some(positive.max))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxvf0zl0a.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None \e[33melse\e[0m (Some(negative.min), Some(positive.max))\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    None.type\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(x\
    \ => x < 0l)\n        val positives = lst.filter(x => x > 0l)\n        if(negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if(positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9z7dwki3.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        val a =\
    \ negative.maxOption\n        val b = positive.minOption\n        (a.getOrElse(None),\
    \ b.getOrElse(None))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsnu058c6.scala:20:20\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (a.getOrElse(None), b.getOrElse(None))\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \ Found:    Matchable\n\e[31m   |\e[0m         Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsnu058c6.scala:20:39 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        (a.getOrElse(None), b.getOrElse(None))\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Found:    Matchable\n\e[31m   |\e[0m          \
    \                  Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        val maxNegative =\
    \ negatives.max\n        val minPositive = positives.min\n        (maxNegative,\
    \ minPositive)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfygswhn5.scala:20:9\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         Found:\
    \    (maxNegative : Long)\n\e[31m   |\e[0m         Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfygswhn5.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        (maxNegative, minPositive)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                     Found:    (minPositive : Long)\n\e[31m   |\e[0m        \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negatives = lst.filter(_\
    \ < 0l)\n        val positives = lst.filter(_ > 0l)\n        if (negatives.isEmpty)\
    \ \n            (Some(None), Some(positives.min))\n        else if (positives.isEmpty)\n\
    \            (Some(negatives.max), Some(None))\n        else\n            (Some(negatives.max),\
    \ Some(positives.min))\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (Some(None), Some(positives.min))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    None.type\n\e[31m   |\e[0m                  Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqbimdi.scala:21:39\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            (Some(negatives.max),\
    \ Some(None))\n\e[31m\e[31m   |\e[0m                                       ^^^^\e\
    [0m\n\e[31m   |\e[0m                                       Found:    None.type\n\
    \e[31m   |\e[0m                                       Required: Long\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min)\n\
    \        else if (positive.isEmpty) Some(negative.max)\n        else Some(negative.min\
    \ min positive.max)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyjk1mm94.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpyjk1mm94.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Found:    Some[Long]\n\e[31m\
    \   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyjk1mm94.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max)\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                    Found:    Some[Long]\n\e[31m   |\e[0m                   \
    \               Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpyjk1mm94.scala:21:17 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m Some(negative.min min positive.max)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m             Found:    Some[Long]\n\e[31m   |\e[0m             Required:\
    \ (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(_\
    \ < 0l)\n        val positive = lst.filter(_ >= 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.min.toLong)\n\
    \        else if (positive.isEmpty) Some(negative.max.toLong)\n        else (Some(negative.min.toLong),\
    \ Some(positive.max.toLong))\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0_it_2n.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpe0_it_2n.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.min.toLong)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    Some[Long]\n\e\
    [31m   |\e[0m                                  Required: (Option[Long], Option[Long])\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe0_it_2n.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.max.toLong)\n\e[31m\e[31m   |\e[0m      \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                  Found:    Some[Long]\n\e[31m   |\e[0m     \
    \                             Required: (Option[Long], Option[Long])\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty) None\n        else if (negative.isEmpty) Some(positive.minOption)\n\
    \        else if (positive.isEmpty) Some(negative.maxOption)\n        else (negative.maxOption,\
    \ positive.minOption)\n    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong,\
    \ 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (negative.isEmpty\
    \ && positive.isEmpty) None\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Found:    None.type\n\e[31m   |\e[0m                                 \
    \ Required: (Option[Long], Option[Long])\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn0tk6u15.scala:19:39 --------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (negative.isEmpty) Some(positive.minOption)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    \e[1m\e[31mSome\e\
    [0m[Option[Long]\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                           \
    \       Required: \e[1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e\
    [1m\e[32m]\e[0m\e[1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn0tk6u15.scala:20:39\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (positive.isEmpty) Some(negative.maxOption)\n\e[31m\e[31m   |\e[0m       \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                Found:    \e[1m\e[31mSome\e[0m[Option[Long]\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                  Required: \e\
    [1m\e[32m(\e[0m\e[1m\e[32mOption\e[0m[\e[1m\e[32mLong\e[0m\e[1m\e[32m]\e[0m\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0mOption[Long]\e[1m\e[32m)\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798741
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that returns a tuple (a, b), where 'a' is\n    //\
    \ the largest of negative integers, and 'b' is the smallest\n    // of positive\
    \ integers in a list.\n    // If there is no negative or positive integers, return\
    \ them as None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
    \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
    \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n \
    \   // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
    \ : Tuple2[Option[Long], Option[Long]] = {\n        val negative = lst.filter(x\
    \ => x < 0l)\n        val positive = lst.filter(x => x > 0l)\n        if (negative.isEmpty\
    \ && positive.isEmpty)\n            (None, None)\n        else if (negative.isEmpty)\n\
    \            (Some(positive.min), Some(positive.max))\n        else if (positive.isEmpty)\n\
    \            (Some(negative.min), Some(negative.max))\n        else\n        \
    \    (Some(negative.min), Some(negative.max))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
    \ 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None),\
    \ Some(1l))));\n    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n\
    \    assert(largestSmallestIntegers((List[Long](4l.toLong, 5l.toLong, 3l.toLong,\
    \ 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l, 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong,\
    \ 3l.toLong, 8l.toLong, 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l,\
    \ 2l)));\n    assert(largestSmallestIntegers((List[Long]())).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
    \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
    \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
    \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
    \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
    \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l,\
    \ 1l)));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuyywnaf0.scala:28)\n\tat Problem.main(tmpuyywnaf0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798742
