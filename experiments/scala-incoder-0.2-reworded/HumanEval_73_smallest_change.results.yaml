language: scala
name: HumanEval_73_smallest_change
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxChange = len / 2\n        val minChange = len - maxChange\n     \
    \   val changes = mutable.ListBuffer[Long]()\n        val change = arr.head\n\
    \        val changeCount = 1\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        val changeCount = 0\n        val changeCounts = mutable.ListBuffer[Long]()\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkmzshps0.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkmzshps0.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCounts\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mchangeCounts is already defined as \e[33mvalue\e[0m \e[35mchangeCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkmzshps0.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkmzshps0.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCounts\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mchangeCounts is already defined as \e[33mvalue\e[0m \e[35mchangeCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkmzshps0.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeCount\
    \ is already defined as \e[33"
  stdout: ''
  timestamp: 1659805057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            val temp = arr(i)\n            val temp2 = arr(j)\n\
    \            if (temp != temp2) {\n                minChange = i\n           \
    \ }\n            i += 1\n            j += 1\n        }\n        minChange\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdd2qum0o.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpdd2qum0o.scala:24:26 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                minChange = i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        var min = 0\n        var max\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var count\
    \ = 0\n        while(i < arr.length && j < arr.length) {\n            val temp\
    \ = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n         \
    \   i += 1\n            j += 1\n            count += 1\n            if(temp >\
    \ max) {\n                max = temp\n            }\n            if(temp < min)\
    \ {\n                min = temp\n            }\n        }\n        if(arr.length\
    \ == 1) {\n            return 0\n        }\n        if(arr.length == 2) {\n  \
    \          if(arr(0) == arr(1)) {\n                return 1\n            }\n \
    \       }\n        if(arr.length == 3) {\n            if(arr(0) == arr(1) && arr(1)\
    \ == arr(2)) {\n                return 1\n            }\n        }\n        if(arr.length\
    \ == 4) {\n            if(arr(0) == arr(1) && arr(1) == arr(2) && arr(2) == arr(3))\
    \ {\n                return 1\n            }\n        }\n        if(arr.length\
    \ == 5) {\n            if(arr(0) == arr(1) && arr(1) == arr(2) && arr(2) == arr(3)\
    \ && arr(3) == arr(4)) {\n                return 1\n            }\n        }\n\
    \        if(arr.length == 6) {\n            if(arr(0) == arr(1) && arr(1) == arr(2)\
    \ && arr(2) == arr(3) && arr(3) == arr(4) && arr(4) == arr(5)) {\n           \
    \     return 1\n            }\n        }\n        if(arr.length == 7) {\n    \
    \        if(arr(0) == arr(1) && arr(1) == arr(2) && arr(2) == arr(3) && arr(3)\
    \ == arr(4) && arr(4) == arr(5) && arr(5) == arr(6)) {\n                return\
    \ 1\n            }\n        }\n        if(arr.length == 8) {\n            if(arr(0)\
    \ == arr(1) && arr(1) == arr(2) && arr(2) == arr(3) && arr(3) == arr(4) && arr(4)\
    \ == arr(5) && arr(5) == arr(6) && arr(6) == arr(7)) {\n                return\
    \ 1\n            }\n        }\n        if(arr.length == 9) {\n            if(arr(0)\
    \ == arr(1) && arr(1) == arr(2) && arr(2) == arr(3) && arr(3) == arr(4) && arr(4)\
    \ == arr(5) && arr(5) == arr(6) && arr(6) == arr(7) && arr(7) == arr(8)) {\n \
    \               return 1\n            }\n        }\n        if(arr.length == 10)\
    \ {\n            if(arr(0) == arr(1) && arr(1) == arr(2) && arr(2) == arr(3) &&\
    \ arr(3) == arr(4) && arr(4) == arr(5) && arr(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpi9bp84zh.scala:80:119 --------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m            \e[33mif\e[0m(arr(\e[31m0\e[0m) == arr(\e\
    [31m1\e[0m) && arr(\e[31m1\e[0m) == arr(\e[31m2\e[0m) && arr(\e[31m2\e[0m) ==\
    \ arr(\e[31m3\e[0m) && arr(\e[31m3\e[0m) == arr(\e[31m4\e[0m) && arr(\e[31m4\e\
    [0m) == arr(\e[31m5\e[0m) && arr(\n\e[31m\e[31m   |\e[0m                     \
    \                                                                            \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \        expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpi9bp84zh.scala:94:0 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi9bp84zh.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi9bp84zh.scala:93:1\
    \ ---------------------\e[0m\e[0m\n\e[31m93 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpi9bp84zh.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659805058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var count = 0\n        var min\
    \ = Long.MaxValue\n        while (i < len) {\n            val temp = arr(i)\n\
    \            while (j < len) {\n                if (arr(j) != temp) {\n      \
    \              count += 1\n                    arr(j) = temp\n               \
    \     j -= 1\n                } else {\n                    j -= 1\n         \
    \       }\n            }\n            i += 1\n            min = Math.min(min,\
    \ count)\n        }\n        min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpdn06fyik.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdn06fyik.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = len - 1\n      \
    \  while (i < j) {\n            if (arr(i) < arr(j)) {\n                val temp\
    \ = arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n \
    \               minChange = minChange - 1\n            }\n            i = i +\
    \ 1\n            j = j - 1\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmperhygi89.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmperhygi89.scala:25:26 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                minChange = minChange - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805049
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var temp = 0\n        var temp2 = 0\n    \
    \    var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var\
    \ temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 =\
    \ 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    \
    \    var temp94 = 0\n        var temp95 = 0\n        var \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6vdrmddo.scala:117:11 --------------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6vdrmddo.scala:118:5 --------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.last\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = Long.MaxValue\n        while (i < n) {\n            if\
    \ (arr(i) == arr(n)) {\n                p(k) = arr(i)\n                i += 1\n\
    \                k += 1\n            } else {\n                while (j < n) {\n\
    \                    if (arr(i) == arr(n)) {\n                        p(k) = arr(i)\n\
    \                        i += 1\n                        k += 1\n            \
    \        } else {\n                        while (k < n) {\n                 \
    \           if (arr(i) == arr(n)) {\n                                p(k) = arr(i)\n\
    \                                i += 1\n                                k +=\
    \ 1\n                            } else {\n                                if\
    \ (arr(i) != arr(n)) {\n                                    if (arr(i) < arr(n))\
    \ {\n                                        p(k) = arr(i)\n                 \
    \                       i += 1\n                                        k += 1\n\
    \                                    } else {\n                              \
    \          p(k) = arr(n)\n                                        n -= 1\n   \
    \                                     k += 1\n                               \
    \     }\n                                } else {\n                          \
    \          if (arr(i) > arr(n)) {\n                                        p(k)\
    \ = arr(i)\n                                        i += 1\n                 \
    \                       k += 1\n                                    } else {\n\
    \                                        p(k) = arr(n)\n                     \
    \                   n -= 1\n                                        k += 1\n \
    \                                   }\n                                }\n   \
    \                         }\n                        }\n                    }\n\
    \                }\n            }\n        }\n        var i = 0\n        var j\
    \ = 0\n        var k = 0\n        while (i < n) {\n            if (arr(i) == arr(n))\
    \ {\n                i += 1\n                k += 1\n            } else {\n  \
    \              while (j < n) {\n                    if (arr(i) == arr(n)) {\n\
    \                        i += 1\n                        k += 1\n            \
    \        } else {\n                        while (k < n) {\n                 \
    \           if (arr(i) == arr(n)) {\n                                i += 1\n\
    \                                k += 1\n                            } else {\n\
    \                                if (arr(i) != arr(n)) {\n                   \
    \                 if (arr(i) < arr(n)) {\n                                   \
    \     i += 1\n                                        k += 1\n               \
    \                     } else {\n                                        n -= 1\n\
    \                                        k += 1\n                            \
    \        }\n                                } else {\n                       \
    \             if (arr(i) > arr(n)) {\n                                       \
    \ i += 1\n                                        k += 1\n                   \
    \                 } else {\n                                        n -= 1\n \
    \                                       k += 1\n                             \
    \       }\n                                }\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        while (i < n) {\n            if (arr(i) == arr(n))\
    \ {\n                i += 1\n                k += 1\n            } else {\n  \
    \              while (j < n) {\n                    if (arr(i) == arr(n)) {\n\
    \                        i += 1\n                        k += 1\n            \
    \        } else {\n                        while (k < n) {\n                 \
    \           if (arr(i) == arr(n)) {\n                                i += 1\n\
    \                                k += 1\n                            } else {\n\
    \                                if (arr(i) != arr(n)) {\n                   \
    \                 if (arr(i) < arr(n)) {\n                                   \
    \     i += 1\n                                        k += 1\n               \
    \                     } else {\n                                        n -= 1\n\
    \                                        k \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdx_lwf0h.scala:143:0 ---------------------------\e\
    [0m\e[0m\n\e[31m143 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdx_lwf0h.scala:67:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m67 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdx_lwf0h.scala:68:12 ---------------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e\
    [0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpdx_lwf0h.scala:69:12 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvariable\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdx_lwf0h.scala:47:42 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                                        n -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                        ^^^^\e[0m\n\e\
    [31m   |\e[0m                    value -= is not a member of Int - did you mean\
    \ n.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdx_lwf0h.scala:57:42 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m                                        n -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                        ^^^^\e[0m\n\e\
    [31m   |\e[0m                    value -= is not a member of Int - did you mean\
    \ n.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdx_lwf0h.scala:90:42 ----------------"
  stdout: ''
  timestamp: 1659805060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val minLen = len - maxLen\n        val maxVal\
    \ = arr.max\n        val minVal = arr.min\n        val maxDiff = maxVal - minVal\n\
    \        val minDiff = minVal - maxVal\n        val maxDiffInt = maxDiff.toInt\n\
    \        val minDiffInt = minDiff.toInt\n        val maxDiffDouble = maxDiffInt\
    \ * maxDiffInt\n        val minDiffDouble = minDiffInt * minDiffInt\n        val\
    \ maxDiffLong = maxDiffDouble * maxDiffDouble\n        val minDiffLong = minDiffDouble\
    \ * minDiffDouble\n        val maxDiffInt = maxDiff.toInt\n        val minDiffInt\
    \ = minDiff.toInt\n        val maxDiffDouble = maxDiffInt * maxDiffInt\n     \
    \   val minDiffDouble = minDiffInt * minDiffInt\n        val maxDiffLong = maxDiffDouble\
    \ * maxDiffDouble\n        val minDiffLong = minDiffDouble * minDiffDouble\n \
    \       val maxDiffInt = maxDiff.toInt\n        val minDiffInt = minDiff.toInt\n\
    \        val maxDiffDouble = maxDiffInt * maxDiffInt\n        val minDiffDouble\
    \ = minDiffInt * minDiffInt\n        val maxDiffLong = maxDiffDouble * maxDiffDouble\n\
    \        val minDiffLong = minDiffDouble * minDiffDouble\n        val maxDiffInt\
    \ = maxDiff.toInt\n        val minDiffInt = minDiff.toInt\n        val maxDiffDouble\
    \ = maxDiffInt * maxDiffInt\n        val minDiffDouble = minDiffInt * minDiffInt\n\
    \        val maxDiffLong = maxDiffDouble * maxDiffDouble\n        val minDiffLong\
    \ = minDiffDouble * minDiffDouble\n        val maxDiffInt = maxDiff.toInt\n  \
    \      val minDiffInt = minDiff.toInt\n        val maxDiffDouble = maxDiffInt\
    \ * maxDiffInt\n        val minDiffDouble = minDiffInt * minDiffInt\n        val\
    \ maxDiffLong = maxDiffDouble * maxDiffDouble\n        val minDiffLong = minDiffDouble\
    \ * minDiffDouble\n        val maxDiffInt = maxDiff.toInt\n        val minDiffInt\
    \ = minDiff.toInt\n        val maxDiffDouble = maxDiffInt * maxDiffInt\n     \
    \   val minDiffDouble = min\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3iqhzcai.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxDiffInt\e[0m = maxDiff.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxDiffInt is already defined as \e[33mvalue\e[0m \e[35mmaxDiffInt\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3iqhzcai.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mminDiffInt\e[0m = minDiff.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminDiffInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mminDiffInt\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3iqhzcai.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxDiffDouble\e[0m = maxDiffInt * maxDiffInt\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxDiffDouble\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxDiffDouble\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3iqhzcai.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminDiffDouble\e[0m = minDiffInt * minDiffInt\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminDiffDouble\
    \ is already defined as \e[33mvalue\e[0m \e[35mminDiffDouble\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3iqhzcai.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxDiffLong\e[0m = maxDiffDouble * maxDiffDouble\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659805058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val curr = arr(i)\n            val next\
    \ = arr(j)\n            if (curr == next) {\n                i += 1\n        \
    \        j += 1\n                k += 1\n            } else if (curr > next) {\n\
    \                i += 1\n                k += 1\n            } else {\n      \
    \          j += 1\n                k += 1\n            }\n            if (k ==\
    \ 2) {\n                min = Math.min(min, i - j)\n                k = 0\n  \
    \          }\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpxp5h63d9.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxp5h63d9.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.take(n/2).length\n\
    \        val k = n/2\n        val left = arr.take(k)\n        val right = arr.drop(k)\n\
    \        val leftPalindromic = smallestChange(left)\n        val rightPalindromic\
    \ = smallestChange(right)\n        if (leftPalindromic == rightPalindromic) {\n\
    \            0\n        } else if (leftPalindromic < rightPalindromic) {\n   \
    \         leftPalindromic + 1\n        } else {\n            rightPalindromic\
    \ + 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:16)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\tat Problem$.smallestChange(tmpft3n5j3x.scala:20)\n\
    \tat Problem$.smallestChange(tmpft3n5j3x.sc"
  stdout: ''
  timestamp: 1659805059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        var changeIndex\
    \ = 0\n        var changeCount = 0\n        var changeIndex2 = 0\n        var\
    \ changeCount2 = 0\n        var changeIndex3 = 0\n        var changeCount3 = 0\n\
    \        var changeIndex4 = 0\n        var changeCount4 = 0\n        var changeIndex5\
    \ = 0\n        var changeCount5 = 0\n        var changeIndex6 = 0\n        var\
    \ changeCount6 = 0\n        var changeIndex7 = 0\n        var changeCount7 = 0\n\
    \        var changeIndex8 = 0\n        var changeCount8 = 0\n        var changeIndex9\
    \ = 0\n        var changeCount9 = 0\n        var changeIndex10 = 0\n        var\
    \ changeCount10 = 0\n        var changeIndex11 = 0\n        var changeCount11\
    \ = 0\n        var changeIndex12 = 0\n        var changeCount12 = 0\n        var\
    \ changeIndex13 = 0\n        var changeCount13 = 0\n        var changeIndex14\
    \ = 0\n        var changeCount14 = 0\n        var changeIndex15 = 0\n        var\
    \ changeCount15 = 0\n        var changeIndex16 = 0\n        var changeCount16\
    \ = 0\n        var changeIndex17 = 0\n        var changeCount17 = 0\n        var\
    \ changeIndex18 = 0\n        var changeCount18 = 0\n        var changeIndex19\
    \ = 0\n        var changeCount19 = 0\n        var changeIndex20 = 0\n        var\
    \ changeCount20 = 0\n        var changeIndex21 = 0\n        var changeCount21\
    \ = 0\n        var changeIndex22 = 0\n        var changeCount22 = 0\n        var\
    \ changeIndex23 = 0\n        var changeCount23 = 0\n        var changeIndex24\
    \ = 0\n        var changeCount24 = 0\n        var changeIndex25 = 0\n        var\
    \ changeCount25 = 0\n        var changeIndex26 = 0\n        var changeCount26\
    \ = 0\n        var changeIndex27 = 0\n        var changeCount27 = 0\n        var\
    \ changeIndex28 = 0\n        var changeCount28 = 0\n        var changeIndex29\
    \ = 0\n        var changeCount29 = 0\n        var changeIndex30 = 0\n        var\
    \ changeCount30 = 0\n        var changeIndex31 = 0\n        var changeCount31\
    \ = 0\n        var changeIndex32 = 0\n        var changeCount32 = 0\n        var\
    \ changeIndex33 = 0\n        var changeCount33 = 0\n        var changeIndex34\
    \ = 0\n        var changeCount34 = 0\n        var changeIndex35 = 0\n        var\
    \ changeCount35 = 0\n        var changeIndex36 = 0\n        var changeCount36\
    \ = 0\n        var changeIndex37 = 0\n        var changeCount37 = 0\n        var\
    \ changeIndex38 = 0\n        var changeCount38 = 0\n        var changeIndex39\
    \ = 0\n        var changeCount39 = 0\n        var changeIndex40 = 0\n        var\
    \ changeCount40 = 0\n        var changeIndex41 = 0\n        var \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6fnfowgb.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6fnfowgb.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6fnfowgb.scala:101:5 --------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659805056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ minChange = math.min(m, n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var change = 0\n        var maxChange = 0\n        var maxChangeIndex\
    \ = 0\n        while (i < n && j < m) {\n            if (arr(i) == arr(j)) {\n\
    \                i += 1\n                j += 1\n                change += 1\n\
    \            } else {\n                val temp = arr(i)\n                arr(i)\
    \ = arr(j)\n                arr(j) = temp\n                i += 1\n          \
    \      j += 1\n                change += 1\n            }\n            if (change\
    \ > maxChange) {\n                maxChange = change\n                maxChangeIndex\
    \ = k\n            }\n            k += 1\n        }\n        if (maxChange ==\
    \ 0) {\n            return 0\n        }\n        if (maxChange == minChange) {\n\
    \            return 1\n        }\n        if (maxChange == minChange + 1) {\n\
    \            return 2\n        }\n        if (maxChange == minChange + 2) {\n\
    \            return 3\n        }\n        if (maxChange == minChange + 3) {\n\
    \            return 4\n        }\n        if (maxChange == minChange + 4) {\n\
    \            return 5\n        }\n        if (maxChange == minChange + 5) {\n\
    \            return 6\n        }\n        if (maxChange == minChange + 6) {\n\
    \            return 7\n        }\n        if (maxChange == minChange + 7) {\n\
    \            return 8\n        }\n        if (maxChange == minChange + 8) {\n\
    \            return 9\n        }\n        if (maxChange == minChange + 9) {\n\
    \            return 10\n        }\n        if (maxChange == minChange + 10) {\n\
    \            return 11\n        }\n        if (maxChange == minChange + 11) {\n\
    \            return 12\n        }\n        if (maxChange == minChange + 12) {\n\
    \            return 13\n        }\n        if (maxChange == minChange + 13) {\n\
    \            return 14\n        }\n        if (maxChange == minChange + 14) {\n\
    \            return 15\n        }\n        if (maxChange == minChange + 15) {\n\
    \            return 16\n        }\n        if (maxChange == minChange + 16) {\n\
    \            return 17\n        }\n        if (maxChange == minChange + 17) {\n\
    \            return 18\n        }\n        if (maxChange == minChange + 18) {\n\
    \            return 19\n        }\n        if (maxChange == minChange + 19) {\n\
    \            return 20\n        }\n        if (maxChange == minChange + 20) {\n\
    \            return 21\n        }\n        if (maxChange == minChange + 21) {\n\
    \            return 22\n        }\n        if (maxChange == minChange + 22) {\n\
    \            return 23\n        }\n        if (maxChange == minChange + 23) {\n\
    \            return 24\n        }\n        if (maxChange == minChange + 24) {\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm6jpast3.scala:133:0 ---------------------------\e\
    [0m\e[0m\n\e[31m133 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm6jpast3.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                arr(i) =\
    \ arr(j)\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpm6jpast3.scala:32:16 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                arr(j) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm6jpast3.scala:132:1\
    \ --------------------\e[0m\e[0m\n\e[31m132 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpm6jpast3.scala:121:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m121 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659805060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ val s = new Array[Long](n + 1)\n        val t = 0\n        val k = 0\n     \
    \   var i = 0\n        var j = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n        var k = 0\n     \
    \   var k = 0\n        var k = 0\n        var k = 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp58j_q71r.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp58j_q71r.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp58j_q71r.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp58j_q71r.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp58j_q71r.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp58j_q71r.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e"
  stdout: ''
  timestamp: 1659805058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val max = (len / 2) - 1\n        val min = len - max\n        val mid\
    \ = len / 2\n        val arr1 = arr.take(mid)\n        val arr2 = arr.drop(mid)\n\
    \        val arr3 = arr1.zip(arr2).map { case (x, y) => x - y }\n        val arr4\
    \ = arr3.takeWhile(x => x >= 0)\n        val arr5 = arr4.takeWhile(x => x <= max)\n\
    \        val arr6 = arr5.takeWhile(x => x <= min)\n        val arr7 = arr6.takeWhile(x\
    \ => x <= max)\n        val arr8 = arr7.takeWhile(x => x <= min)\n        val\
    \ arr9 = arr8.takeWhile(x => x <= max)\n        val arr10 = arr9.takeWhile(x =>\
    \ x <= min)\n        val arr11 = arr10.takeWhile(x => x <= max)\n        val arr12\
    \ = arr11.takeWhile(x => x <= min)\n        val arr13 = arr12.takeWhile(x => x\
    \ <= max)\n        val arr14 = arr13.takeWhile(x => x <= min)\n        val arr15\
    \ = arr14.takeWhile(x => x <= max)\n        val arr16 = arr15.takeWhile(x => x\
    \ <= min)\n        val arr17 = arr16.takeWhile(x => x <= max)\n        val arr18\
    \ = arr17.takeWhile(x => x <= min)\n        val arr19 = arr18.takeWhile(x => x\
    \ <= max)\n        val arr20 = arr19.takeWhile(x => x <= min)\n        val arr21\
    \ = arr20.takeWhile(x => x <= max)\n        val arr22 = arr21.takeWhile(x => x\
    \ <= min)\n        val arr23 = arr22.takeWhile(x => x <= max)\n        val arr24\
    \ = arr23.takeWhile(x => x <= min)\n        val arr25 = arr24.takeWhile(x => x\
    \ <= max)\n        val arr26 = arr25.takeWhile(x => x <= min)\n        val arr27\
    \ = arr26.takeWhile(x => x <= max)\n        val arr28 = arr27.takeWhile(x => x\
    \ <= min)\n        val arr29 = arr28.takeWhile(x => x <= max)\n        val arr30\
    \ = arr29.takeWhile(x => x <= min)\n        val arr31 = arr30.takeWhile(x => x\
    \ <= max)\n        val arr32 = arr31.takeWhile(x => x <= min)\n        val arr33\
    \ = arr32.take\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcy9oasj_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcy9oasj_.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var min = 0\n        var count = 0\n        while(i\
    \ < arr.length && j < arr.length) {\n            val a = arr(i)\n            val\
    \ b = arr(j)\n            if(a.toString == b.toString) {\n                count\
    \ += 1\n                i += 1\n                j += 1\n            }\n      \
    \      else if(a.toString < b.toString) {\n                count += 1\n      \
    \          i += 1\n            }\n            else {\n                count +=\
    \ 1\n                j += 1\n            }\n            if(count < min) {\n  \
    \              min = count\n                k = i\n            }\n        }\n\
    \        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptdr2kldy.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var minIndex = 0\n        var maxIndex = 0\n\
    \        var max = 0\n        var maxIndex = 0\n        var temp = 0\n       \
    \ var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5\
    \ = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n \
    \       var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n      \
    \  var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n        var\
    \ temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var temp18\
    \ = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n\
    \        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n    \
    \    var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n        var\
    \ temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var temp31\
    \ = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n\
    \        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n    \
    \    var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n        var\
    \ temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var temp44\
    \ = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n\
    \        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n    \
    \    var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n        var\
    \ temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var temp57\
    \ = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n\
    \        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n    \
    \    var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n        var\
    \ temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var temp70\
    \ = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n\
    \        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n    \
    \    var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n        var\
    \ temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var temp83\
    \ = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n\
    \        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n    \
    \    var temp90 = 0\n        var temp91 = 0\n        var temp\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp42lk_jly.scala:118:4 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp42lk_jly.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndex is already defined as \e[33mvariable\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp42lk_jly.scala:118:5 --------------------\e[0m\e[0m\n\
    \e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m   \
    \  Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m\
    \    |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var count = 0\n        var min = 0\n        var max\
    \ = 0\n        var temp = 0\n        while(i < m) {\n            max = arr(i)\n\
    \            while(j < m) {\n                min = arr(j)\n                while(k\
    \ <= j) {\n                    temp = arr(k)\n                    if(temp < min)\
    \ {\n                        min = temp\n                    }\n             \
    \       if(temp > max) {\n                        max = temp\n               \
    \     }\n                    k += 1\n                }\n                j += 1\n\
    \            }\n            count += 1\n            if(max != min) {\n       \
    \         min = max - min\n            }\n            i += 1\n        }\n    \
    \    if(count < m) {\n            return 0\n        }\n        return min\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprt02a0rb.scala:24:21\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            max = arr(i)\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \      Found:    Long\n\e[31m   |\e[0m                  Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprt02a0rb.scala:26:25 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                min = arr(j)\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    Long\n\e[31m   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprt02a0rb.scala:28:30 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    temp = arr(k)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \        Found:    Long\n\e[31m   |\e[0m                           Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var change = 0\n        var i = 0\n       \
    \ var j = 0\n        var k = 0\n        var temp = 0\n        while(i < len) {\n\
    \            while(j < len) {\n                if(arr(i) == arr(j)) {\n      \
    \              temp = 1\n                    j++\n                } else {\n \
    \                   temp = 0\n                }\n                change = change\
    \ + temp\n                j++\n            }\n            i = i + 1\n        \
    \    change = change + 1\n            minChange = minChange - change\n       \
    \ }\n        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4mub38n4.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp4mub38n4.scala:32:19 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                j++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4mub38n4.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4mub38n4.scala:36:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            minChange\
    \ = minChange - change\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val minChange\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val minChange = len\n    \
    \    val minChangeIndex = 0\n        val minChangeIndexArr : List[Int] = new Array[Int](len)\n\
    \        val minChangeIndexArrIndex = 0\n        val minChangeIndexArrIndexArr\
    \ = 0\n        val minChangeIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArr\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArr\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n      \
    \  val minChangeIndexArrIndexArrIndexArrIndexArrIndex = 0\n        val minChangeIndexArrIndexArrIndexArrIndexArrIndex\
    \ = 0\n        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbbjcrbjw.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArrIndexArrIndexArrIndexArrIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexArrIndexArrIndexArrIndexArrIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mminChangeIndexArrIndexArrIndexArrIndexArrIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbbjcrbjw.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArrIndexArrIndexArrIndexArrIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexArrIndexArrIndexArrIndexArrIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mminChangeIndexArrIndexArrIndexArrIndexArrIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbbjcrbjw.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArrIndexArrIndexArrIndexArrIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexArrIndexArrIndexArrIndexArrIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mminChangeIndexArrIndexArrIndexArrIndexArrIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbbjcrbjw.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArrIndexArrIndexArrIndexArrIndex\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexArrIndexArrIndexArrIndexArrIndex is already\
    \ defined as \e[33m"
  stdout: ''
  timestamp: 1659805058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.max\n        val\
    \ p = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = Long.MaxValue\n        while (i < n) {\n          \
    \  if (arr(i) < m) {\n                p(j) = arr(i)\n                j += 1\n\
    \            } else {\n                p(j) = m\n                k += 1\n    \
    \            min = Math.min(min, k)\n            }\n            i += 1\n     \
    \   }\n        p(j) = m\n        val r = new Array[Long](j + 1)\n        var i\
    \ = 0\n        while (i < j) {\n            r(i) = p(j)\n            i += 1\n\
    \        }\n        r(j) = min\n        val s = r.mkString\n        val l = s.toLong\n\
    \        l\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppzmhq6rt.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        var count = 0\n \
    \       var i = 0\n        var j = arr.length - 1\n        while (i < j) {\n \
    \           if (arr(i) == arr(j)) {\n                count += 1\n            \
    \    i += 1\n                j -= 1\n            } else {\n                if\
    \ (arr(i) < arr(j)) {\n                    i += 1\n                } else {\n\
    \                    j -= 1\n                }\n            }\n        }\n   \
    \     count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxs6c2vuw.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ r = arr.last\n        val d = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val r =\
    \ n - 1\n        val c = m - r\n        val r = n - 1\n        val c = m - r\n\
    \        val r = n - 1\n        val c = m - r\n        val r = n - 1\n       \
    \ val c = m - r\n        val r = n - 1\n        val c = m - r\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpz47yx7ck.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz47yx7ck.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz47yx7ck.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = m - r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already defined as\
    \ \e[33mvalue\e[0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz47yx7ck.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz47yx7ck.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = m - r\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already defined as\
    \ \e[33mvalue\e[0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz47yx7ck.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = n - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr"
  stdout: ''
  timestamp: 1659805059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var k1 = len - 1\n        var k2 = len - 1\n        var k3 = len - 1\n\
    \        var k4 = len - 1\n        var k5 = len - 1\n        var k6 = len - 1\n\
    \        var k7 = len - 1\n        var k8 = len - 1\n        var k9 = len - 1\n\
    \        var k10 = len - 1\n        var k11 = len - 1\n        var k12 = len -\
    \ 1\n        var k13 = len - 1\n        var k14 = len - 1\n        var k15 = len\
    \ - 1\n        var k16 = len - 1\n        var k17 = len - 1\n        var k18 =\
    \ len - 1\n        var k19 = len - 1\n        var k20 = len - 1\n        var k21\
    \ = len - 1\n        var k22 = len - 1\n        var k23 = len - 1\n        var\
    \ k24 = len - 1\n        var k25 = len - 1\n        var k26 = len - 1\n      \
    \  var k27 = len - 1\n        var k28 = len - 1\n        var k29 = len - 1\n \
    \       var k30 = len - 1\n        var k31 = len - 1\n        var k32 = len -\
    \ 1\n        var k33 = len - 1\n        var k34 = len - 1\n        var k35 = len\
    \ - 1\n        var k36 = len - 1\n        var k37 = len - 1\n        var k38 =\
    \ len - 1\n        var k39 = len - 1\n        var k40 = len - 1\n        var k41\
    \ = len - 1\n        var k42 = len - 1\n        var k43 = len - 1\n        var\
    \ k44 = len - 1\n        var k45 = len - 1\n        var k46 = len - 1\n      \
    \  var k47 = len - 1\n        var k48 = len - 1\n        var k49 = len - 1\n \
    \       var k50 = len - 1\n        var k51 = len - 1\n        var k52 = len -\
    \ 1\n        var k53 = len - 1\n        var k54 = len - 1\n        var k55 = len\
    \ - 1\n        var k56 = len - 1\n        var k57 = len - 1\n        var k58 =\
    \ len - 1\n        var k59 = len - 1\n        var k60 = len - 1\n        var k61\
    \ = len - 1\n        var k62 = len - 1\n        var k63 = len - 1\n        var\
    \ k64 = len - 1\n        var k65 = len - 1\n        var k66 = len - 1\n      \
    \  var k67 = len - 1\n        var k68 = len - 1\n        var k69 = len - 1\n \
    \       var k70 = len - 1\n        var k71 = len - 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiqevur_j.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpiqevur_j.scala:92:5 ---------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.length\n       \
    \ val p = new Array[Long](m)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var\
    \ p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var\
    \ t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var\
    \ x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var\
    \ b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var\
    \ f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var\
    \ n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var\
    \ s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var\
    \ w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var\
    \ a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var\
    \ e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var\
    \ m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n        var\
    \ r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var\
    \ v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var\
    \ z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var\
    \ d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var\
    \ h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n        var\
    \ q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var\
    \ u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var\
    \ y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var\
    \ c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var\
    \ g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var\
    \ p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var\
    \ t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var\
    \ x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var\
    \ b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var\
    \ f = 0\n        var g = 0\n        var h = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_843y8_6.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_843y8_6.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_843y8_6.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mp\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mp is already defined\
    \ as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_843y8_6.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_843y8_6.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_843y8_6.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0"
  stdout: ''
  timestamp: 1659805072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.length\n     \
    \   val m = arr.head\n        val p = new Array[Long](n)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m1 = new\
    \ Array[Long](n)\n        var m2 = new Array[Long](n)\n        var m3 = new Array[Long](n)\n\
    \        var m4 = new Array[Long](n)\n        var m5 = new Array[Long](n)\n  \
    \      var m6 = new Array[Long](n)\n        var m7 = new Array[Long](n)\n    \
    \    var m8 = new Array[Long](n)\n        var m9 = new Array[Long](n)\n      \
    \  var m10 = new Array[Long](n)\n        var m11 = new Array[Long](n)\n      \
    \  var m12 = new Array[Long](n)\n        var m13 = new Array[Long](n)\n      \
    \  var m14 = new Array[Long](n)\n        var m15 = new Array[Long](n)\n      \
    \  var m16 = new Array[Long](n)\n        var m17 = new Array[Long](n)\n      \
    \  var m18 = new Array[Long](n)\n        var m19 = new Array[Long](n)\n      \
    \  var m20 = new Array[Long](n)\n        var m21 = new Array[Long](n)\n      \
    \  var m22 = new Array[Long](n)\n        var m23 = new Array[Long](n)\n      \
    \  var m24 = new Array[Long](n)\n        var m25 = new Array[Long](n)\n      \
    \  var m26 = new Array[Long](n)\n        var m27 = new Array[Long](n)\n      \
    \  var m28 = new Array[Long](n)\n        var m29 = new Array[Long](n)\n      \
    \  var m30 = new Array[Long](n)\n        var m31 = new Array[Long](n)\n      \
    \  var m32 = new Array[Long](n)\n        var m33 = new Array[Long](n)\n      \
    \  var m34 = new Array[Long](n)\n        var m35 = new Array[Long](n)\n      \
    \  var m36 = new Array[Long](n)\n        var m37 = new Array[Long](n)\n      \
    \  var m38 = new Array[Long](n)\n        var m39 = new Array[Long](n)\n      \
    \  var m40 = new Array[Long](n)\n        var m41 = new Array[Long](n)\n      \
    \  var m42 = new Array[Long](n)\n        var m43 = new Array[Long](n)\n      \
    \  var m44 = new Array[Long](n)\n        var m45 = new Array[Long](n)\n      \
    \  var m46 = new Array[Long](n)\n        var m47 = new \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc6dkayo8.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpc6dkayo8.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpc6dkayo8.scala:70:5 ---------------------\e[0m\e[0m\n\e[31m70\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805071
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var min = Long.MaxValue\n        while (i < m && j\
    \ < m) {\n            if (arr(i) < arr(j)) {\n                k = j\n        \
    \        min = Math.min(min, arr(i) - arr(k))\n                i = k + 1\n   \
    \         } else {\n                k = i\n                min = Math.min(min,\
    \ arr(j) - arr(k))\n                j = k + 1\n            }\n        }\n    \
    \    if (i < m) {\n            min = Math.min(min, arr(i) - arr(j))\n        }\n\
    \        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659805075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val n = arr.length\n\
    \        val m = arr.take(n/2).length\n        val k = arr.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.length\n        val k\
    \ = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n        val m =\
    \ arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n        val\
    \ k = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val k = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val k = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val k = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.length\n\
    \        val k = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).length\n\
    \        val m = arr.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/2).reverse.take(n/\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_l_083fo.scala:31:171 --------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).reverse.take(n/\e[31m2\e[0m).reverse.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).reverse.take(n/\e[31m2\e[0m).reverse.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).reverse.take(n/\e[31m2\e[0m).reverse.take(n/\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                                                                            \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_l_083fo.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).reverse.take(n/\e[31m2\e[0m).reverse.length\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm\
    \ is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_l_083fo.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mk\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mk is already defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l_083fo.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).reverse.take(n/\e\
    [31m2\e[0m).reverse.take(n/\e[31m2\e[0m).reverse.length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val mid = len / 2\n        val left = arr.take(mid)\n        val right =\
    \ arr.drop(mid)\n        val leftLen = left.length\n        val rightLen = right.length\n\
    \        val leftMin = left.min\n        val rightMin = right.min\n        val\
    \ leftMax = left.max\n        val rightMax = right.max\n        val leftSum =\
    \ left.sum\n        val rightSum = right.sum\n        val leftDiff = left.diff\n\
    \        val rightDiff = right.diff\n        val leftMinDiff = left.minDiff\n\
    \        val rightMinDiff = right.minDiff\n        val leftMaxDiff = left.maxDiff\n\
    \        val rightMaxDiff = right.maxDiff\n        val leftSumDiff = left.sumDiff\n\
    \        val rightSumDiff = right.sumDiff\n        val leftDiffDiff = left.diffDiff\n\
    \        val rightDiffDiff = right.diffDiff\n        val leftMinDiffDiff = left.minDiffDiff\n\
    \        val rightMinDiffDiff = right.minDiffDiff\n        val leftMaxDiffDiff\
    \ = left.maxDiffDiff\n        val rightMaxDiffDiff = right.maxDiffDiff\n     \
    \   val leftSumDiffDiff = left.sumDiffDiff\n        val rightSumDiffDiff = right.sumDiffDiff\n\
    \        val leftDiffDiffDiff = left.diffDiffDiff\n        val rightDiffDiff =\
    \ right.diffDiffDiff\n        val leftMinDiffDiff = left.minDiffDiff\n       \
    \ val rightMinDiffDiff = right.minDiffDiff\n        val leftMaxDiffDiff = left.maxDiffDiff\n\
    \        val rightMaxDiffDiff = right.maxDiffDiff\n        val leftSumDiffDiff\
    \ = left.sumDiffDiff\n        val rightSumDiffDiff = right.sumDiffDiff\n     \
    \   val leftDiffDiffDiff = left.diffDiffDiff\n        val rightDiffDiff = right.diffDiffDiff\n\
    \        val leftMinDiffDiff = left.minDiffDiff\n        val rightMinDiffDiff\
    \ = right.minDiffDiff\n        val leftMaxDiffDiff = left.maxDiffDiff\n      \
    \  val rightMaxDiffDiff = right.maxDiffDiff\n        val leftSumDiffDiff = left.sumDiffDiff\n\
    \        val rightSumDiffDiff = right.sumDiffDiff\n        val leftDiffDiffDiff\
    \ = left.diffDiffDiff\n        val rightDiffDiff = right.diffDiffDiff\n      \
    \  val leftMinDiffDiff = left.minDiffDiff\n        val rightMinDiffDiff = right.minDiffDiff\n\
    \        val leftMax\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgibbeozm.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgibbeozm.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightDiffDiff\e[0m = right.diffDiffDiff\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightDiffDiff is\
    \ already defined as \e[33mvalue\e[0m \e[35mrightDiffDiff\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgibbeozm.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftMinDiffDiff\e[0m = left.minDiffDiff\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftMinDiffDiff\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftMinDiffDiff\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgibbeozm.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightMinDiffDiff\e[0m = right.minDiffDiff\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightMinDiffDiff\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightMinDiffDiff\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgibbeozm.scala:48:12 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftMaxDiffDiff\e[0m = left.maxDiffDiff\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mleftMaxDiffDiff is already defined as \e[33mvalue\e[0m \e[35mleftMaxDiffDiff\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /"
  stdout: ''
  timestamp: 1659805072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.length\n     \
    \   val m = arr.max\n        val maxChange = arr.filter(_ % 2 == 0).length\n \
    \       val maxChange2 = arr.filter(_ % 2 == 1).length\n        val maxChange3\
    \ = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).length\n        val maxChange4 =\
    \ arr.filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 == 1).length\n      \
    \  val maxChange5 = arr.filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 0).length\n        val maxChange6 = arr.filter(_ % 2 == 0).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).length\n\
    \        val maxChange7 = arr.filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ %\
    \ 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ %\
    \ 2 == 0).length\n        val maxChange8 = arr.filter(_ % 2 == 0).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2\
    \ == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).length\n    \
    \    val maxChange9 = arr.filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 ==\
    \ 0).length\n        val maxChange10 = arr.filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 ==\
    \ 1).filter(_ % 2 == 0).filter(_ % 2 == 0).length\n        val maxChange11 = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 0).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 0).length\n        val maxChange12 = arr.filter(_ % 2 == 0).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 0).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmputsc4gg4.scala:29:254 --------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxChange12\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_\
    \ % \e[31m2\e[0m == \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                                                            \
    \                                                                            \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmputsc4gg4.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmputsc4gg4.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        var count = 0\n \
    \       var i = 0\n        var j = arr.length - 1\n        while (i < j) {\n \
    \           if (arr(i) == arr(j)) {\n                count += 1\n            \
    \    i += 1\n                j -= 1\n            } else {\n                val\
    \ temp = arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n\
    \                count += 1\n                i += 1\n                j -= 1\n\
    \            }\n        }\n        arr(j)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptnib7zsz.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.take(n/2).length\n\
    \        val k = arr.take(m).length\n        val r = arr.take(k).length\n    \
    \    val s = arr.take(r).length\n        val t = arr.take(s).length\n        val\
    \ u = arr.take(t).length\n        val v = arr.take(u).length\n        val w =\
    \ arr.take(v).length\n        val x = arr.take(w).length\n        val y = arr.take(x).length\n\
    \        val z = arr.take(y).length\n        val a = arr.take(z).length\n    \
    \    val b = arr.take(a).length\n        val c = arr.take(b).length\n        val\
    \ d = arr.take(c).length\n        val e = arr.take(d).length\n        val f =\
    \ arr.take(e).length\n        val g = arr.take(f).length\n        val h = arr.take(g).length\n\
    \        val i = arr.take(h).length\n        val j = arr.take(i).length\n    \
    \    val k = arr.take(j).length\n        val l = arr.take(k).length\n        val\
    \ m = arr.take(l).length\n        val n = arr.take(m).length\n        val o =\
    \ arr.take(n).length\n        val p = arr.take(o).length\n        val q = arr.take(p).length\n\
    \        val r = arr.take(q).length\n        val s = arr.take(r).length\n    \
    \    val t = arr.take(s).length\n        val u = arr.take(t).length\n        val\
    \ v = arr.take(u).length\n        val w = arr.take(v).length\n        val x =\
    \ arr.take(w).length\n        val y = arr.take(x).length\n        val z = arr.take(y).length\n\
    \        val a = arr.take(z).length\n        val b = arr.take(a).length\n    \
    \    val c = arr.take(b).length\n        val d = arr.take(c).length\n        val\
    \ e = arr.take(d).length\n        val f = arr.take(e).length\n        val g =\
    \ arr.take(f).length\n        val h = arr.take(g).length\n        val i = arr.take(h).length\n\
    \        val j = arr.take(i).length\n        val k = arr.take(j).length\n    \
    \    val l = arr.take(k).length\n        val m = arr.take(l).length\n        val\
    \ n = arr.take(m).length\n        val o = arr.take(n).length\n        val p =\
    \ arr.take(o).length\n        val q = arr.take(p).length\n        val r = arr.take(q).length\n\
    \        val s = arr.take(r).length\n        val t = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph027wjhx.scala:72:15 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = \n\e[31m\e[31m\
    \   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph027wjhx.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mk\e[0m = arr.take(j).length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already\
    \ defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph027wjhx.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(l).length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm\
    \ is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph027wjhx.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = arr.take(m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph027wjhx.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.take(q).length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already\
    \ defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph027wjhx.scala:45:12 ---------------------------\e"
  stdout: ''
  timestamp: 1659805074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val curr = arr(i)\n            val next\
    \ = (i + 1) % len\n            val nextCurr = arr(next)\n            if (curr\
    \ == nextCurr) {\n                min = Math.min(min, next - i)\n            \
    \    i = next\n            } else {\n                val newLen = len - 1\n  \
    \              while (j < newLen && arr(j) == curr) {\n                    j +=\
    \ 1\n                }\n                val newMin = j - i + 1\n             \
    \   if (newMin < min) {\n                    min = newMin\n                  \
    \  k = i\n                }\n                i = next\n            }\n       \
    \ }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppu4kfp4e.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.max\n        val\
    \ arr = arr.sortBy(_)\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var min = n\n        var max = n\n        while (i < n) {\n         \
    \   while (j < n) {\n                if (arr(i) == arr(j)) {\n               \
    \     j++\n                } else {\n                    k++\n               \
    \ }\n            }\n            if (k == m) {\n                min = i\n     \
    \           max = j\n            }\n            i += 1\n            j = 0\n  \
    \          k = 0\n        }\n        if (min == n) {\n            return 0\n \
    \       }\n        if (min == 0) {\n            return 1\n        }\n        if\
    \ (min == max - 1) {\n            return max - min\n        }\n        return\
    \ min + smallestChange(arr.drop(min - 1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqgpxhm_p.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpqgpxhm_p.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpqgpxhm_p.scala:17:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m   |\e[0m                    \
    \         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded function:\n\
    \e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpqgpxhm_p.scala:17:18 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e\
    [33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val maxLen = len / 2\n   \
    \     var minChange = 0\n        var maxChange = 0\n        var maxLenChange =\
    \ 0\n        var maxLenChangeIndex = 0\n        var maxLenChangeIndex2 = 0\n \
    \       var maxLenChangeIndex3 = 0\n        var maxLenChangeIndex4 = 0\n     \
    \   var maxLenChangeIndex5 = 0\n        var maxLenChangeIndex6 = 0\n        var\
    \ maxLenChangeIndex7 = 0\n        var maxLenChangeIndex8 = 0\n        var maxLenChangeIndex9\
    \ = 0\n        var maxLenChangeIndex10 = 0\n        var maxLenChangeIndex11 =\
    \ 0\n        var maxLenChangeIndex12 = 0\n        var maxLenChangeIndex13 = 0\n\
    \        var maxLenChangeIndex14 = 0\n        var maxLenChangeIndex15 = 0\n  \
    \      var maxLenChangeIndex16 = 0\n        var maxLenChangeIndex17 = 0\n    \
    \    var maxLenChangeIndex18 = 0\n        var maxLenChangeIndex19 = 0\n      \
    \  var maxLenChangeIndex20 = 0\n        var maxLenChangeIndex21 = 0\n        var\
    \ maxLenChangeIndex22 = 0\n        var maxLenChangeIndex23 = 0\n        var maxLenChangeIndex24\
    \ = 0\n        var maxLenChangeIndex25 = 0\n        var maxLenChangeIndex26 =\
    \ 0\n        var maxLenChangeIndex27 = 0\n        var maxLenChangeIndex28 = 0\n\
    \        var maxLenChangeIndex29 = 0\n        var maxLenChangeIndex30 = 0\n  \
    \      var maxLenChangeIndex31 = 0\n        var maxLenChangeIndex32 = 0\n    \
    \    var maxLenChangeIndex33 = 0\n        var maxLenChangeIndex34 = 0\n      \
    \  var maxLenChangeIndex35 = 0\n        var maxLenChangeIndex36 = 0\n        var\
    \ maxLenChangeIndex37 = 0\n        var maxLenChangeIndex38 = 0\n        var maxLenChangeIndex39\
    \ = 0\n        var maxLenChangeIndex40 = 0\n        var maxLenChangeIndex41 =\
    \ 0\n        var maxLenChangeIndex42 = 0\n        var maxLenChangeIndex43 = 0\n\
    \        var maxLenChangeIndex44 = 0\n        var maxLenChangeIndex45 = 0\n  \
    \      var maxLenChangeIndex46 = 0\n        var maxLenChangeIndex47 = 0\n    \
    \    var maxLenChangeIndex48 = 0\n        var maxLenChangeIndex49 = 0\n      \
    \  var maxLenChangeIndex50 = 0\n        var maxLenChangeIndex51 = 0\n        var\
    \ maxLenChangeIndex52 = 0\n        var maxLenChangeIndex53 = 0\n        var maxLenChangeIndex54\
    \ = 0\n        var maxLenChangeIndex55 = 0\n        var maxLenChangeIndex56 =\
    \ 0\n        var maxLenChangeIndex57 = 0\n        var maxLenChangeIndex58 = 0\n\
    \        var maxLenChangeIndex59 = 0\n        var maxLenChangeIndex60 = 0\n  \
    \      var max\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9pccjuud.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9pccjuud.scala:81:5 ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        val min = len / 2\n        val max = len - min\n        val mid = len\
    \ / 2\n        val mid2 = len - mid\n        val mid3 = len - mid2\n        val\
    \ mid4 = len - mid3\n        val mid5 = len - mid4\n        val mid6 = len - mid5\n\
    \        val mid7 = len - mid6\n        val mid8 = len - mid7\n        val mid9\
    \ = len - mid8\n        val mid10 = len - mid9\n        val mid11 = len - mid10\n\
    \        val mid12 = len - mid11\n        val mid13 = len - mid12\n        val\
    \ mid14 = len - mid13\n        val mid15 = len - mid14\n        val mid16 = len\
    \ - mid15\n        val mid17 = len - mid16\n        val mid18 = len - mid17\n\
    \        val mid19 = len - mid18\n        val mid20 = len - mid19\n        val\
    \ mid21 = len - mid20\n        val mid22 = len - mid21\n        val mid23 = len\
    \ - mid22\n        val mid24 = len - mid23\n        val mid25 = len - mid24\n\
    \        val mid26 = len - mid25\n        val mid27 = len - mid26\n        val\
    \ mid28 = len - mid27\n        val mid29 = len - mid28\n        val mid30 = len\
    \ - mid29\n        val mid31 = len - mid30\n        val mid32 = len - mid31\n\
    \        val mid33 = len - mid32\n        val mid34 = len - mid33\n        val\
    \ mid35 = len - mid34\n        val mid36 = len - mid35\n        val mid37 = len\
    \ - mid36\n        val mid38 = len - mid37\n        val mid39 = len - mid38\n\
    \        val mid40 = len - mid39\n        val mid41 = len - mid40\n        val\
    \ mid42 = len - mid41\n        val mid43 = len - mid42\n        val mid44 = len\
    \ - mid43\n        val mid45 = len - mid44\n        val mid46 = len - mid45\n\
    \        val mid47 = len - mid46\n        val mid48 = len - mid47\n        val\
    \ mid49 = len - mid48\n        val mid50 = len - mid49\n        val mid51 = len\
    \ - mid50\n        val mid52 = len - mid51\n        val mid53 = len - mid52\n\
    \        val mid54 = len - mid53\n        val mid55 = len - mid54\n\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp30q0797a.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp30q0797a.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpewmprc29.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpewmprc29.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpewmprc29.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var max = 0\n        var count = 0\n     \
    \   var isPalindromic = false\n        var isPalindromic2 = false\n        var\
    \ isPalindromic3 = false\n        var isPalindromic4 = false\n        var isPalindromic5\
    \ = false\n        var isPalindromic6 = false\n        var isPalindromic7 = false\n\
    \        var isPalindromic8 = false\n        var isPalindromic9 = false\n    \
    \    var isPalindromic10 = false\n        var isPalindromic11 = false\n      \
    \  var isPalindromic12 = false\n        var isPalindromic13 = false\n        var\
    \ isPalindromic14 = false\n        var isPalindromic15 = false\n        var isPalindromic16\
    \ = false\n        var isPalindromic17 = false\n        var isPalindromic18 =\
    \ false\n        var isPalindromic19 = false\n        var isPalindromic20 = false\n\
    \        var isPalindromic21 = false\n        var isPalindromic22 = false\n  \
    \      var isPalindromic23 = false\n        var isPalindromic24 = false\n    \
    \    var isPalindromic25 = false\n        var isPalindromic26 = false\n      \
    \  var isPalindromic27 = false\n        var isPalindromic28 = false\n        var\
    \ isPalindromic29 = false\n        var isPalindromic30 = false\n        var isPalindromic31\
    \ = false\n        var isPalindromic32 = false\n        var isPalindromic33 =\
    \ false\n        var isPalindromic34 = false\n        var isPalindromic35 = false\n\
    \        var isPalindromic36 = false\n        var isPalindromic37 = false\n  \
    \      var isPalindromic38 = false\n        var isPalindromic39 = false\n    \
    \    var isPalindromic40 = false\n        var isPalindromic41 = false\n      \
    \  var isPalindromic42 = false\n        var isPalindromic43 = false\n        var\
    \ isPalindromic44 = false\n        var isPalindromic45 = false\n        var isPalindromic46\
    \ = false\n        var isPalindromic47 = false\n        var isPalindromic48 =\
    \ false\n        var isPalindromic49 = false\n        var isPalindromic50 = false\n\
    \        var isPalindromic51 = false\n        var isP\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_awwkvur.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_awwkvur.scala:76:5 ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var temp = 0\n        while(i < len) {\n            while(j < len)\
    \ {\n                while(k >= 0) {\n                    if(arr(i) == arr(j))\
    \ {\n                        temp = arr(i)\n                        arr(i) = arr(j)\n\
    \                        arr(j) = temp\n                        minChange = minChange\
    \ - 1\n                        k = k - 1\n                    } else {\n     \
    \                   k = k - 1\n                    }\n                }\n    \
    \            j = j + 1\n            }\n            i = i + 1\n        }\n    \
    \    minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7psnqj_9.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp7psnqj_9.scala:29:34 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        minChange = minChange - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val minChange\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val arr\
    \ = arr.sortBy(_.toLong)\n        val len = arr.size\n        val maxLen = len\
    \ / 2\n        val maxLen2 = len / 3\n        val maxLen3 = len / 4\n        val\
    \ maxLen4 = len / 5\n        val maxLen5 = len / 6\n        val maxLen6 = len\
    \ / 7\n        val maxLen7 = len / 8\n        val maxLen8 = len / 9\n        val\
    \ maxLen9 = len / 10\n        val maxLen10 = len / 11\n        val maxLen11 =\
    \ len / 12\n        val maxLen12 = len / 13\n        val maxLen13 = len / 14\n\
    \        val maxLen14 = len / 15\n        val maxLen15 = len / 16\n        val\
    \ maxLen16 = len / 17\n        val maxLen17 = len / 18\n        val maxLen18 =\
    \ len / 19\n        val maxLen19 = len / 20\n        val maxLen20 = len / 21\n\
    \        val maxLen21 = len / 22\n        val maxLen22 = len / 23\n        val\
    \ maxLen23 = len / 24\n        val maxLen24 = len / 25\n        val maxLen25 =\
    \ len / 26\n        val maxLen26 = len / 27\n        val maxLen27 = len / 28\n\
    \        val maxLen28 = len / 29\n        val maxLen29 = len / 30\n        val\
    \ maxLen30 = len / 31\n        val maxLen31 = len / 32\n        val maxLen32 =\
    \ len / 33\n        val maxLen33 = len / 34\n        val maxLen34 = len / 35\n\
    \        val maxLen35 = len / 36\n        val maxLen36 = len / 37\n        val\
    \ maxLen37 = len / 38\n        val maxLen38 = len / 39\n        val maxLen39 =\
    \ len / 40\n        val maxLen40 = len / 41\n        val maxLen41 = len / 42\n\
    \        val maxLen42 = len / 43\n        val maxLen43 = len / 44\n        val\
    \ maxLen44 = len / 45\n        val maxLen45 = len / 46\n        val maxLen46 =\
    \ len / 47\n        val maxLen47 = len / 48\n        val maxLen48 = len / 49\n\
    \        val maxLen49 = len / 50\n        val maxLen50\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvv1g579g.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvv1g579g.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(_.toLong)\n\e[31m\e[31m   |\e[0m               \
    \   ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvv1g579g.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val minChange = len\n    \
    \    var i = 0\n        var j = 0\n        var k = 0\n        while (i < len)\
    \ {\n            while (j < len) {\n                if (arr(i) == arr(j)) {\n\
    \                    j++\n                }\n                else {\n        \
    \            minChange = minChange - 1\n                    i = i + 1\n      \
    \              j = j + 1\n                }\n            }\n            i = i\
    \ + 1\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwa5h4kc0.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpwa5h4kc0.scala:26:30 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    minChange = minChange - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while(i\
    \ < len) {\n            while(j < len && arr(i) == arr(j)) {\n               \
    \ j += 1\n            }\n            if(j == len) {\n                minChange\
    \ = i\n            }\n            i += 1\n            j = 0\n        }\n     \
    \   minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiy3yzcud.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpiy3yzcud.scala:25:26 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                minChange = i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.head\n        val max = arr.last\n        val mid = len /\
    \ 2\n        val midVal = arr.apply(mid)\n        val midValReverse = arr.apply(len\
    \ - mid - 1)\n        val midValReverseReverse = arr.apply(len - mid - 2)\n  \
    \      val midValReverseReverseReverse = arr.apply(len - mid - 3)\n        val\
    \ midValReverseReverseReverseReverse = arr.apply(len - mid - 4)\n        val midValReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 5)\n        val midValReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 6)\n        val midValReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 7)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 8)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 9)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 10)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 11)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 12)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 13)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 14)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 15)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 16)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 17)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 18)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 19)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 20)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 21)\n        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.apply(len - mid - 22)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6mx_o935.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmidValReverseReverseReverseReverseReverseReverseReverseReverse\e\
    [0m = arr.apply(len - mid - \e[31m9\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmidValReverseReverseReverseReverseReverseReverseReverseReverse\
    \ is already defined as \e[33mvalue\e[0m \e[35mmidValReverseReverseReverseReverseReverseReverseReverseReverse\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6mx_o935.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmidValReverseReverseReverseReverseReverseReverseReverseReverseReverse\e\
    [0m = arr.apply(len - mid - \e[31m11\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmidValReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ is already defined as \e[33mvalue\e[0m \e[35mmidValReverseReverseReverseReverseReverseReverseReverseReverseReverse\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6mx_o935.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmidValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\e\
    [0m = arr.apply(len - mid - \e[31m13\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmidValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  midValReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloa"
  stdout: ''
  timestamp: 1659805077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        var count = 0\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n    \
    \    var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n        var\
    \ temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp95 = 0\n        var temp96 = 0\n        var temp\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpanqziedc.scala:118:4 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpanqziedc.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(_.toLong)\n\e[31m\e[31m   |\e[0m               \
    \   ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpanqziedc.scala:118:5\
    \ --------------------\e[0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805078
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.last\n        val\
    \ arr = arr.dropRight(1)\n        val p = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var minIndex\
    \ = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n\
    \        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n        var\
    \ temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n        var temp7 =\
    \ 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n  \
    \      var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n      \
    \  var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n        var\
    \ temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var temp20\
    \ = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n\
    \        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n    \
    \    var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n        var\
    \ temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var temp33\
    \ = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n\
    \        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n    \
    \    var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n        var\
    \ temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var temp46\
    \ = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n\
    \        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n    \
    \    var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n        var\
    \ temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var temp59\
    \ = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n\
    \        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n    \
    \    var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n        var\
    \ temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var temp72\
    \ = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n\
    \        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n    \
    \    var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n        var\
    \ temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var temp85\
    \ = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n\
    \        var temp89 = 0\n        var temp90 = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3ygf_vsr.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mmaxIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3ygf_vsr.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \          ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m\
    \ \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3ygf_vsr.scala:117:5 --------------------\e[0m\e[0m\n\e[31m117\
    \ |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:\
    \    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805079
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var minChangeCount = 0\n        var minChangeIndex = 0\n      \
    \  while (i < len) {\n            val curr = arr(i)\n            val next = arr(j)\n\
    \            val next2 = arr(k)\n            val next3 = arr(len - 1 - k)\n  \
    \          val next4 = arr(len - 1 - j)\n            val next5 = arr(len - 1 -\
    \ i)\n            val next6 = arr(len - 1 - k)\n            val next7 = arr(len\
    \ - 1 - j)\n            val next8 = arr(len - 1 - i)\n            val next9 =\
    \ arr(len - 1 - k)\n            val next10 = arr(len - 1 - j)\n            val\
    \ next11 = arr(len - 1 - i)\n            val next12 = arr(len - 1 - k)\n     \
    \       val next13 = arr(len - 1 - j)\n            val next14 = arr(len - 1 -\
    \ i)\n            val next15 = arr(len - 1 - k)\n            val next16 = arr(len\
    \ - 1 - j)\n            val next17 = arr(len - 1 - i)\n            val next18\
    \ = arr(len - 1 - k)\n            val next19 = arr(len - 1 - j)\n            val\
    \ next20 = arr(len - 1 - i)\n            val next21 = arr(len - 1 - k)\n     \
    \       val next22 = arr(len - 1 - j)\n            val next23 = arr(len - 1 -\
    \ i)\n            val next24 = arr(len - 1 - k)\n            val next25 = arr(len\
    \ - 1 - j)\n            val next26 = arr(len - 1 - i)\n            val next27\
    \ = arr(len - 1 - k)\n            val next28 = arr(len - 1 - j)\n            val\
    \ next29 = arr(len - 1 - i)\n            val next30 = arr(len - 1 - k)\n     \
    \       val next31 = arr(len - 1 - j)\n            val next32 = arr(len - 1 -\
    \ i)\n            val next33 = arr(len - 1 - k)\n            val next34 = arr(len\
    \ - 1 - j)\n            val next35 = arr(len - 1 - i)\n            val next36\
    \ = arr(len - 1 - k)\n            val next37 = arr(len - 1 - j)\n            val\
    \ next38 = arr(len - 1 - i)\n            val next39 = arr(len - 1 - k)\n     \
    \       val next40 = arr(len - 1 - j)\n            val next41 = arr(len - 1 -\
    \ i)\n            val next42 = arr(len - 1 - k)\n            val next43 = arr(len\
    \ - 1 - j)\n            \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpywc8id4f.scala:82:0 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpywc8id4f.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywc8id4f.scala:81:1\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpywc8id4f.scala:70:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m70 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659805080
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        val minChange = len\n        var i = 0\n        var j = len - 1\n   \
    \     while (i < j) {\n            if (arr(i) != arr(j)) {\n                minChange\
    \ = minChange + 1\n            }\n            i = i + 1\n            j = j - 1\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6c8sc_k_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp6c8sc_k_.scala:22:26 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                minChange = minChange + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.last\n        val\
    \ arr = arr.dropRight(1)\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n        val arr6\
    \ = arr5.toList\n        val arr7 = arr6.toList\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.toList\n        val arr10 = arr9.toList\n        val\
    \ arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val arr13 =\
    \ arr12.toList\n        val arr14 = arr13.toList\n        val arr15 = arr14.toList\n\
    \        val arr16 = arr15.toList\n        val arr17 = arr16.toList\n        val\
    \ arr18 = arr17.toList\n        val arr19 = arr18.toList\n        val arr20 =\
    \ arr19.toList\n        val arr21 = arr20.toList\n        val arr22 = arr21.toList\n\
    \        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n        val\
    \ arr25 = arr24.toList\n        val arr26 = arr25.toList\n        val arr27 =\
    \ arr26.toList\n        val arr28 = arr27.toList\n        val arr29 = arr28.toList\n\
    \        val arr30 = arr29.toList\n        val arr31 = arr30.toList\n        val\
    \ arr32 = arr31.toList\n        val arr33 = arr32.toList\n        val arr34 =\
    \ arr33.toList\n        val arr35 = arr34.toList\n        val arr36 = arr35.toList\n\
    \        val arr37 = arr36.toList\n        val arr38 = arr37.toList\n        val\
    \ arr39 = arr38.toList\n        val arr40 = arr39.toList\n        val arr41 =\
    \ arr40.toList\n        val arr42 = arr41.toList\n        val arr43 = arr42.toList\n\
    \        val arr44 = arr43.toList\n        val arr45 = arr44.toList\n        val\
    \ arr46 = arr45.toList\n        val arr47 = arr46.toList\n        val arr48 =\
    \ arr47.toList\n        val arr49 = arr48.toList\n        val arr50 = arr49.toList\n\
    \        val arr51 = arr50.toList\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpla0in7ww.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m  \
    \                Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpla0in7ww.scala:69:5 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805088
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val mid = len / 2\n        val left = arr.take(mid)\n        val right\
    \ = arr.drop(mid)\n        val leftLen = left.length\n        val rightLen = right.length\n\
    \        val leftSum = left.foldLeft(0l) { (sum, elem) => sum + elem }\n     \
    \   val rightSum = right.foldLeft(0l) { (sum, elem) => sum + elem }\n        val\
    \ leftDiff = leftSum - rightSum\n        val rightDiff = rightSum - leftSum\n\
    \        if (leftDiff == rightDiff) {\n            0\n        } else if (leftDiff\
    \ < rightDiff) {\n            smallestChange(left) + smallestChange(right)\n \
    \       } else {\n            smallestChange(right) + smallestChange(left)\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp_xda4rib.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_xda4rib.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805082
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        val min = len / 2\n        val max = len - min\n        val mid = len\
    \ / 2\n        val mid1 = mid + 1\n        val mid2 = mid - 1\n        val mid3\
    \ = mid * 2\n        val mid4 = mid * 3\n        val mid5 = mid * 4\n        val\
    \ mid6 = mid * 5\n        val mid7 = mid * 6\n        val mid8 = mid * 7\n   \
    \     val mid9 = mid * 8\n        val mid10 = mid * 9\n        val mid11 = mid\
    \ * 10\n        val mid12 = mid * 11\n        val mid13 = mid * 12\n        val\
    \ mid14 = mid * 13\n        val mid15 = mid * 14\n        val mid16 = mid * 15\n\
    \        val mid17 = mid * 16\n        val mid18 = mid * 17\n        val mid19\
    \ = mid * 18\n        val mid20 = mid * 19\n        val mid21 = mid * 20\n   \
    \     val mid22 = mid * 21\n        val mid23 = mid * 22\n        val mid24 =\
    \ mid * 23\n        val mid25 = mid * 24\n        val mid26 = mid * 25\n     \
    \   val mid27 = mid * 26\n        val mid28 = mid * 27\n        val mid29 = mid\
    \ * 28\n        val mid30 = mid * 29\n        val mid31 = mid * 30\n        val\
    \ mid32 = mid * 31\n        val mid33 = mid * 32\n        val mid34 = mid * 33\n\
    \        val mid35 = mid * 34\n        val mid36 = mid * 35\n        val mid37\
    \ = mid * 36\n        val mid38 = mid * 37\n        val mid39 = mid * 38\n   \
    \     val mid40 = mid * 39\n        val mid41 = mid * 40\n        val mid42 =\
    \ mid * 41\n        val mid43 = mid * 42\n        val mid44 = mid * 43\n     \
    \   val mid45 = mid * 44\n        val mid46 = mid * 45\n        val mid47 = mid\
    \ * 46\n        val mid48 = mid * 47\n        val mid49 = mid * 48\n        val\
    \ mid50 = mid * 49\n        val mid51 = mid * 50\n        val mid52 = mid * 51\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx47hwp6_.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx47hwp6_.scala:73:5 ---------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val maxLen = len - 2\n        var count = 0\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var temp = 0\n        var temp2 = 0\n\
    \        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n       \
    \ var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9\
    \ = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    \
    \    var temp94 = 0\n        var temp95 = 0\n        var \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmps0ypy1l8.scala:117:11 --------------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmps0ypy1l8.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps0ypy1l8.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps0ypy1l8.scala:118:5 --------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ val maxChange = arr.max\n        val minChange = arr.min\n        val changes\
    \ = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < n) {\n \
    \           if (arr(i) == arr(n)) {\n                changes += arr(i)\n     \
    \           i += 1\n                n -= 1\n            } else if (arr(i) < arr(n))\
    \ {\n                changes += arr(i)\n                i += 1\n            }\
    \ else {\n                changes += arr(n)\n                n -= 1\n        \
    \    }\n        }\n        if (changes.size < maxChange) {\n            changes\
    \ += minChange\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmimn6w4t.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmimn6w4t.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        var count\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp\
    \ = 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n \
    \       var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var\
    \ temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11\
    \ = 0\n        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n\
    \        var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n    \
    \    var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var\
    \ temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24\
    \ = 0\n        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n\
    \        var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n    \
    \    var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var\
    \ temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37\
    \ = 0\n        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n\
    \        var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n    \
    \    var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var\
    \ temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50\
    \ = 0\n        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n\
    \        var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n    \
    \    var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var\
    \ temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63\
    \ = 0\n        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n\
    \        var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n    \
    \    var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var\
    \ temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76\
    \ = 0\n        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n\
    \        var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n    \
    \    var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var\
    \ temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89\
    \ = 0\n        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n\
    \        var temp93 = 0\n        var temp\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmwi6ndy1.scala:117:4 ---------------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmwi6ndy1.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmwi6ndy1.scala:117:5\
    \ --------------------\e[0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var k1 = len - 1\n        var k2 = len - 1\n        var k3 = len - 1\n\
    \        var k4 = len - 1\n        var k5 = len - 1\n        var k6 = len - 1\n\
    \        var k7 = len - 1\n        var k8 = len - 1\n        var k9 = len - 1\n\
    \        var k10 = len - 1\n        var k11 = len - 1\n        var k12 = len -\
    \ 1\n        var k13 = len - 1\n        var k14 = len - 1\n        var k15 = len\
    \ - 1\n        var k16 = len - 1\n        var k17 = len - 1\n        var k18 =\
    \ len - 1\n        var k19 = len - 1\n        var k20 = len - 1\n        var k21\
    \ = len - 1\n        var k22 = len - 1\n        var k23 = len - 1\n        var\
    \ k24 = len - 1\n        var k25 = len - 1\n        var k26 = len - 1\n      \
    \  var k27 = len - 1\n        var k28 = len - 1\n        var k29 = len - 1\n \
    \       var k30 = len - 1\n        var k31 = len - 1\n        var k32 = len -\
    \ 1\n        var k33 = len - 1\n        var k34 = len - 1\n        var k35 = len\
    \ - 1\n        var k36 = len - 1\n        var k37 = len - 1\n        var k38 =\
    \ len - 1\n        var k39 = len - 1\n        var k40 = len - 1\n        var k41\
    \ = len - 1\n        var k42 = len - 1\n        var k43 = len - 1\n        var\
    \ k44 = len - 1\n        var k45 = len - 1\n        var k46 = len - 1\n      \
    \  var k47 = len - 1\n        var k48 = len - 1\n        var k49 = len - 1\n \
    \       var k50 = len - 1\n        var k51 = len - 1\n        var k52 = len -\
    \ 1\n        var k53 = len - 1\n        var k54 = len - 1\n        var k55 = len\
    \ - 1\n        var k56 = len - 1\n        var k57 = len - 1\n        var k58 =\
    \ len - 1\n        var k59 = len - 1\n        var k60 = len - 1\n        var k61\
    \ = len - 1\n        var k62 = len - 1\n        var k63 = len - 1\n        var\
    \ k64 = len - 1\n        var k65 = len - 1\n        var k66 = len - 1\n      \
    \  var k67 = len - 1\n        var k68 = len - 1\n        var k69 = len - 1\n \
    \       var k70 = len - 1\n        var k71 = len - 1\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiqevur_j.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpiqevur_j.scala:92:5 ---------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ListBuffer.empty[Long]\n     \
    \   val changed = mutable.ListBuffer.empty[Long]\n        val change = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ListBuffer.empty[Long]\n        val changeIndex2\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex3 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex4 = mutable.ListBuffer.empty[Long]\n        val changeIndex5\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex6 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex7 = mutable.ListBuffer.empty[Long]\n        val changeIndex8\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex9 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex10 = mutable.ListBuffer.empty[Long]\n        val changeIndex11\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex12 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex13 = mutable.ListBuffer.empty[Long]\n        val changeIndex14\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex15 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex16 = mutable.ListBuffer.empty[Long]\n        val changeIndex17\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex18 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex19 = mutable.ListBuffer.empty[Long]\n        val changeIndex20\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex21 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex22 = mutable.ListBuffer.empty[Long]\n        val changeIndex23\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex24 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex25 = mutable.ListBuffer.empty[Long]\n        val changeIndex26\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex27 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex28 = mutable.ListBuffer.empty[Long]\n        val changeIndex29\
    \ = mutable.ListBuffer.empty[Long]\n        val changeIndex30 = mutable.ListBuffer.empty[Long]\n\
    \        val changeIndex31 = mutable.ListBuffer.empty[Long]\n        val change\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaz_cruss.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaz_cruss.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaz_cruss.scala:18:22\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaz_cruss.scala:19:22\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaz_cruss.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaz_cruss.scala:21:26\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeIndex\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659805091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val min = len / 2\n        val max = len - min\n        val mid = len\
    \ / 2\n        val left = arr.take(mid)\n        val right = arr.drop(mid)\n \
    \       val leftMin = smallestChange(left)\n        val rightMin = smallestChange(right)\n\
    \        val leftMax = smallestChange(left.reverse)\n        val rightMax = smallestChange(right.reverse)\n\
    \        val leftMinMax = if (leftMin < leftMax) leftMin else leftMax\n      \
    \  val rightMinMax = if (rightMin < rightMax) rightMin else rightMax\n       \
    \ val minMax = if (leftMinMax < rightMinMax) leftMinMax else rightMinMax\n   \
    \     minMax\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcwu6v3rx.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805085
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.length\n     \
    \   val m = arr.last\n        val p = new Array[Long](arr.length)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        var count = 0\n        while (i < n) {\n            while (j < n) {\n\
    \                if (arr(i) == arr(j)) {\n                    p(i) = arr(i)\n\
    \                    p(i) = arr(j)\n                    j++\n                }\
    \ else {\n                    j++\n                }\n            }\n        \
    \    while (k < n) {\n                if (arr(i) == arr(k)) {\n              \
    \      p(i) = arr(i)\n                    p(i) = arr(k)\n                    k++\n\
    \                } else {\n                    k++\n                }\n      \
    \      }\n            while (k < n) {\n                if (arr(i) == arr(k)) {\n\
    \                    p(i) = arr(i)\n                    p(i) = arr(k)\n      \
    \              k++\n                } else {\n                    k++\n      \
    \          }\n            }\n            while (j < n) {\n                if (arr(i)\
    \ == arr(j)) {\n                    p(i) = arr(i)\n                    p(i) =\
    \ arr(j)\n                    j++\n                } else {\n                \
    \    j++\n                }\n            }\n            while (k < n) {\n    \
    \            if (arr(i) == arr(k)) {\n                    p(i) = arr(i)\n    \
    \                p(i) = arr(k)\n                    k++\n                } else\
    \ {\n                    k++\n                }\n            }\n            while\
    \ (k < n) {\n                if (arr(i) == arr(k)) {\n                    p(i)\
    \ = arr(i)\n                    p(i) = arr(k)\n                    k++\n     \
    \           } else {\n                    k++\n                }\n           \
    \ }\n            while (j < n) {\n                if (arr(i) == arr(j)) {\n  \
    \                  p(i) = arr(i)\n                    p(i) = arr(j)\n        \
    \            j++\n                } else {\n                    j++\n        \
    \        }\n            }\n            while (k < n) {\n                if (arr(i)\
    \ == arr(k)) {\n                    p(i) = arr(i)\n                    p(i) =\
    \ arr(k)\n                    k++\n                } else {\n                \
    \    k++\n                }\n            }\n            while (k < n) {\n    \
    \            if (arr(i) == arr(k)) {\n                    p(i) = arr(i)\n    \
    \                p(i) = arr(k)\n                    k++\n                } else\
    \ {\n                    k++\n                }\n            }\n            while\
    \ (j < n) {\n                if (arr(i) == arr(j)) {\n                    p(i)\
    \ = arr(i)\n                    p(i) = arr(j)\n                    j++\n     \
    \           } else {\n                    j++\n                }\n           \
    \ }\n            while (k < n) {\n                if (arr(i) == arr(k)) {\n  \
    \                  p(i) = arr(i)\n                    p(i) = arr(k)\n        \
    \            k++\n                } else {\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5lw51cal.scala:29:23 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp5lw51cal.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5lw51cal.scala:38:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp5lw51cal.scala:40:23 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp5lw51cal.scala:47:23 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5lw51cal.scala:49:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1659805087
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.length\n     \
    \   val p = new Array[Long](n)\n        var i = 0\n        var j = 0\n       \
    \ var k = 0\n        var min = Long.MaxValue\n        while (i < n) {\n      \
    \      if (arr(i) < 0) {\n                arr(i) = -arr(i)\n            }\n  \
    \          if (arr(i) == arr(n)) {\n                p(k) = arr(i)\n          \
    \      i += 1\n                k += 1\n            } else {\n                while\
    \ (j < n) {\n                    if (arr(i) == arr(j)) {\n                   \
    \     p(k) = arr(i)\n                        i += 1\n                        j\
    \ += 1\n                        k += 1\n                    } else if (arr(i)\
    \ < arr(j)) {\n                        arr(i) = arr(j)\n                     \
    \   i += 1\n                        j += 1\n                        k += 1\n \
    \                   } else {\n                        arr(i) = arr(j)\n      \
    \                  i += 1\n                        j += 1\n                  \
    \      k += 1\n                    }\n                }\n                if (arr(i)\
    \ < 0) {\n                    arr(i) = -arr(i)\n                }\n          \
    \      if (arr(i) == arr(n)) {\n                    p(k) = arr(i)\n          \
    \          i += 1\n                    k += 1\n                } else {\n    \
    \                while (j < n) {\n                        if (arr(i) == arr(j))\
    \ {\n                            p(k) = arr(i)\n                            i\
    \ += 1\n                            j += 1\n                            k += 1\n\
    \                        } else if (arr(i) < arr(j)) {\n                     \
    \       arr(i) = arr(j)\n                            i += 1\n                \
    \            j += 1\n                            k += 1\n                    \
    \    } else {\n                            arr(i) = arr(j)\n                 \
    \           i += 1\n                            j += 1\n                     \
    \       k += 1\n                        }\n                    }\n           \
    \         if (arr(i) < 0) {\n                        arr(i) = -arr(i)\n      \
    \              }\n                    if (arr(i) == arr(n)) {\n              \
    \          p(k) = arr(i)\n                        i += 1\n                   \
    \     k += 1\n                    } else {\n                        while (j <\
    \ n) {\n                            if (arr(i) == arr(j)) {\n                \
    \                p(k) = arr(i)\n                                i += 1\n     \
    \                           j += 1\n                                k += 1\n \
    \                           } else if (arr(i) < arr(j)) {\n                  \
    \              arr(i) = arr(j)\n                                i += 1\n     \
    \                           j += 1\n                                k += 1\n \
    \                           } else {\n                                arr(i) =\
    \ arr(j)\n                                i += 1\n                           \
    \     j += 1\n                                k += 1\n                       \
    \     }\n                        }\n                        if (arr(i) < 0) {\n\
    \                            arr(i) = -arr(i)\n                        }\n   \
    \                     if (arr(i) == arr(n)) {\n                            p(k)\
    \ = arr(i)\n                            i += 1\n                            k\
    \ += 1\n                        } else {\n                            while (j\
    \ < n) {\n                                if (arr(i) == arr(j)) {\n          \
    \                          p(k) = arr(i)\n                                   \
    \ i += 1\n                                    j += 1\n                       \
    \             k += 1\n                                } else if (arr(i) < arr(j))\
    \ {\n                                    \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfq_6jmux.scala:130:0 ---------------------------\e\
    [0m\e[0m\n\e[31m130 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfq_6jmux.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfq_6jmux.scala:22:8\
    \ ---------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        \e[33mwhile\e[0m (i\
    \ < n) {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: Long\n\e[31m 23 |\e[0m          \
    \  \e[33mif\e[0m (arr(i) < \e[31m0\e[0m) {\n\e[31m 24 |\e[0m                arr(i)\
    \ = -arr(i)\n\e[31m 25 |\e[0m            }\n\e[31m 26 |\e[0m            \e[33mif\e\
    [0m (arr(i) == arr(n)) {\n\e[31m 27 |\e[0m                p(k) = arr(i)\n\e[31m\
    \ 28 |\e[0m                i += \e[31m1\e[0m\n\e[31m 29 |\e[0m               \
    \ k += \e[31m1\e[0m\n\e[31m 30 |\e[0m            } \e[33melse\e[0m {\n\e[31m 31\
    \ |\e[0m                \e[33mwhile\e[0m (j < n) {\n\e[31m 32 |\e[0m         \
    \           \e[33mif\e[0m (arr(i) == arr(j)) {\n\e[31m 33 |\e[0m             \
    \           p(k) = arr(i)\n\e[31m 34 |\e[0m                        i += \e[31m1\e\
    [0m\n\e[31m 35 |\e[0m                        j += \e[31m1\e[0m\n\e[31m 36 |\e\
    [0m                        k += \e[31m1\e[0m\n\e[31m 37 |\e[0m               \
    \     } \e[33melse\e[0m \e[33mif\e[0m (arr(i) < arr(j)) {\n\e[31m 38 |\e[0m  \
    \                      arr(i) = arr(j)\n\e[31m 39 |\e[0m                     \
    \   i += \e[31m1\e[0m\n\e[31m 40 |\e[0m                        j += \e[31m1\e\
    [0m\n\e[31m 41 |\e[0m                        k += \e[31m1\e[0m\n\e[31m 42 |\e\
    [0m                    } \e[33melse\e[0m {\n\e[31m 43 |\e[0m                 \
    \       arr(i) = arr(j)\n\e[31m 44 |\e[0m                        i += \e[31m1\e\
    [0m\n\e[31m 45 |\e[0m                        j += \e[31m1\e[0m\n\e[31m 46 |\e\
    [0m       "
  stdout: ''
  timestamp: 1659805095
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val n = arr.length\n\
    \        val m = arr.last\n        val max = (n / 2).toInt\n        val min =\
    \ (n / 2).toInt\n        val maxChange = arr.take(max).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplzw2k1fo.scala:20:1611 -------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxChange\e[0m = arr.take(max).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max - min).reverse.take(max\
    \ - min).reverse.take(\n\e[31m\e[31m   |\e[0m                                \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                            "
  stdout: ''
  timestamp: 1659805092
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var minIndex = 0\n        var max = 0\n  \
    \      var maxIndex = 0\n        while (i < n) {\n            if (arr(i) < m)\
    \ {\n                p(j) = arr(i)\n                j += 1\n            } else\
    \ {\n                p(j) = m\n                j += 1\n            }\n       \
    \     i += 1\n        }\n        val p1 = new Array[Long](j)\n        val p2 =\
    \ new Array[Long](j)\n        var i = 0\n        var j = 0\n        while (i <\
    \ j) {\n            p1(i) = p(j)\n            p2(i) = p(j + 1)\n            i\
    \ += 1\n            j += 1\n        }\n        val p3 = new Array[Long](j)\n \
    \       var i = 0\n        while (i < j) {\n            p3(i) = p(j)\n       \
    \     i += 1\n            j += 1\n        }\n        val p4 = new Array[Long](j)\n\
    \        var i = 0\n        while (i < j) {\n            p4(i) = p(j)\n      \
    \      i += 1\n            j += 1\n        }\n        var i = 0\n        while\
    \ (i < n) {\n            if (p(i) == p(i + 1)) {\n                val temp = p(i)\n\
    \                p(i) = p(i + 1)\n                p(i + 1) = temp\n          \
    \      i += 1\n            } else {\n                val temp = p(i)\n       \
    \         p(i) = p(i + 1)\n                p(i + 1) = temp\n                i\
    \ += 1\n            }\n        }\n        var i = 0\n        while (i < n) {\n\
    \            if (p(i) == p(i + 1)) {\n                val temp = p(i)\n      \
    \          p(i) = p(i + 1)\n                p(i + 1) = temp\n                i\
    \ += 1\n            } else {\n                val temp = p(i)\n              \
    \  p(i) = p(i + 1)\n                p(i + 1) = temp\n                i += 1\n\
    \            }\n        }\n        var i = 0\n        while (i < n) {\n      \
    \      if (p(i) == p(i + 1)) {\n                val temp = p(i)\n            \
    \    p(i) = p(i + 1)\n                p(i + 1) = temp\n                i += 1\n\
    \            } else {\n                val temp = p(i)\n                p(i) =\
    \ p(i + 1)\n                p(i + 1) = temp\n                i += 1\n        \
    \    }\n        }\n        var i = 0\n        while (i < n) {\n            if\
    \ (p(i) == p(i + 1)) {\n                val temp = p(i)\n                p(i)\
    \ = p(i + 1)\n                p(i + 1) = temp\n                i += 1\n      \
    \      } else {\n                val temp = p(i)\n                p(i) = p(i +\
    \ 1)\n                p(i + 1) = temp\n                i += 1\n            }\n\
    \        }\n        var i = 0\n        while (i < n) {\n            if (p(i) ==\
    \ p(i + 1)) {\n                val temp = p(i)\n                p(i) = p(i + 1)\n\
    \                p(i + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcgppousa.scala:134:0 ---------------------------\e\
    [0m\e[0m\n\e[31m134 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcgppousa.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcgppousa.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e\
    [0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpcgppousa.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcgppousa.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcgppousa.scala:59:12 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in t"
  stdout: ''
  timestamp: 1659805095
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ val s = new Array[Long](n + 1)\n        val t = 0\n        var i = 0\n     \
    \   var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n     \
    \   var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n     \
    \   var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n     \
    \   var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n     \
    \   var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n     \
    \   var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n     \
    \   var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n     \
    \   var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n     \
    \   var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n     \
    \   var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n     \
    \   var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n     \
    \   var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n     \
    \   var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n     \
    \   var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n     \
    \   var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n     \
    \   var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n     \
    \   var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n     \
    \   var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n     \
    \   var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n     \
    \   var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n     \
    \   var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n     \
    \   var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n     \
    \   var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n     \
    \   var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n     \
    \   var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n     \
    \   var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n     \
    \   var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n     \
    \   var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n     \
    \   var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n     \
    \   var v = 0\n        var \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp7xpaao6s.scala:139:11 --------------------------\e\
    [0m\e[0m\n\e[31m139 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7xpaao6s.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7xpaao6s.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7xpaao6s.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mp\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mp is already defined\
    \ as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7xpaao6s.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mr\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7xpaao6s.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m \e[36ms\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as"
  stdout: ''
  timestamp: 1659805097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        var changes = 0\n        while(i < len) {\n            while(j < len)\
    \ {\n                if(arr(i) == arr(j)) {\n                    j++\n       \
    \             k++\n                }\n                else {\n               \
    \     if(arr(i) < arr(j)) {\n                        j++\n                   \
    \ }\n                    else {\n                        k++\n               \
    \     }\n                }\n            }\n            if(k > 1) {\n         \
    \       changes += k\n                k = 0\n            }\n            i++\n\
    \            j = 0\n        }\n        if(changes > 0) {\n            changes\
    \ += k\n        }\n        changes\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1sq7k1mx.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp1sq7k1mx.scala:30:27 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                        j++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp1sq7k1mx.scala:33:27 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                        k++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp1sq7k1mx.scala:42:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m42 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp1sq7k1mx.scala:15:18 ---------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp1sq7k1mx.scala:25:21 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \              ^^^\e[0m\n\e[31m   |\e[0m                    value ++ is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1sq7k1mx.scala:41:13\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m  "
  stdout: ''
  timestamp: 1659805097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var min = 0\n        var max = 0\n\
    \        var count = 0\n        while (i < len) {\n            max = arr(i)\n\
    \            while (j < len) {\n                if (arr(j) < max) {\n        \
    \            max = arr(j)\n                }\n                j++\n          \
    \  }\n            min = max\n            while (j < len) {\n                if\
    \ (arr(j) > min) {\n                    min = arr(j)\n                }\n    \
    \            j++\n            }\n            if (min != max) {\n             \
    \   count = min - max\n            }\n            i += 1\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7ap0aav5.scala:28:19 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7ap0aav5.scala:35:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                j++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp7ap0aav5.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            if (arr(i) == arr(len - 1 - j)) {\n               \
    \ minChange = minChange - 1\n                j = j + 1\n            } else {\n\
    \                i = i + 1\n            }\n        }\n        minChange\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp9ipfzk2o.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9ipfzk2o.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp9ipfzk2o.scala:22:26 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                minChange = minChange - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805089
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val mid = len / 2\n        val left = arr.take(mid)\n        val right\
    \ = arr.drop(mid)\n        val leftLen = left.length\n        val rightLen = right.length\n\
    \        val leftMin = left.min\n        val rightMin = right.min\n        val\
    \ leftMax = left.max\n        val rightMax = right.max\n        val leftSum =\
    \ left.sum\n        val rightSum = right.sum\n        val leftDiff = left.diff\n\
    \        val rightDiff = right.diff\n        val leftMinDiff = left.minDiff\n\
    \        val rightMinDiff = right.minDiff\n        val leftMaxDiff = left.maxDiff\n\
    \        val rightMaxDiff = right.maxDiff\n        val leftSumDiff = left.sumDiff\n\
    \        val rightSumDiff = right.sumDiff\n        val leftDiffDiff = left.diffDiff\n\
    \        val rightDiffDiff = right.diffDiff\n        val leftMinDiffDiff = left.minDiffDiff\n\
    \        val rightMinDiffDiff = right.minDiffDiff\n        val leftMaxDiffDiff\
    \ = left.maxDiffDiff\n        val rightMaxDiffDiff = right.maxDiffDiff\n     \
    \   val leftSumDiffDiff = left.sumDiffDiff\n        val rightSumDiffDiff = right.sumDiffDiff\n\
    \        val leftDiffDiffDiff = left.diffDiffDiff\n        val rightDiffDiff =\
    \ right.diffDiffDiff\n        val leftMinDiffDiff = left.minDiffDiff\n       \
    \ val rightMinDiffDiff = right.minDiffDiff\n        val leftMaxDiffDiff = left.maxDiffDiff\n\
    \        val rightMaxDiffDiff = right.maxDiffDiff\n        val leftSumDiffDiff\
    \ = left.sumDiffDiff\n        val rightSumDiffDiff = right.sumDiffDiff\n     \
    \   val leftDiffDiffDiff = left.diffDiffDiff\n        val rightDiffDiff = right.diffDiffDiff\n\
    \        val leftMinDiffDiff = left.minDiffDiff\n        val rightMinDiffDiff\
    \ = right.minDiffDiff\n        val leftMaxDiffDiff = left.maxDiffDiff\n      \
    \  val rightMaxDiffDiff = right.maxDiffDiff\n        val leftSumDiffDiff = left.sumDiffDiff\n\
    \        val rightSumDiffDiff = right.sumDiffDiff\n        val leftDiffDiff =\
    \ left.diffDiff\n        val rightDiffDiff = right.diffDiff\n        val leftMinDiffDiff\
    \ = left.minDiffDiff\n        val rightMinDiffDiff = right.minDiffDiff\n     \
    \   val left\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphr454_q4.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphr454_q4.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightDiffDiff\e[0m = right.diffDiffDiff\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightDiffDiff is\
    \ already defined as \e[33mvalue\e[0m \e[35mrightDiffDiff\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphr454_q4.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftMinDiffDiff\e[0m = left.minDiffDiff\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftMinDiffDiff\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftMinDiffDiff\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphr454_q4.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightMinDiffDiff\e[0m = right.minDiffDiff\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightMinDiffDiff\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightMinDiffDiff\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphr454_q4.scala:48:12 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftMaxDiffDiff\e[0m = left.maxDiffDiff\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mleftMaxDiffDiff is already defined as \e[33mvalue\e[0m \e[35mleftMaxDiffDiff\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /"
  stdout: ''
  timestamp: 1659805097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr2 = arr.tail\n        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val\
    \ arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n       \
    \ val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14\
    \ = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n      \
    \  val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n      \
    \  val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n      \
    \  val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n      \
    \  val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n      \
    \  val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n      \
    \  val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr56\
    \ = arr55.reverse\n        val arr57 = arr56.reverse\n        \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmparc6zx7j.scala:74:5\
    \ ---------------------\e[0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var k = 0\n        var minChange =\
    \ 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n       \
    \ var minChangeIndex3 = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5\
    \ = 0\n        var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n    \
    \    var minChangeIndex8 = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10\
    \ = 0\n        var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n  \
    \      var minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var\
    \ minChangeIndex15 = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17\
    \ = 0\n        var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n  \
    \      var minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var\
    \ minChangeIndex22 = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24\
    \ = 0\n        var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n  \
    \      var minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var\
    \ minChangeIndex29 = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31\
    \ = 0\n        var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n  \
    \      var minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var\
    \ minChangeIndex36 = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38\
    \ = 0\n        var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n  \
    \      var minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var\
    \ minChangeIndex43 = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45\
    \ = 0\n        var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n  \
    \      var minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var\
    \ minChangeIndex50 = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52\
    \ = 0\n        var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n  \
    \      var minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var\
    \ minChangeIndex57 = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59\
    \ = 0\n        var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n  \
    \      var minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var\
    \ minChangeIndex64 = 0\n        var minChangeIndex65 = 0\n        var minChangeIndex66\
    \ = 0\n        var minChangeIndex67 = 0\n        var minChangeIndex68 = 0\n  \
    \      var minChangeIndex69 = 0\n        var \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpx0rfzm5h.scala:90:11 ---------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx0rfzm5h.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpx0rfzm5h.scala:91:5 ---------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var minLen = maxLen\n        var i = 0\n \
    \       var j = 0\n        var k = 0\n        var count = 0\n        var min =\
    \ Long.MaxValue\n        var max = Long.MinValue\n        while (i < len) {\n\
    \            while (j < len) {\n                if (arr(i) == arr(j)) {\n    \
    \                j++\n                }\n                else {\n            \
    \        k++\n                }\n            }\n            while (k < len) {\n\
    \                if (arr(i) == arr(k)) {\n                    k++\n          \
    \      }\n                else {\n                    count++\n              \
    \  }\n            }\n            if (count < minLen) {\n                minLen\
    \ = count\n                min = arr(i)\n            }\n            if (count\
    \ > maxLen) {\n                maxLen = count\n                max = arr(i)\n\
    \            }\n            i = 0\n            j = 0\n            k = 0\n    \
    \        count = 0\n        }\n        if (minLen > maxLen) {\n            minLen\
    \ = maxLen\n        }\n        minLen\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppx50hwne.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmppx50hwne.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppx50hwne.scala:36:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmppx50hwne.scala:39:27 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    count++\n\e[31m\e[31m   |\e[0m  \
    \                         ^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmppx50hwne.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmppx50hwne.scala:47:23 -----------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m                maxLen = count\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val maxLen\n\e[31m   |\e[0m\n\
    \e"
  stdout: ''
  timestamp: 1659805093
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = arr.map(x => (x - m) * (x - m))\n    \
    \    val maxChange = changes.max\n        if (maxChange < 0)\n            0\n\
    \        else\n            n - maxChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2j4rpoc8.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = (len - 1) * 2\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var temp = 0\n        var count = 0\n\
    \        while (i < len) {\n            while (j < len) {\n                if\
    \ (arr(i) == arr(j)) {\n                    temp = arr(i)\n                  \
    \  arr(i) = arr(j)\n                    arr(j) = temp\n                    j++\n\
    \                }\n                else {\n                    j++\n        \
    \        }\n            }\n            i = i + 1\n            j = k\n        \
    \    k = k + 1\n        }\n        count = 0\n        while (j < len) {\n    \
    \        if (arr(i) == arr(j)) {\n                temp = arr(i)\n            \
    \    arr(i) = arr(j)\n                arr(j) = temp\n                j++\n   \
    \             count++\n            }\n            else {\n                j++\n\
    \            }\n        }\n        if (count < min) {\n            min = count\n\
    \        }\n        if (count > max) {\n            max = count\n        }\n \
    \       min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpojrue4_7.scala:30:23 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpojrue4_7.scala:33:23 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpojrue4_7.scala:47:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                count++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpojrue4_7.scala:50:19 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpojrue4_7.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpojrue4_7.scala:46:17\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m                j++\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m                value ++\
    \ is not a member of Int\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpojrue4_7.scala:5"
  stdout: ''
  timestamp: 1659805099
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.head\n        val n = arr.last\n        val\
    \ arr = arr.drop(1).takeRight(arr.length-1)\n        val arr2 = arr.toList\n \
    \       val arr3 = arr2.reverse\n        val arr4 = arr3.takeWhile(x => x != m)\n\
    \        val arr5 = arr4.takeWhile(x => x != n)\n        val arr6 = arr5.takeWhile(x\
    \ => x != m)\n        val arr7 = arr6.takeWhile(x => x != n)\n        val arr8\
    \ = arr7.takeWhile(x => x != m)\n        val arr9 = arr8.takeWhile(x => x != n)\n\
    \        val arr10 = arr9.takeWhile(x => x != m)\n        val arr11 = arr10.takeWhile(x\
    \ => x != n)\n        val arr12 = arr11.takeWhile(x => x != m)\n        val arr13\
    \ = arr12.takeWhile(x => x != n)\n        val arr14 = arr13.takeWhile(x => x !=\
    \ m)\n        val arr15 = arr14.takeWhile(x => x != n)\n        val arr16 = arr15.takeWhile(x\
    \ => x != m)\n        val arr17 = arr16.takeWhile(x => x != n)\n        val arr18\
    \ = arr17.takeWhile(x => x != m)\n        val arr19 = arr18.takeWhile(x => x !=\
    \ n)\n        val arr20 = arr19.takeWhile(x => x != m)\n        val arr21 = arr20.takeWhile(x\
    \ => x != n)\n        val arr22 = arr21.takeWhile(x => x != m)\n        val arr23\
    \ = arr22.takeWhile(x => x != n)\n        val arr24 = arr23.takeWhile(x => x !=\
    \ m)\n        val arr25 = arr24.takeWhile(x => x != n)\n        val arr26 = arr25.takeWhile(x\
    \ => x != m)\n        val arr27 = arr26.takeWhile(x => x != n)\n        val arr28\
    \ = arr27.takeWhile(x => x != m)\n        val arr29 = arr28.takeWhile(x => x !=\
    \ n)\n        val arr30 = arr29.takeWhile(x => x != m)\n        val arr31 = arr30.takeWhile(x\
    \ => x != n)\n        val arr32 = arr31.takeWhile(x => x != m)\n        val arr33\
    \ = arr32.takeWhile(x => x != n)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7n16_llr.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e\
    [0m).takeRight(arr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \   ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7n16_llr.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805100
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var temp = 0\n        while(i < len) {\n            temp = arr(i)\n \
    \           j = i\n            while(j < len) {\n                if(arr(j) !=\
    \ temp) {\n                    k = j\n                    while(k >= i) {\n  \
    \                      arr(k) = arr(k)\n                        k -= 1\n     \
    \               }\n                    arr(k) = temp\n                    min\
    \ = k\n                }\n                j += 1\n            }\n            i\
    \ += 1\n        }\n        min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaprdld06.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805098
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpewmprc29.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpewmprc29.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpewmprc29.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = arr.head\n        val maxChange = arr.last\n        val\
    \ changes = mutable.ListBuffer[Long]()\n        var i = 0\n        while (i <\
    \ len) {\n            val curr = arr(i)\n            val next = arr(i + 1)\n \
    \           if (curr < next) {\n                changes += curr\n            \
    \    i += 1\n            } else if (curr > next) {\n                changes +=\
    \ next\n                i -= 1\n            } else {\n                changes\
    \ += curr\n                i += 1\n                i -= 1\n            }\n   \
    \     }\n        val changeCount = changes.toList.length\n        if (changeCount\
    \ < minChange) {\n            minChange\n        } else if (changeCount > maxChange)\
    \ {\n            maxChange\n        } else {\n            changeCount\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9b6gzpa7.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9b6gzpa7.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805100
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.min\n        val max = arr.max\n        val mid = len / 2\n\
    \        val midVal = arr(mid)\n        val leftArr = (arr.take(mid).toList ++\
    \ arr.drop(mid+1)).toList\n        val rightArr = (arr.take(mid+1).reverse.toList\
    \ ++ arr.drop(mid)).toList\n        val leftMin = smallestChange(leftArr)\n  \
    \      val rightMin = smallestChange(rightArr)\n        val leftMax = smallestChange(leftArr.reverse)\n\
    \        val rightMax = smallestChange(rightArr.reverse)\n        val leftSum\
    \ = leftMin + leftMax\n        val rightSum = rightMin + rightMax\n        val\
    \ leftDiff = leftSum - midVal\n        val rightDiff = rightSum - midVal\n   \
    \     val leftSumDiff = leftSum - leftDiff\n        val rightSumDiff = rightSum\
    \ - rightDiff\n        val leftMaxDiff = leftMax - leftDiff\n        val rightMaxDiff\
    \ = rightMax - rightDiff\n        val leftMinDiff = leftMin - leftDiff\n     \
    \   val rightMinDiff = rightMin - rightDiff\n        val leftSumDiffDiff = leftSumDiff\
    \ - leftMaxDiff\n        val rightSumDiffDiff = rightSumDiff - rightMaxDiff\n\
    \        val leftMaxDiffDiff = leftMaxDiff - leftSumDiff\n        val rightMaxDiffDiff\
    \ = rightMaxDiff - rightSumDiff\n        val leftMinDiffDiff = leftMinDiff - leftSumDiffDiff\n\
    \        val rightMinDiffDiff = rightMinDiff - rightSumDiffDiff\n        val leftSumDiffDiffDiff\
    \ = leftSumDiffDiff - leftMinDiffDiff\n        val rightSumDiffDiff = rightSumDiffDiff\
    \ - rightMinDiffDiff\n        val leftMaxDiffDiff = leftMaxDiffDiff - leftSumDiffDiff\n\
    \        val rightMaxDiffDiff = rightMaxDiffDiff - rightSumDiffDiff\n        val\
    \ leftMinDiffDiff = leftMinDiffDiff - leftSumDiffDiffDiff\n        val rightMinDiffDiff\
    \ = rightMinDiffDiff - rightSumDiffDiffDiff\n        val leftSumDiffDiffDiff =\
    \ leftSumDiffDiff - leftMaxDiffDiff\n        val rightSumDiffDiff = rightSumDiffDiff\
    \ - rightMaxDiffDiff\n        val leftMaxDiffDiff = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzm2_6ilg.scala:51:29 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mleftMaxDiffDiff\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzm2_6ilg.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mrightSumDiffDiff\e[0m =\
    \ rightSumDiffDiff - rightMinDiffDiff\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightSumDiffDiff is already defined as \e[33mvalue\e[0m \e\
    [35mrightSumDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzm2_6ilg.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mleftMaxDiffDiff\e[0m = leftMaxDiffDiff\
    \ - leftSumDiffDiff\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMaxDiffDiff is already defined as \e[33mvalue\e[0m \e\
    [35mleftMaxDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzm2_6ilg.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mrightMaxDiffDiff\e[0m =\
    \ rightMaxDiffDiff - rightSumDiffDiff\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMaxDiffDiff is already defined as \e[33mvalue\e[0m \e\
    [35mrightMaxDiffDiff\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzm2_6ilg.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mleftMinDiffDiff\e[0m = leftMinDiffDiff\
    \ - "
  stdout: ''
  timestamp: 1659805106
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var change = 0\n        while (i < len) {\n            while (j\
    \ < len) {\n                if (arr(i) == arr(j)) {\n                    j++\n\
    \                    k++\n                } else {\n                    j++\n\
    \                }\n            }\n            while (k < len) {\n           \
    \     if (arr(i) == arr(k)) {\n                    k++\n                } else\
    \ {\n                    k++\n                }\n            }\n            if\
    \ (k > j) {\n                change = k - j\n                minChange = minChange.min(change)\n\
    \            }\n            i += 1\n            j += 1\n            k += 1\n \
    \       }\n        minChange\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfzekz93d.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpfzekz93d.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfzekz93d.scala:33:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpfzekz93d.scala:35:23 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpfzekz93d.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpfzekz93d.scala:25:21 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                    j++\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\
    \e[31m   |\e[0m                    value ++ is not a member of Int\n\e[31m\e[31m--\
    \ [E052] Type Error: "
  stdout: ''
  timestamp: 1659805108
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var temp = 0\n        var temp2 = 0\n        while (i < len) {\n\
    \            while (j < len) {\n                if (arr(i) == arr(j)) {\n    \
    \                temp = arr(i)\n                    temp2 = arr(j)\n         \
    \           arr(i) = arr(j)\n                    arr(j) = temp\n             \
    \       arr(j) = temp2\n                    j++\n                }\n         \
    \       j++\n            }\n            minChange = math.min(minChange, j - i)\n\
    \            i = j\n            j = 0\n            k++\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd0cegkjb.scala:31:23 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpd0cegkjb.scala:33:19 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                j++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd0cegkjb.scala:38:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            k++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpd0cegkjb.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpd0cegkjb.scala:35:22 -----------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            minChange = math.min(minChange, j - i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \          Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805103
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        var minIndex = 0\n        var maxIndex = 0\n        var changes\
    \ = 0\n        var change = 0\n        var temp = 0\n        var temp2 = 0\n \
    \       var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var\
    \ temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 =\
    \ 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpubgncltw.scala:119:5\
    \ --------------------\e[0m\e[0m\n\e[31m119 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805110
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.last\n        val\
    \ arr = arr.sortBy(_).reverse\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var l = 0\n        var count = 0\n        while (i < m && j <\
    \ n) {\n            if (arr(i) == arr(j)) {\n                count += 1\n    \
    \            i += 1\n                j += 1\n            } else if (arr(i) < arr(j))\
    \ {\n                i += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        if (count == m) {\n            return 0\n   \
    \     } else if (count == n) {\n            return 1\n        } else {\n     \
    \       val m = arr.length\n            val n = arr.last\n            val arr\
    \ = arr.sortBy(_).reverse\n            var i = 0\n            var j = 0\n    \
    \        var k = 0\n            var l = 0\n            var count = 0\n       \
    \     while (i < m && j < n) {\n                if (arr(i) == arr(j)) {\n    \
    \                count += 1\n                    i += 1\n                    j\
    \ += 1\n                } else if (arr(i) < arr(j)) {\n                    i +=\
    \ 1\n                } else {\n                    j += 1\n                }\n\
    \            }\n            if (count == m) {\n                return 0\n    \
    \        } else if (count == n) {\n                return 1\n            } else\
    \ {\n                val m = arr.length\n                val n = arr.last\n  \
    \              val arr = arr.sortBy(_).reverse\n                var i = 0\n  \
    \              var j = 0\n                var k = 0\n                var l = 0\n\
    \                var count = 0\n                while (i < m && j < n) {\n   \
    \                 if (arr(i) == arr(j)) {\n                        count += 1\n\
    \                        i += 1\n                        j += 1\n            \
    \        } else if (arr(i) < arr(j)) {\n                        i += 1\n     \
    \               } else {\n                        j += 1\n                   \
    \ }\n                }\n                if (count == m) {\n                  \
    \  return 0\n                } else if (count == n) {\n                    return\
    \ 1\n                } else {\n                    val m = arr.length\n      \
    \              val n = arr.last\n                    val arr = arr.sortBy(_).reverse\n\
    \                    var i = 0\n                    var j = 0\n              \
    \      var k = 0\n                    var l = 0\n                    var count\
    \ = 0\n                    while (i < m && j < n) {\n                        if\
    \ (arr(i) == arr(j)) {\n                            count += 1\n             \
    \               i += 1\n                            j += 1\n                 \
    \       } else if (arr(i) < arr(j)) {\n                            i += 1\n  \
    \                      } else {\n                            j += 1\n        \
    \                }\n                    }\n                    if (count == m)\
    \ {\n                        return 0\n                    } else if (count ==\
    \ n) {\n                        return 1\n                    } else {\n     \
    \                   val m = arr.length\n                        val n = arr.last\n\
    \                        val arr = arr.sortBy(_).reverse\n                   \
    \     var i = 0\n                        var j = 0\n                        var\
    \ k = 0\n                        var l = 0\n                        var count\
    \ = 0\n                        while (i < m && j < n) {\n                    \
    \        if (arr(i) == arr(j)) {\n                                count += 1\n\
    \                                i += 1\n                                j +=\
    \ 1\n                            } else if (arr(i) < arr(j)) {\n             \
    \                   i += 1\n                            } else {\n           \
    \                     j += 1\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg6ugn064.scala:141:0 ---------------------------\e\
    [0m\e[0m\n\e[31m141 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpg6ugn064.scala:17:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m            \
    \                 ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded\
    \ function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpg6ugn064.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmpg6ugn064.scala:41:33 -----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 =>\
    \ arr.sortBy(_$2).reverse.\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg6ugn064.scala:41:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m            \
    \          ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpg6ugn064.scala:65:37 -----------------------------\e[0m\e[0m\n\e[31m65\
    \ |\e[0m                \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0m   Missing para"
  stdout: ''
  timestamp: 1659805113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        while(i < len) {\n            while(j < len) {\n              \
    \  if(arr(i) == arr(j)) {\n                    j++\n                    k++\n\
    \                }\n                else {\n                    j++\n        \
    \        }\n            }\n            minChange = minChange.min(k)\n        \
    \    i = i + 1\n            j = j + 1\n            k = 0\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp10khv434.scala:25:23 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp10khv434.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp10khv434.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp10khv434.scala:24:21\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m           \
    \         value ++ is not a member of Int\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp10khv434.scala:31:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            minChange\
    \ = minChange.min(k)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val minChange\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659805111
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var max = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        while(i < len) {\n         \
    \   max = arr(i)\n            while(j < len) {\n                if(arr(i) == arr(j))\
    \ {\n                    temp = arr(i)\n                    arr(i) = arr(j)\n\
    \                    arr(j) = temp\n                    j++\n                }\n\
    \                else {\n                    j++\n                }\n        \
    \    }\n            min = arr(i)\n            while(k < (len - i)) {\n       \
    \         if(arr(i) == arr(k)) {\n                    temp = arr(i)\n        \
    \            arr(i) = arr(k)\n                    arr(k) = temp\n            \
    \        k++\n                }\n                else {\n                    k++\n\
    \                }\n            }\n            i++\n        }\n        min\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfh4a0ur3.scala:30:23 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpfh4a0ur3.scala:33:23 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfh4a0ur3.scala:42:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpfh4a0ur3.scala:45:23 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpfh4a0ur3.scala:48:15 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m            i++\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfh4a0ur3.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explan"
  stdout: ''
  timestamp: 1659805106
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(-_)\n        val len = arr.length\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(-_)\n\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmeliswtq.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmeliswtq.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmeliswtq.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmeliswtq.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmeliswtq.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmeliswtq.scala:"
  stdout: ''
  timestamp: 1659805112
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var count = 0\n        var min = 0\n  \
    \      while(i < n && j < n) {\n            temp = arr(i)\n            arr(i)\
    \ = arr(j)\n            arr(j) = temp\n            i += 1\n            j += 1\n\
    \            k += 1\n            count += 1\n            if(arr(i) == arr(j))\
    \ {\n                min = k\n            }\n        }\n        if(min == 0) {\n\
    \            return 0\n        }\n        while(i < n) {\n            temp = arr(i)\n\
    \            arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n\
    \            j += 1\n            k += 1\n            count += 1\n            if(arr(i)\
    \ == arr(j)) {\n                min = k\n            }\n        }\n        if(min\
    \ == 0) {\n            return 0\n        }\n        while(count < min) {\n   \
    \         temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n\
    \            i += 1\n            j += 1\n            k += 1\n            count\
    \ += 1\n            if(arr(i) == arr(j)) {\n                min = k\n        \
    \    }\n        }\n        while(i < n) {\n            temp = arr(i)\n       \
    \     arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n       \
    \     j += 1\n            k += 1\n            count += 1\n            if(arr(i)\
    \ == arr(j)) {\n                min = k\n            }\n        }\n        while(count\
    \ < min) {\n            temp = arr(i)\n            arr(i) = arr(j)\n         \
    \   arr(j) = temp\n            i += 1\n            j += 1\n            k += 1\n\
    \            count += 1\n            if(arr(i) == arr(j)) {\n                min\
    \ = k\n            }\n        }\n        while(i < n) {\n            temp = arr(i)\n\
    \            arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n\
    \            j += 1\n            k += 1\n            count += 1\n            if(arr(i)\
    \ == arr(j)) {\n                min = k\n            }\n        }\n        while(count\
    \ < min) {\n            temp = arr(i)\n            arr(i) = arr(j)\n         \
    \   arr(j) = temp\n            i += 1\n            j += 1\n            k += 1\n\
    \            count += 1\n            if(arr(i) == arr(j)) {\n                min\
    \ = k\n            }\n        }\n        while(i < n) {\n            temp = arr(i)\n\
    \            arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n\
    \            j += 1\n            k += 1\n            count += 1\n            if(arr(i)\
    \ == arr(j)) {\n                \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprnc93t5d.scala:137:0 ---------------------------\e\
    [0m\e[0m\n\e[31m137 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprnc93t5d.scala:25:22\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            temp = arr(i)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        Found:    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprnc93t5d.scala:26:12 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprnc93t5d.scala:27:12\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            arr(j) = temp\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmprnc93t5d.scala:40:22 --------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m            temp = arr(i)\n\e[31m\e[31m   |\e[0m              \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Long\n\e[31m  \
    \ |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprnc93t5d.scala:41:12 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m            arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m       \
    \     ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long] -\
    \ did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprnc93t5d.scala:42:12\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            arr(j) = temp\n\
    \e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmprnc93t5d.scala:55:22 -----------"
  stdout: ''
  timestamp: 1659805118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = arr.take(len/2).foldLeft(0) { (acc, x) => if (x == arr(len-1))\
    \ acc + 1 else acc }\n        val maxChange = arr.take(len/2).foldLeft(0) { (acc,\
    \ x) => if (x == arr(0)) acc + 1 else acc }\n        minChange < maxChange ? minChange\
    \ : maxChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbi136ikw.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbi136ikw.scala:19:44 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        minChange < maxChange ? minChange : \e[35mmaxChange\e\
    [0m\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: type\
    \ maxChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805105
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var minChange\
    \ = 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n     \
    \   while (i < len) {\n            val temp = arr(i)\n            val temp2 =\
    \ arr(j)\n            val temp3 = arr(k)\n            val temp4 = arr(len - i\
    \ - 1)\n            val temp5 = arr(len - j - 1)\n            val temp6 = arr(len\
    \ - k - 1)\n            val temp7 = arr(len - len - 1)\n            val temp8\
    \ = arr(len - len - 2)\n            val temp9 = arr(len - len - 3)\n         \
    \   val temp10 = arr(len - len - 4)\n            val temp11 = arr(len - len -\
    \ 5)\n            val temp12 = arr(len - len - 6)\n            val temp13 = arr(len\
    \ - len - 7)\n            val temp14 = arr(len - len - 8)\n            val temp15\
    \ = arr(len - len - 9)\n            val temp16 = arr(len - len - 10)\n       \
    \     val temp17 = arr(len - len - 11)\n            val temp18 = arr(len - len\
    \ - 12)\n            val temp19 = arr(len - len - 13)\n            val temp20\
    \ = arr(len - len - 14)\n            val temp21 = arr(len - len - 15)\n      \
    \      val temp22 = arr(len - len - 16)\n            val temp23 = arr(len - len\
    \ - 17)\n            val temp24 = arr(len - len - 18)\n            val temp25\
    \ = arr(len - len - 19)\n            val temp26 = arr(len - len - 20)\n      \
    \      val temp27 = arr(len - len - 21)\n            val temp28 = arr(len - len\
    \ - 22)\n            val temp29 = arr(len - len - 23)\n            val temp30\
    \ = arr(len - len - 24)\n            val temp31 = arr(len - len - 25)\n      \
    \      val temp32 = arr(len - len - 26)\n            val temp33 = arr(len - len\
    \ - 27)\n            val temp34 = arr(len - len - 28)\n            val temp35\
    \ = arr(len - len - 29)\n            val temp36 = arr(len - len - 30)\n      \
    \      val temp37 = arr(len - len - 31)\n            val temp38 = arr(len - len\
    \ - 32)\n            val temp39 = arr(len - len - 33)\n            val temp40\
    \ = arr(len - len - 34)\n            val temp41 = arr(len - len - 35)\n      \
    \      val temp42 = arr(len - len - 36)\n            val temp43 = arr(len - \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq6j74sa9.scala:66:34 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m            \e[33mval\e[0m \e[36mtemp43\e[0m = arr(len\
    \ - \n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m  \
    \ |\e[0m                                  expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq6j74sa9.scala:80:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpq6j74sa9.scala:15:18 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpq6j74sa9.scala:79:1 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpq6j74sa9.scala:68:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m68 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n    \
    \    val change = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCount = mutable.ArrayBuffer.empty[Long]\n        val changeCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMax = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMaxs = mutable.ArrayBuffer.empty[Long]\n        val changeCountMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMins = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMinMax = mutable.ArrayBuffer.empty[Long]\n        val\
    \ changeCountMinMaxs = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMins = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeCountMinMaxMinMax = mutable.ArrayBuffer.empty[Long]\n     \
    \   val changeCountMinMaxMinMaxs = mutable.ArrayBuffer.empty[Long]\n        val\
    \ changeCountMinMaxMinMaxMin = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMins\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMins\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMinMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMinMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMinMaxMin\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMinMaxMins\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMinMaxMinMax\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMaxMinMaxMinMaxMinMaxs\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeCountMinMaxMinMax\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpahvcqzns.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpahvcqzns.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpahvcqzns.scala:18:22\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpahvcqzns.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpahvcqzns.scala:20:22\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpahvcqzns.scala:21:26\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeCount\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659805114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var minChangeCount = 0\n        var minChangeIndex\
    \ = 0\n        var minChangeIndex2 = 0\n        var minChangeIndex3 = 0\n    \
    \    var minChangeIndex4 = 0\n        var minChangeIndex5 = 0\n        var minChangeIndex6\
    \ = 0\n        var minChangeIndex7 = 0\n        var minChangeIndex8 = 0\n    \
    \    var minChangeIndex9 = 0\n        var minChangeIndex10 = 0\n        var minChangeIndex11\
    \ = 0\n        var minChangeIndex12 = 0\n        var minChangeIndex13 = 0\n  \
    \      var minChangeIndex14 = 0\n        var minChangeIndex15 = 0\n        var\
    \ minChangeIndex16 = 0\n        var minChangeIndex17 = 0\n        var minChangeIndex18\
    \ = 0\n        var minChangeIndex19 = 0\n        var minChangeIndex20 = 0\n  \
    \      var minChangeIndex21 = 0\n        var minChangeIndex22 = 0\n        var\
    \ minChangeIndex23 = 0\n        var minChangeIndex24 = 0\n        var minChangeIndex25\
    \ = 0\n        var minChangeIndex26 = 0\n        var minChangeIndex27 = 0\n  \
    \      var minChangeIndex28 = 0\n        var minChangeIndex29 = 0\n        var\
    \ minChangeIndex30 = 0\n        var minChangeIndex31 = 0\n        var minChangeIndex32\
    \ = 0\n        var minChangeIndex33 = 0\n        var minChangeIndex34 = 0\n  \
    \      var minChangeIndex35 = 0\n        var minChangeIndex36 = 0\n        var\
    \ minChangeIndex37 = 0\n        var minChangeIndex38 = 0\n        var minChangeIndex39\
    \ = 0\n        var minChangeIndex40 = 0\n        var minChangeIndex41 = 0\n  \
    \      var minChangeIndex42 = 0\n        var minChangeIndex43 = 0\n        var\
    \ minChangeIndex44 = 0\n        var minChangeIndex45 = 0\n        var minChangeIndex46\
    \ = 0\n        var minChangeIndex47 = 0\n        var minChangeIndex48 = 0\n  \
    \      var minChangeIndex49 = 0\n        var minChangeIndex50 = 0\n        var\
    \ minChangeIndex51 = 0\n        var minChangeIndex52 = 0\n        var minChangeIndex53\
    \ = 0\n        var minChangeIndex54 = 0\n        var minChangeIndex55 = 0\n  \
    \      var minChangeIndex56 = 0\n        var minChangeIndex57 = 0\n        var\
    \ minChangeIndex58 = 0\n        var minChangeIndex59 = 0\n        var minChangeIndex60\
    \ = 0\n        var minChangeIndex61 = 0\n        var minChangeIndex62 = 0\n  \
    \      var minChangeIndex63 = 0\n        var minChangeIndex64 = 0\n        var\
    \ minChangeIndex65 = 0\n        var minChangeIndex66 = 0\n        var minChangeIndex67\
    \ = 0\n        var minChangeIndex68 = 0\n        var minChangeIndex69 = 0\n  \
    \      var minChangeIndex\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4efh2nwv.scala:89:4 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4efh2nwv.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4efh2nwv.scala:89:5\
    \ ---------------------\e[0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ result = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        var temp = 0\n    \
    \    var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n        var\
    \ temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 =\
    \ 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n \
    \       var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n     \
    \   var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7afypgam.scala:118:4 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7afypgam.scala:118:5 --------------------\e[0m\e[0m\n\e[31m118 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n     \
    \   val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n \
    \       val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0ipw60o_.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0ipw60o_.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0ipw60o_.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0ipw60o_.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0ipw60o_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0ipw60o_.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805119
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n     \
    \   var minIndex = 0\n        var max = 0\n        var maxIndex = 0\n        var\
    \ temp = 0\n        var tempIndex = 0\n        var temp2 = 0\n        var temp2Index\
    \ = 0\n        var temp3 = 0\n        var temp3Index = 0\n        var temp4 =\
    \ 0\n        var temp4Index = 0\n        var temp5 = 0\n        var temp5Index\
    \ = 0\n        var temp6 = 0\n        var temp6Index = 0\n        var temp7 =\
    \ 0\n        var temp7Index = 0\n        var temp8 = 0\n        var temp8Index\
    \ = 0\n        var temp9 = 0\n        var temp9Index = 0\n        var temp10 =\
    \ 0\n        var temp10Index = 0\n        var temp11 = 0\n        var temp11Index\
    \ = 0\n        var temp12 = 0\n        var temp12Index = 0\n        var temp13\
    \ = 0\n        var temp13Index = 0\n        var temp14 = 0\n        var temp14Index\
    \ = 0\n        var temp15 = 0\n        var temp15Index = 0\n        var temp16\
    \ = 0\n        var temp16Index = 0\n        var temp17 = 0\n        var temp17Index\
    \ = 0\n        var temp18 = 0\n        var temp18Index = 0\n        var temp19\
    \ = 0\n        var temp19Index = 0\n        var temp20 = 0\n        var temp20Index\
    \ = 0\n        var temp21 = 0\n        var temp21Index = 0\n        var temp22\
    \ = 0\n        var temp22Index = 0\n        var temp23 = 0\n        var temp23Index\
    \ = 0\n        var temp24 = 0\n        var temp24Index = 0\n        var temp25\
    \ = 0\n        var temp25Index = 0\n        var temp26 = 0\n        var temp26Index\
    \ = 0\n        var temp27 = 0\n        var temp27Index = 0\n        var temp28\
    \ = 0\n        var temp28Index = 0\n        var temp29 = 0\n        var temp29Index\
    \ = 0\n        var temp30 = 0\n        var temp30Index = 0\n        var temp31\
    \ = 0\n        var temp31Index = 0\n        var temp32 = 0\n        var temp32Index\
    \ = 0\n        var temp33 = 0\n        var temp33Index = 0\n        var temp34\
    \ = 0\n        var temp34Index = 0\n        var temp35 = 0\n        var temp35Index\
    \ = 0\n        var temp36 = 0\n        var temp36Index = 0\n        var temp37\
    \ = 0\n        var temp37Index = 0\n        var temp38 = 0\n        var temp38Index\
    \ = 0\n        var temp39 = 0\n        var temp39Index = 0\n        var temp40\
    \ = 0\n        var temp40Index = 0\n        var temp41 = 0\n        var temp41Index\
    \ = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7nbyw92i.scala:109:5\
    \ --------------------\e[0m\e[0m\n\e[31m109 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n     \
    \   val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n \
    \       val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val m = arr.head\n        val arr = arr.tail\n\
    \        val m = arr.head\n        val arr = arr.tail\n        val \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpgyszjzqn.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgyszjzqn.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgyszjzqn.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgyszjzqn.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgyszjzqn.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgyszjzqn.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805119
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var minIndex = 0\n        var maxIndex = 0\n        var max = 0\n   \
    \     var maxIndex = 0\n        while(i < len) {\n            min = arr(i)\n \
    \           minIndex = i\n            max = arr(len)\n            maxIndex = len\n\
    \            while(j < len) {\n                if(arr(i) == arr(j)) {\n      \
    \              if(arr(i) < max) {\n                        max = arr(j)\n    \
    \                    maxIndex = j\n                    }\n                   \
    \ j++\n                } else {\n                    if(arr(i) < min) {\n    \
    \                    min = arr(j)\n                        minIndex = j\n    \
    \                }\n                    j++\n                }\n            }\n\
    \            if(min < max) {\n                arr(minIndex) = max\n          \
    \      arr(maxIndex) = min\n                min++\n                max--\n   \
    \             minIndex++\n                maxIndex--\n            }\n        \
    \    i += 1\n            j += 1\n            k += 1\n        }\n        arr.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpai5s3pwl.scala:36:23 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpai5s3pwl.scala:42:23 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpai5s3pwl.scala:51:26\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m                maxIndex--\n\
    \e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m       \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpai5s3pwl.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mmaxIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpai5s3pwl.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(_.toLong)\n\e[31m\e[31m   |\e[0m               \
    \   ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpai5s3pwl.scala:48:19\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m                min++\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m          "
  stdout: ''
  timestamp: 1659805118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.max\n        val\
    \ arr = arr.sortBy(-_)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var min = n\n        var max = 0\n        var changes = 0\n     \
    \   while (i < n) {\n            val curr = arr(i)\n            if (curr < m)\
    \ {\n                val temp = arr(j)\n                arr(j) = curr\n      \
    \          arr(k) = temp\n                j++\n                k++\n         \
    \       changes += 1\n            } else if (curr > m) {\n                val\
    \ temp = arr(j)\n                arr(j) = curr\n                arr(k) = temp\n\
    \                k++\n                changes += 1\n            } else {\n   \
    \             j++\n                k++\n                changes += 1\n       \
    \     }\n            i += 1\n        }\n        if (changes < min) {\n       \
    \     min = changes\n        }\n        if (changes > max) {\n            max\
    \ = changes\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph0_39vdp.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmph0_39vdp.scala:30:17 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \      ^^^\e[0m\n\e[31m   |\e[0m                value ++ is not a member of Int\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph0_39vdp.scala:37:17 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                k++\n\e[31m\e[31m   |\e[0m          \
    \      ^^^\e[0m\n\e[31m   |\e[0m                value ++ is not a member of Int\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph0_39vdp.scala:40:17 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \      ^^^\e[0m\n\e[31m   |\e[0m                value ++ is not a member of Int\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ max = (n / 2).toInt\n        val max2 = max / 2\n        val max3 = max2 / 2\n\
    \        val max4 = max3 / 2\n        val max5 = max4 / 2\n        val max6 =\
    \ max5 / 2\n        val max7 = max6 / 2\n        val max8 = max7 / 2\n       \
    \ val max9 = max8 / 2\n        val max10 = max9 / 2\n        val max11 = max10\
    \ / 2\n        val max12 = max11 / 2\n        val max13 = max12 / 2\n        val\
    \ max14 = max13 / 2\n        val max15 = max14 / 2\n        val max16 = max15\
    \ / 2\n        val max17 = max16 / 2\n        val max18 = max17 / 2\n        val\
    \ max19 = max18 / 2\n        val max20 = max19 / 2\n        val max21 = max20\
    \ / 2\n        val max22 = max21 / 2\n        val max23 = max22 / 2\n        val\
    \ max24 = max23 / 2\n        val max25 = max24 / 2\n        val max26 = max25\
    \ / 2\n        val max27 = max26 / 2\n        val max28 = max27 / 2\n        val\
    \ max29 = max28 / 2\n        val max30 = max29 / 2\n        val max31 = max30\
    \ / 2\n        val max32 = max31 / 2\n        val max33 = max32 / 2\n        val\
    \ max34 = max33 / 2\n        val max35 = max34 / 2\n        val max36 = max35\
    \ / 2\n        val max37 = max36 / 2\n        val max38 = max37 / 2\n        val\
    \ max39 = max38 / 2\n        val max40 = max39 / 2\n        val max41 = max40\
    \ / 2\n        val max42 = max41 / 2\n        val max43 = max42 / 2\n        val\
    \ max44 = max43 / 2\n        val max45 = max44 / 2\n        val max46 = max45\
    \ / 2\n        val max47 = max46 / 2\n        val max48 = max47 / 2\n        val\
    \ max49 = max48 / 2\n        val max50 = max49 / 2\n        val max51 = max50\
    \ / 2\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfr1au0qq.scala:68:11 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfr1au0qq.scala:69:5 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var k = 0\n        var minChange =\
    \ 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n       \
    \ var minChangeIndex3 = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5\
    \ = 0\n        var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n    \
    \    var minChangeIndex8 = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10\
    \ = 0\n        var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n  \
    \      var minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var\
    \ minChangeIndex15 = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17\
    \ = 0\n        var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n  \
    \      var minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var\
    \ minChangeIndex22 = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24\
    \ = 0\n        var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n  \
    \      var minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var\
    \ minChangeIndex29 = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31\
    \ = 0\n        var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n  \
    \      var minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var\
    \ minChangeIndex36 = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38\
    \ = 0\n        var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n  \
    \      var minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var\
    \ minChangeIndex43 = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45\
    \ = 0\n        var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n  \
    \      var minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var\
    \ minChangeIndex50 = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52\
    \ = 0\n        var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n  \
    \      var minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var\
    \ minChangeIndex57 = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59\
    \ = 0\n        var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n  \
    \      var minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var\
    \ minChangeIndex64 = 0\n        var minChangeIndex65 = 0\n        var minChangeIndex66\
    \ = 0\n        var minChangeIndex67 = 0\n        var minChangeIndex68 = 0\n  \
    \      var minChangeIndex69 = 0\n        var \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpx0rfzm5h.scala:90:11 ---------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx0rfzm5h.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpx0rfzm5h.scala:91:5 ---------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805097
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        var changes = 0\n        while (i < len) {\n            val x = arr(i)\n\
    \            val y = arr(len - 1 - i)\n            val z = arr(len - 1 - j)\n\
    \            val w = arr(len - 1 - k)\n            if (x == y && y == z && z ==\
    \ w) {\n                val temp = arr(i)\n                arr(i) = arr(len -\
    \ 1 - i)\n                arr(len - 1 - i) = temp\n                changes +=\
    \ 1\n                min = Math.min(min, changes)\n                i += 1\n  \
    \              j -= 1\n                k -= 1\n            } else if (x == y &&\
    \ y == z) {\n                val temp = arr(i)\n                arr(i) = arr(len\
    \ - 1 - i)\n                arr(len - 1 - i) = temp\n                changes +=\
    \ 1\n                min = Math.min(min, changes)\n                i += 1\n  \
    \              j += 1\n                k -= 1\n            } else if (x == y &&\
    \ y == w) {\n                val temp = arr(i)\n                arr(i) = arr(len\
    \ - 1 - i)\n                arr(len - 1 - i) = temp\n                changes +=\
    \ 1\n                min = Math.min(min, changes)\n                i += 1\n  \
    \              j += 1\n                k += 1\n            } else if (x == z &&\
    \ y == w) {\n                val temp = arr(i)\n                arr(i) = arr(len\
    \ - 1 - i)\n                arr(len - 1 - i) = temp\n                changes +=\
    \ 1\n                min = Math.min(min, changes)\n                i += 1\n  \
    \              j += 1\n                k += 1\n            } else if (x == w)\
    \ {\n                val temp = arr(i)\n                arr(i) = arr(len - 1 -\
    \ i)\n                arr(len - 1 - i) = temp\n                changes += 1\n\
    \                min = Math.min(min, changes)\n                i += 1\n      \
    \          j += 1\n                k += 1\n            } else if (x == z) {\n\
    \                val temp = arr(i)\n                arr(i) = arr(len - 1 - i)\n\
    \                arr(len - 1 - i) = temp\n                changes += 1\n     \
    \           min = Math.min(min, changes)\n                i += 1\n           \
    \     j += 1\n                k -= 1\n            } else if (x == y) {\n     \
    \           val temp = arr(i)\n                arr(i) = arr(len - 1 - i)\n   \
    \             arr(len - 1 - i) = temp\n                changes += 1\n        \
    \        min = Math.min(min, changes)\n                i += 1\n              \
    \  j += 1\n                k -= 1\n            } else if (x == j) {\n        \
    \        val temp = arr(i)\n                arr(i) = arr(len - 1 - i)\n      \
    \          arr(len - 1 - i) = temp\n                changes += 1\n           \
    \     min = Math.min(min, changes)\n                i += 1\n                k\
    \ -= 1\n            } else if (x == k) {\n                val temp = arr\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaq5k7mqk.scala:113:0 ---------------------------\e\
    [0m\e[0m\n\e[31m113 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaq5k7mqk.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                \
    \  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaq5k7mqk.scala:22:8\
    \ ---------------------\e[0m\e[0m\n\e[31m 22 |\e[0m        \e[33mwhile\e[0m (i\
    \ < len) {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: Long\n\e[31m 23 |\e[0m          \
    \  \e[33mval\e[0m \e[36mx\e[0m = arr(i)\n\e[31m 24 |\e[0m            \e[33mval\e\
    [0m \e[36my\e[0m = arr(len - \e[31m1\e[0m - i)\n\e[31m 25 |\e[0m            \e\
    [33mval\e[0m \e[36mz\e[0m = arr(len - \e[31m1\e[0m - j)\n\e[31m 26 |\e[0m    \
    \        \e[33mval\e[0m \e[36mw\e[0m = arr(len - \e[31m1\e[0m - k)\n\e[31m 27\
    \ |\e[0m            \e[33mif\e[0m (x == y && y == z && z == w) {\n\e[31m 28 |\e\
    [0m                \e[33mval\e[0m \e[36mtemp\e[0m = arr(i)\n\e[31m 29 |\e[0m \
    \               arr(i) = arr(len - \e[31m1\e[0m - i)\n\e[31m 30 |\e[0m       \
    \         arr(len - \e[31m1\e[0m - i) = temp\n\e[31m 31 |\e[0m               \
    \ changes += \e[31m1\e[0m\n\e[31m 32 |\e[0m                min = Math.min(min,\
    \ changes)\n\e[31m 33 |\e[0m                i += \e[31m1\e[0m\n\e[31m 34 |\e[0m\
    \                j -= \e[31m1\e[0m\n\e[31m 35 |\e[0m                k -= \e[31m1\e\
    [0m\n\e[31m 36 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (x == y && y\
    \ == z) {\n\e[31m 37 |\e[0m                \e[33mval\e[0m \e[36mtemp\e[0m = arr(i)\n\
    \e[31m 38 |\e[0m                arr(i) = arr(len - \e[31m1\e[0m - i)\n\e[31m 39\
    \ |\e[0m                arr(len - \e[31m1\e[0m - i) = temp\n\e[31m 40 |\e[0m \
    \               changes += \e[31m1\e[0m\n\e[31m 41 |\e[0m                min =\
    \ Math.min(min, changes)\n\e[31m 42 |\e[0m                i += \e[31m1\e[0m\n\e\
    [3"
  stdout: ''
  timestamp: 1659805123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var minChange = 0\n        var minChangeIndex = 0\n        var\
    \ minChangeLen = 0\n        var minChangeIndexLen = 0\n        var minChangeIndexLen2\
    \ = 0\n        var minChangeIndexLen3 = 0\n        var minChangeIndexLen4 = 0\n\
    \        var minChangeIndexLen5 = 0\n        var minChangeIndexLen6 = 0\n    \
    \    var minChangeIndexLen7 = 0\n        var minChangeIndexLen8 = 0\n        var\
    \ minChangeIndexLen9 = 0\n        var minChangeIndexLen10 = 0\n        var minChangeIndexLen11\
    \ = 0\n        var minChangeIndexLen12 = 0\n        var minChangeIndexLen13 =\
    \ 0\n        var minChangeIndexLen14 = 0\n        var minChangeIndexLen15 = 0\n\
    \        var minChangeIndexLen16 = 0\n        var minChangeIndexLen17 = 0\n  \
    \      var minChangeIndexLen18 = 0\n        var minChangeIndexLen19 = 0\n    \
    \    var minChangeIndexLen20 = 0\n        var minChangeIndexLen21 = 0\n      \
    \  var minChangeIndexLen22 = 0\n        var minChangeIndexLen23 = 0\n        var\
    \ minChangeIndexLen24 = 0\n        var minChangeIndexLen25 = 0\n        var minChangeIndexLen26\
    \ = 0\n        var minChangeIndexLen27 = 0\n        var minChangeIndexLen28 =\
    \ 0\n        var minChangeIndexLen29 = 0\n        var minChangeIndexLen30 = 0\n\
    \        var minChangeIndexLen31 = 0\n        var minChangeIndexLen32 = 0\n  \
    \      var minChangeIndexLen33 = 0\n        var minChangeIndexLen34 = 0\n    \
    \    var minChangeIndexLen35 = 0\n        var minChangeIndexLen36 = 0\n      \
    \  var minChangeIndexLen37 = 0\n        var minChangeIndexLen38 = 0\n        var\
    \ minChangeIndexLen39 = 0\n        var minChangeIndexLen40 = 0\n        var minChangeIndexLen41\
    \ = 0\n        var minChangeIndexLen42 = 0\n        var minChangeIndexLen43 =\
    \ 0\n        var minChangeIndexLen44 = 0\n        var minChangeIndexLen45 = 0\n\
    \        var minChangeIndexLen46 = 0\n        var minChangeIndexLen47 = 0\n  \
    \      var minChangeIndexLen48 = 0\n        var minChangeIndexLen49 = 0\n    \
    \    var minChangeIndexLen50 = 0\n        var minChangeIndexLen51 = 0\n      \
    \  var minChangeIndexLen52 = 0\n        var minChangeIndexLen53 = 0\n        var\
    \ minChangeIndexLen54 = 0\n        var minChangeIndexLen55 = 0\n        var minChangeIndexLen56\
    \ = 0\n        var minChangeIndexLen57 = 0\n        var minChangeIndexLen58 =\
    \ 0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7_r0b4_1.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp7_r0b4_1.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ val max = (arr.lastOption.getOrElse(0l)).max(arr.headOption.getOrElse(0l))\n\
    \        val min = arr.headOption.getOrElse(0l)\n        val maxIndex = arr.lastIndexWhere(x\
    \ => x == max)\n        val minIndex = arr.indexOf(min)\n        val maxIndex2\
    \ = arr.lastIndexWhere(x => x == max)\n        val minIndex2 = arr.indexOf(min)\n\
    \        val maxIndex3 = arr.lastIndexWhere(x => x == max)\n        val minIndex3\
    \ = arr.indexOf(min)\n        val maxIndex4 = arr.lastIndexWhere(x => x == max)\n\
    \        val minIndex4 = arr.indexOf(min)\n        val maxIndex5 = arr.lastIndexWhere(x\
    \ => x == max)\n        val minIndex5 = arr.indexOf(min)\n        val maxIndex6\
    \ = arr.lastIndexWhere(x => x == max)\n        val minIndex6 = arr.indexOf(min)\n\
    \        val maxIndex7 = arr.lastIndexWhere(x => x == max)\n        val minIndex7\
    \ = arr.indexOf(min)\n        val maxIndex8 = arr.lastIndexWhere(x => x == max)\n\
    \        val minIndex8 = arr.indexOf(min)\n        val maxIndex9 = arr.lastIndexWhere(x\
    \ => x == max)\n        val minIndex9 = arr.indexOf(min)\n        val maxIndex10\
    \ = arr.lastIndexWhere(x => x == max)\n        val minIndex10 = arr.indexOf(min)\n\
    \        val maxIndex11 = arr.lastIndexWhere(x => x == max)\n        val minIndex11\
    \ = arr.indexOf(min)\n        val maxIndex12 = arr.lastIndexWhere(x => x == max)\n\
    \        val minIndex12 = arr.indexOf(min)\n        val maxIndex13 = arr.lastIndexWhere(x\
    \ => x == max)\n        val minIndex13 = arr.indexOf(min)\n        val maxIndex14\
    \ = arr.lastIndexWhere(x => x == max)\n        val minIndex14 = arr.indexOf(min)\n\
    \        val maxIndex15 = arr.lastIndexWhere(x => x == max)\n        val minIndex15\
    \ = arr.indexOf(min)\n        val maxIndex16 = arr.lastIndexWhere(x => x == max)\n\
    \        val minIndex16 = arr.indexOf(min)\n        val maxIndex17 = arr.lastIndexWhere(x\
    \ => x == max)\n        val minIndex17 = arr.indexOf(min)\n        val maxIndex18\
    \ = arr.lastIndexWhere(x => x == max)\n        val minIndex18 = arr.indexOf(min)\n\
    \        val maxIndex19 = arr.lastIndexWhere(x => x == max)\n        val minIndex19\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5qi8c70m.scala:56:24 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36mminIndex19\e[0m = \n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp5qi8c70m.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5qi8c70m.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        var changes = 0\n        while (i < len) {\n            while (j < len)\
    \ {\n                if (arr(i) == arr(j)) {\n                    j++\n      \
    \          } else {\n                    k++\n                }\n            }\n\
    \            if (k > 0) {\n                changes += k\n                k = 0\n\
    \            }\n            i += 1\n            j += 1\n        }\n        if\
    \ (changes > 0) {\n            changes += len\n        }\n        min\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1o5gwe2k.scala:25:23 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp1o5gwe2k.scala:27:23 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp1o5gwe2k.scala:15:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m   |\e[0m                    \
    \         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded function:\n\
    \e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp1o5gwe2k.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e\
    [33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805119
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var minChange = 0\n        var maxChange =\
    \ 0\n        var maxLenChange = 0\n        var minLenChange = 0\n        var minChangeIndex\
    \ = 0\n        var maxChangeIndex = 0\n        var maxLenChangeIndex = 0\n   \
    \     var minLenChangeIndex = 0\n        var minChangeIndex2 = 0\n        var\
    \ maxChangeIndex2 = 0\n        var maxLenChangeIndex2 = 0\n        var minLenChangeIndex2\
    \ = 0\n        var minChangeIndex3 = 0\n        var maxChangeIndex3 = 0\n    \
    \    var maxLenChangeIndex3 = 0\n        var minLenChangeIndex3 = 0\n        var\
    \ minChangeIndex4 = 0\n        var maxChangeIndex4 = 0\n        var maxLenChangeIndex4\
    \ = 0\n        var minLenChangeIndex4 = 0\n        var minChangeIndex5 = 0\n \
    \       var maxChangeIndex5 = 0\n        var maxLenChangeIndex5 = 0\n        var\
    \ minLenChangeIndex5 = 0\n        var minChangeIndex6 = 0\n        var maxChangeIndex6\
    \ = 0\n        var maxLenChangeIndex6 = 0\n        var minLenChangeIndex6 = 0\n\
    \        var minChangeIndex7 = 0\n        var maxChangeIndex7 = 0\n        var\
    \ maxLenChangeIndex7 = 0\n        var minLenChangeIndex7 = 0\n        var minChangeIndex8\
    \ = 0\n        var maxChangeIndex8 = 0\n        var maxLenChangeIndex8 = 0\n \
    \       var minLenChangeIndex8 = 0\n        var minChangeIndex9 = 0\n        var\
    \ maxChangeIndex9 = 0\n        var maxLenChangeIndex9 = 0\n        var minLenChangeIndex9\
    \ = 0\n        var minChangeIndex10 = 0\n        var maxChangeIndex10 = 0\n  \
    \      var maxLenChangeIndex10 = 0\n        var minLenChangeIndex10 = 0\n    \
    \    var minChangeIndex11 = 0\n        var maxChangeIndex11 = 0\n        var maxLenChangeIndex11\
    \ = 0\n        var minLenChangeIndex11 = 0\n        var minChangeIndex12 = 0\n\
    \        var maxChangeIndex12 = 0\n        var maxLenChangeIndex12 = 0\n     \
    \   var minLenChangeIndex12 = 0\n        var minChangeIndex13 = 0\n        var\
    \ maxChangeIndex13 = 0\n        var maxLenChangeIndex13 = 0\n        var minLenChangeIndex13\
    \ = 0\n        var minChangeIndex14 = 0\n        var maxChangeIndex14 = 0\n  \
    \      var maxLenChangeIndex14 = 0\n        var minLenChangeIndex14 = 0\n    \
    \    var minChangeIndex15 = 0\n        var maxChangeIndex15 = 0\n        var maxLenChangeIndex15\
    \ = 0\n        var minLenChangeIndex15 = 0\n        var minChangeIndex16 = 0\n\
    \        var maxChangeIndex16 = 0\n        var maxLenChangeIndex16 = 0\n\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmppbn9sc.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpmppbn9sc.scala:86:5 ---------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val curr = arr(i)\n            val next\
    \ = arr(j)\n            val diff = curr - next\n            if (diff > 0) {\n\
    \                min = Math.min(min, diff)\n                k = j\n          \
    \  } else if (diff < 0) {\n                min = Math.min(min, -diff)\n      \
    \          k = j\n            }\n            i += 1\n            j += 1\n    \
    \    }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpit1t605i.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpit1t605i.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val mid = len / 2\n        val left = arr.take(mid)\n        val right\
    \ = arr.drop(mid)\n        val leftLen = left.length\n        val rightLen = right.length\n\
    \        val leftMin = left.min\n        val rightMin = right.min\n        val\
    \ leftMax = left.max\n        val rightMax = right.max\n        val leftMinChange\
    \ = leftLen - leftMin\n        val rightMinChange = rightLen - rightMin\n    \
    \    val leftMaxChange = leftMax - leftMin\n        val rightMaxChange = rightMax\
    \ - rightMin\n        val leftMinChangeChange = leftMinChange - leftMaxChange\n\
    \        val rightMinChangeChange = rightMinChange - rightMaxChange\n        val\
    \ leftMaxChangeChange = leftMaxChange - leftMinChange\n        val rightMaxChangeChange\
    \ = rightMaxChange - rightMinChange\n        val leftMinChangeChangeChange = leftMinChangeChange\
    \ - rightMaxChangeChange\n        val rightMinChangeChangeChange = rightMinChangeChange\
    \ - leftMaxChangeChange\n        val leftMaxChangeChangeChange = leftMaxChangeChange\
    \ - leftMinChangeChange\n        val rightMaxChangeChange = rightMaxChangeChange\
    \ - rightMinChangeChange\n        val leftMinChangeChangeChangeChange = leftMinChangeChangeChange\
    \ - rightMaxChangeChangeChange\n        val rightMinChangeChangeChangeChange =\
    \ rightMinChangeChangeChange - leftMaxChangeChangeChange\n        val leftMaxChangeChangeChangeChange\
    \ = leftMaxChangeChangeChange - leftMinChangeChangeChange\n        val rightMaxChangeChangeChange\
    \ = rightMaxChangeChangeChange - rightMinChangeChangeChange\n        val leftMinChangeChangeChangeChangeChange\
    \ = leftMinChangeChangeChangeChange - rightMaxChangeChangeChange\n        val\
    \ rightMinChangeChangeChangeChangeChange = rightMinChangeChangeChangeChange -\
    \ leftMaxChangeChangeChangeChange\n        val leftMaxChangeChangeChangeChangeChange\
    \ = leftMaxChangeChangeChangeChange - leftMinChangeChangeChangeChange\n      \
    \  val rightMaxChangeChangeChangeChange = rightMaxChangeChangeChangeChange - rightMinChangeChangeChangeChange\n\
    \        val leftMinChangeChangeChangeChangeChange = leftMinChangeChangeChangeChange\
    \ - rightMaxChangeChangeChangeChange\n        val rightMinChangeChangeChangeChangeChange\
    \ = rightMinChangeChangeChangeChange - leftMaxChangeChangeChangeChangeChange\n\
    \        val leftMaxChangeChangeChangeChangeChange = leftMaxChangeChangeChangeChange\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpogzfb8d3.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mrightMaxChangeChange\e[0m\
    \ = rightMaxChangeChange - rightMinChangeChange\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mrightMaxChangeChange is already defined as \e[33mvalue\e[0m \e\
    [35mrightMaxChangeChange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpogzfb8d3.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mleftMinChangeChangeChangeChangeChange\e\
    [0m = leftMinChangeChangeChangeChange - rightMaxChangeChangeChangeChange\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinChangeChangeChangeChangeChange is already defined as\
    \ \e[33mvalue\e[0m \e[35mleftMinChangeChangeChangeChangeChange\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpogzfb8d3.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightMinChangeChangeChangeChangeChange\e[0m = rightMinChangeChangeChangeChange\
    \ - leftMaxChangeChangeChangeChangeChange\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMinChangeChangeChangeChangeChange is already defined\
    \ as \e[33mvalue\e[0m \e[35mrightMinChangeChangeChangeChangeChange\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpogzfb8d3.scala:48:12 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftMaxChangeChangeChangeChangeChange\e[0m\
    \ = leftMaxChangeChangeChangeChange \n\e["
  stdout: ''
  timestamp: 1659805127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpewmprc29.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpewmprc29.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpewmprc29.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.length\n     \
    \   val maxChange = arr.foldLeft(0)((acc, x) => if (x == arr.last) acc else acc\
    \ + 1)\n        val minChange = arr.foldLeft(0)((acc, x) => if (x == arr.first)\
    \ acc else acc + 1)\n        val change = maxChange - minChange\n        val changes\
    \ = arr.size - change\n        val changesToMakePalindromic = change / 2\n   \
    \     val changesToMakePalindromic2 = change / 4\n        val changesToMakePalindromic3\
    \ = change / 8\n        val changesToMakePalindromic4 = change / 16\n        val\
    \ changesToMakePalindromic5 = change / 32\n        val changesToMakePalindromic6\
    \ = change / 64\n        val changesToMakePalindromic7 = change / 128\n      \
    \  val changesToMakePalindromic8 = change / 256\n        val changesToMakePalindromic9\
    \ = change / 512\n        val changesToMakePalindromic10 = change / 1024\n   \
    \     val changesToMakePalindromic11 = change / 2048\n        val changesToMakePalindromic12\
    \ = change / 4096\n        val changesToMakePalindromic13 = change / 8192\n  \
    \      val changesToMakePalindromic14 = change / 16384\n        val changesToMakePalindromic15\
    \ = change / 32768\n        val changesToMakePalindromic16 = change / 65536\n\
    \        val changesToMakePalindromic17 = change / 131072\n        val changesToMakePalindromic18\
    \ = change / 262144\n        val changesToMakePalindromic19 = change / 524288\n\
    \        val changesToMakePalindromic20 = change / 1048576\n        val changesToMakePalindromic21\
    \ = change / 2097152\n        val changesToMakePalindromic22 = change / 4194304\n\
    \        val changesToMakePalindromic23 = change / 8388608\n        val changesToMakePalindromic24\
    \ = change / 16777216\n        val changesToMakePalindromic25 = change / 33554432\n\
    \        val changesToMakePalindromic26 = change / 67108864\n        val changesToMakePalindromic27\
    \ = change / 134217728\n        val changesToMakePalindro\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphxpszp4m.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphxpszp4m.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphxpszp4m.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var smallest = 0\n        var largest\
    \ = arr.length\n        while (i < arr.length && j < arr.length) {\n         \
    \   if (arr(i) == arr(j)) {\n                i += 1\n                j += 1\n\
    \                k += 1\n            } else if (arr(i) < arr(j)) {\n         \
    \       smallest = k\n                largest = j\n                i += 1\n  \
    \          } else if (arr(i) > arr(j)) {\n                smallest = k\n     \
    \           largest = i\n                j += 1\n            }\n        }\n  \
    \      if (smallest == 0) {\n            return 0\n        }\n        if (smallest\
    \ == largest) {\n            return smallest\n        }\n        if (smallest\
    \ > largest) {\n            return largest\n        }\n        return smallest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvtjax9mq.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        var i = 0\n        var j =\
    \ 0\n        var count = 0\n        var min = Long.MaxValue\n        while(i <\
    \ arr.length && j < arr.length) {\n            val a = arr(i)\n            val\
    \ b = arr(j)\n            if(a.toString == b.toString) {\n                count\
    \ += 1\n                i += 1\n                j += 1\n            }\n      \
    \      else {\n                if(a.toString < b.toString) {\n               \
    \     count += 1\n                    i += 1\n                }\n            \
    \    else {\n                    count += 1\n                    j += 1\n    \
    \            }\n            }\n            if(count > min) {\n               \
    \ min = count\n            }\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp29zsgiv6.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var change = 0\n        var minChange\
    \ = 0\n        while(i < len) {\n            while(j < len) {\n              \
    \  if(arr(i) == arr(j)) {\n                    j++\n                }\n      \
    \          else {\n                    j = 0\n                    change++\n \
    \               }\n            }\n            minChange = change\n           \
    \ i = 0\n            j = 0\n            change = 0\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpeozq08d7.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpeozq08d7.scala:28:28 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    change++\n\e[31m\e[31m   |\e[0m                  \
    \          ^\e[0m\n\e[31m   |\e[0m                            expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpeozq08d7.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        var count\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp\
    \ = 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n \
    \       var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var\
    \ temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11\
    \ = 0\n        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n\
    \        var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n    \
    \    var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var\
    \ temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24\
    \ = 0\n        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n\
    \        var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n    \
    \    var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var\
    \ temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37\
    \ = 0\n        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n\
    \        var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n    \
    \    var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var\
    \ temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50\
    \ = 0\n        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n\
    \        var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n    \
    \    var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var\
    \ temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63\
    \ = 0\n        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n\
    \        var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n    \
    \    var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var\
    \ temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76\
    \ = 0\n        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n\
    \        var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n    \
    \    var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var\
    \ temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89\
    \ = 0\n        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n\
    \        var temp93 = 0\n        var temp\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmwi6ndy1.scala:117:4 ---------------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmwi6ndy1.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmwi6ndy1.scala:117:5\
    \ --------------------\e[0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805091
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = minChangeIndex\
    \ + 1\n        val minChange = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr(0))\n        val minChangeIndex = minChangeIndex - 1\n        val\
    \ minChange = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x =>\
    \ x == arr[len-1])\n        val minChangeIndex = minChangeIndex - 1\n        val\
    \ minChange = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x =>\
    \ x == arr(0))\n        val minChangeIndex = minChangeIndex + 1\n        val minChange\
    \ = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = minChangeIndex - 1\n        val minChange = minChangeIndex\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr(0))\n        val minChangeIndex\
    \ = minChangeIndex + 1\n        val minChange = minChangeIndex\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChange = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr(0))\n        val minChangeIndex = minChangeIndex + 1\n        val\
    \ minChange = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x =>\
    \ x == arr[len-1])\n        val minChangeIndex = minChangeIndex - 1\n        val\
    \ minChange = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x =>\
    \ x == arr(0))\n        val minChangeIndex = minChangeIndex + 1\n        val minChange\
    \ = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = minChangeIndex - 1\n        val minChange = minChangeIndex\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr(0))\n        val minChangeIndex\
    \ = minChangeIndex + 1\n        val minChange = minChangeIndex\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChange = minChangeIndex\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr(0))\n        val minChangeIndex = minChangeIndex + 1\n        val\
    \ minChange = minChangeIndex\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpek272qez.scala:61:11 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpek272qez.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.indexWhere(\e\
    [36mx\e[0m => x == arr[\e[35mlen-\e[31m1\e[0m])\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpek272qez.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpek272qez.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = minChangeIndex\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChange\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChange\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpek272qez.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminChangeIndex\e[0m = arr.indexWhere(\e[36mx\e[0m => x == arr(\e[31m0\e\
    [0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e"
  stdout: ''
  timestamp: 1659805133
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = -1\n        val minChangeIndex\
    \ = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x\
    \ => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x ==\
    \ arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n\
    \        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n       \
    \ val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex\
    \ = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x\
    \ => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x ==\
    \ arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n\
    \        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n       \
    \ val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex\
    \ = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x\
    \ => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x ==\
    \ arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n\
    \        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n       \
    \ val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex\
    \ = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x\
    \ => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x ==\
    \ arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n\
    \        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n       \
    \ val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex\
    \ = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x\
    \ => x == arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x ==\
    \ arr.last)\n        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n\
    \        val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n       \
    \ val minChangeIndex = arr.lastIndexWhere(x => x == arr.last)\n        val minChangeIndex\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5gm7je7m.scala:49:28 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5gm7je7m.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.lastIndexWhere(\e\
    [36mx\e[0m => x == arr.last)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5gm7je7m.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.lastIndexWhere(\e\
    [36mx\e[0m => x == arr.last)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5gm7je7m.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.lastIndexWhere(\e\
    [36mx\e[0m => x == arr.last)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5gm7je7m.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex"
  stdout: ''
  timestamp: 1659805135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var min = 0\n        var max = 0\n       \
    \ while(i < arr.length && j < arr.length) {\n            if(arr(i) == arr(j))\
    \ {\n                i += 1\n                j += 1\n                k += 1\n\
    \                min = Math.min(min, k)\n                max = Math.max(max, k)\n\
    \            }\n            else if(arr(i) < arr(j)) {\n                i += 1\n\
    \                k += 1\n                min = Math.min(min, k)\n            \
    \    max = Math.max(max, k)\n            }\n            else {\n             \
    \   j += 1\n                k += 1\n                min = Math.min(min, k)\n \
    \               max = Math.max(max, k)\n            }\n        }\n        if(arr.length\
    \ == 1) {\n            return 0\n        }\n        if(arr.length == 2) {\n  \
    \          if(arr(0) == arr(1)) {\n                return 1\n            }\n \
    \           else {\n                return 0\n            }\n        }\n     \
    \   if(arr.length == 3) {\n            if(arr(0) == arr(1) && arr(1) == arr(2))\
    \ {\n                return 2\n            }\n            else {\n           \
    \     return 0\n            }\n        }\n        if(arr.length == 4) {\n    \
    \        if(arr(0) == arr(1) && arr(1) == arr(2) && arr(2) == arr(3)) {\n    \
    \            return 3\n            }\n            else {\n                return\
    \ 0\n            }\n        }\n        if(arr.length == 5) {\n            if(arr(0)\
    \ == arr(1) && arr(1) == arr(2) && arr(2) == arr(3) && arr(3) == arr(4)) {\n \
    \               return 4\n            }\n            else {\n                return\
    \ 0\n            }\n        }\n        if(arr.length == 6) {\n            if(arr(0)\
    \ == arr(1) && arr(1) == arr(2) && arr(2) == arr(3) && arr(3) == arr(4) && arr(4)\
    \ == arr(5)) {\n                return 5\n            }\n            else {\n\
    \                return 0\n            }\n        }\n        if(arr.length ==\
    \ 7) {\n            if(arr(0) == arr(1) && arr(1) == arr(2) && arr(2) == arr(3)\
    \ && arr(3) == arr(4) && arr(4) == arr(5) && arr(5) == arr(6)) {\n           \
    \     return 6\n            }\n            else {\n                return 0\n\
    \            }\n        }\n        if(arr.length == 8) {\n            if(arr(0)\
    \ == arr(1) && arr(1) == arr(2) && arr(2) == arr(3) && arr(3) == arr(4) && arr(4)\
    \ == arr(5) && arr(5) == arr(6) && arr(6) == arr(7)) {\n                return\
    \ 7\n            }\n            else {\n                return 0\n           \
    \ }\n        }\n        if(arr.length == 9) {\n            if(arr(0) == arr(1)\
    \ && arr(1) == arr(2) && arr(2) == arr(3) && arr(3\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9n0cmkr7.scala:103:4 ---------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9n0cmkr7.scala:116:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m116 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmp9n0cmkr7.scala:15:29 -----------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e\
    [31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9n0cmkr7.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9n0cmkr7.scala:115:1 --------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e[0m\n\e[31m    |\e[0m Found:\
    \    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp9n0cmkr7.scala:104:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m104 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n5 errors found\n"
  stdout: ''
  timestamp: 1659805136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.last\n        val\
    \ max = (n - 1).toLong\n        val min = (m + 1).toLong\n        var count =\
    \ 0\n        val arr = arr.sortWith(_ < _)\n        var i = 0\n        var j =\
    \ 0\n        while (i < n && j < m) {\n            if (arr(i) == arr(j)) {\n \
    \               count += 1\n                i += 1\n                j += 1\n \
    \           } else if (arr(i) < arr(j)) {\n                i += 1\n          \
    \  } else {\n                j += 1\n            }\n        }\n        if (count\
    \ == 0) {\n            return 0\n        } else if (count == 1) {\n          \
    \  return 1\n        } else {\n            return count - 2\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9d7cr3no.scala:20:18 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805131
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.last\n        val\
    \ arr = arr.sortBy(-_)\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n        val arr6\
    \ = arr5.toList\n        val arr7 = arr6.toList\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.toList\n        val arr10 = arr9.toList\n        val\
    \ arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val arr13 =\
    \ arr12.toList\n        val arr14 = arr13.toList\n        val arr15 = arr14.toList\n\
    \        val arr16 = arr15.toList\n        val arr17 = arr16.toList\n        val\
    \ arr18 = arr17.toList\n        val arr19 = arr18.toList\n        val arr20 =\
    \ arr19.toList\n        val arr21 = arr20.toList\n        val arr22 = arr21.toList\n\
    \        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n        val\
    \ arr25 = arr24.toList\n        val arr26 = arr25.toList\n        val arr27 =\
    \ arr26.toList\n        val arr28 = arr27.toList\n        val arr29 = arr28.toList\n\
    \        val arr30 = arr29.toList\n        val arr31 = arr30.toList\n        val\
    \ arr32 = arr31.toList\n        val arr33 = arr32.toList\n        val arr34 =\
    \ arr33.toList\n        val arr35 = arr34.toList\n        val arr36 = arr35.toList\n\
    \        val arr37 = arr36.toList\n        val arr38 = arr37.toList\n        val\
    \ arr39 = arr38.toList\n        val arr40 = arr39.toList\n        val arr41 =\
    \ arr40.toList\n        val arr42 = arr41.toList\n        val arr43 = arr42.toList\n\
    \        val arr44 = arr43.toList\n        val arr45 = arr44.toList\n        val\
    \ arr46 = arr45.toList\n        val arr47 = arr46.toList\n        val arr48 =\
    \ arr47.toList\n        val arr49 = arr48.toList\n        val arr50 = arr49.toList\n\
    \        val arr51 = arr50.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprc8ewrt3.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprc8ewrt3.scala:68:5 ---------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = len - 1\n        val mid = len / 2\n  \
    \      val mid2 = len / 2\n        val mid3 = len / 2\n        val mid4 = len\
    \ / 2\n        val mid5 = len / 2\n        val mid6 = len / 2\n        val mid7\
    \ = len / 2\n        val mid8 = len / 2\n        val mid9 = len / 2\n        val\
    \ mid10 = len / 2\n        val mid11 = len / 2\n        val mid12 = len / 2\n\
    \        val mid13 = len / 2\n        val mid14 = len / 2\n        val mid15 =\
    \ len / 2\n        val mid16 = len / 2\n        val mid17 = len / 2\n        val\
    \ mid18 = len / 2\n        val mid19 = len / 2\n        val mid20 = len / 2\n\
    \        val mid21 = len / 2\n        val mid22 = len / 2\n        val mid23 =\
    \ len / 2\n        val mid24 = len / 2\n        val mid25 = len / 2\n        val\
    \ mid26 = len / 2\n        val mid27 = len / 2\n        val mid28 = len / 2\n\
    \        val mid29 = len / 2\n        val mid30 = len / 2\n        val mid31 =\
    \ len / 2\n        val mid32 = len / 2\n        val mid33 = len / 2\n        val\
    \ mid34 = len / 2\n        val mid35 = len / 2\n        val mid36 = len / 2\n\
    \        val mid37 = len / 2\n        val mid38 = len / 2\n        val mid39 =\
    \ len / 2\n        val mid40 = len / 2\n        val mid41 = len / 2\n        val\
    \ mid42 = len / 2\n        val mid43 = len / 2\n        val mid44 = len / 2\n\
    \        val mid45 = len / 2\n        val mid46 = len / 2\n        val mid47 =\
    \ len / 2\n        val mid48 = len / 2\n        val mid49 = len / 2\n        val\
    \ mid50 = len / 2\n        val mid51 = len / 2\n        val mid52 = len / 2\n\
    \        val mid53 = len / 2\n        val mid54 = len / 2\n        val mid55 =\
    \ len / 2\n        val mid56 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpsh8wv7fx.scala:74:19 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36mmid56\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpsh8wv7fx.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsh8wv7fx.scala:75:5 ---------------------\e[0m\e[0m\n\e[31m75\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val maxLen = len / 2\n        val maxLen2 = len / 4\n        val maxLen3\
    \ = len / 8\n        val maxLen4 = len / 16\n        val maxLen5 = len / 32\n\
    \        val maxLen6 = len / 64\n        val maxLen7 = len / 128\n        val\
    \ maxLen8 = len / 256\n        val maxLen9 = len / 512\n        val maxLen10 =\
    \ len / 1024\n        val maxLen11 = len / 2048\n        val maxLen12 = len /\
    \ 4096\n        val maxLen13 = len / 8192\n        val maxLen14 = len / 16384\n\
    \        val maxLen15 = len / 32768\n        val maxLen16 = len / 65536\n    \
    \    val maxLen17 = len / 131072\n        val maxLen18 = len / 262144\n      \
    \  val maxLen19 = len / 524288\n        val maxLen20 = len / 1048576\n       \
    \ val maxLen21 = len / 2097152\n        val maxLen22 = len / 4194304\n       \
    \ val maxLen23 = len / 8388608\n        val maxLen24 = len / 16777216\n      \
    \  val maxLen25 = len / 33554432\n        val maxLen26 = len / 67108864\n    \
    \    val maxLen27 = len / 134217728\n        val maxLen28 = len / 268435456\n\
    \        val maxLen29 = len / 536870912\n        val maxLen30 = len / 1073741824\n\
    \        val maxLen31 = len / 2147483648\n        val maxLen32 = len / 4294967296\n\
    \        val maxLen33 = len / 8589934592\n        val maxLen34 = len / 17179869184\n\
    \        val maxLen35 = len / 34359738368\n        val maxLen36 = len / 68719476736\n\
    \        val maxLen37 = len / 137438953472\n        val maxLen38 = len / 274877906944\n\
    \        val maxLen39 = len / 549755813888\n        val maxLen40 = len / 1099511627776\n\
    \        val maxLen41 = len / 2199023255552\n        val maxLen42 = len / 4398046511104\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx7q0jzk0.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx7q0jzk0.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.head\n        val n = arr.last\n        val\
    \ m = m.toString.toInt\n        val n = n.toString.toInt\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val m = m -\
    \ n\n        val n = n + m\n        val m = m - n\n        val n = n + m\n   \
    \     val m = m - n\n        val n = n + m\n        val m = m - n\n        val\
    \ n = n + m\n        val m = m - n\n        val n = n + m\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyt6l3e7p.scala:99:11 ---------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpyt6l3e7p.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = m.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is\
    \ already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyt6l3e7p.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = n.toString.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyt6l3e7p.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = m - n\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpyt6l3e7p.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n + m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined as\
    \ \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpyt6l3e7p.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = m - n\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e["
  stdout: ''
  timestamp: 1659805140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.last\n        val\
    \ arr = arr.sortBy(-_)\n        val arr2 = arr.toList\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n        val arr6\
    \ = arr5.toList\n        val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n        val\
    \ arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val arr13 =\
    \ arr12.reverse\n        val arr14 = arr13.toList\n        val arr15 = arr14.toList\n\
    \        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n       \
    \ val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.toList\n        val arr21 = arr20.reverse\n        val arr22 = arr21.toList\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.toList\n       \
    \ val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.toList\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.toList\n        val arr31 = arr30.reverse\n       \
    \ val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.toList\n        val arr35 = arr34.reverse\n        val arr36 = arr35.toList\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.toList\n       \
    \ val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.toList\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.toList\n        val arr45 = arr44.reverse\n       \
    \ val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50 = arr49.toList\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n       \
    \ val arr53 = arr52.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6jg3wqll.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6jg3wqll.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var count = 0\n        var min\
    \ = Long.MaxValue\n        while(i < len) {\n            while(j < len && arr(i)\
    \ == arr(j)) {\n                j++\n            }\n            count = j - i\n\
    \            if(count < min) {\n                min = count\n            }\n \
    \           i = j\n            j = 0\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx_k42bj1.scala:23:19 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpx_k42bj1.scala:15:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m            \
    \                 ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded\
    \ function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpx_k42bj1.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805133
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val maxChange\
    \ = arr.size - 1\n        var change = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3\
    \ = 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n \
    \       var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n\
    \        var temp95 = 0\n        var temp\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpufs2rdni.scala:118:4 ---------------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpufs2rdni.scala:118:5 --------------------\e[0m\e[0m\n\e[31m118 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        var count = 0\n        while(i < len) {\n            while(j < len &&\
    \ arr(i) == arr(j)) {\n                j += 1\n            }\n            while(j\
    \ < len) {\n                val temp = arr(i)\n                arr(i) = arr(j)\n\
    \                arr(j) = temp\n                j += 1\n            }\n      \
    \      while(j < len) {\n                val temp = arr(i)\n                arr(i)\
    \ = arr(j)\n                arr(j) = temp\n                j += 1\n          \
    \      k += 1\n            }\n            while(j < len) {\n                val\
    \ temp = arr(i)\n                arr(i) = arr(j)\n                arr(j) = temp\n\
    \                j += 1\n                k += 1\n                count += 1\n\
    \            }\n            i += 1\n            j += 1\n        }\n        if(count\
    \ < min) {\n            min = count\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp_3a8z2a8.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_3a8z2a8.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        while(i < len) {\n            while(j < len) {\n\
    \                if(arr(i) == arr(j)) {\n                    temp = arr(i)\n \
    \                   arr(i) = arr(j)\n                    arr(j) = temp\n     \
    \               j++\n                }\n                else {\n             \
    \       j++\n                }\n            }\n            i = i + 1\n       \
    \     j = 0\n            k = k + 1\n        }\n        if(arr.length == min) {\n\
    \            return 0\n        }\n        else {\n            return min\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp9divsl4o.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp9divsl4o.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9divsl4o.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val p = new Array[Long](n)\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var temp = 0\n        var temp2 = 0\n\
    \        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n       \
    \ var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9\
    \ = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    \
    \    var temp94 = 0\n        var temp95 = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmputy0_kea.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmputy0_kea.scala:117:5 --------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var min = 0\n        var max = arr.length\n\
    \        while (i < max && j < max) {\n            if (arr(i) == arr(j)) {\n \
    \               i += 1\n                j += 1\n                k += 1\n     \
    \           if (k == 2) {\n                    min = Math.min(min, i - j)\n  \
    \              }\n            } else {\n                i += 1\n             \
    \   j += 1\n                k = 0\n            }\n        }\n        min\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpnm632k8q.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnm632k8q.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.head\n        val max = arr.last\n        val mid = len /\
    \ 2\n        val midVal = arr.take(mid).toList\n        val midValReverse = arr.drop(mid).toList\n\
    \        val midValReverseReverse = arr.take(mid).toList.reverse\n        val\
    \ midValReverseReverseReverse = arr.drop(mid).toList.reverse.reverse\n       \
    \ val midValReverseReverseReverseReverse = arr.take(mid).toList.reverse.reverse.reverse\n\
    \        val midValReverseReverseReverseReverseReverse = arr.drop(mid).toList.reverse.reverse.reverse.reverse\n\
    \        val midValReverseReverseReverseReverseReverseReverse = arr.take(mid).toList.reverse.reverse.reverse.reverse.reverse\n\
    \        val midValReverseReverseReverseReverseReverseReverseReverse = arr.drop(mid).toList.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \        val midValReverseReverseReverseReverseReverseReverseReverse = arr.take(mid).toList.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \        val midValReverseReverseReverseReverseReverseReverseReverseReverse =\
    \ arr.drop(mid).toList.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \        val midValReverseReverseReverseReverseReverseReverseReverseReverseReverse\
    \ = arr.take(mid).toList.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx5dez2v0.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmidValReverseReverseReverseReverseReverseReverseReverse\e\
    [0m = arr.take(mid).toList.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmidValReverseReverseReverseReverseReverseReverseReverse is\
    \ already defined as \e[33mvalue\e[0m \e[35mmidValReverseReverseReverseReverseReverseReverseReverse\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpx5dez2v0.scala:15:18 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m\
    \   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpx5dez2v0.scala:31:5 ---------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        var flag = 0\n    \
    \    var temp = 0\n        var count = 0\n        var flag = 0\n        var temp\
    \ = 0\n        var count = 0\n        var flag = 0\n        var temp = 0\n   \
    \     var count = 0\n        var flag = 0\n        var temp = 0\n        var count\
    \ = 0\n        var flag = 0\n        var temp = 0\n        var count = 0\n   \
    \     var flag = 0\n        var temp = 0\n        var count = 0\n        var flag\
    \ = 0\n        var temp = 0\n        var count = 0\n        var flag = 0\n   \
    \     var temp = 0\n        var count = 0\n        var flag = 0\n        var temp\
    \ = 0\n        var count = 0\n        var flag = 0\n        var temp = 0\n   \
    \     var count = 0\n        var flag = 0\n        var temp = 0\n        var count\
    \ = 0\n        var flag = 0\n        var temp = 0\n        var count = 0\n   \
    \     var flag = 0\n        var temp = 0\n        var count = 0\n        var flag\
    \ = 0\n        var temp = 0\n        var count = 0\n        var flag = 0\n   \
    \     var temp = 0\n        var count = 0\n        var flag = 0\n        var temp\
    \ = 0\n        var count = 0\n        var flag = 0\n        var temp = 0\n   \
    \     var count = 0\n        var flag = 0\n        var temp = 0\n        var count\
    \ = 0\n        var flag = 0\n        var temp = 0\n        var count = 0\n   \
    \     var flag = 0\n        var temp = 0\n        var count = 0\n        var flag\
    \ = 0\n        var temp = 0\n        var count = 0\n        var flag = 0\n   \
    \     var temp = 0\n        var count = 0\n        var flag = 0\n        var temp\
    \ = 0\n        var count = 0\n        var flag = 0\n        var temp = 0\n   \
    \     var count = 0\n        var flag = 0\n        var temp = 0\n        var count\
    \ = 0\n        var flag = 0\n        var temp = 0\n        var count = 0\n   \
    \     var flag = 0\n        var temp = 0\n        var count = 0\n        var flag\
    \ = 0\n        var temp = 0\n        var count = 0\n        var flag = 0\n   \
    \     var temp = 0\n        var count = 0\n        var flag = 0\n        var temp\
    \ = 0\n        var count = 0\n        var flag = 0\n        var temp = 0\n   \
    \     var count = 0\n        var flag = 0\n        var temp = 0\n        var count\
    \ = 0\n        var flag = 0\n        var temp = 0\n        var count = 0\n   \
    \     var flag = 0\n        var temp = 0\n        var count = 0\n        var flag\
    \ = 0\n        var temp = 0\n        var count = 0\n        var flag = 0\n   \
    \     var temp = 0\n        var count = 0\n        var flag = 0\n        var temp\
    \ = 0\n        var count = 0\n        var flag = 0\n        var temp = 0\n   \
    \     var count = 0\n        var flag = 0\n        var temp = 0\n        var count\
    \ = 0\n        var flag = 0\n        var temp = 0\n        var count = 0\n   \
    \     var flag = 0\n        var temp = 0\n        var count = 0\n        var flag\
    \ = 0\n        var temp = 0\n        var count = 0\n        var flag = 0\n   \
    \     var temp = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu2a39ypt.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m \e[36mflag\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mflag is already\
    \ defined as \e[33mvariable\e[0m \e[35mflag\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu2a39ypt.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mtemp\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtemp is already defined as \e[33mvariable\e[0m \e[35mtemp\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu2a39ypt.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mvar\e[0m \e[36mcount\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcount is already defined\
    \ as \e[33mvariable\e[0m \e[35mcount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu2a39ypt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36mflag\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mflag is already\
    \ defined as \e[33mvariable\e[0m \e[35mflag\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu2a39ypt.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mtemp\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtemp is already defined as \e[33mvariable\e[0m \e[35mtemp\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu2a39ypt.scala:31:12 ----------------"
  stdout: ''
  timestamp: 1659805144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndex2\
    \ = len\n        val minChangeIndex3 = len\n        val minChangeIndex4 = len\n\
    \        val minChangeIndex5 = len\n        val minChangeIndex6 = len\n      \
    \  val minChangeIndex7 = len\n        val minChangeIndex8 = len\n        val minChangeIndex9\
    \ = len\n        val minChangeIndex10 = len\n        val minChangeIndex11 = len\n\
    \        val minChangeIndex12 = len\n        val minChangeIndex13 = len\n    \
    \    val minChangeIndex14 = len\n        val minChangeIndex15 = len\n        val\
    \ minChangeIndex16 = len\n        val minChangeIndex17 = len\n        val minChangeIndex18\
    \ = len\n        val minChangeIndex19 = len\n        val minChangeIndex20 = len\n\
    \        val minChangeIndex21 = len\n        val minChangeIndex22 = len\n    \
    \    val minChangeIndex23 = len\n        val minChangeIndex24 = len\n        val\
    \ minChangeIndex25 = len\n        val minChangeIndex26 = len\n        val minChangeIndex27\
    \ = len\n        val minChangeIndex28 = len\n        val minChangeIndex29 = len\n\
    \        val minChangeIndex30 = len\n        val minChangeIndex31 = len\n    \
    \    val minChangeIndex32 = len\n        val minChangeIndex33 = len\n        val\
    \ minChangeIndex34 = len\n        val minChangeIndex35 = len\n        val minChangeIndex36\
    \ = len\n        val minChangeIndex37 = len\n        val minChangeIndex38 = len\n\
    \        val minChangeIndex39 = len\n        val minChangeIndex40 = len\n    \
    \    val minChangeIndex41 = len\n        val minChangeIndex42 = len\n        val\
    \ minChangeIndex43 = len\n        val minChangeIndex44 = len\n        val minChangeIndex45\
    \ = len\n        val minChangeIndex46 = len\n        val minChangeIndex47 = len\n\
    \        val minChangeIndex48 = len\n        val minChangeIndex49 = len\n    \
    \    val minChangeIndex50 = len\n        val minChangeIndex51 = len\n        val\
    \ minChangeIndex52 = len\n        val minChangeIndex53 = len\n        val minChangeIndex54\
    \ = len\n        val minChangeIndex55 = len\n        val minChangeIndex56 = len\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw_73y4fv.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpw_73y4fv.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexLen\
    \ = 0\n        val minChangeIndexLen2 = len\n        val minChangeIndexLen3 =\
    \ len\n        val minChangeIndexLen4 = len\n        val minChangeIndexLen5 =\
    \ len\n        val minChangeIndexLen6 = len\n        val minChangeIndexLen7 =\
    \ len\n        val minChangeIndexLen8 = len\n        val minChangeIndexLen9 =\
    \ len\n        val minChangeIndexLen10 = len\n        val minChangeIndexLen11\
    \ = len\n        val minChangeIndexLen12 = len\n        val minChangeIndexLen13\
    \ = len\n        val minChangeIndexLen14 = len\n        val minChangeIndexLen15\
    \ = len\n        val minChangeIndexLen16 = len\n        val minChangeIndexLen17\
    \ = len\n        val minChangeIndexLen18 = len\n        val minChangeIndexLen19\
    \ = len\n        val minChangeIndexLen20 = len\n        val minChangeIndexLen21\
    \ = len\n        val minChangeIndexLen22 = len\n        val minChangeIndexLen23\
    \ = len\n        val minChangeIndexLen24 = len\n        val minChangeIndexLen25\
    \ = len\n        val minChangeIndexLen26 = len\n        val minChangeIndexLen27\
    \ = len\n        val minChangeIndexLen28 = len\n        val minChangeIndexLen29\
    \ = len\n        val minChangeIndexLen30 = len\n        val minChangeIndexLen31\
    \ = len\n        val minChangeIndexLen32 = len\n        val minChangeIndexLen33\
    \ = len\n        val minChangeIndexLen34 = len\n        val minChangeIndexLen35\
    \ = len\n        val minChangeIndexLen36 = len\n        val minChangeIndexLen37\
    \ = len\n        val minChangeIndexLen38 = len\n        val minChangeIndexLen39\
    \ = len\n        val minChangeIndexLen40 = len\n        val minChangeIndexLen41\
    \ = len\n        val minChangeIndexLen42 = len\n        val minChangeIndexLen43\
    \ = len\n        val minChangeIndexLen44 = len\n        val minChangeIndexLen45\
    \ = len\n        val minChangeIndexLen46 = len\n        val minChangeIndexLen47\
    \ = len\n        val minChangeIndexLen48 = len\n        val minChangeIndexLen49\
    \ = len\n        val minChangeIndexLen50 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6hdxqpr2.scala:68:33 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexLen50\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6hdxqpr2.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6hdxqpr2.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while(i\
    \ < len) {\n            while(j < len) {\n                if(arr(i) == arr(j))\
    \ {\n                    j++\n                }\n                else {\n    \
    \                minChange = math.min(minChange, j-i)\n                    j =\
    \ 0\n                }\n            }\n            i++\n            j = 0\n  \
    \      }\n        minChange\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpebxymkid.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpebxymkid.scala:31:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpebxymkid.scala:15:18 ---------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpebxymkid.scala:26:30 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    minChange = math.min(minChange, j-i)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val minChange\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpebxymkid.scala:30:13 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            i++\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m            value ++ is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1659805148
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = -1\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val\
    \ minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val\
    \ minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val\
    \ minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val\
    \ minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val\
    \ minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex\
    \ = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x\
    \ => x == arr[len-1])\n        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n\
    \        val minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val\
    \ minChangeIndex = arr.indexWhere(x => x == arr[len-1])\n        val minChangeIndex\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmd19ni4n.scala:49:28 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmd19ni4n.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.indexWhere(\e\
    [36mx\e[0m => x == arr[\e[35mlen-\e[31m1\e[0m])\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmd19ni4n.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.indexWhere(\e\
    [36mx\e[0m => x == arr[\e[35mlen-\e[31m1\e[0m])\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmd19ni4n.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = arr.indexWhere(\e\
    [36mx\e[0m => x == arr[\e[35mlen-\e[31m1\e[0m])\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmd19ni4n.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e["
  stdout: ''
  timestamp: 1659805149
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while(i < n && j < n) {\n            if(arr(i) == arr(j)) {\n       \
    \         i += 1\n                j += 1\n                k += 1\n           \
    \     if(k == m) {\n                    min = k\n                }\n         \
    \   } else {\n                i += 1\n                j += 1\n               \
    \ k = 0\n            }\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgx68pzvi.scala:38)\n\tat Problem.main(tmpgx68pzvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805152
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        var min = 0\n        var max\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp\
    \ = 0\n        var count = 0\n        var tempCount = 0\n        var tempMin =\
    \ 0\n        var tempMax = 0\n        var tempMinIndex = 0\n        var tempMaxIndex\
    \ = 0\n        var tempMinIndex2 = 0\n        var tempMaxIndex2 = 0\n        var\
    \ tempMinIndex3 = 0\n        var tempMaxIndex3 = 0\n        var tempMinIndex4\
    \ = 0\n        var tempMaxIndex4 = 0\n        var tempMinIndex5 = 0\n        var\
    \ tempMaxIndex5 = 0\n        var tempMinIndex6 = 0\n        var tempMaxIndex6\
    \ = 0\n        var tempMinIndex7 = 0\n        var tempMaxIndex7 = 0\n        var\
    \ tempMinIndex8 = 0\n        var tempMaxIndex8 = 0\n        var tempMinIndex9\
    \ = 0\n        var tempMaxIndex9 = 0\n        var tempMinIndex10 = 0\n       \
    \ var tempMaxIndex10 = 0\n        var tempMinIndex11 = 0\n        var tempMaxIndex11\
    \ = 0\n        var tempMinIndex12 = 0\n        var tempMaxIndex12 = 0\n      \
    \  var tempMinIndex13 = 0\n        var tempMaxIndex13 = 0\n        var tempMinIndex14\
    \ = 0\n        var tempMaxIndex14 = 0\n        var tempMinIndex15 = 0\n      \
    \  var tempMaxIndex15 = 0\n        var tempMinIndex16 = 0\n        var tempMaxIndex16\
    \ = 0\n        var tempMinIndex17 = 0\n        var tempMaxIndex17 = 0\n      \
    \  var tempMinIndex18 = 0\n        var tempMaxIndex18 = 0\n        var tempMinIndex19\
    \ = 0\n        var tempMaxIndex19 = 0\n        var tempMinIndex20 = 0\n      \
    \  var tempMaxIndex20 = 0\n        var tempMinIndex21 = 0\n        var tempMaxIndex21\
    \ = 0\n        var tempMinIndex22 = 0\n        var tempMaxIndex22 = 0\n      \
    \  var tempMinIndex23 = 0\n        var tempMaxIndex23 = 0\n        var tempMinIndex24\
    \ = 0\n        var tempMaxIndex24 = 0\n        var tempMinIndex25 = 0\n      \
    \  var tempMaxIndex25 = 0\n        var tempMinIndex26 = 0\n        var tempMaxIndex26\
    \ = 0\n        var tempMinIndex27 = 0\n        var tempMaxIndex27 = 0\n      \
    \  var tempMinIndex28 = 0\n        var tempMaxIndex28 = 0\n        var tempMinIndex29\
    \ = 0\n        var tempMaxIndex29 = 0\n        var tempMinIndex30 = 0\n      \
    \  var tempMaxIndex30 = 0\n        var tempMinIndex31 = 0\n        var tempMaxIndex31\
    \ = 0\n        var tempMinIndex32 = 0\n        var tempMaxIndex32 = 0\n      \
    \  var tempMinIndex33 = 0\n        var tempMaxIndex33 = 0\n        var tempMinIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo3f0ejy9.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo3f0ejy9.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo3f0ejy9.scala:93:5\
    \ ---------------------\e[0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var max = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var count = 0\n        while(i\
    \ < len) {\n            max = arr(i)\n            while(j < len) {\n         \
    \       if(arr(i) == arr(j)) {\n                    temp = arr(i)\n          \
    \          arr(i) = arr(j)\n                    arr(j) = temp\n              \
    \      j++\n                    k++\n                }\n                else if(arr(i)\
    \ < arr(j)) {\n                    temp = arr(i)\n                    arr(i) =\
    \ arr(j)\n                    arr(j) = temp\n                    j++\n       \
    \         }\n                else {\n                    temp = arr(j)\n     \
    \               arr(j) = arr(i)\n                    arr(i) = temp\n         \
    \           i++\n                }\n            }\n            min = arr(i)\n\
    \            while(j < len) {\n                if(arr(i) == arr(j)) {\n      \
    \              temp = arr(i)\n                    arr(i) = arr(j)\n          \
    \          arr(j) = temp\n                    j++\n                    k++\n \
    \               }\n                else if(arr(i) < arr(j)) {\n              \
    \      temp = arr(i)\n                    arr(i) = arr(j)\n                  \
    \  arr(j) = temp\n                    j++\n                }\n               \
    \ else {\n                    temp = arr(j)\n                    arr(j) = arr(i)\n\
    \                    arr(i) = temp\n                    i++\n                }\n\
    \            }\n            count += 1\n            i += 1\n        }\n      \
    \  if(min == 0) {\n            return 0\n        }\n        else {\n         \
    \   return count\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphjluuk2j.scala:32:23 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmphjluuk2j.scala:38:23 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphjluuk2j.scala:44:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                    i++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmphjluuk2j.scala:54:23 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m                    k++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmphjluuk2j.scala:60:23 ---------------------------\e[0m\e[0m\n\e[31m60\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphjluuk2j.scala:66:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m66 |\e[0m                    i++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1659805155
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var change\
    \ = 0\n        var changeCount = 0\n        while (i < len) {\n            while\
    \ (j < len) {\n                if (arr(i) == arr(j)) {\n                    j++\n\
    \                } else {\n                    change = arr(i) - arr(j)\n    \
    \                if (change < minChange) {\n                        minChange\
    \ = change\n                        changeCount = 1\n                    } else\
    \ if (change == minChange) {\n                        changeCount += 1\n     \
    \               }\n                    j++\n                }\n            }\n\
    \            i += 1\n            j += 1\n        }\n        minChange\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpk0x8nenb.scala:25:23 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpk0x8nenb.scala:34:23 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk0x8nenb.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpk0x8nenb.scala:29:34\
    \ -----------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                   \
    \     minChange = change\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val minChange\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805150
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = len\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var temp = 0\n        var count = 0\n        while\
    \ (i < len) {\n            while (j < len) {\n                if (arr(i) == arr(j))\
    \ {\n                    temp = arr(i)\n                    arr(i) = arr(j)\n\
    \                    arr(j) = temp\n                    count += 1\n         \
    \       }\n                j += 1\n            }\n            i += 1\n       \
    \     j += 1\n        }\n        if (count < min) {\n            min = count\n\
    \        }\n        if (count > max) {\n            max = count\n        }\n \
    \       if (min == max) {\n            return 0\n        }\n        if (min >\
    \ max) {\n            max = min\n        }\n        val ans = min - max\n    \
    \    return ans.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsnxuwvau.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpsnxuwvau.scala:38:16 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            min = count\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val min\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpsnxuwvau.scala:41:16 -----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            max = count\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val max\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpsnxuwvau.scala:47:16 -----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            max = min\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val max\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805149
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        var count = 0\n        var i = 0\n        var j = 0\n\
    \        while (i < n && j < n) {\n            if (arr(i) == arr(j)) {\n     \
    \           count += 1\n                i += 1\n                j += 1\n     \
    \       } else if (arr(i) < arr(j)) {\n                count += 1\n          \
    \      i += 1\n            } else {\n                count += 1\n            \
    \    j += 1\n            }\n        }\n        if (count == 0) {\n           \
    \ return 0\n        }\n        if (count == 1) {\n            return 1\n     \
    \   }\n        if (count == 2) {\n            return 2\n        }\n        if\
    \ (count == 3) {\n            return 3\n        }\n        if (count == 4) {\n\
    \            return 4\n        }\n        if (count == 5) {\n            return\
    \ 5\n        }\n        if (count == 6) {\n            return 6\n        }\n \
    \       if (count == 7) {\n            return 7\n        }\n        if (count\
    \ == 8) {\n            return 8\n        }\n        if (count == 9) {\n      \
    \      return 9\n        }\n        if (count == 10) {\n            return 10\n\
    \        }\n        if (count == 11) {\n            return 11\n        }\n   \
    \     if (count == 12) {\n            return 12\n        }\n        if (count\
    \ == 13) {\n            return 13\n        }\n        if (count == 14) {\n   \
    \         return 14\n        }\n        if (count == 15) {\n            return\
    \ 15\n        }\n        if (count == 16) {\n            return 16\n        }\n\
    \        if (count == 17) {\n            return 17\n        }\n        if (count\
    \ == 18) {\n            return 18\n        }\n        if (count == 19) {\n   \
    \         return 19\n        }\n        if (count == 20) {\n            return\
    \ 20\n        }\n        if (count == 21) {\n            return 21\n        }\n\
    \        if (count == 22) {\n            return 22\n        }\n        if (count\
    \ == 23) {\n            return 23\n        }\n        if (count == 24) {\n   \
    \         return 24\n        }\n        if (count == 25) {\n            return\
    \ 25\n        }\n        if (count == 26) {\n            return 26\n        }\n\
    \        if (count == 27) {\n            return 27\n        }\n        if (count\
    \ == 28) {\n            return 28\n        }\n        if (count == 29) {\n   \
    \         return 29\n        }\n        if (count == 30) {\n            return\
    \ 30\n        }\n        if (count == 31) {\n            return 31\n        }\n\
    \        if (count == 32) {\n            return 32\n        }\n        if (count\
    \ == 33) {\n            return 33\n        }\n        if (count == 34) {\n   \
    \         return 34\n        }\n        if (count == 35) {\n            return\
    \ 35\n        }\n        if (count == 36) {\n            return 36\n        }\n\
    \        if (count == 37) {\n            return 37\n        }\n        if (count\
    \ == 38) {\n            return 38\n        }\n        if (count == 39) {\n   \
    \         return 39\n        }\n        if (count == 40) {\n            return\
    \ 40\n        }\n        if (count == 41) {\n            return 41\n        }\n\
    \        if (count == 42) {\n            return 42\n        }\n        if (count\
    \ == 43) {\n            return \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1zl7tsky.scala:178:0 ---------------------------\e\
    [0m\e[0m\n\e[31m178 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1zl7tsky.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1zl7tsky.scala:164:12\
    \ -------------------\e[0m\e[0m\n\e[31m164 |\e[0m            \e[33mreturn\e[0m\
    \ \n\e[31m\e[31m    |\e[0m            ^^^^^^\e[0m\n\e[31m    |\e[0m          \
    \  Found:    Unit\n\e[31m    |\e[0m            Required: Long\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1zl7tsky.scala:177:1 --------------------\e\
    [0m\e[0m\n\e[31m177 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e[0m\n\e[31m    |\e[0m Found:\
    \    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp1zl7tsky.scala:166:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m166 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659805158
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n \
    \       while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ == arr(j)) {\n                    j++\n                }\n                else\
    \ {\n                    if(arr(i) < arr(j)) {\n                        min =\
    \ arr(i)\n                        k = i\n                    }\n             \
    \       else {\n                        min = arr(j)\n                       \
    \ k = j\n                    }\n                    j++\n                }\n \
    \           }\n            i++\n            j++\n        }\n        min\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpay_x6xyc.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpay_x6xyc.scala:35:23 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpay_x6xyc.scala:39:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            j++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpay_x6xyc.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpay_x6xyc.scala:38:13 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            i++\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m\
    \            value ++ is not a member of Int\n5 errors found\n"
  stdout: ''
  timestamp: 1659805156
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexLen\
    \ = 0\n        val minChangeIndexLen2 = 0\n        val minChangeIndexLen3 = 0\n\
    \        val minChangeIndexLen4 = 0\n        val minChangeIndexLen5 = 0\n    \
    \    val minChangeIndexLen6 = 0\n        val minChangeIndexLen7 = 0\n        val\
    \ minChangeIndexLen8 = 0\n        val minChangeIndexLen9 = 0\n        val minChangeIndexLen10\
    \ = 0\n        val minChangeIndexLen11 = 0\n        val minChangeIndexLen12 =\
    \ 0\n        val minChangeIndexLen13 = 0\n        val minChangeIndexLen14 = 0\n\
    \        val minChangeIndexLen15 = 0\n        val minChangeIndexLen16 = 0\n  \
    \      val minChangeIndexLen17 = 0\n        val minChangeIndexLen18 = 0\n    \
    \    val minChangeIndexLen19 = 0\n        val minChangeIndexLen20 = 0\n      \
    \  val minChangeIndexLen21 = 0\n        val minChangeIndexLen22 = 0\n        val\
    \ minChangeIndexLen23 = 0\n        val minChangeIndexLen24 = 0\n        val minChangeIndexLen25\
    \ = 0\n        val minChangeIndexLen26 = 0\n        val minChangeIndexLen27 =\
    \ 0\n        val minChangeIndexLen28 = 0\n        val minChangeIndexLen29 = 0\n\
    \        val minChangeIndexLen30 = 0\n        val minChangeIndexLen31 = 0\n  \
    \      val minChangeIndexLen32 = 0\n        val minChangeIndexLen33 = 0\n    \
    \    val minChangeIndexLen34 = 0\n        val minChangeIndexLen35 = 0\n      \
    \  val minChangeIndexLen36 = 0\n        val minChangeIndexLen37 = 0\n        val\
    \ minChangeIndexLen38 = 0\n        val minChangeIndexLen39 = 0\n        val minChangeIndexLen40\
    \ = 0\n        val minChangeIndexLen41 = 0\n        val minChangeIndexLen42 =\
    \ 0\n        val minChangeIndexLen43 = 0\n        val minChangeIndexLen44 = 0\n\
    \        val minChangeIndexLen45 = 0\n        val minChangeIndexLen46 = 0\n  \
    \      val minChangeIndexLen47 = 0\n        val minChangeIndexLen48 = 0\n    \
    \    val minChangeIndexLen49 = 0\n        val minChangeIndexLen50 = 0\n      \
    \  val minChangeIndexLen51 = 0\n        val minChangeIndexLen52 = 0\n        val\
    \ minChangeIndexLen53 = 0\n        val minChangeIndexLen54 = 0\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5yeoms6z.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5yeoms6z.scala:74:5 ---------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805157
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        var count = 0\n        while(i < len) {\n     \
    \       while(j < len) {\n                if(arr(i) == arr(j)) {\n           \
    \         temp = arr(i)\n                    arr(i) = arr(j)\n               \
    \     arr(j) = temp\n                    k = j\n                    j++\n    \
    \            }\n                else {\n                    j++\n            \
    \    }\n            }\n            i = k\n            k = j\n            j = 0\n\
    \            count += 1\n        }\n        if(count < min) {\n            min\
    \ = count\n        }\n        min\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyew28h80.scala:30:23 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpyew28h80.scala:33:23 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyew28h80.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpyew28h80.scala:42:16\
    \ -----------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            min = count\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Reassignment to val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805151
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var temp = 0\n        var count = 0\n        while(i < len) {\n\
    \            while(j < len) {\n                if(arr(i) == arr(j)) {\n      \
    \              temp = arr(i)\n                    arr(i) = arr(j)\n          \
    \          arr(j) = temp\n                    count += 1\n                   \
    \ j++\n                }\n                else {\n                    j++\n  \
    \              }\n            }\n            i = i + 1\n            j = j - 1\n\
    \            k = k + 1\n        }\n        if(count < minChange) {\n         \
    \   minChange = count\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp231fkabf.scala:30:23 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp231fkabf.scala:33:23 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp231fkabf.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp231fkabf.scala:41:22\
    \ -----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            minChange\
    \ = count\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805152
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexSet\
    \ = Set[Long]()\n        val minChangeIndexSet2 = Set[Long]()\n        val minChangeIndexSet3\
    \ = Set[Long]()\n        val minChangeIndexSet4 = Set[Long]()\n        val minChangeIndexSet5\
    \ = Set[Long]()\n        val minChangeIndexSet6 = Set[Long]()\n        val minChangeIndexSet7\
    \ = Set[Long]()\n        val minChangeIndexSet8 = Set[Long]()\n        val minChangeIndexSet9\
    \ = Set[Long]()\n        val minChangeIndexSet10 = Set[Long]()\n        val minChangeIndexSet11\
    \ = Set[Long]()\n        val minChangeIndexSet12 = Set[Long]()\n        val minChangeIndexSet13\
    \ = Set[Long]()\n        val minChangeIndexSet14 = Set[Long]()\n        val minChangeIndexSet15\
    \ = Set[Long]()\n        val minChangeIndexSet16 = Set[Long]()\n        val minChangeIndexSet17\
    \ = Set[Long]()\n        val minChangeIndexSet18 = Set[Long]()\n        val minChangeIndexSet19\
    \ = Set[Long]()\n        val minChangeIndexSet20 = Set[Long]()\n        val minChangeIndexSet21\
    \ = Set[Long]()\n        val minChangeIndexSet22 = Set[Long]()\n        val minChangeIndexSet23\
    \ = Set[Long]()\n        val minChangeIndexSet24 = Set[Long]()\n        val minChangeIndexSet25\
    \ = Set[Long]()\n        val minChangeIndexSet26 = Set[Long]()\n        val minChangeIndexSet27\
    \ = Set[Long]()\n        val minChangeIndexSet28 = Set[Long]()\n        val minChangeIndexSet29\
    \ = Set[Long]()\n        val minChangeIndexSet30 = Set[Long]()\n        val minChangeIndexSet31\
    \ = Set[Long]()\n        val minChangeIndexSet32 = Set[Long]()\n        val minChangeIndexSet33\
    \ = Set[Long]()\n        val minChangeIndexSet34 = Set[Long]()\n        val minChangeIndexSet35\
    \ = Set[Long]()\n        val minChangeIndexSet36\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdje_aa_z.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdje_aa_z.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdje_aa_z.scala:55:5\
    \ ---------------------\e[0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805158
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.size\n        val n = arr.size\n        val\
    \ arr = arr.toList\n        val len = arr.size\n        val arr2 = arr.toList\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n\
    \        var m1 = arr.size\n        var m2 = arr.size\n        var m3 = arr.size\n\
    \        var m4 = arr.size\n        var m5 = arr.size\n        var m6 = arr.size\n\
    \        var m7 = arr.size\n        var m8 = arr.size\n        var m9 = arr.size\n\
    \        var m10 = arr.size\n        var m11 = arr.size\n        var m12 = arr.size\n\
    \        var m13 = arr.size\n        var m14 = arr.size\n        var m15 = arr.size\n\
    \        var m16 = arr.size\n        var m17 = arr.size\n        var m18 = arr.size\n\
    \        var m19 = arr.size\n        var m20 = arr.size\n        var m21 = arr.size\n\
    \        var m22 = arr.size\n        var m23 = arr.size\n        var m24 = arr.size\n\
    \        var m25 = arr.size\n        var m26 = arr.size\n        var m27 = arr.size\n\
    \        var m28 = arr.size\n        var m29 = arr.size\n        var m30 = arr.size\n\
    \        var m31 = arr.size\n        var m32 = arr.size\n        var m33 = arr.size\n\
    \        var m34 = arr.size\n        var m35 = arr.size\n        var m36 = arr.size\n\
    \        var m37 = arr.size\n        var m38 = arr.size\n        var m39 = arr.size\n\
    \        var m40 = arr.size\n        var m41 = arr.size\n        var m42 = arr.size\n\
    \        var m43 = arr.size\n        var m44 = arr.size\n        var m45 = arr.size\n\
    \        var m46 = arr.size\n        var m47 = arr.size\n        var m48 = arr.size\n\
    \        var m49 = arr.size\n        var m50 = arr.size\n        var m51 = arr.size\n\
    \        var m52 = arr.size\n        var m53 = arr.size\n        var m54 = arr.size\n\
    \        var m55 = arr.size\n        var m56 = arr.size\n        var m57 = arr.size\n\
    \        var m58 = arr.size\n        var m59 = arr.size\n        var m60 = arr.size\n\
    \        var m61 = arr.size\n        var m62 = arr.size\n        var m63 = arr.size\n\
    \        var m64 = arr.size\n        var m65 = arr.size\n        var m66 = arr.size\n\
    \        var m67 = arr.size\n        var m68 = arr.size\n        var m\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps3m3pac4.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps3m3pac4.scala:17:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps3m3pac4.scala:93:5\
    \ ---------------------\e[0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805158
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = arr.take(len/2).foldLeft(0){ (acc, x) => if (x == arr[len/2\
    \ - acc]) acc else acc }\n        val maxChange = arr.take(len/2).foldLeft(0){\
    \ (acc, x) => if (x == arr[len/2 + acc]) acc else acc }\n        val change =\
    \ minChange + maxChange\n        val change2 = arr.take(len/2).foldLeft(0){ (acc,\
    \ x) => if (x == arr[len/2 - acc]) acc else acc }\n        val change3 = arr.take(len/2).foldLeft(0){\
    \ (acc, x) => if (x == arr[len/2 + acc]) acc else acc }\n        val change4 =\
    \ arr.take(len/2).foldLeft(0){ (acc, x) => if (x == arr[len/2 - acc]) acc else\
    \ acc }\n        val change5 = arr.take(len/2).foldLeft(0){ (acc, x) => if (x\
    \ == arr[len/2 + acc]) acc else acc }\n        val change6 = arr.take(len/2).foldLeft(0){\
    \ (acc, x) => if (x == arr[len/2 - acc]) acc else acc }\n        val change7 =\
    \ arr.take(len/2).foldLeft(0){ (acc, x) => if (x == arr[len/2 + acc]) acc else\
    \ acc }\n        val change8 = arr.take(len/2).foldLeft(0){ (acc, x) => if (x\
    \ == arr[len/2 - acc]) acc else acc }\n        val change9 = arr.take(len/2).foldLeft(0){\
    \ (acc, x) => if (x == arr[len/2 + acc]) acc else acc }\n        val change10\
    \ = arr.take(len/2).foldLeft(0){ (acc, x) => if (x == arr[len/2 - acc]) acc else\
    \ acc }\n        val change11 = arr.take(len/2).foldLeft(0){ (acc, x) => if (x\
    \ == arr[len/2 + acc]) acc else acc }\n        val change12 = arr.take(len/2).foldLeft(0){\
    \ (acc, x) => if (x == arr[len/2 - acc]) acc else acc }\n        val change13\
    \ = arr.take(len/2).foldLeft(0){ (acc, x) => if (x == arr[len/2 + acc]) acc else\
    \ acc }\n        val change14 = arr.take(len/2).foldLeft(0){ (acc, x) => if (x\
    \ == arr[\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1216v6cv.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp1216v6cv.scala:46:0 ----------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1216v6cv.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1216v6cv.scala:45:1 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp1216v6cv.scala:34:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m34 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805161
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.take(n/2).length\n\
    \        val k = arr.take(m).length\n        val l = arr.take(k).length\n    \
    \    val r = arr.length - n - m - k\n        val max = (n*(n+1)/2 - m*m - k*k\
    \ + l*l - r*r)/2\n        val min = (n*(n+1)/2 - m*m - k*k + l*l - r*r)/2\n  \
    \      if (max > min) {\n            min\n        } else {\n            max\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2mv1p7qw.scala:29)\n\tat Problem.main(tmp2mv1p7qw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805162
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndex2\
    \ = len\n        val minChangeIndex3 = len\n        val minChangeIndex4 = len\n\
    \        val minChangeIndex5 = len\n        val minChangeIndex6 = len\n      \
    \  val minChangeIndex7 = len\n        val minChangeIndex8 = len\n        val minChangeIndex9\
    \ = len\n        val minChangeIndex10 = len\n        val minChangeIndex11 = len\n\
    \        val minChangeIndex12 = len\n        val minChangeIndex13 = len\n    \
    \    val minChangeIndex14 = len\n        val minChangeIndex15 = len\n        val\
    \ minChangeIndex16 = len\n        val minChangeIndex17 = len\n        val minChangeIndex18\
    \ = len\n        val minChangeIndex19 = len\n        val minChangeIndex20 = len\n\
    \        val minChangeIndex21 = len\n        val minChangeIndex22 = len\n    \
    \    val minChangeIndex23 = len\n        val minChangeIndex24 = len\n        val\
    \ minChangeIndex25 = len\n        val minChangeIndex26 = len\n        val minChangeIndex27\
    \ = len\n        val minChangeIndex28 = len\n        val minChangeIndex29 = len\n\
    \        val minChangeIndex30 = len\n        val minChangeIndex31 = len\n    \
    \    val minChangeIndex32 = len\n        val minChangeIndex33 = len\n        val\
    \ minChangeIndex34 = len\n        val minChangeIndex35 = len\n        val minChangeIndex36\
    \ = len\n        val minChangeIndex37 = len\n        val minChangeIndex38 = len\n\
    \        val minChangeIndex39 = len\n        val minChangeIndex40 = len\n    \
    \    val minChangeIndex41 = len\n        val minChangeIndex42 = len\n        val\
    \ minChangeIndex43 = len\n        val minChangeIndex44 = len\n        val minChangeIndex45\
    \ = len\n        val minChangeIndex46 = len\n        val minChangeIndex47 = len\n\
    \        val minChangeIndex48 = len\n        val minChangeIndex49 = len\n    \
    \    val minChangeIndex50 = len\n        val minChangeIndex51 = len\n        val\
    \ minChangeIndex52 = len\n        val minChangeIndex53 = len\n        val minChangeIndex54\
    \ = len\n        val minChangeIndex55 = len\n        val minChangeIndex56 = len\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw_73y4fv.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpw_73y4fv.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val minChange = len\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n   \
    \     while (i < len) {\n            val curr = arr(i)\n            val next =\
    \ (len - i) - arr(len - i - 1)\n            val change = next - curr\n       \
    \     if (change < minChange) {\n                minChange = change\n        \
    \        minChangeIndex = i\n            }\n            i += 1\n        }\n  \
    \      while (j < len) {\n            val curr = arr(j)\n            val next\
    \ = (len - j) - arr(len - j - 1)\n            val change = next - curr\n     \
    \       if (change < minChange) {\n                minChange = change\n      \
    \          minChangeIndex = j\n            }\n            j += 1\n        }\n\
    \        while (k < len) {\n            val curr = arr(k)\n            val next\
    \ = (len - k) - arr(len - k - 1)\n            val change = next - curr\n     \
    \       if (change < minChange) {\n                minChange = change\n      \
    \          minChangeIndex = k\n            }\n            k += 1\n        }\n\
    \        minChangeIndex\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmperfnwcfy.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmperfnwcfy.scala:28:26 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                minChange = change\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmperfnwcfy.scala:38:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                minChange\
    \ = change\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmperfnwcfy.scala:48:26 -----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                minChange = change\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805155
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val n = arr.size\n       \
    \ val m = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.last\n\
    \        val arr = arr.dropRight(arr.size - 1)\n        val m = arr.last\n   \
    \     val arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val\
    \ arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size\
    \ - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size - 1)\n \
    \       val m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val\
    \ m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n\
    \        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val\
    \ arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size\
    \ - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size - 1)\n \
    \       val m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val\
    \ m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n\
    \        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val\
    \ arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size\
    \ - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size - 1)\n \
    \       val m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val\
    \ m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n\
    \        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val\
    \ arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size\
    \ - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size - 1)\n \
    \       val m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val\
    \ m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n\
    \        val arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val\
    \ arr = arr.take(arr.size - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size\
    \ - 1)\n        val m = arr.last\n        val arr = arr.take(arr.size - 1)\n \
    \       val m = arr.last\n        val arr = arr.take(arr.size - 1)\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpg7teq1qc.scala:79:11 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpg7teq1qc.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg7teq1qc.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.last\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpg7teq1qc.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(arr.size - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpg7teq1qc.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e\
    [0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpg7teq1qc.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e["
  stdout: ''
  timestamp: 1659805161
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val changes = mutable.ListBuffer[Long]()\n\
    \        val changed = mutable.ListBuffer[Long]()\n        val change = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < len) {\n            val curr = arr(i)\n\
    \            val j = len - i - 1\n            val nextVal = arr(j)\n         \
    \   if (curr == nextVal) {\n                changes += curr\n                changed.append(curr)\n\
    \                change.append(nextVal)\n                i += 1\n            }\
    \ else if (curr < nextVal) {\n                changes += curr\n              \
    \  changed.append(curr)\n                change.append(nextVal)\n            \
    \    i += 1\n            } else {\n                changes += nextVal\n      \
    \          changed.append(nextVal)\n                change.append(curr)\n    \
    \            i += 1\n            }\n        }\n        val changeCount = changes.toList.length\n\
    \        if (changeCount < minChange) {\n            minChange = changeCount\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpasc4hspv.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpasc4hspv.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpasc4hspv.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpasc4hspv.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpasc4hspv.scala:45:22 -----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            minChange = changeCount\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805158
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val arr = arr.toList\n     \
    \   val len = arr.length\n        val min = arr.head\n        val max = arr.last\n\
    \        val mid = len / 2\n        val mid2 = len / 2\n        val mid3 = len\
    \ / 2\n        val mid4 = len / 2\n        val mid5 = len / 2\n        val mid6\
    \ = len / 2\n        val mid7 = len / 2\n        val mid8 = len / 2\n        val\
    \ mid9 = len / 2\n        val mid10 = len / 2\n        val mid11 = len / 2\n \
    \       val mid12 = len / 2\n        val mid13 = len / 2\n        val mid14 =\
    \ len / 2\n        val mid15 = len / 2\n        val mid16 = len / 2\n        val\
    \ mid17 = len / 2\n        val mid18 = len / 2\n        val mid19 = len / 2\n\
    \        val mid20 = len / 2\n        val mid21 = len / 2\n        val mid22 =\
    \ len / 2\n        val mid23 = len / 2\n        val mid24 = len / 2\n        val\
    \ mid25 = len / 2\n        val mid26 = len / 2\n        val mid27 = len / 2\n\
    \        val mid28 = len / 2\n        val mid29 = len / 2\n        val mid30 =\
    \ len / 2\n        val mid31 = len / 2\n        val mid32 = len / 2\n        val\
    \ mid33 = len / 2\n        val mid34 = len / 2\n        val mid35 = len / 2\n\
    \        val mid36 = len / 2\n        val mid37 = len / 2\n        val mid38 =\
    \ len / 2\n        val mid39 = len / 2\n        val mid40 = len / 2\n        val\
    \ mid41 = len / 2\n        val mid42 = len / 2\n        val mid43 = len / 2\n\
    \        val mid44 = len / 2\n        val mid45 = len / 2\n        val mid46 =\
    \ len / 2\n        val mid47 = len / 2\n        val mid48 = len / 2\n        val\
    \ mid49 = len / 2\n        val mid50 = len / 2\n        val mid51 = len / 2\n\
    \        val mid52 = len / 2\n        val mid53 = len / 2\n        val mid54 =\
    \ len / 2\n        val mid55 = len / \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpm7_2jm32.scala:74:25 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36mmid55\e[0m = len / \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpm7_2jm32.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpm7_2jm32.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.length / 2\n   \
    \     val arr = arr.sortBy(-_)\n        val pal = arr.take(m).reverse.take(m).reverse\n\
    \        val change = arr.take(n).filter(_ != pal(0)).length\n        change\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsm4oihl1.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805159
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        var minChange = 0\n      \
    \  var minChangeIndex = 0\n        var minChangeIndex2 = 0\n        var minChangeIndex3\
    \ = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5 = 0\n    \
    \    var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n        var minChangeIndex8\
    \ = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10 = 0\n   \
    \     var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n        var\
    \ minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var minChangeIndex15\
    \ = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17 = 0\n  \
    \      var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n        var\
    \ minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var minChangeIndex22\
    \ = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24 = 0\n  \
    \      var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n        var\
    \ minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var minChangeIndex29\
    \ = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31 = 0\n  \
    \      var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n        var\
    \ minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var minChangeIndex36\
    \ = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38 = 0\n  \
    \      var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n        var\
    \ minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var minChangeIndex43\
    \ = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45 = 0\n  \
    \      var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n        var\
    \ minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var minChangeIndex50\
    \ = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52 = 0\n  \
    \      var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n        var\
    \ minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var minChangeIndex57\
    \ = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59 = 0\n  \
    \      var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n        var\
    \ minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var minChangeIndex64\
    \ = 0\n        var minChangeIndex65 = 0\n        var minChangeIndex66 = 0\n  \
    \      var minChangeIndex67 = 0\n        var minChangeIndex68 = 0\n        var\
    \ minChangeIndex69 = 0\n        var minChangeIndex70 = 0\n        var minChangeIndex71\
    \ = 0\n        var minChangeIndex72\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdyo1pdhh.scala:89:4 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpdyo1pdhh.scala:89:5 ---------------------\e[0m\e[0m\n\e[31m89 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805165
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val change = arr.take(len/2).reverse.take(len/2).length\n        arr.take(len/2).reverse.take(len/2).length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmps_03xlq9.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps_03xlq9.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805161
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val maxLen = len / 2\n        val maxLen2 = len / 4\n        val maxLen3\
    \ = len / 8\n        val maxLen4 = len / 16\n        val maxLen5 = len / 32\n\
    \        val maxLen6 = len / 64\n        val maxLen7 = len / 128\n        val\
    \ maxLen8 = len / 256\n        val maxLen9 = len / 512\n        val maxLen10 =\
    \ len / 1024\n        val maxLen11 = len / 2048\n        val maxLen12 = len /\
    \ 4096\n        val maxLen13 = len / 8192\n        val maxLen14 = len / 16384\n\
    \        val maxLen15 = len / 32768\n        val maxLen16 = len / 65536\n    \
    \    val maxLen17 = len / 131072\n        val maxLen18 = len / 262144\n      \
    \  val maxLen19 = len / 524288\n        val maxLen20 = len / 1048576\n       \
    \ val maxLen21 = len / 2097152\n        val maxLen22 = len / 4194304\n       \
    \ val maxLen23 = len / 8388608\n        val maxLen24 = len / 16777216\n      \
    \  val maxLen25 = len / 33554432\n        val maxLen26 = len / 67108864\n    \
    \    val maxLen27 = len / 134217728\n        val maxLen28 = len / 268435456\n\
    \        val maxLen29 = len / 536870912\n        val maxLen30 = len / 1073741824\n\
    \        val maxLen31 = len / 2147483648\n        val maxLen32 = len / 4294967296\n\
    \        val maxLen33 = len / 8589934592\n        val maxLen34 = len / 17179869184\n\
    \        val maxLen35 = len / 34359738368\n        val maxLen36 = len / 68719476736\n\
    \        val maxLen37 = len / 137438953472\n        val maxLen38 = len / 274877906944\n\
    \        val maxLen39 = len / 549755813888\n        val maxLen40 = len / 1099511627776\n\
    \        val maxLen41 = len / 2199023255552\n        val maxLen42 = len / 4398046511104\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpbqfm9slb.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbqfm9slb.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbqfm9slb.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805166
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val minChange = len\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var minChangeCount = 0\n        while(i < len) {\n          \
    \  while(j < len) {\n                if(arr(i) == arr(j)) {\n                \
    \    j++\n                } else {\n                    minChangeCount = minChangeCount\
    \ + 1\n                    if(minChangeCount > minChange) {\n                \
    \        minChange = minChangeCount\n                    }\n                 \
    \   j = 0\n                }\n            }\n            minChangeCount = 1\n\
    \            i += 1\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7x2akhfx.scala:25:23 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmp7x2akhfx.scala:15:29 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp7x2akhfx.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmp7x2akhfx.scala:29:34 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        minChange = minChangeCount\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        while(i < len) {\n            while(j < len) {\n\
    \                if(arr(i) == arr(j)) {\n                    temp = arr(i)\n \
    \                   arr(i) = arr(j)\n                    arr(j) = temp\n     \
    \               j++\n                }\n                else {\n             \
    \       j++\n                }\n            }\n            i = i + 1\n       \
    \     j = 0\n            k = k + 1\n        }\n        if(arr.length == 1) {\n\
    \            return 0\n        }\n        else {\n            while(k != len)\
    \ {\n                temp = arr(k)\n                arr(k) = arr(len - k - 1)\n\
    \                arr(len - k - 1) = temp\n                k = k - 1\n        \
    \    }\n            return arr.length\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp21hq0d1u.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp21hq0d1u.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp21hq0d1u.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805163
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val m = arr.length\n        val n = arr.length\n       \
    \ val p = new Array[Long](m)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var max = 0\n        var count = 0\n   \
    \     while (i < m && j < n) {\n            if (arr(i) < arr(j)) {\n         \
    \       p(i) = arr(i)\n                i += 1\n                count += 1\n  \
    \          } else {\n                p(i) = arr(j)\n                j += 1\n \
    \               count += 1\n            }\n        }\n        while (i < m) {\n\
    \            p(i) = arr(i)\n            i += 1\n            count += 1\n     \
    \   }\n        while (j < n) {\n            p(i) = arr(j)\n            j += 1\n\
    \            count += 1\n        }\n        max = count\n        min = count\n\
    \        while (i < m) {\n            if (p(i) != arr(i)) {\n                max\
    \ = count\n                min = count\n            }\n            i += 1\n  \
    \      }\n        while (j < n) {\n            if (p(i) != arr(j)) {\n       \
    \         max = count\n                min = count\n            }\n          \
    \  j += 1\n        }\n        if (min == max) {\n            return 0\n      \
    \  }\n        if (min > max) {\n            max = count\n            min = count\n\
    \        }\n        val ans = max\n        val temp = new Array[Long](ans)\n \
    \       var i = 0\n        while (i < ans) {\n            temp(i) = p(i)\n   \
    \         i += 1\n        }\n        val temp = temp.reverse\n        var j =\
    \ 0\n        while (j < ans) {\n            if (temp(j) != arr(j)) {\n       \
    \         ans = count\n            }\n            j += 1\n        }\n        ans\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpey2wrc_y.scala:70:12 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpey2wrc_y.scala:75:12 ---------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m        \e[33mval\e[0m \e[36mtemp\e[0m = temp.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtemp\
    \ is already defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpey2wrc_y.scala:76:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m76 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mj is already defined as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpey2wrc_y.scala:79:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m                ans\
    \ = count\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Reassignment to val ans\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805165
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var min = 0\n        while(i < arr.length\
    \ && j < arr.length) {\n            if(arr(i) == arr(j)) {\n                i\
    \ += 1\n                j += 1\n                k += 1\n            } else {\n\
    \                if(arr(i) < arr(j)) {\n                    min = k\n        \
    \            i += 1\n                } else {\n                    min = k\n \
    \                   j += 1\n                }\n                k += 1\n      \
    \      }\n        }\n        min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp85e5pug1.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp85e5pug1.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805164
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.takeRight(n).length\n        val m =\
    \ arr.takeRight(n).reverse.takeRight(n).length\n        val m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \        val m = arr.takeRight(n).reverse.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmwamfbz6.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmwamfbz6.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmwamfbz6.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmwamfbz6.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmwamfbz6.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.takeRight(n).reverse.takeRight(n).length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming "
  stdout: ''
  timestamp: 1659805171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        while(i < len) {\n            while(j < len) {\n\
    \                if(arr(i) == arr(j)) {\n                    temp = arr(i)\n \
    \                   arr(i) = arr(j)\n                    arr(j) = temp\n     \
    \               j++\n                }\n                else {\n             \
    \       j++\n                }\n            }\n            i = i + 1\n       \
    \     j = len - 1\n            k = k + 1\n            while(k >= 0) {\n      \
    \          if(arr(i) == arr(k)) {\n                    temp = arr(i)\n       \
    \             arr(i) = arr(k)\n                    arr(k) = temp\n           \
    \         k--\n                }\n                else {\n                   \
    \ k--\n                }\n            }\n        }\n        arr.toList.min\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbqzlxw7y.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpbqzlxw7y.scala:31:23 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbqzlxw7y.scala:42:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                    k--\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpbqzlxw7y.scala:45:23 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                    k--\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpbqzlxw7y.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805166
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpewmprc29.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpewmprc29.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpewmprc29.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        var min = arr.head\n     \
    \   var max = 0\n        var i = 0\n        var j = 0\n        while(i < arr.length)\
    \ {\n            max = Math.max(max, arr(i))\n            i += 1\n        }\n\
    \        while(j < arr.length) {\n            min = Math.min(min, arr(j))\n  \
    \          j += 1\n        }\n        val maxDiff = max - min\n        val diff\
    \ = (arr.length - maxDiff) / 2\n        val diff2 = diff * 2\n        val diff3\
    \ = diff * 3\n        val diff4 = diff * 4\n        val diff5 = diff * 5\n   \
    \     val diff6 = diff * 6\n        val diff7 = diff * 7\n        val diff8 =\
    \ diff * 8\n        val diff9 = diff * 9\n        val diff10 = diff * 10\n   \
    \     val diff11 = diff * 11\n        val diff12 = diff * 12\n        val diff13\
    \ = diff * 13\n        val diff14 = diff * 14\n        val diff15 = diff * 15\n\
    \        val diff16 = diff * 16\n        val diff17 = diff * 17\n        val diff18\
    \ = diff * 18\n        val diff19 = diff * 19\n        val diff20 = diff * 20\n\
    \        val diff21 = diff * 21\n        val diff22 = diff * 22\n        val diff23\
    \ = diff * 23\n        val diff24 = diff * 24\n        val diff25 = diff * 25\n\
    \        val diff26 = diff * 26\n        val diff27 = diff * 27\n        val diff28\
    \ = diff * 28\n        val diff29 = diff * 29\n        val diff30 = diff * 30\n\
    \        val diff31 = diff * 31\n        val diff32 = diff * 32\n        val diff33\
    \ = diff * 33\n        val diff34 = diff * 34\n        val diff35 = diff * 35\n\
    \        val diff36 = diff * 36\n        val diff37 = diff * 37\n        val diff38\
    \ = diff * 38\n        val diff39 = diff * 39\n        val diff40 = diff * 40\n\
    \        val diff41 = diff * 41\n        val diff42 = diff * 42\n        val diff43\
    \ = diff * 43\n        val diff44 = diff * 44\n        val diff45 = diff * 45\n\
    \        val diff46 = diff * 46\n        val diff47 = diff * 47\n        val diff48\
    \ = diff * 48\n        val diff49 = diff * 49\n        val diff50 = diff * 50\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb0ooy83h.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb0ooy83h.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805171
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        val minChange = len / 2\n        val maxChange = len - minChange\n  \
    \      val changes = mutable.ArrayBuffer.empty[Long]\n        val change = minChange\n\
    \        while (change <= maxChange) {\n            changes += change\n      \
    \      change += 1\n        }\n        changes.min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnnbgz9yj.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnnbgz9yj.scala:19:22 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805167
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        val max = (len / 2) - 1\n        val mid = len /\
    \ 2\n        var i = 0\n        var j = 0\n        var k = 0\n        var count\
    \ = 0\n        var change = 0\n        while (i < len) {\n            if (arr(i)\
    \ < arr(max)) {\n                max = max\n                mid = mid\n      \
    \          max = max - 1\n            }\n            else if (arr(i) > arr(max))\
    \ {\n                max = max\n                mid = mid\n                max\
    \ = max + 1\n            }\n            else {\n                mid = mid\n  \
    \              max = max + 1\n            }\n            i = i + 1\n        }\n\
    \        while (j < len) {\n            if (arr(j) < arr(max)) {\n           \
    \     max = max\n                mid = mid\n                max = max - 1\n  \
    \          }\n            else if (arr(j) > arr(max)) {\n                max =\
    \ max\n                mid = mid\n                max = max + 1\n            }\n\
    \            else {\n                mid = mid\n                max = max + 1\n\
    \            }\n            j = j + 1\n        }\n        while (k < (len / 2))\
    \ {\n            if (arr(k) < arr(max)) {\n                max = max\n       \
    \         mid = mid\n                max = max - 1\n            }\n          \
    \  else if (arr(k) > arr(max)) {\n                max = max\n                mid\
    \ = mid\n                max = max + 1\n            }\n            else {\n  \
    \              mid = mid\n                max = max + 1\n            }\n     \
    \       k = k + 1\n        }\n        while (i < len) {\n            if (arr(i)\
    \ < arr(max)) {\n                max = max\n                mid = mid\n      \
    \          max = max - 1\n            }\n            else if (arr(i) > arr(max))\
    \ {\n                max = max\n                mid = mid\n                max\
    \ = max + 1\n            }\n            else {\n                mid = mid\n  \
    \              max = max + 1\n            }\n            i = i + 1\n        }\n\
    \        while (j < len) {\n            if (arr(j) < arr(max)) {\n           \
    \     max = max\n                mid = mid\n                max = max - 1\n  \
    \          }\n            else if (arr(j) > arr(max)) {\n                max =\
    \ max\n                mid = mid\n                max = max + 1\n            }\n\
    \            else {\n                mid = mid\n                max = max + 1\n\
    \            }\n            j = j + 1\n        }\n        while (k < (len / 2))\
    \ {\n            if (arr(k) < arr(max)) {\n                max = max\n       \
    \         mid = mid\n                max = max - 1\n            }\n          \
    \  else if (arr(k) > arr(max)) {\n                max = max\n                mid\
    \ = mid\n                max = max + 1\n            }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3z0rsn5x.scala:134:0 ---------------------------\e\
    [0m\e[0m\n\e[31m134 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3z0rsn5x.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp3z0rsn5x.scala:27:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                max\
    \ = max\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp3z0rsn5x.scala:28:20 -----------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                mid = mid\n\e[31m\e[31m   |\e[0m         \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val mid\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp3z0rsn5x.scala:29:20 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                max = max - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp3z0rsn5x.scala:32:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                max\
    \ = max\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val max\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp3z0rsn5x.scala:33:20 -----------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m                mid = mid\n\e[31m\e[31m   |\e[0m         \
    \       ^"
  stdout: ''
  timestamp: 1659805177
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var max = 0\n        var i = 0\n        var j = 0\n\
    \        while (i < len) {\n            max = arr(i)\n            while (j < len)\
    \ {\n                if (arr(i) == arr(j)) {\n                    min = Math.min(min,\
    \ j - i)\n                }\n                j++\n            }\n            i\
    \ = i + 1\n        }\n        min\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcwrehl48.scala:27:19 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcwrehl48.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            val temp = arr(i)\n            while (j < len) {\n\
    \                if (arr(j) != temp) {\n                    minChange = minChange\
    \ - 1\n                    arr(j) = temp\n                    j = j + 1\n    \
    \            } else {\n                    j = j + 1\n                }\n    \
    \        }\n            i = i + 1\n        }\n        minChange\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_e1459de.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp_e1459de.scala:24:30 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    minChange = minChange - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805170
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.last\n        val\
    \ max = (n * (n + 1) / 2) - (n + 1)\n        val max2 = max * max\n        val\
    \ max3 = max2 * max\n        val max4 = max3 * max\n        val max5 = max4 *\
    \ max\n        val max6 = max5 * max\n        val max7 = max6 * max\n        val\
    \ max8 = max7 * max\n        val max9 = max8 * max\n        val max10 = max9 *\
    \ max\n        val max11 = max10 * max\n        val max12 = max11 * max\n    \
    \    val max13 = max12 * max\n        val max14 = max13 * max\n        val max15\
    \ = max14 * max\n        val max16 = max15 * max\n        val max17 = max16 *\
    \ max\n        val max18 = max17 * max\n        val max19 = max18 * max\n    \
    \    val max20 = max19 * max\n        val max21 = max20 * max\n        val max22\
    \ = max21 * max\n        val max23 = max22 * max\n        val max24 = max23 *\
    \ max\n        val max25 = max24 * max\n        val max26 = max25 * max\n    \
    \    val max27 = max26 * max\n        val max28 = max27 * max\n        val max29\
    \ = max28 * max\n        val max30 = max29 * max\n        val max31 = max30 *\
    \ max\n        val max32 = max31 * max\n        val max33 = max32 * max\n    \
    \    val max34 = max33 * max\n        val max35 = max34 * max\n        val max36\
    \ = max35 * max\n        val max37 = max36 * max\n        val max38 = max37 *\
    \ max\n        val max39 = max38 * max\n        val max40 = max39 * max\n    \
    \    val max41 = max40 * max\n        val max42 = max41 * max\n        val max43\
    \ = max42 * max\n        val max44 = max43 * max\n        val max45 = max44 *\
    \ max\n        val max46 = max45 * max\n        val max47 = max46 * max\n    \
    \    val max48 = max47 * max\n        val max49 = max48 * max\n        val max50\
    \ = max49 * max\n        val max51 = max50 * max\n        val max5\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwyjuo68x.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwyjuo68x.scala:69:5 ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805176
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var min = 0\n        var max = 0\n        while (i < n && j < n)\
    \ {\n            if (arr(i) < arr(j)) {\n                p(k) = arr(i)\n     \
    \           i += 1\n                k += 1\n            } else {\n           \
    \     p(k) = arr(j)\n                j += 1\n                k += 1\n        \
    \    }\n        }\n        while (i < n) {\n            p(k) = arr(i)\n      \
    \      i += 1\n            k += 1\n        }\n        while (j < n) {\n      \
    \      p(k) = arr(j)\n            j += 1\n            k += 1\n        }\n    \
    \    val l = p.length\n        if (l == 0) {\n            return 0\n        }\n\
    \        var i = 0\n        var j = 0\n        while (i < l && j < l) {\n    \
    \        if (p(j) < p(i)) {\n                min = i\n                max = j\n\
    \            } else {\n                min = j\n                max = i\n    \
    \        }\n            i += 1\n            j += 1\n        }\n        if (min\
    \ == max) {\n            return min\n        }\n        if (min > max) {\n   \
    \         return smallestChange(arr.take(max))\n        }\n        return smallestChange(arr.take(min))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjxp4c04x.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjxp4c04x.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805173
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n    \
    \    val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ArrayBuffer.empty[Int]\n        val changeIndexMap\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n   \
    \     val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n   \
    \     val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n   \
    \     val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n   \
    \     val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n   \
    \     val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n   \
    \     val changeIndexMapSize = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMapSize = mutable.HashMap.empty[Int,\
    \ Int]\n        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5hi2v9zp.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMapSize\e[0m\
    \ = mutable.HashMap.empty[\e[35mInt\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mchangeIndexMapSize is already defined as \e[33mvalue\e[0m \e[35mchangeIndexMapSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5hi2v9zp.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMapSize\e[0m = mutable.HashMap.empty[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndexMapSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mchangeIndexMapSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5hi2v9zp.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMapSize\e[0m\
    \ = mutable.HashMap.empty[\e[35mInt\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mchangeIndexMapSize is already defined as \e[33mvalue\e[0m \e[35mchangeIndexMapSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5hi2v9zp.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMapSize\e[0m = mutable.HashMap.empty[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeIndexMapSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mchangeIndexMapSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel "
  stdout: ''
  timestamp: 1659805177
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpewmprc29.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpewmprc29.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpewmprc29.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        val minChangeIndex = 0\n        val minChangeCount\
    \ = 0\n        val minChangeCountIndex = 0\n        val minChangeCountIndex2 =\
    \ 0\n        val minChangeCountIndex3 = 0\n        val minChangeCountIndex4 =\
    \ 0\n        val minChangeCountIndex5 = 0\n        val minChangeCountIndex6 =\
    \ 0\n        val minChangeCountIndex7 = 0\n        val minChangeCountIndex8 =\
    \ 0\n        val minChangeCountIndex9 = 0\n        val minChangeCountIndex10 =\
    \ 0\n        val minChangeCountIndex11 = 0\n        val minChangeCountIndex12\
    \ = 0\n        val minChangeCountIndex13 = 0\n        val minChangeCountIndex14\
    \ = 0\n        val minChangeCountIndex15 = 0\n        val minChangeCountIndex16\
    \ = 0\n        val minChangeCountIndex17 = 0\n        val minChangeCountIndex18\
    \ = 0\n        val minChangeCountIndex19 = 0\n        val minChangeCountIndex20\
    \ = 0\n        val minChangeCountIndex21 = 0\n        val minChangeCountIndex22\
    \ = 0\n        val minChangeCountIndex23 = 0\n        val minChangeCountIndex24\
    \ = 0\n        val minChangeCountIndex25 = 0\n        val minChangeCountIndex26\
    \ = 0\n        val minChangeCountIndex27 = 0\n        val minChangeCountIndex28\
    \ = 0\n        val minChangeCountIndex29 = 0\n        val minChangeCountIndex30\
    \ = 0\n        val minChangeCountIndex31 = 0\n        val minChangeCountIndex32\
    \ = 0\n        val minChangeCountIndex33 = 0\n        val minChangeCountIndex34\
    \ = 0\n        val minChangeCountIndex35 = 0\n        val minChangeCountIndex36\
    \ = 0\n        val minChangeCountIndex37 = 0\n        val minChangeCountIndex38\
    \ = 0\n        val minChangeCountIndex39 = 0\n        val minChangeCountIndex40\
    \ = 0\n        val minChangeCountIndex41 = 0\n        val minChangeCountIndex42\
    \ = 0\n        val minChangeCountIndex43 = 0\n        val minChangeCountIndex44\
    \ = 0\n        val minChangeCountIndex45 = 0\n        val minChangeCountIndex46\
    \ = 0\n        val minChangeCountIndex47 = 0\n        val minChangeCountIndex48\
    \ = 0\n        val minChangeCountIndex49 = 0\n        val minChangeCountIndex50\
    \ = 0\n        val minChangeCountIndex51 = 0\n        val minChangeCountIndex52\
    \ = 0\n        val minChangeCountIndex53 = 0\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpwjyyy0ah.scala:73:11 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwjyyy0ah.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwjyyy0ah.scala:74:5 ---------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805177
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        while (i < len) {\n            val x = arr(i)\n            val\
    \ y = arr(j)\n            if (x == y) {\n                i += 1\n            \
    \    j += 1\n                k += 1\n            } else if (x < y) {\n       \
    \         i += 1\n                k += 1\n            } else {\n             \
    \   j += 1\n                k += 1\n            }\n            if (k == minChange)\
    \ {\n                minChange = k\n            }\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcgpuq_js.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpcgpuq_js.scala:36:26 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                minChange = k\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805172
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            val temp = arr(i)\n            val temp2 = arr(j)\n\
    \            if (temp != temp2) {\n                minChange = minChange - 1\n\
    \                i = i + 1\n                j = j + 1\n            } else {\n\
    \                i = i + 1\n                j = j + 1\n            }\n       \
    \ }\n        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp61e0hgok.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp61e0hgok.scala:24:26 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                minChange = minChange - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805174
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.max\n        val d\
    \ = arr.min\n        val d = arr.max\n        val d = arr.min\n        val d =\
    \ arr.max\n        val d = arr.min\n        val d = arr.max\n        val d = arr.min\n\
    \        val d = arr.max\n        val d = arr.min\n        val d = arr.max\n \
    \       val d = arr.min\n        val d = arr.max\n        val d = arr.min\n  \
    \      val d = arr.max\n        val d = arr.min\n        val d = arr.max\n   \
    \     val d = arr.min\n        val d = arr.max\n        val d = arr.min\n    \
    \    val d = arr.max\n        val d = arr.min\n        val d = arr.max\n     \
    \   val d = arr.min\n        val d = arr.max\n        val d = arr.min\n      \
    \  val d = arr.max\n        val d = arr.min\n        val d = arr.max\n       \
    \ val d = arr.min\n        val d = arr.max\n        val d = arr.min\n        val\
    \ d = arr.max\n        val d = arr.min\n        val d = arr.max\n        val d\
    \ = arr.min\n        val d = arr.max\n        val d = arr.min\n        val d =\
    \ arr.max\n        val d = arr.min\n        val d = arr.max\n        val d = arr.min\n\
    \        val d = arr.max\n        val d = arr.min\n        val d = arr.max\n \
    \       val d = arr.min\n        val d = arr.max\n        val d = arr.min\n  \
    \      val d = arr.max\n        val d = arr.min\n        val d = arr.max\n   \
    \     val d = arr.min\n        val d = arr.max\n        val d = arr.min\n    \
    \    val d = arr.max\n        val d = arr.min\n        val d = arr.max\n     \
    \   val d = arr.min\n        val d = arr.max\n        val d = arr.min\n      \
    \  val d = arr.max\n        val d = arr.min\n        val d = arr.max\n       \
    \ val d = arr.min\n        val d = arr.max\n        val d = arr.min\n        val\
    \ d = arr.max\n        val d = arr.min\n        val d = arr.max\n        val d\
    \ = arr.min\n        val d = arr.max\n        val d = arr.min\n        val d =\
    \ arr.max\n        val d = arr.min\n        val d = arr.max\n        val d = arr.min\n\
    \        val d = arr.max\n        val d = arr.min\n        val d = arr.max\n \
    \       val d = arr.min\n        val d = arr.max\n        val d = arr.min\n  \
    \      val d = arr.max\n        val d = arr.min\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmps7acp_cd.scala:100:11 --------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7acp_cd.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7acp_cd.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.min\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7acp_cd.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7acp_cd.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.min\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps7acp_cd.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is alr"
  stdout: ''
  timestamp: 1659805181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = Long.MaxValue\n        var minIndex = 0\n        var\
    \ maxIndex = 0\n        while (i < len) {\n            val temp = arr(i)\n   \
    \         val temp2 = arr(j)\n            val temp3 = arr(k)\n            if (temp\
    \ == temp2) {\n                if (temp == temp3) {\n                    arr(k)\
    \ = temp\n                    arr(j) = 0\n                    arr(k) = 0\n   \
    \                 k -= 1\n                    j -= 1\n                    i -=\
    \ 1\n                    min -= 1\n                    minIndex -= 1\n       \
    \             maxIndex -= 1\n                } else {\n                    arr(k)\
    \ = temp\n                    arr(j) = 0\n                    arr(k) = 0\n   \
    \                 k -= 1\n                    j -= 1\n                    i -=\
    \ 1\n                    min -= 1\n                    minIndex -= 1\n       \
    \         }\n            } else if (temp == temp3) {\n                arr(k) =\
    \ temp\n                arr(j) = 0\n                arr(k) = 0\n             \
    \   k -= 1\n                j -= 1\n                i -= 1\n                min\
    \ -= 1\n                minIndex -= 1\n            } else {\n                arr(k)\
    \ = temp\n                arr(j) = 0\n                arr(k) = 0\n           \
    \     k -= 1\n                j -= 1\n                i -= 1\n               \
    \ min -= 1\n                minIndex -= 1\n            }\n            i += 1\n\
    \            j += 1\n            k += 1\n        }\n        if (min == 0) {\n\
    \            return 0\n        } else {\n            return min\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmnzutobc.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805175
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val minLen = len - maxLen\n        val maxVal\
    \ = arr(maxLen)\n        val minVal = arr(minLen)\n        val maxIndex = arr.lastIndexWhere(x\
    \ => x == maxVal)\n        val minIndex = arr.lastIndexWhere(x => x == minVal)\n\
    \        val maxPalindromic = arr.take(maxIndex + 1)\n        val minPalindromic\
    \ = arr.take(minIndex + 1)\n        val maxPalindromicIndex = maxPalindromic.length\
    \ - 1\n        val minPalindromicIndex = minPalindromic.length - 1\n        val\
    \ maxPalindromicVal = maxPalindromic(maxPalindromicIndex)\n        val minPalindromicVal\
    \ = minPalindromic(minPalindromicIndex)\n        val maxPalindromicIndex = maxPalindromicIndex\
    \ - maxPalindromicVal\n        val minPalindromicIndex = minPalindromicIndex -\
    \ minPalindromicVal\n        val maxPalindromicIndex = maxPalindromicIndex + maxPalindromicVal\n\
    \        val minPalindromicIndex = minPalindromicIndex + minPalindromicVal\n \
    \       val maxPalindromic = arr.take(maxPalindromicIndex)\n        val minPalindromic\
    \ = arr.take(minPalindromicIndex)\n        val maxPalindromicIndex = maxPalindromic.length\
    \ - 1\n        val minPalindromicIndex = minPalindromic.length - 1\n        val\
    \ maxPalindromicVal = maxPalindromic(maxPalindromicIndex)\n        val minPalindromicVal\
    \ = minPalindromic(minPalindromicIndex)\n        val maxPalindromicIndex = maxPalindromicIndex\
    \ - maxPalindromicVal\n        val minPalindromicIndex = minPalindromicIndex -\
    \ minPalindromicVal\n        val maxPalindromicIndex = maxPalindromicIndex + maxPalindromicVal\n\
    \        val minPalindromicIndex = minPalindromicIndex + minPalindromicVal\n \
    \       val maxPalindromic = arr.take(maxPalindromicIndex)\n        val minPalindromic\
    \ = arr.take(minPalindromicIndex)\n        val maxPalin\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1lji9jt5.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1lji9jt5.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxPalindromicIndex\e[0m = maxPalindromicIndex - maxPalindromicVal\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxPalindromicIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxPalindromicIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1lji9jt5.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mminPalindromicIndex\e[0m\
    \ = minPalindromicIndex - minPalindromicVal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminPalindromicIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mminPalindromicIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1lji9jt5.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxPalindromicIndex\e[0m\
    \ = maxPalindromicIndex + maxPalindromicVal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxPalindromicIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxPalindromicIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp1lji9jt5.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mminPalindromicIndex\e[0m\
    \ = minPalindromicIndex + minPalindromicVal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m "
  stdout: ''
  timestamp: 1659805181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val q = new Array[Long](n + 1)\n       \
    \ val r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n   \
    \     val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n\
    \        val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long](n + 1)\n\
    \        val j = new Array[Long](n + 1)\n        val k = new Array[Long](n + 1)\n\
    \        val l = new Array[Long](n + 1)\n        val m = new Array[Long](n + 1)\n\
    \        val n = new Array[Long](n + 1)\n        val o = new Array[Long](n + 1)\n\
    \        val p = new Array[Long](n + 1)\n        val q = new Array[Long](n + 1)\n\
    \        val r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n\
    \        val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n\
    \        val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3hw772mz.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3hw772mz.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3hw772mz.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3hw772mz.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3hw772mz.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mq is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3hw772mz.scala:45:12\
    \ ------"
  stdout: ''
  timestamp: 1659805182
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpsuvnx38a.scala:83:11 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpsuvnx38a.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsuvnx38a.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsuvnx38a.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsuvnx38a.scala:20:12 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsuvnx38a.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length"
  stdout: ''
  timestamp: 1659805184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        val\
    \ p = new Array[Long](n)\n        val r = new Array[Long](n)\n        val minChange\
    \ = Long.MaxValue\n        val minChangeIndex = -1\n        for(i <- 0 until n){\n\
    \            p(i) = arr(i)\n            r(i) = arr(i)\n        }\n        for(i\
    \ <- 0 until n){\n            if(p(i) == r(i)){\n                for(j <- 0 until\
    \ i){\n                    if(j > i){\n                        if(arr(i-j) !=\
    \ arr(j)){\n                            p(i) = arr(i-j)\n                    \
    \        r(i) = arr(j)\n                            minChange = minChange.min(minChange)\n\
    \                            minChangeIndex = i\n                        }\n \
    \                   }\n                }\n            }\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4cwrvoc0.scala:32:38 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                            minChange = minChange.min(minChange)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Reassignment to val minChange\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp4cwrvoc0.scala:33:43 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                            minChangeIndex = i\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                            Reassignment to val minChangeIndex\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ arr = arr.tail\n        val max = (arr.length / 2) - 1\n        val max2 = max\
    \ / 2\n        val max3 = max / 3\n        val max4 = max / 4\n        val max5\
    \ = max / 5\n        val max6 = max / 6\n        val max7 = max / 7\n        val\
    \ max8 = max / 8\n        val max9 = max / 9\n        val max10 = max / 10\n \
    \       val max11 = max / 11\n        val max12 = max / 12\n        val max13\
    \ = max / 13\n        val max14 = max / 14\n        val max15 = max / 15\n   \
    \     val max16 = max / 16\n        val max17 = max / 17\n        val max18 =\
    \ max / 18\n        val max19 = max / 19\n        val max20 = max / 20\n     \
    \   val max21 = max / 21\n        val max22 = max / 22\n        val max23 = max\
    \ / 23\n        val max24 = max / 24\n        val max25 = max / 25\n        val\
    \ max26 = max / 26\n        val max27 = max / 27\n        val max28 = max / 28\n\
    \        val max29 = max / 29\n        val max30 = max / 30\n        val max31\
    \ = max / 31\n        val max32 = max / 32\n        val max33 = max / 33\n   \
    \     val max34 = max / 34\n        val max35 = max / 35\n        val max36 =\
    \ max / 36\n        val max37 = max / 37\n        val max38 = max / 38\n     \
    \   val max39 = max / 39\n        val max40 = max / 40\n        val max41 = max\
    \ / 41\n        val max42 = max / 42\n        val max43 = max / 43\n        val\
    \ max44 = max / 44\n        val max45 = max / 45\n        val max46 = max / 46\n\
    \        val max47 = max / 47\n        val max48 = max / 48\n        val max49\
    \ = max / 49\n        val max50 = max / 50\n        val max51 = max / 51\n   \
    \     val max52 = max / 52\n        val max53 = max / 53\n        val max54 =\
    \ max / 54\n        val max55 = max / 55\n        val max56 = max / 56\n\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeh1lifs0.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpeh1lifs0.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            val x = arr(i)\n            val y = arr(j)\n\
    \            if (x == y) {\n                i += 1\n                j += 1\n \
    \               k += 1\n            } else if (x < y) {\n                i +=\
    \ 1\n                k += 1\n            } else {\n                j += 1\n  \
    \              k += 1\n            }\n            if (k > min) {\n           \
    \     min = k\n            }\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph0i3b43z.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805179
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpewmprc29.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpewmprc29.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpewmprc29.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ p = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ val s = new Array[Long](n + 1)\n        val t = new Array[Long](n + 1)\n   \
    \     val u = new Array[Long](n + 1)\n        val v = new Array[Long](n + 1)\n\
    \        val w = new Array[Long](n + 1)\n        val x = new Array[Long](n + 1)\n\
    \        val y = new Array[Long](n + 1)\n        val z = new Array[Long](n + 1)\n\
    \        val a = new Array[Long](n + 1)\n        val b = new Array[Long](n + 1)\n\
    \        val c = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n\
    \        val e = new Array[Long](n + 1)\n        val f = new Array[Long](n + 1)\n\
    \        val g = new Array[Long](n + 1)\n        val h = new Array[Long](n + 1)\n\
    \        val i = new Array[Long](n + 1)\n        val j = new Array[Long](n + 1)\n\
    \        val k = new Array[Long](n + 1)\n        val l = new Array[Long](n + 1)\n\
    \        val m = new Array[Long](n + 1)\n        val n = new Array[Long](n + 1)\n\
    \        val o = new Array[Long](n + 1)\n        val p = new Array[Long](n + 1)\n\
    \        val q = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n\
    \        val s = new Array[Long](n + 1)\n        val t = new Array[Long](n + 1)\n\
    \        val u = new Array[Long](n + 1)\n        val v = new Array[Long](n + 1)\n\
    \        val w = new Array[Long](n + 1)\n        val x = new Array[Long](n + 1)\n\
    \        val y = new Array[Long](n + 1)\n        val z = new Array[Long](n + 1)\n\
    \        val a = new Array[Long](n + 1)\n        val b = new Array[Long](n + 1)\n\
    \        val c = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n\
    \        val e = new Array[Long](n + 1)\n        val f = new Array[Long](n + 1)\n\
    \        val g = new Array[Long](n + 1)\n        val h = new Array[Long](n + 1)\n\
    \        val i = new Array[Long](n + 1)\n        val j = new Array[Long\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpicmnpspc.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpicmnpspc.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpicmnpspc.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpicmnpspc.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpicmnpspc.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpicmnpspc.scala:45:12\
    \ ------"
  stdout: ''
  timestamp: 1659805185
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var change = 0\n        var i = 0\n       \
    \ var j = 0\n        while(i < len) {\n            while(j < len && arr(i) ==\
    \ arr(j)) {\n                j += 1\n            }\n            if(j == len) {\n\
    \                change += 1\n                j = 0\n            }\n         \
    \   i += 1\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph0cdbtzr.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805181
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val mid = len / 2\n        var minChange = 0\n        var minChangeIndex\
    \ = 0\n        var minChangeIndex2 = len - 1\n        var minChangeIndex3 = len\
    \ - 1\n        var minChangeIndex4 = len - 1\n        var minChangeIndex5 = len\
    \ - 1\n        var minChangeIndex6 = len - 1\n        var minChangeIndex7 = len\
    \ - 1\n        var minChangeIndex8 = len - 1\n        var minChangeIndex9 = len\
    \ - 1\n        var minChangeIndex10 = len - 1\n        var minChangeIndex11 =\
    \ len - 1\n        var minChangeIndex12 = len - 1\n        var minChangeIndex13\
    \ = len - 1\n        var minChangeIndex14 = len - 1\n        var minChangeIndex15\
    \ = len - 1\n        var minChangeIndex16 = len - 1\n        var minChangeIndex17\
    \ = len - 1\n        var minChangeIndex18 = len - 1\n        var minChangeIndex19\
    \ = len - 1\n        var minChangeIndex20 = len - 1\n        var minChangeIndex21\
    \ = len - 1\n        var minChangeIndex22 = len - 1\n        var minChangeIndex23\
    \ = len - 1\n        var minChangeIndex24 = len - 1\n        var minChangeIndex25\
    \ = len - 1\n        var minChangeIndex26 = len - 1\n        var minChangeIndex27\
    \ = len - 1\n        var minChangeIndex28 = len - 1\n        var minChangeIndex29\
    \ = len - 1\n        var minChangeIndex30 = len - 1\n        var minChangeIndex31\
    \ = len - 1\n        var minChangeIndex32 = len - 1\n        var minChangeIndex33\
    \ = len - 1\n        var minChangeIndex34 = len - 1\n        var minChangeIndex35\
    \ = len - 1\n        var minChangeIndex36 = len - 1\n        var minChangeIndex37\
    \ = len - 1\n        var minChangeIndex38 = len - 1\n        var minChangeIndex39\
    \ = len - 1\n        var minChangeIndex40 = len - 1\n        var minChangeIndex41\
    \ = len - 1\n        var minChangeIndex42 = len - 1\n        var minChangeIndex43\
    \ = len - 1\n        var minChangeIndex44 = len - 1\n        var minChangeIndex45\
    \ = len - 1\n        var minChangeIndex46 = len - 1\n        var minChangeIndex47\
    \ = len - 1\n        var minChangeIndex48 = len - 1\n        var minChangeIndex49\
    \ = len - 1\n        var minChangeIndex50 = len - 1\n        var minChangeIndex51\
    \ = len - 1\n        var minChangeIndex52 = len - 1\n        var minChangeIndex53\
    \ = len - 1\n        var minChangeIndex54 = len - 1\n        var minChangeIndex55\
    \ = len - 1\n        var minChangeIndex5\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0r9_2zsj.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0r9_2zsj.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0r9_2zsj.scala:75:5\
    \ ---------------------\e[0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805185
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var minIndex = 0\n        var maxIndex = 0\n        while (i < len) {\n\
    \            val current = arr(i)\n            val next = arr(j)\n           \
    \ val currentIndex = i\n            val nextIndex = j\n            val currentValue\
    \ = current.toLong\n            val nextValue = next.toLong\n            if (currentValue\
    \ == nextValue) {\n                j++\n            } else {\n               \
    \ min = Math.min(min, currentValue - nextValue)\n                minIndex = currentIndex\n\
    \                maxIndex = nextIndex\n                j++\n            }\n  \
    \          i++\n        }\n        if (min == 0) {\n            return 0\n   \
    \     }\n        val minIndex = minIndex + 1\n        val maxIndex = maxIndex\
    \ + 1\n        val result = min - arr[minIndex] - arr[maxIndex]\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqdgxh942.scala:31:19 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqdgxh942.scala:36:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                j++\n\e\
    [31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmpqdgxh942.scala:38:15 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            i++\n\e[31m\e[31m   |\e[0m              \
    \ ^\e[0m\n\e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqdgxh942.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminIndex\e[0m = minIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminIndex is already defined\
    \ as \e[33mvariable\e[0m \e[35mminIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqdgxh942.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxIndex is already defined as \e[33mvariable\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpqdgxh942.scala:15:18 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toLong)\n\e\
    [31m\e[31m   |\e"
  stdout: ''
  timestamp: 1659805182
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var minIndex = 0\n        var maxIndex = 0\n        while(i < len) {\n\
    \            while(j < len) {\n                if(arr(i) == arr(j)) {\n      \
    \              j++\n                }\n                else {\n              \
    \      j = 0\n                }\n            }\n            k = i\n          \
    \  while(k >= 0) {\n                if(arr(k) == arr(len - 1 - k)) {\n       \
    \             k--\n                }\n                else {\n               \
    \     k = 0\n                }\n            }\n            if(k == 0) {\n    \
    \            min = arr(i)\n                minIndex = i\n                maxIndex\
    \ = i\n            }\n            else {\n                if(arr(i) < arr(min))\
    \ {\n                    min = arr(i)\n                    minIndex = i\n    \
    \            }\n                if(arr(i) > arr(max)) {\n                    max\
    \ = arr(i)\n                    maxIndex = i\n                }\n            }\n\
    \            i += 1\n        }\n        if(min == arr(len - 1)) {\n          \
    \  return 0\n        }\n        else if(min == arr(len - 1 - maxIndex)) {\n  \
    \          return maxIndex\n        }\n        else {\n            return minIndex\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7_c299mq.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp7_c299mq.scala:35:23 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                    k--\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp7_c299mq.scala:15:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m   |\e[0m                    \
    \         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded function:\n\
    \e[31m   |\e[0m   _$1 => arr.sortBy(_$1).\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp7_c299mq.scala:15:18 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e\
    [33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmp7_c299mq.scala:52:24 -----------------------------\e[0m\e\
    [0m\n\e[31m52 |\e[0m                    max = arr(i)\n\e[31m\e[31m   |\e[0m  \
    \                  ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val <none>\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        var count = 0\n\
    \        var i = 0\n        var j = arr.length - 1\n        while (i < j) {\n\
    \            if (arr(i) != arr(j)) {\n                count += 1\n           \
    \ }\n            i += 1\n            j -= 1\n        }\n        count\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpz0oq6h5y.scala:15:29 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz0oq6h5y.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.last\n        val\
    \ p = new Array[Long](n + 1)\n        val q = new Array[Long](n + 1)\n       \
    \ val r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n   \
    \     val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n\
    \        val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long](n + 1)\n\
    \        val j = new Array[Long](n + 1)\n        val k = new Array[Long](n + 1)\n\
    \        val l = new Array[Long](n + 1)\n        val m = new Array[Long](n + 1)\n\
    \        val n = new Array[Long](n + 1)\n        val o = new Array[Long](n + 1)\n\
    \        val p = new Array[Long](n + 1)\n        val q = new Array[Long](n + 1)\n\
    \        val r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n\
    \        val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n\
    \        val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppdje0j6c.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppdje0j6c.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppdje0j6c.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppdje0j6c.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mp\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mp is already defined as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppdje0j6c.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mq\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mq is already defined as \e[33mvalue\e[0m \e[35mq\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppdje0j6c.scala:45:12\
    \ ------"
  stdout: ''
  timestamp: 1659805189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            val left = arr(i)\n            val right = arr(len\
    \ - 1 - j)\n            if (left == right) {\n                i += 1\n       \
    \         j += 1\n            } else if (left > right) {\n                minChange\
    \ = i\n                i += 1\n            } else {\n                minChange\
    \ = len - 1 - j\n                j += 1\n            }\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfrrn5iz2.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpfrrn5iz2.scala:27:26 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                minChange = i\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpfrrn5iz2.scala:30:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                minChange\
    \ = len - \e[31m1\e[0m - j\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659805185
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var minChangeIndex = 0\n        var minChangeIndex2 = 0\n     \
    \   var minChangeIndex3 = 0\n        var minChangeIndex4 = 0\n        var minChangeIndex5\
    \ = 0\n        var minChangeIndex6 = 0\n        var minChangeIndex7 = 0\n    \
    \    var minChangeIndex8 = 0\n        var minChangeIndex9 = 0\n        var minChangeIndex10\
    \ = 0\n        var minChangeIndex11 = 0\n        var minChangeIndex12 = 0\n  \
    \      var minChangeIndex13 = 0\n        var minChangeIndex14 = 0\n        var\
    \ minChangeIndex15 = 0\n        var minChangeIndex16 = 0\n        var minChangeIndex17\
    \ = 0\n        var minChangeIndex18 = 0\n        var minChangeIndex19 = 0\n  \
    \      var minChangeIndex20 = 0\n        var minChangeIndex21 = 0\n        var\
    \ minChangeIndex22 = 0\n        var minChangeIndex23 = 0\n        var minChangeIndex24\
    \ = 0\n        var minChangeIndex25 = 0\n        var minChangeIndex26 = 0\n  \
    \      var minChangeIndex27 = 0\n        var minChangeIndex28 = 0\n        var\
    \ minChangeIndex29 = 0\n        var minChangeIndex30 = 0\n        var minChangeIndex31\
    \ = 0\n        var minChangeIndex32 = 0\n        var minChangeIndex33 = 0\n  \
    \      var minChangeIndex34 = 0\n        var minChangeIndex35 = 0\n        var\
    \ minChangeIndex36 = 0\n        var minChangeIndex37 = 0\n        var minChangeIndex38\
    \ = 0\n        var minChangeIndex39 = 0\n        var minChangeIndex40 = 0\n  \
    \      var minChangeIndex41 = 0\n        var minChangeIndex42 = 0\n        var\
    \ minChangeIndex43 = 0\n        var minChangeIndex44 = 0\n        var minChangeIndex45\
    \ = 0\n        var minChangeIndex46 = 0\n        var minChangeIndex47 = 0\n  \
    \      var minChangeIndex48 = 0\n        var minChangeIndex49 = 0\n        var\
    \ minChangeIndex50 = 0\n        var minChangeIndex51 = 0\n        var minChangeIndex52\
    \ = 0\n        var minChangeIndex53 = 0\n        var minChangeIndex54 = 0\n  \
    \      var minChangeIndex55 = 0\n        var minChangeIndex56 = 0\n        var\
    \ minChangeIndex57 = 0\n        var minChangeIndex58 = 0\n        var minChangeIndex59\
    \ = 0\n        var minChangeIndex60 = 0\n        var minChangeIndex61 = 0\n  \
    \      var minChangeIndex62 = 0\n        var minChangeIndex63 = 0\n        var\
    \ minChangeIndex64 = 0\n        var minChangeIndex65 = 0\n        var minChangeIndex66\
    \ = 0\n        var minChangeIndex67 = 0\n        var minChangeIndex68 = 0\n  \
    \      var minChangeIndex69 = 0\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmped95voot.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmped95voot.scala:90:5 ---------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805189
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = len\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n        var\
    \ temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n        var temp7 =\
    \ 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n  \
    \      var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n      \
    \  var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n        var\
    \ temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var temp20\
    \ = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n\
    \        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n    \
    \    var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n        var\
    \ temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var temp33\
    \ = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n\
    \        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n    \
    \    var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n        var\
    \ temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var temp46\
    \ = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n\
    \        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n    \
    \    var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n        var\
    \ temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var temp59\
    \ = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n\
    \        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n    \
    \    var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n        var\
    \ temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var temp72\
    \ = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n\
    \        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n    \
    \    var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n        var\
    \ temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var temp85\
    \ = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n\
    \        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n    \
    \    var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n        var\
    \ temp95 = 0\n        var temp96 = 0\n        var temp97 = 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2adkdjae.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2adkdjae.scala:118:5 --------------------\e\
    [0m\e[0m\n\e[31m118 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.min\n        val max = arr.max\n        val mid = len / 2\n\
    \        val midVal = arr(mid)\n        val midValReverse = arr(len - mid - 1)\n\
    \        val midValReverse2 = arr(len - mid - 2)\n        val midValReverse3 =\
    \ arr(len - mid - 3)\n        val midValReverse4 = arr(len - mid - 4)\n      \
    \  val midValReverse5 = arr(len - mid - 5)\n        val midValReverse6 = arr(len\
    \ - mid - 6)\n        val midValReverse7 = arr(len - mid - 7)\n        val midValReverse8\
    \ = arr(len - mid - 8)\n        val midValReverse9 = arr(len - mid - 9)\n    \
    \    val midValReverse10 = arr(len - mid - 10)\n        val midValReverse11 =\
    \ arr(len - mid - 11)\n        val midValReverse12 = arr(len - mid - 12)\n   \
    \     val midValReverse13 = arr(len - mid - 13)\n        val midValReverse14 =\
    \ arr(len - mid - 14)\n        val midValReverse15 = arr(len - mid - 15)\n   \
    \     val midValReverse16 = arr(len - mid - 16)\n        val midValReverse17 =\
    \ arr(len - mid - 17)\n        val midValReverse18 = arr(len - mid - 18)\n   \
    \     val midValReverse19 = arr(len - mid - 19)\n        val midValReverse20 =\
    \ arr(len - mid - 20)\n        val midValReverse21 = arr(len - mid - 21)\n   \
    \     val midValReverse22 = arr(len - mid - 22)\n        val midValReverse23 =\
    \ arr(len - mid - 23)\n        val midValReverse24 = arr(len - mid - 24)\n   \
    \     val midValReverse25 = arr(len - mid - 25)\n        val midValReverse26 =\
    \ arr(len - mid - 26)\n        val midValReverse27 = arr(len - mid - 27)\n   \
    \     val midValReverse28 = arr(len - mid - 28)\n        val midValReverse29 =\
    \ arr(len - mid - 29)\n        val midValReverse30 = arr(len - mid - 30)\n   \
    \     val midValReverse31 = arr(len - mid - 31)\n        val midValReverse32 =\
    \ arr(\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7ja19vno.scala:52:34 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mmidValReverse32\e[0m = arr(\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                  expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7ja19vno.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ja19vno.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.head\n        val\
    \ l = arr.tail\n        val p = arr.toList.reverse\n        val p2 = p.toList.reverse\n\
    \        val p3 = p2.toList.reverse\n        val p4 = p3.toList.reverse\n    \
    \    val p5 = p4.toList.reverse\n        val p6 = p5.toList.reverse\n        val\
    \ p7 = p6.toList.reverse\n        val p8 = p7.toList.reverse\n        val p9 =\
    \ p8.toList.reverse\n        val p10 = p9.toList.reverse\n        val p11 = p10.toList.reverse\n\
    \        val p12 = p11.toList.reverse\n        val p13 = p12.toList.reverse\n\
    \        val p14 = p13.toList.reverse\n        val p15 = p14.toList.reverse\n\
    \        val p16 = p15.toList.reverse\n        val p17 = p16.toList.reverse\n\
    \        val p18 = p17.toList.reverse\n        val p19 = p18.toList.reverse\n\
    \        val p20 = p19.toList.reverse\n        val p21 = p20.toList.reverse\n\
    \        val p22 = p21.toList.reverse\n        val p23 = p22.toList.reverse\n\
    \        val p24 = p23.toList.reverse\n        val p25 = p24.toList.reverse\n\
    \        val p26 = p25.toList.reverse\n        val p27 = p26.toList.reverse\n\
    \        val p28 = p27.toList.reverse\n        val p29 = p28.toList.reverse\n\
    \        val p30 = p29.toList.reverse\n        val p31 = p30.toList.reverse\n\
    \        val p32 = p31.toList.reverse\n        val p33 = p32.toList.reverse\n\
    \        val p34 = p33.toList.reverse\n        val p35 = p34.toList.reverse\n\
    \        val p36 = p35.toList.reverse\n        val p37 = p36.toList.reverse\n\
    \        val p38 = p37.toList.reverse\n        val p39 = p38.toList.reverse\n\
    \        val p40 = p39.toList.reverse\n        val p41 = p40.toList.reverse\n\
    \        val p42 = p41.toList.reverse\n        val p43 = p42.toList.reverse\n\
    \        val p44 = p43.toList.reverse\n        val p45 = p44.toList.reverse\n\
    \        val p46 = p45.toList.reverse\n        val p47 = p46.toList.reverse\n\
    \        val p48 = p47.toList.reverse\n        val p49 = p48.toList.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu08nuum0.scala:67:5\
    \ ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val min = arr.head\n        val max = arr.last\n        val mid = len /\
    \ 2\n        val leftArr = arr.take(mid)\n        val rightArr = arr.drop(mid)\n\
    \        val leftLen = leftArr.length\n        val rightLen = rightArr.length\n\
    \        val leftMin = leftArr.head\n        val leftMax = leftArr.last\n    \
    \    val rightMin = rightArr.head\n        val rightMax = rightArr.last\n    \
    \    val leftSum = leftArr.foldLeft(0l) { (sum, elem) => sum + elem }\n      \
    \  val rightSum = rightArr.foldLeft(0l) { (sum, elem) => sum + elem }\n      \
    \  val leftSumMin = leftSum - leftMin\n        val leftSumMax = leftSum - leftMax\n\
    \        val rightSumMin = rightSum - rightMin\n        val rightSumMax = rightSum\
    \ - rightMax\n        val leftSumMinMax = leftSumMin - leftSumMax\n        val\
    \ rightSumMinMax = rightSumMin - rightSumMax\n        val leftSumMinMaxSum = leftSumMinMax\
    \ * leftLen\n        val rightSumMinMaxSum = rightSumMinMax * rightLen\n     \
    \   val leftSumMinMaxSumMin = leftSumMinMaxSum * leftMin\n        val rightSumMinMaxSumMin\
    \ = rightSumMinMaxSum * rightMin\n        val leftSumMinMaxSumMinMax = leftSumMinMaxSumMin\
    \ * leftMax\n        val rightSumMinMaxSumMinMax = rightSumMinMaxSumMin * rightMax\n\
    \        val leftSumMinMaxSumMinMaxSum = leftSumMinMaxSumMinMax * leftSum\n  \
    \      val rightSumMinMaxSumMinMaxSum = rightSumMinMaxSumMinMax * rightSum\n \
    \       val leftSumMinMaxSumMinMaxSumMin = leftSumMinMaxSumMinMaxSum * leftSumMin\n\
    \        val rightSumMinMaxSumMinMaxSumMin = rightSumMinMaxSumMinMaxSum * rightSumMin\n\
    \        val leftSumMinMaxSumMinMaxSumMinMax = leftSumMinMaxSumMinMaxSumMin *\
    \ leftSumMax\n        val rightSumMinMaxSumMinMaxSumMinMax = rightSumMinMaxSumMinMaxSumMin\
    \ * rightSumMax\n        val leftSumMinMaxSumMinMaxSumMinMaxSum = left\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvitvztzp.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvitvztzp.scala:48:49 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mleftSumMinMaxSumMinMaxSumMinMaxSum\e\
    [0m = left\n\e[31m\e[31m   |\e[0m                                            \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                                             \
    \    Not found: left\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvitvztzp.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var min = 0\n        var max = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        while(i < len) {\n            max = Math.max(max,\
    \ arr(i))\n            min = Math.min(min, arr(i))\n            i += 1\n     \
    \   }\n        while(j < len) {\n            max = Math.max(max, arr(j))\n   \
    \         min = Math.min(min, arr(j))\n            j += 1\n        }\n       \
    \ while(k < (len-1)) {\n            max = Math.max(max, arr(k))\n            min\
    \ = Math.min(min, arr(k))\n            k += 1\n        }\n        val diff = max\
    \ - min\n        if(diff == 0) {\n            return 0\n        }\n        val\
    \ mid = (min + max) / 2\n        val mid1 = mid - 1\n        val mid2 = mid +\
    \ 1\n        val mid3 = mid + 2\n        val mid4 = mid - 2\n        val mid5\
    \ = mid - 3\n        val mid6 = mid - 4\n        val mid7 = mid - 5\n        val\
    \ mid8 = mid - 6\n        val mid9 = mid - 7\n        val mid10 = mid - 8\n  \
    \      val mid11 = mid - 9\n        val mid12 = mid - 10\n        val mid13 =\
    \ mid - 11\n        val mid14 = mid - 12\n        val mid15 = mid - 13\n     \
    \   val mid16 = mid - 14\n        val mid17 = mid - 15\n        val mid18 = mid\
    \ - 16\n        val mid19 = mid - 17\n        val mid20 = mid - 18\n        val\
    \ mid21 = mid - 19\n        val mid22 = mid - 20\n        val mid23 = mid - 21\n\
    \        val mid24 = mid - 22\n        val mid25 = mid - 23\n        val mid26\
    \ = mid - 24\n        val mid27 = mid - 25\n        val mid28 = mid - 26\n   \
    \     val mid29 = mid - 27\n        val mid30 = mid - 28\n        val mid31 =\
    \ mid - 29\n        val mid32 = mid - 30\n        val mid33 = mid - 31\n     \
    \   val mid34 = mid - 32\n        val mid35 = mid - 33\n        val mid36 = mid\
    \ - 34\n        val mid37 = mid - 35\n        val mid38 = mid - 36\n        val\
    \ mid39 = mid - 37\n        val mid40 = mid - 38\n        val mid41 = m\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsby1o0xr.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsby1o0xr.scala:82:20 ------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m        \e[33mval\e[0m \e[36mmid41\e[0m = m\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    Not\
    \ found: m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsby1o0xr.scala:83:5\
    \ ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val minChange = len\n        var i = 0\n        var j = 0\n        while\
    \ (i < len) {\n            val temp = arr(i)\n            val temp = temp.toLong\n\
    \            val temp = temp.toInt\n            if (temp > 0) {\n            \
    \    val temp = temp.toLong\n                val temp = temp.toInt\n         \
    \       val temp = temp.toLong\n                val temp = temp.toInt\n      \
    \          val temp = temp.toLong\n                val temp = temp.toInt\n   \
    \             val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n                val temp = temp.toInt\n\
    \                val temp = temp.toLong\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcucy0klr.scala:104:0 ---------------------------\e\
    [0m\e[0m\n\e[31m104 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcucy0klr.scala:15:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcucy0klr.scala:22:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e\
    [0m \e[36mtemp\e[0m = temp.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtemp is already defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpcucy0klr.scala:23:16 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = temp.toInt\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtemp is already\
    \ defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcucy0klr.scala:26:20 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m \e[36mtemp\e[0m = temp.toInt\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mtemp is already defined as \e[33mvalue\e[0m \e[35mtemp\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcucy0klr.scala:27:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mval\e\
    [0m \e[36mtemp\e[0m = temp.toLong\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtemp is already defined "
  stdout: ''
  timestamp: 1659805190
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.size\n        val m = arr.head\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ minIndex = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var minIndex = 0\n        var minIndex = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n        var maxIndex = 0\n        var maxIndex = 0\n\
    \        var max = 0\n        var maxIndex = 0\n        var maxIndex = 0\n   \
    \     var max = 0\n        var maxIndex = 0\n        var maxIndex = 0\n      \
    \  var max = 0\n        var maxIndex = 0\n        var maxIndex = 0\n        var\
    \ max = 0\n        var maxIndex = 0\n        var maxIndex = 0\n        var max\
    \ = 0\n        var maxIndex = 0\n        var maxIndex = 0\n        var max = 0\n\
    \        var maxIndex = 0\n        var maxIndex = 0\n        var max = 0\n   \
    \     var maxIndex = 0\n        var maxIndex = 0\n        var max = 0\n      \
    \  var maxIndex = 0\n        var maxIndex = 0\n        var max = 0\n        var\
    \ maxIndex = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n\
    \        var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n   \
    \     var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n      \
    \  var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n        var\
    \ max = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n        var maxIndex = 0\n        var max = 0\n  \
    \      var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n     \
    \   var max = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n        var maxIndex = 0\n        var max = 0\n  \
    \      var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n     \
    \   var max = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n        var maxIndex = 0\n        var max = 0\n  \
    \      var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n     \
    \   var max = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n        var maxIndex = 0\n        var max = 0\n  \
    \      var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n     \
    \   var max = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n        var maxIndex = 0\n        var max = 0\n  \
    \      var maxIndex = 0\n        var max = 0\n        var maxIndex = 0\n     \
    \   var max = 0\n        var maxIndex = 0\n        var max = 0\n        var maxIndex\
    \ = 0\n        var max = 0\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1rv74fvp.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mmaxIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1rv74fvp.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mminIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminIndex is already defined as \e[33mvariable\e[0m \e[35mminIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1rv74fvp.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mvar\e[0m \e[36mminIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminIndex is already\
    \ defined as \e[33mvariable\e[0m \e[35mminIndex\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1rv74fvp.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mmaxIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndex is already defined as \e[33mvariable\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1rv74fvp.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mvar\e[0m \e[36mmax\e[0m = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax is already defined as \e\
    [33mvariable\e[0m \e[35mmax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Nam"
  stdout: ''
  timestamp: 1659805192
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.sortBy(_).reverse\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while (i < len) {\n            while (j < len) {\n                if\
    \ (arr(i) == arr(j)) {\n                    j++\n                } else {\n  \
    \                  k = j\n                    while (k < len) {\n            \
    \            if (arr(i) != arr(k)) {\n                            k = k + 1\n\
    \                        } else {\n                            if (arr(i) < arr(k))\
    \ {\n                                min = arr(i) - arr(k)\n                 \
    \               break\n                            } else {\n                \
    \                min = arr(k) - arr(i)\n                                break\n\
    \                            }\n                        }\n                  \
    \  }\n                    j++\n                }\n            }\n            i\
    \ += 1\n        }\n        min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpe77mja6f.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpe77mja6f.scala:40:23 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpe77mja6f.scala:15:29\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e\
    [0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\e[31m\e[31m   |\e[0m            \
    \                 ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded\
    \ function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpe77mja6f.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpe77mja6f.scala:33:32 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                                break\n\e[31m\e[31m \
    \  |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                       Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpe77mja6f.scala:36:32 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                                break\n\e[31m\e[31m   |\e\
    [0m                              "
  stdout: ''
  timestamp: 1659805191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     var count = 0\n        var min = Long.MaxValue\n        var max = 0\n  \
    \      var i = 0\n        var j = 0\n        while (i < len) {\n            val\
    \ temp = arr(i)\n            val temp2 = arr(j)\n            if (temp == temp2)\
    \ {\n                count += 1\n                i += 1\n                j +=\
    \ 1\n            } else if (temp > temp2) {\n                count += 1\n    \
    \            i += 1\n            } else {\n                count += 1\n      \
    \          j += 1\n            }\n            if (count > max) {\n           \
    \     max = count\n            }\n            if (count < min) {\n           \
    \     min = count\n            }\n        }\n        if (max > min) {\n      \
    \      min\n        } else {\n            max\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4_zpa24y.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpewmprc29.scala:63:22 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpewmprc29.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpewmprc29.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val arr = arr.toList\n        var min = 0\n        var max\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var count\
    \ = 0\n        while(i < arr.length) {\n            max = arr(i)\n           \
    \ while(j < arr.length) {\n                if(arr(i) == arr(j)) {\n          \
    \          count += 1\n                    j++\n                }\n          \
    \      else {\n                    if(arr(i) < arr(j)) {\n                   \
    \     max = arr(j)\n                    }\n                    else {\n      \
    \                  max = arr(i)\n                    }\n                }\n  \
    \          }\n            if(count < min) {\n                min = count\n   \
    \         }\n            count = 0\n            i++\n        }\n        min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcf_msmto.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpcf_msmto.scala:42:15 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m            i++\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcf_msmto.scala:15:18 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805191
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given a list arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the list palindromic. A palindromic\
    \ list is a list that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    //\
    \ (1l)\n    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long])\
    \ : Long = {\n        val n = arr.length\n        val m = arr.max\n        val\
    \ arr = arr.sortWith(_ < _)\n        val arr2 = arr.toList\n        val arr3 =\
    \ arr2.reverse\n        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toList\n        val arr7 = arr6.toList\n        val arr8\
    \ = arr7.toList\n        val arr9 = arr8.toList\n        val arr10 = arr9.toList\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val\
    \ arr13 = arr12.toList\n        val arr14 = arr13.toList\n        val arr15 =\
    \ arr14.toList\n        val arr16 = arr15.toList\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toList\n        val arr19 = arr18.toList\n        val\
    \ arr20 = arr19.toList\n        val arr21 = arr20.toList\n        val arr22 =\
    \ arr21.toList\n        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n\
    \        val arr25 = arr24.toList\n        val arr26 = arr25.toList\n        val\
    \ arr27 = arr26.toList\n        val arr28 = arr27.toList\n        val arr29 =\
    \ arr28.toList\n        val arr30 = arr29.toList\n        val arr31 = arr30.toList\n\
    \        val arr32 = arr31.toList\n        val arr33 = arr32.toList\n        val\
    \ arr34 = arr33.toList\n        val arr35 = arr34.toList\n        val arr36 =\
    \ arr35.toList\n        val arr37 = arr36.toList\n        val arr38 = arr37.toList\n\
    \        val arr39 = arr38.toList\n        val arr40 = arr39.toList\n        val\
    \ arr41 = arr40.toList\n        val arr42 = arr41.toList\n        val arr43 =\
    \ arr42.toList\n        val arr44 = arr43.toList\n        val arr45 = arr44.toList\n\
    \        val arr46 = arr45.toList\n        val arr47 = arr46.toList\n        val\
    \ arr48 = arr47.toList\n        val arr49 = arr48.toList\n        val arr50 =\
    \ arr49.toList\n        val arr51 = arr50.to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnr5w2dbb.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnr5w2dbb.scala:68:5 ---------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805192
