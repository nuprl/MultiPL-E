language: scala
name: HumanEval_9_rolling_max
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.clear()\n            rollingMax.push(number)\n\
    \            rollingMax.foreach { rollingMax =>\n                if (rollingMax.compareTo(_)\
    \ > 0) {\n                    rollingMax.clear()\n                    rollingMax.push(number)\n\
    \                }\n            }\n        }\n        rollingMax.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpppwhj43e.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max += ((x, x)))\n        val maxList = max.toList.sortWith(_._2 > _._2)\n \
    \       val result = new mutable.ArrayList[Long]()\n        for(i <- 0 until maxList.size)\
    \ {\n            val max = maxList(i)\n            val rollingMax = maxList.drop(i).takeWhile(_._2\
    \ > max).last\n            result += rollingMax\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp88fhpi19.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp88fhpi19.scala:12:25\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        }\n        val maxList = max.values.toList\n        val maxListWithIndex\
    \ = maxList.zipWithIndex.sortBy(_._1).reverse\n        val maxListWithIndex =\
    \ maxListWithIndex.takeWhile(_._2 <= numbers.size).reverse\n        val maxListWithIndex\
    \ = maxListWithIndex.map(_._1).toList\n        maxListWithIndex\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfvsbxbsw.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxListWithIndex\e[0m =\
    \ maxListWithIndex.takeWhile(_._2 <= numbers.size).reverse\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWithIndex is already defined as \e[33mvalue\e[0m \e\
    [35mmaxListWithIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfvsbxbsw.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxListWithIndex\e[0m =\
    \ maxListWithIndex.map(_._1).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWithIndex is already defined as \e[33mvalue\e[0m \e\
    [35mmaxListWithIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfvsbxbsw.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxValue = number match {\n                case x if x\
    \ > maxList.length => x\n                case x => maxList(x)\n            }\n\
    \            maxList += maxValue\n        })\n        maxList.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbufnd9sk.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.head :: rollingMax\n \
    \           } else {\n                rollingMax.head :: rollingMax.tail.max\n\
    \            }\n        })\n        rollingMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp29tw4535.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp29tw4535.scala:14:32 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                rollingMax.head :: rollingMax.tail.max\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                value :: is not a member of\
    \ Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659795252
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        var max = 0L\n       \
    \ numbers.foreach { number =>\n            max = math.max(max, number)\n     \
    \       maxList += number\n        }\n        maxList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5vd3rr40.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => {\n            if (max.size < x) {\n           \
    \     max += x\n                rollingMax += x\n            }\n        })\n \
    \       rollingMax.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpygh3ckja.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpygh3ckja.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxNumber = numbers.max\n            if (number > maxNumber)\
    \ {\n                maxList += maxNumber\n            }\n        })\n       \
    \ maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpabgoscx8.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            val maxKey = max.minKey\n            if (maxKey == null || n\
    \ < maxKey) {\n                max.put(n, n)\n            } else {\n         \
    \       val maxValue = max.getOrElse(n, n)\n                max.put(n, maxValue\
    \ + 1)\n            }\n        })\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(n => result += n)\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbc32fva3.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbc32fva3.scala:19:25\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val rollingMax = acc.lastOption.map(_ + x)\n            rollingMax.getOrElse(acc.head\
    \ + x)\n        })\n        rollingMax.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnfoah80q.scala:11:32\
    \ --------------------\e[0m\e[0m\n\e[31m11 |\e[0m            rollingMax.getOrElse(acc.head\
    \ + x)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    Long\n\e[31m   |\e[0m            Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = number.toLong\n            val maxValue = max.getOrElseUpdate(maxKey,\
    \ 0l)\n            val newMaxValue = maxValue + number\n            max.put(maxKey,\
    \ newMaxValue)\n        }\n        val maxList = max.toList.sortBy(_._2).reverse\n\
    \        val maxListWithMax = maxList.takeWhile(_._2 != 0l).reverse\n        val\
    \ maxListWithoutMax = maxList.takeWhile(_._2 == 0l).reverse\n        val maxListWithMaxAndMax\
    \ = maxListWithMax.takeWhile(_._2 != 0l).reverse\n        val maxListWithoutMaxAndMax\
    \ = maxListWithoutMax.takeWhile(_._2 == 0l).reverse\n        val maxListWithMaxAndMaxAndMax\
    \ = maxListWithMaxAndMax.takeWhile(_._2 != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMax\
    \ = maxListWithoutMaxAndMax.takeWhile(_._2 == 0l).reverse\n        val maxListWithMaxAndMaxAndMaxAndMax\
    \ = maxListWithMaxAndMaxAndMax.takeWhile(_._2 != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMaxAndMax\
    \ = maxListWithoutMaxAndMaxAndMax.takeWhile(_._2 == 0l).reverse\n        val maxListWithMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithMaxAndMaxAndMaxAndMax.takeWhile(_._2 != 0l).reverse\n        val\
    \ maxListWithoutMaxAndMaxAndMaxAndMaxAndMax = maxListWithoutMaxAndMaxAndMaxAndMax.takeWhile(_._2\
    \ == 0l).reverse\n        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMaxAndMaxAndMax.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithoutMaxAndMaxAndMaxAndMaxAndMax.takeWhile(_._2 == 0l).reverse\n\
    \        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMax.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithoutMaxAnd\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaev1g_p.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaev1g_p.scala:30:68\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListWithoutMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\e[0m = maxListWithoutMaxAnd\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                   Not found: maxListWithoutMaxAnd\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgaev1g_p.scala:31:5 ---------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result += x)\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxabm6ofo.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxabm6ofo.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            if (max.containsKey(number)) {\n                val maxValue\
    \ = max.get(number)\n                if (number > maxValue) {\n              \
    \      max.put(number, number)\n                } else {\n                   \
    \ max.put(number, maxValue)\n                }\n            } else {\n       \
    \         max.put(number, number)\n            }\n        }\n        max.values.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5f8u44zg.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val res = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => res += x)\n        res\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3wdk32g.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3wdk32g.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mres\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            val max = max.getOrElseUpdate(n, 0l)\n            val cur = max\n\
    \            val curMax = if (cur > n) cur else n\n            val curMaxIndex\
    \ = numbers.indexOf(n)\n            val curMaxIndex = if (curMaxIndex < 0) curMaxIndex\
    \ + 1 else curMaxIndex\n            max.put(curMax, curMaxIndex)\n        })\n\
    \        val maxList = max\n        val maxListSize = maxList.size\n        val\
    \ maxListIterator = maxList.iterator\n        val maxListIteratorSize = maxListIterator.size\n\
    \        val maxListIteratorIterator = maxListIterator.iterator\n        val maxListIteratorIteratorSize\
    \ = maxListIteratorIterator.size\n        val maxListIteratorIteratorIterator\
    \ = maxListIteratorIterator.iterator\n        val maxListIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIterator.size\n        val maxListIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIterator.iterator\n        val maxListIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIterator.size\n        val maxListIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIterator.iterator\n        val maxListIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIterator.size\n        val maxListIteratorIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIteratorIterator.iterator\n        val maxListIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIterator.size\n        val\
    \ maxListIteratorIteratorIteratorIteratorIteratorIteratorIterator = maxListIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n   \
    \     val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIterator\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5fuc3flk.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5fuc3flk.scala:15:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36mcurMaxIndex\e[0m = \e[33mif\e[0m (curMaxIndex < \e[31m0\e[0m) curMaxIndex\
    \ + \e[31m1\e[0m \e[33melse\e[0m curMaxIndex\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcurMaxIndex is already defined as \e[33mvalue\e[0m \e[35mcurMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp5fuc3flk.scala:40:5 ---------------------\e[0m\e[0m\n\
    \e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            if (max.containsKey(n)) {\n                max.update(n, max(max(n),\
    \ n))\n            } else {\n                max.put(n, n)\n            }\n  \
    \      })\n        val result = new mutable.ListBuffer[Long]()\n        max.values.foreach(n\
    \ => result += n)\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphi6tk36f.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphi6tk36f.scala:17:25\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val max = number.toLong\n            if (max.isDefined) {\n\
    \                val maxKey = max.key\n                if (maxKey > max.value)\
    \ {\n                    max.value = maxKey\n                }\n            }\n\
    \        }\n        numbers.toList.map(_.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplbqywwc5.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplbqywwc5.scala:12:20\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m            \e[33mif\e[0m\
    \ (max.isDefined) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value isDefined is not a member of Long\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmplbqywwc5.scala:13:33 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                \e[33mval\e[0m \e[36mmaxKey\e[0m = max.key\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             value key is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmplbqywwc5.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    max.value = maxKey\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    value value is not a member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1659795252
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxRollingNumbers = mutable.ListBuffer.empty[Long]\n        val rollingNumbers\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach{ number =>\n     \
    \       rollingNumbers += number\n            val maxRollingNumber = rollingNumbers.max\n\
    \            if (maxRollingNumber > maxRollingNumbers.last)\n                maxRollingNumbers\
    \ += maxRollingNumber\n        }\n        maxRollingNumbers\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmta2x3_y.scala:9:32 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxRollingNumbers\e[0m =\
    \ mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  |\e[0m            \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                            \
    \    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmta2x3_y.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingNumbers\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach{ n\
    \ =>\n            val maxKey = max.max.key\n            if (maxKey < n) max.put(n,\
    \ maxKey)\n            else max.remove(n)\n        }\n        max.toList.sortBy(_._1).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjxfnsdmv.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max += ((x, x)))\n        val maxList = max.toList.sortBy(_._1).reverse\n  \
    \      val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListElementIndex\
    \ = maxListIndex - 1\n        val maxListElementSize = maxListElement.length\n\
    \        val maxListElementIndexSize = maxListElementIndex.length\n        val\
    \ maxListElementIndexLast = maxListElementIndex.last\n        val maxListElementIndexLastSize\
    \ = maxListElementIndexLast.length\n        val maxListElementIndexLastLast =\
    \ maxListElementIndexLast.last\n        val maxListElementIndexLastLastSize =\
    \ maxListElementIndexLastLast.length\n        val maxListElementIndexLastLastLast\
    \ = maxListElementIndexLastLast.last\n        val maxListElementIndexLastLastLastSize\
    \ = maxListElementIndexLastLastLast.length\n        val maxListElementIndexLastLastLastLast\
    \ = maxListElementIndexLastLastLast.last\n        val maxListElementIndexLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLast.last\n        val maxListElementIndexLastLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLastLast.last\n        val maxListElementIndexLastLastLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLastLastLastLast.last\n        val maxListElementIndexLastLastLastLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLastLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLastLastLastLastLastLast.last\n        val\
    \ maxListElementIndexLastLastLastLastLastLastLastLastSize = maxListElementIndexLastLastLastLastLastLastLastLastLast.length\n\
    \        val maxListElementIndexLastLastLastLastLastLastLastLastLast = maxListElementIndexLastLastLastLastLastLastLastLastLastLastLast.last\n\
    \        val maxListElementIndexLastLastLastLastLastLastLastLast\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb_cpzwh_.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb_cpzwh_.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpb_cpzwh_.scala:30:62 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxListElementIndexLastLastLastLastLastLastLast\e\
    [0m = maxListElementIndexLastLastLastLastLastLastLast.last\n\e[31m\e[31m   |\e\
    [0m                                                              ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxListElementIndexLastLastLastLastLastLastLast\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb_cpzwh_.scala:34:70\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListElementIndexLastLastLastLastLastLastLastLastLast\e[0m = maxListElementIndexLastLastLastLastLastLastLastLastLastLastLast.last\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxListElementIndexLastLastLastLastLastLastLastLastLastLastLast\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb_cpzwh_.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        val maxIndex = numbers.indexOf(0)\n\
    \        numbers.foreach { n =>\n            if (n >= maxIndex) {\n          \
    \      maxList += maxIndex\n                maxIndex += 1\n            }\n   \
    \     }\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphfvp19go.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmphfvp19go.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                maxIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value\
    \ += is not a member of Int - did you mean maxIndex.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659795250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        max.values.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp09vcxjwb.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        max.values.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp09vcxjwb.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val result: List[Long] = new\
    \ mutable.ListBuffer[Long]()\n        val maxKey = max.keys.max\n        val maxValue\
    \ = max.get(maxKey)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n     \
    \   val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKey\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqo26iri7.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqo26iri7.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxKeyIndex\e[0m = numbers.indexOf(maxKey)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxKeyIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxKeyIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqo26iri7.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxValueIndex\e[0m = numbers.indexOf(maxValue)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqo26iri7.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxKeyIndex\e[0m = numbers.indexOf(maxKey)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxKeyIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxKeyIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqo26iri7.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxValueIndex\e[0m = numbers.indexOf(maxValue)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValueIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxValueIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] N"
  stdout: ''
  timestamp: 1659795252
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        numbers.foreach { x =>\n\
    \            val maxIndex = max.indexOf(x)\n            if (maxIndex == -1) {\n\
    \                max += x\n            } else {\n                max += max(maxIndex\
    \ - 1)\n            }\n        }\n        max.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnn49x9fj.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList.sortWith(_\
    \ > _)\n        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListValue = maxList(maxListIndex)\n        val maxListIndex\
    \ = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n     \
    \   val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3d0sl7v9.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d0sl7v9.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListIndex\e[0m = maxListIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxListIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d0sl7v9.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListValue\e[0m = maxList(maxListIndex)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxListValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListValue\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d0sl7v9.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListIndex\e[0m = maxListIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxListIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d0sl7v9.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListValue\e[0m = maxList(maxListIndex)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxListValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListValue\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3d0sl"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortWith(_.key\
    \ < _.key).reverse\n        val maxListWithMax = maxList.takeWhile(x => x.key\
    \ < numbers.last).reverse\n        val maxListWithoutMax = maxList.dropWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithMax = maxListWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMax =\
    \ maxListWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n        val\
    \ maxListWithoutMaxWithoutMaxWithMax = maxListWithoutMaxWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithMax = maxListWithoutMaxWithoutMaxWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax.takeWhile(x => x.key\
    \ < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax.takeWhile(x => x.key\
    \ < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithout\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp54wnfti7.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp54wnfti7.scala:25:92\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\e\
    [0m = maxListWithoutMaxWithout\n\e[31m\e[31m   |\e[0m                        \
    \                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: maxListWithoutMaxWithout\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp54wnfti7.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795259
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val maxIndex = acc.lastIndexWhere(y => y > x)\n            if (maxIndex ==\
    \ -1)\n                acc :+ x\n            else\n                acc :+ max(acc(maxIndex),\
    \ x)\n        })\n        rollingMax.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgzghknhm.scala:20)\n\tat Problem.main(tmpgzghknhm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortWith(_.key\
    \ < _.key)\n        val maxListSize = maxList.size\n        val maxListTail =\
    \ maxList.tail\n        val maxListTailSize = maxListTail.size\n        val maxListTailTail\
    \ = maxListTail.tail\n        val maxListTailTailSize = maxListTailTail.size\n\
    \        val maxListTailTailTail = maxListTailTail.tail\n        val maxListTailTailTailSize\
    \ = maxListTailTailTail.size\n        val maxListTailTailTailTail = maxListTailTailTail.tail\n\
    \        val maxListTailTailTailTailSize = maxListTailTailTailTail.size\n    \
    \    val maxListTailTailTailTailTail = maxListTailTailTailTailTail.tail\n    \
    \    val maxListTailTailTailTailTailSize = maxListTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailTailTail = maxListTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpickw7u2n.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpickw7u2n.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpickw7u2n.scala:21:42 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxListTailTailTailTailTail\e[0m = maxListTailTailTailTailTail.tail\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mmaxListTailTailTailTailTail\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpickw7u2n.scala:23:46\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListTailTailTailTailTailTail\e[0m = maxListTailTailTailTailTailTail.tail\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0m              Recursive \e[33mvalue\e[0m \e[35mmaxListTailTailTailTailTailTail\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpickw7u2n.scala:33:66\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListTailTailTailTailTailTailTailTailTailTailTail\e[0m = maxListTailTailTailTailTailTailTailTailTailTailTailTail.tail\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      Not found: maxListTailTailTailTailTailTailTailTailTailTailTailTail\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = number match {\n                case x\
    \ if x > maxList.length => x\n                case x => maxList(x)\n         \
    \   }\n            maxList += maxValue\n        }\n        maxList.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi0xbs39j.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n        }\n        rollingMax.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppe70wzrn.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result.add(x)) // add all elements to result\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5e74f38q.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5e74f38q.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        })\n        val maxList = max.toList.sortWith((x, y) => x._2 > y._2)\n\
    \        val maxListWithIndex = maxList.zipWithIndex.filter(_._2 != 0).map(_._1)\n\
    \        val maxListWithIndexAndMax = maxListWithIndex.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMax = maxListWithIndexAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMax = maxListWithIndexAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMax = maxListWithIndexAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2 == _._2).map(_._1)\n\
    \        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAnd\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7ea6w8h4.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7ea6w8h4.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\e[0m\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp7ea6w8h4.scala:9:22 -------------------------\e[0m\e[0m\n\
    \e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp7ea6w8h4.scala:29:5 ---------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795258
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length\
    \ - 1) {\n                acc :+ x\n            } else {\n                acc\
    \ :+ max(acc(maxIndex + 1), x)\n            }\n        })\n        rollingMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgwjwt7km.scala:21)\n\tat Problem.main(tmpgwjwt7km.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val result: List[Long] = new\
    \ mutable.ListBuffer[Long]()\n        max.values.foreach(x => if (x > result.last)\
    \ result += x)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuqmdj2__.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuqmdj2__.scala:11:37\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        val maxKey = max.keySet().iterator().next()\n        val maxValue = max.get(maxKey)\n\
    \        val maxKeyList = List(maxKey)\n        val maxValueList = List(maxValue)\n\
    \        val maxKeySet = max.keySet()\n        val maxValueSet = max.values\n\
    \        while(maxKeySet.hasNext) {\n            val maxKey = maxKeySet.next()\n\
    \            val maxValue = maxValueSet.next()\n            val maxKeyList = List(maxKey)\n\
    \            val maxValueList = List(maxValue)\n            val maxKeySet = max.keySet()\n\
    \            val maxValueSet = max.values\n            val maxKeySetIterator =\
    \ maxKeySet.iterator()\n            val maxValueSetIterator = maxValueSet.iterator()\n\
    \            while(maxKeySetIterator.hasNext && maxValueSetIterator.hasNext) {\n\
    \                val maxKeyValue = maxKeySetIterator.next()\n                val\
    \ maxValueValue = maxValueSetIterator.next()\n                val maxKeyList =\
    \ List(maxKeyValue)\n                val maxValueList = List(maxValueValue)\n\
    \                val maxKeySetIterator = maxKeySet.iterator()\n              \
    \  val maxValueSetIterator = maxValueSet.iterator()\n                while(maxKeySetIterator.hasNext\
    \ && maxValueSetIterator.hasNext) {\n                    val maxKeyValue = maxKeySetIterator.next()\n\
    \                    val maxValueValue = maxValueSetIterator.next()\n        \
    \            val maxKeyList = List(maxKeyValue)\n                    val maxValueList\
    \ = List(maxValueValue)\n                    val maxKeySetIterator = maxKeySet.iterator()\n\
    \                    val maxValueSetIterator = maxValueSet.iterator()\n      \
    \              while(maxKeySetIterator.hasNext && maxValueSetIterator.hasNext)\
    \ {\n                        val maxKeyValue = maxKeySetIterator.next()\n    \
    \                    val maxValueValue = maxValueSetIterator.next()\n        \
    \                val maxKeyList = List(maxKeyValue)\n                        val\
    \ maxValueList = List(maxValueValue)\n                        val maxKeySetIterator\
    \ = maxKeySet.iterator()\n                        val maxValueSetIterator = maxValueSet.iterator()\n\
    \                        while(maxKeySetIterator.hasNext && maxValueSetIterator.hasNext)\
    \ {\n                            val maxKeyValue = maxKeySetIterator.next()\n\
    \                            val maxValueValue = maxValueSetIterator.next()\n\
    \                            val \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp76191r9i.scala:51:31 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                            \e[33mval\e[0m \n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp76191r9i.scala:61:0 ----------------------------\e[0m\e\
    [0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp76191r9i.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp76191r9i.scala:11:26 ------------------------\e[0m\e[0m\n\e[31m11 |\e\
    [0m        \e[33mval\e[0m \e[36mmaxList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [33m\e[33m-- Warning: /tmp/tmp76191r9i.scala:53:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m53 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.last\n            } else\
    \ {\n                if (number > rollingMax(maxIndex)) {\n                  \
    \  rollingMax(maxIndex)\n                } else {\n                    number\n\
    \                }\n            }\n        })\n        rollingMax.reverse\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb0eapgvl.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb0eapgvl.scala:12:27 --------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                rollingMax.last\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found: \
    \   Long\n\e[31m   |\e[0m                Required: \e[1m\e[32mList\e[0m\e[1m\e\
    [32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb0eapgvl.scala:15:30 --------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m                    rollingMax(maxIndex)\n\e[31m\e[31m   |\e[0m      \
    \              ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    Long\n\e[31m   |\e[0m                    Required: \e[1m\e[32mList\e[0m\e\
    [1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpb0eapgvl.scala:17:20 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                    number\n\e[31m\e[31m   |\e[0m        \
    \            ^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:    (number\
    \ : Long)\n\e[31m   |\e[0m                    Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            if (max.containsKey(n)) {\n                val max = max.getOrElseUpdate(n,\
    \ n)\n                max.toLong\n            } else {\n                val max\
    \ = n\n                max.toLong\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0vfp_wx6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0vfp_wx6.scala:10:24\
    \ --------------------\e[0m\e[0m\n\e[31m10 |\e[0m        numbers.foreach { \e\
    [36mn\e[0m =>\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Unit\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m11 |\e[0m      \
    \      \e[33mif\e[0m (max.containsKey(n)) {\n\e[31m12 |\e[0m                \e\
    [33mval\e[0m \e[36mmax\e[0m = max.getOrElseUpdate(n, n)\n\e[31m13 |\e[0m     \
    \           max.toLong\n\e[31m14 |\e[0m            } \e[33melse\e[0m {\n\e[31m15\
    \ |\e[0m                \e[33mval\e[0m \e[36mmax\e[0m = n\n\e[31m16 |\e[0m   \
    \             max.toLong\n\e[31m17 |\e[0m            }\n\e[31m18 |\e[0m      \
    \  }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ max.put(n, max.getOrElse(n, n) + n))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val rollingMax = maxList.takeWhile(n => n < numbers(numbers.size - 1))\n\
    \        rollingMax.map(n => numbers(numbers.size - 1 - n))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8r02dho1.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max += (x, x))\n        val result = new mutable.ListBuffer[Long]()\n      \
    \  numbers.foreach(x => {\n            val max = max get x\n            if (max\
    \ > x) result += max\n            max += x\n        })\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpma706s8p.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpma706s8p.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795258
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, number) => {\n   \
    \         val rollingMax = acc.lastOption.map { max =>\n                if (number\
    \ > max) number else max\n            }.getOrElse(number)\n            acc :+\
    \ rollingMax\n        })\n        rollingMax.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa3je30mb.scala:19)\n\tat Problem.main(tmpa3je30mb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            if (rollingMax.last.isDefined && rollingMax.last.get.compareTo(_)\
    \ > 0) {\n                rollingMax.last\n            } else {\n            \
    \    rollingMax :+ number\n            }\n        })\n        rollingMax\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpn9a1_e6r.scala:10:75 -----------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mif\e[0m (rollingMax.last.isDefined\
    \ && rollingMax.last.get.compareTo(_) > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                                                                           ^\e\
    [0m\n\e[31m   |\e[0mMissing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0mI\
    \ could not infer the type of the parameter _$1 of expanded function:\n\e[31m\
    \   |\e[0m_$1 => rollingMax.last.isDefined && rollingMax.last.get.compareTo(_$1)\
    \ > 0.\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn9a1_e6r.scala:10:32 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mif\e[0m (rollingMax.last.isDefined\
    \ && rollingMax.last.get.compareTo(_) > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \   value isDefined is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpn9a1_e6r.scala:11:27 --------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m                rollingMax.last\n\e[31m\e[31m   |\e[0m               \
    \ ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    Long\n\e[31m\
    \   |\e[0m                Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e\
    [1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(_ > number)\n            if\
    \ (maxIndex == -1) {\n                maxes += number\n            } else {\n\
    \                maxes(maxIndex) = max(maxes(maxIndex), number)\n            }\n\
    \        }\n        maxes.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvng0u4j0.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = number.toLong\n            val maxValue = max.getOrElseUpdate(maxKey,\
    \ 0l)\n            val newMaxValue = maxValue + 1\n            max.put(maxKey,\
    \ newMaxValue)\n        }\n        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        max.foreach { case (key, value) =>\n            maxList += key\n    \
    \    }\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnguqh9n9.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnguqh9n9.scala:16:22\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxList\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = max max number\n            max += number -> maxKey\n\
    \        }\n        max max numbers.lastOption.getOrElse(numbers.last)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuywj_mgw.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex\
    \ + 1, number)\n        })\n        rollingMax.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2tzzfb8t.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += number\n            } else {\n        \
    \        maxList += maxList(maxIndex - 1)\n            }\n        }\n        maxList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp83rewu01.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxListWithIndex = maxList.zipWithIndex.filter(_._2 % 2 == 0)\n \
    \       val maxListWithoutIndex = maxList.filter(_._2 % 2 == 0)\n        val maxListWithIndex\
    \ = maxListWithIndex.map(_._1)\n        val maxListWithoutIndex = maxListWithoutIndex.map(_._1)\n\
    \        val maxListWithoutIndexWithIndex = maxListWithoutIndex.zip(maxListWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndex = maxListWithoutIndex.zip(maxListWithoutIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithIndex = maxListWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndex = maxListWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpos36d_ek.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpos36d_ek.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListWithIndex\e[0m = maxListWithIndex.map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxListWithIndex is already defined as \e[33mvalue\e[0m \e[35mmaxListWithIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpos36d_ek.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxListWithoutIndex\e[0m = maxListWithoutIndex.map(_._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWithoutIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxListWithoutIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpos36d_ek.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpos36d_ek.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795264
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => max.put(x, max(x.getOrElse(x, 0l) + 1)));\n    \
    \    max.values.foreach(x => maxList += x);\n        maxList.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph02zjrj0.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph02zjrj0.scala:10:26\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val maxKey = max.keys.max\n        val maxValue = max.values.max\n  \
    \      val currentMax = max.getOrElse(maxKey, 0L)\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val current\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcc96md1b.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcc96md1b.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcurrentMaxKey\e[0m = maxKey\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrentMaxKey is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxKey\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcc96md1b.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mcurrentMaxValue\e[0m = maxValue\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurrentMaxValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxValue\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcc96md1b.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcurrentMaxKey\e[0m = maxKey\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrentMaxKey is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxKey\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcc96md1b.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mcurrentMaxValue\e[0m = maxValue\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurrentMaxValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxValue\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcc96md1b.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33m"
  stdout: ''
  timestamp: 1659795266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach{ number\
    \ =>\n            val maxNumber = maxList.toList.max\n            if (number >\
    \ maxNumber) {\n                maxList += number\n            }\n        }\n\
    \        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1u67nuao.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.updated(maxIndex + 1,\
    \ number)\n            } else {\n                rollingMax.updated(maxIndex +\
    \ 1, rollingMax(maxIndex + 1) + number)\n            }\n        })\n        rollingMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvj4321dp.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = number match {\n                case x\
    \ if x > maxList.length => x\n                case x => maxList(x)\n         \
    \   }\n            maxList += maxValue\n        }\n        maxList.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi0xbs39j.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => max.put(x, max(x.getOrElse(x, 0l) + 1)));\n    \
    \    max.foreach(x => maxList += x)\n        maxList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp0lbncx3.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp0lbncx3.scala:10:26\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n   \
    \     var maxValue = numbers(0)\n        numbers.foreach(n => {\n            if\
    \ (n > maxValue) {\n                maxValue = n\n                maxIndex = 0\n\
    \            }\n            if (n == maxValue) {\n                max += maxIndex\n\
    \            }\n            maxIndex += 1\n        })\n        max += maxIndex\n\
    \        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe4hsoe50.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795264
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = max max number\n            max += number -> (maxKey\
    \ + 1)\n        }\n        val maxList = max.values.toList\n        val maxListCopy\
    \ = maxList.clone()\n        val maxListCopy.sortWith(_ < _)\n        val maxListCopy.tail\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphfzt1gw8.scala:17:0 ----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m maxListCopy.tail\n\e[31m\e[31m\
    \   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=' expected, but 'end of statement' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphfzt1gw8.scala:18:4 ----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphfzt1gw8.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmphfzt1gw8.scala:16:35 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m maxListCopy.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                Not found: <\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphfzt1gw8.scala:18:5 ---------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            val maxKey = max.getOrElseUpdate(n, 0)\n            max.update(n,\
    \ (maxKey + 1))\n        })\n        max.values.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2676huyl.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) {\n                rollingMax :+ number\n            }\
    \ else {\n                rollingMax\n            }\n        })\n        rollingMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8ewhzecg.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        })\n        val maxList = max.toList.sortBy(_._2).reverse\n        val\
    \ maxElement = maxList.head._1\n        val maxCount = maxList.head._2\n     \
    \   val rollingMax = maxList.take(maxCount)\n        rollingMax.map(n => max(n)\
    \ - maxElement)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4yxiyk0t.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            val maxKey = max.getOrElseUpdate(n, 0l)\n            if (maxKey\
    \ > n) max.put(n, maxKey)\n        })\n        val maxList = max\n           \
    \ .filter(_._2 > numbers.last)\n            .map(_._1)\n        val maxListWithLast\
    \ = maxList :+ numbers.last\n        val maxListWithLastAndRest = maxListWithLast\
    \ :+ numbers.drop(numbers.size - 1)\n        val maxListWithLastAndRestWithLast\
    \ = maxListWithLastAndRest :+ numbers.last\n        val maxListWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLast :+ numbers.drop(numbers.size - 1)\n       \
    \ val maxListWithLastAndRestWithLastAndRestWithLast = maxListWithLastAndRestWithLastAndRest\
    \ :+ numbers.last\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLast :+ numbers.drop(numbers.size\
    \ - 1)\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRest :+ numbers.last\n   \
    \     val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLast :+ numbers.drop(numbers.size\
    \ - 1)\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest :+ numbers.last\n\
    \        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ :+ numbers.drop(numbers.size - 1)\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ :+ numbers.last\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAnd\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoldhxils.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoldhxils.scala:28:112\
    \ -----------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\e\
    [0m = maxListWithLastAndRestWithLastAndRestWithLastAnd\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Not found: maxListWithLastAndRestWithLastAndRestWithLastAnd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoldhxils.scala:29:5\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxNumber = maxList.max\n            if (maxNumber\
    \ < number) {\n                maxList += number\n            }\n        }\n \
    \       maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa0w4ikj2.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val result: List[Long] = numbers.map(x\
    \ => max.getOrElse(x, 0l))\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4fwa175m.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val max = number.toLong\n            val maxKey = max.toLong\n\
    \            max.foreach { maxValue =>\n                if (maxValue > maxKey)\
    \ {\n                    max.remove(maxValue)\n                    max.put(maxValue,\
    \ maxKey)\n                }\n            }\n        }\n        max.values.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi3kuc845.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi3kuc845.scala:13:16\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m            max.foreach {\
    \ \e[36mmaxValue\e[0m =>\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value foreach is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxList\
    \ += x)\n        val maxIndex = maxList.size - 1\n        val maxValue = maxList(maxIndex)\n\
    \        val maxIndexList = maxList.drop(maxIndex)\n        val maxIndexListSize\
    \ = maxIndexList.size\n        val maxIndexListSize = maxIndexListSize + 1\n \
    \       val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val max\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpub6ixapu.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpub6ixapu.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxIndexListSize\e[0m = maxIndexListSize + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxIndexListSize is already defined as \e[33mvalue\e[0m \e[35mmaxIndexListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpub6ixapu.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxIndexListSize\e[0m = maxIndexListSize\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndexListSize is already defined as \e[33mvalue\e[0m \e\
    [35mmaxIndexListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpub6ixapu.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxIndexListSize\e[0m =\
    \ maxIndexListSize + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndexListSize is already defined as \e[33mvalue\e[0m \e\
    [35mmaxIndexListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpub6ixapu.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxIndexListSize\e[0m =\
    \ maxIndexListSize + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndexListSize is already defined as \e[33mvalue\e[0m \e\
    [35mmaxIndexListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be def"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            val maxValue\
    \ = rollingMax(maxIndex)\n            if (number > maxValue) {\n             \
    \   rollingMax :+ number\n            } else {\n                rollingMax\n \
    \           }\n        })\n        rollingMax.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj3b5mf8s.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(x => x > number)\n         \
    \   if (maxIndex == -1) {\n                maxes += number\n            } else\
    \ {\n                maxes(maxIndex) = max(maxes(maxIndex), number)\n        \
    \    }\n        }\n        maxes.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp58zy3hhh.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max(n, n)\n            max += n -> maxKey\n   \
    \     }\n        max.values.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuo87hg1t.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            if (rollingMax.head < number) {\n                rollingMax :+\
    \ number\n            } else {\n                rollingMax.head :+ rollingMax.last\n\
    \            }\n        })\n        rollingMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1ygjdf8a.scala:13:32 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                rollingMax.head :+ rollingMax.last\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \              value :+ is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            if (max.containsKey(n)) {\n                max.put(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        }\n        val maxList = max.values.toList.sortBy(-_)\n        val result\
    \ = new mutable.ArrayList[Long]()\n        val lastMax = maxList(0)\n        val\
    \ lastMaxIndex = numbers.indexOf(lastMax)\n        result.add(lastMax)\n     \
    \   numbers.drop(lastMaxIndex).foreach { n =>\n            if (max(n) > lastMax)\
    \ {\n                result.add(max(n))\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptf8q7zx1.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptf8q7zx1.scala:18:25\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max.max.key\n            if (maxKey < n) max.updated(maxKey,\
    \ n)\n            else max\n        }\n        max.values.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7uq24022.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val rollingMax = numbers.map(x =>\
    \ max.getOrElse(x, 0l)).toList\n        rollingMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpassy79k1.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            if (max.contains(n)) {\n                max += (n, max(n))\n\
    \            } else {\n                max += (n, n)\n            }\n        }\n\
    \        max.values.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2cje8w0n.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => {\n            val maxValue = maxList.max\n            if (x > maxValue)\
    \ {\n                maxList += x\n            }\n        })\n        maxList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ppb2pui.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        var max = 0L\n   \
    \     var index = 0\n        numbers.foreach{number =>\n            max = math.max(max,\
    \ number)\n            maxList += number\n            index += 1\n           \
    \ if(index > numbers.length) maxList += max\n        }\n        maxList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzcblqwp_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val rollingMaxNumber = rollingMax.lastOption.map {\
    \ max =>\n                if (number > max) number else max\n            }.getOrElse(number)\n\
    \            rollingMax += rollingMaxNumber\n        }\n        rollingMax.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpumi2p9cz.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val currentMax = numbers.head\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxValue\
    \ = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n        val\
    \ currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfxher3ca.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfxher3ca.scala:13:12 ---------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mcurrentMaxIndex\e[0m = numbers.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrentMaxIndex is already defined as \e[33mvalue\e[0m \e\
    [35mcurrentMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfxher3ca.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mcurrentMaxValue\e[0m = numbers.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mcurrentMaxValue is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfxher3ca.scala:15:12 ---------------------------\e[0m\e[0m\n\e\
    [31m15 |\e[0m        \e[33mval\e[0m \e[36mcurrentMaxIndex\e[0m = numbers.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrentMaxIndex is already defined as \e[33mvalue\e[0m \e\
    [35mcurrentMaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfxher3ca.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mcurrentMaxValue\e[0m = numbers.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mcurrentMaxValue is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E16"
  stdout: ''
  timestamp: 1659795275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = maxList.getOrElse(number, 0l)\n      \
    \      if (number > maxValue) {\n                maxList += number\n         \
    \   }\n        }\n        maxList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxl518q53.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { x\
    \ =>\n            val maxKey = max max x\n            if (maxKey > x) max += x\
    \ -> maxKey\n        }\n        max max numbers.lastOption.getOrElse(numbers.last)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdpegdo_c.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        var max = 0L\n   \
    \     var currentMax = 0L\n        numbers.foreach{\n            number =>\n \
    \               if (number > max) {\n                    maxList.clear()\n   \
    \                 max = 0L\n                }\n                max += number\n\
    \                if (number > currentMax) {\n                    currentMax =\
    \ number\n                }\n                maxList += number\n        }\n  \
    \      maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi9u8pooz.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n          \
    \  val maxKey = number.toLong\n            val maxValue = max.getOrElse(maxKey,\
    \ 0L)\n            max.put(maxKey, maxValue + 1)\n            rollingMax.append(maxValue)\n\
    \        }\n        rollingMax.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplh93ekby.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplh93ekby.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ArrayList[Long]()\n\
    \        val keys = max.keySet\n        val maxKeys = keys.toList\n        val\
    \ maxValues = maxKeys.map(x => max.get(x))\n        val maxIndex = maxKeys.indexOf(0)\n\
    \        val maxValue = maxValues.head\n        val maxIndex = maxKeys.indexOf(maxValue)\n\
    \        val maxIndex = maxIndex + 1\n        val maxIndex = maxIndex - 1\n  \
    \      val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n    \
    \    val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n      \
    \  val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val\
    \ maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex\
    \ = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex =\
    \ maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex\
    \ - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex -\
    \ 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n\
    \        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n  \
    \      val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n    \
    \    val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n      \
    \  val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val\
    \ maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex\
    \ = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex =\
    \ maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex\
    \ - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex -\
    \ 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n\
    \        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n  \
    \      val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n    \
    \    val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n      \
    \  val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val\
    \ maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex\
    \ = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex =\
    \ maxIndex - 1\n        \n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps9ruqvhw.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxKeys.indexOf(maxValue)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps9ruqvhw.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmps9ruqvhw.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps9ruqvhw.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxIndex\e[0m = maxIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxIndex is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps9ruqvhw.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659795276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = maxList.foldLeft(number)(_ + _)\n    \
    \        if (number > maxValue) {\n                maxList += number\n       \
    \     }\n        }\n        maxList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi8cgaaju.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += number\n            } else {\n        \
    \        val maxValue = maxList(maxIndex) + 1\n                if (number > maxValue)\
    \ {\n                    maxList += number\n                }\n            }\n\
    \        }\n        maxList.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5ynhv9z_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val max = max.getOrElseUpdate(n, 0l)\n            val curMax\
    \ = max max n\n            max.put(curMax, n)\n        }\n        val maxList\
    \ = max.toList.sortBy(_._1).reverse\n        val maxList = maxList.takeWhile(_._2\
    \ > numbers.size).reverse\n        maxList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleiia6bp.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = maxList.takeWhile(_._2\
    \ > numbers.size).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxList is already defined as \e[33mvalue\e[0m \e[35mmaxList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpleiia6bp.scala:9:22 -------------------------\e[0m\e[0m\n\
    \e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e\
    [31m  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val maxIndex = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach(x => {\n            val index = max.indexOf(x)\n    \
    \        if (index == -1) {\n                max += x\n                maxIndex\
    \ += 0\n            } else {\n                max += x(index + 1)\n          \
    \      maxIndex += index + 1\n            }\n        })\n        max.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0o4bq8fq.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0o4bq8fq.scala:10:27\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxIndex\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => {\n            val maxIndex = rollingMax.lastIndex\n            rollingMax.last\
    \ = x\n            rollingMax.updated(maxIndex + 1, x)\n        })\n        rollingMax.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp53ghy9l4.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            if (max.containsKey(n)) {\n                max(n) = max(n) +\
    \ n\n            } else {\n                max.put(n, n)\n            }\n    \
    \    })\n        val maxList = new mutable.ListBuffer[Long]()\n        max.foreach(m\
    \ => {\n            if (m._2 > maxList.lastOption.getOrElse(0l)) {\n         \
    \       maxList += m._2\n            }\n        })\n        maxList.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0ksjebqb.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0ksjebqb.scala:17:26\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.init :+ number\n     \
    \       } else {\n                rollingMax.init :+ rollingMax(maxIndex + 1)\n\
    \            }\n        })\n        rollingMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph7adsp7d.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795278
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length\
    \ - 1) acc :+ x\n            else acc :+ acc.apply(maxIndex + 1)\n        })\n\
    \        rollingMax.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvhaxnf78.scala:18)\n\tat Problem.main(tmpvhaxnf78.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val max = max.getOrElseUpdate(n, n)\n        }\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        max.foreach { n =>\n      \
    \      result += n\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp60eh_tni.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp60eh_tni.scala:13:25\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val numbers_copy = numbers.toList\n\
    \        var maxIndex = 0\n        var maxValue = numbers_copy(maxIndex)\n   \
    \     while(numbers_copy.nonEmpty) {\n            val value = numbers_copy(numbers_copy.size\
    \ - 1)\n            numbers_copy.remove(value)\n            val newMax = if (value\
    \ > maxValue) value else maxValue\n            if (newMax > maxValue) {\n    \
    \            maxValue = newMax\n                maxIndex = numbers_copy.size -\
    \ 1\n            }\n            max.append(newMax)\n        }\n        max.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpga_uzo8x.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpga_uzo8x.scala:15:25\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            numbers_copy.remove(value)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ remove is not a member of List[Long] - did you mean numbers_copy.reduce?\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1659795279
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, n) => {\n        \
    \    val maxIndex = acc.zipWithIndex.maxBy(_._1)._2\n            val maxValue\
    \ = acc.max\n            val newMax = if (maxIndex < acc.length) maxValue else\
    \ n\n            val newAcc = acc :+ newMax\n            newAcc\n        })\n\
    \        rollingMax.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.maxBy\n\tat scala.collection.IterableOnceOps.maxBy(IterableOnce.scala:978)\n\
    \tat scala.collection.IterableOnceOps.maxBy$(IterableOnce.scala:976)\n\tat scala.collection.AbstractIterable.maxBy(Iterable.scala:926)\n\
    \tat Problem$.$anonfun$1(tmpfvy9dvfz.scala:10)\n\tat Problem$.$anonfun$adapted$1(tmpfvy9dvfz.scala:15)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.rollingMax(tmpfvy9dvfz.scala:15)\n\
    \tat Problem$.main(tmpfvy9dvfz.scala:20)\n\tat Problem.main(tmpfvy9dvfz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n          \
    \  val maxValue = max.getOrElse(number, 0L)\n            val newMaxValue = maxValue\
    \ + number\n            max.put(number, newMaxValue)\n            rollingMax +=\
    \ newMaxValue\n        }\n        rollingMax.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph27qhhts.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph27qhhts.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            if (number.toLong > max.lastOption.getOrElse(0l))\
    \ {\n                max += number\n            }\n            else {\n      \
    \          rollingMax += number\n            }\n        }\n        rollingMax.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv6sydetr.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv6sydetr.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val maxIndex = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach(x => {\n            if (max.length < x) max += x\n  \
    \          else if (max.last < x) max += x\n            else {\n             \
    \   val index = max.lastIndex\n                if (max.last == x) maxIndex +=\
    \ index\n                else {\n                    maxIndex += index\n     \
    \               max += x\n                }\n            }\n        })\n     \
    \   val result = new mutable.ListBuffer[Long]()\n        val index = new mutable.ListBuffer[Int]()\n\
    \        val indexMap = new mutable.HashMap[Int, Int]()\n        val indexMap2\
    \ = new mutable.HashMap[Int, Int]()\n        val indexMap3 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap4 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap5 = new mutable.HashMap[Int, Int]()\n        val indexMap6 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap7 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap8 = new mutable.HashMap[Int, Int]()\n        val indexMap9 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap10 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap11 = new mutable.HashMap[Int, Int]()\n        val indexMap12 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap13 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap14 = new mutable.HashMap[Int, Int]()\n        val indexMap15 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap16 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap17 = new mutable.HashMap[Int, Int]()\n        val indexMap18 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap19 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap20 = new mutable.HashMap[Int, Int]()\n        val indexMap21 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap22 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap23 = new mutable.HashMap[Int, Int]()\n        val indexMap24 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap25 = new mutable.HashMap[In\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0jn6qj3h.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0jn6qj3h.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m               \
    \       Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0jn6qj3h.scala:10:27 ------------------------\e[0m\e[0m\n\e[31m10 |\e\
    [0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0jn6qj3h.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0jn6qj3h.scala:24:24\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mindex\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0jn6qj3h.scala:25:27 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mindexMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^^\e[0m\n\e"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList\n\
    \        val maxListLength = maxList.size\n        val maxListIndex = maxList.indexOf(0)\n\
    \        val maxListTail = maxList.drop(maxListIndex).reverse\n        val maxListTailLength\
    \ = maxListTail.size\n        val maxListTailIndex = maxListTail.indexOf(0)\n\
    \        val maxListTailTail = maxListTail.drop(maxListTailIndex).reverse\n  \
    \      val maxListTailTailLength = maxListTailTail.size\n        val maxListTailTailIndex\
    \ = maxListTailTail.indexOf(0)\n        val maxListTailTailTail = maxListTailTail.drop(maxListTailTailIndex).reverse\n\
    \        val maxListTailTailTailLength = maxListTailTailTail.size\n        val\
    \ maxListTailTailTailIndex = maxListTailTailTail.indexOf(0)\n        val maxListTailTailTailTail\
    \ = maxListTailTailTail.drop(maxListTailTailTailIndex).reverse\n        val maxListTailTailTailLength\
    \ = maxListTailTailTailTail.size\n        val maxListTailTailTailIndex = maxListTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTail = maxListTailTailTailTail.drop(maxListTailTailTailTailIndex).reverse\n\
    \        val maxListTailTailTailTailLength = maxListTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailIndex = maxListTailTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTailTail = maxListTailTailTailTailTail.drop(maxListTailTailTailTailTailIndex).reverse\n\
    \        val maxListTailTailTailTailLength = maxListTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailIndex = maxListTailTailTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTailTail = maxListTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailIndex).reverse\n\
    \        val maxListTailTailTailTailTailLength = maxListTailTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailTailIndex = maxListTailTailTailTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTailTailTail = maxListTailTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailTailIndex).\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr7kh7oj4.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpr7kh7oj4.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxListTailTailTailLength\e[0m = maxListTailTailTailTail.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListTailTailTailLength is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListTailTailTailLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr7kh7oj4.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmaxListTailTailTailIndex\e\
    [0m = maxListTailTailTailTail.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxListTailTailTailIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxListTailTailTailIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr7kh7oj4.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxListTailTailTailTail\e\
    [0m = maxListTailTailTailTail.drop(maxListTailTailTailTailIndex).reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListTailTailTailTail is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListTailTailTailTail\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr7kh7oj4.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxListTailTailTailTailLength\e\
    [0m = maxListTailTailTailTailTailTail"
  stdout: ''
  timestamp: 1659795279
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            if (max.contains(number)) {\n                val maxValue =\
    \ max.get(number)\n                if (number > maxValue) {\n                \
    \    max.put(number, number)\n                }\n            } else {\n      \
    \          max.put(number, number)\n            }\n        }\n        max.values.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn2o6v_km.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val rollingMax = rollingMax.lastOption.orElse(rollingMax.lastOption.getOrElse(0l))\n\
    \            rollingMax max number\n        })\n        rollingMax\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbrlmk355.scala:10:29 ---------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mrollingMax\e[0m = rollingMax.lastOption.orElse(rollingMax.lastOption.getOrElse(\e\
    [31m0l\e[0m))\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m\
    \   |\e[0m                             Recursive \e[33mvalue\e[0m \e[35mrollingMax\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) {\n                rollingMax :+ number\n            }\
    \ else {\n                rollingMax\n            }\n        })\n        rollingMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfmmsryr0.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            val maxValue\
    \ = maxList(maxIndex)\n            if (number > maxValue) {\n                maxList\
    \ += number\n            }\n        }\n        maxList.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk7ibqh9x.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            number match {\n           \
    \     case x if x > maxList.length => maxList += x\n                case x if\
    \ x == maxList.length => maxIndex += x\n                case x => maxList += x\n\
    \            }\n        }\n        maxIndex.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp02dqchtb.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp02dqchtb.scala:10:23 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        numbers.foreach { n =>\n\
    \            val maxIndex = max.indexOf(n)\n            if (maxIndex == -1) {\n\
    \                max += n\n            } else {\n                max += max(maxIndex\
    \ + 1, n)\n            }\n        }\n        max.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7xjzzrxw.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        var max = 0\n    \
    \    var currentMax = 0\n        var currentIndex = 0\n        numbers.foreach\
    \ { number =>\n            max = math.max(max, number)\n            currentMax\
    \ = math.max(currentMax, number)\n            currentIndex += 1\n            if\
    \ (currentIndex == numbers.size)\n                maxList += currentMax\n    \
    \    }\n        return maxList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7e54o4vc.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp7e54o4vc.scala:14:32 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            max = math.max(max, number)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                         Found:    (number : Long)\n\e[31m   |\e[0m         \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp7e54o4vc.scala:15:46 --------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m            currentMax = math.max(currentMax, number)\n\e\
    [31m\e[31m   |\e[0m                                              ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Found:    (number\
    \ : Long)\n\e[31m   |\e[0m                                              Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        max.values.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp09vcxjwb.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val result: List[Long] = numbers.map(x\
    \ => max.getOrElse(x, 0l))\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmf9ruzx8.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            val maxValue = number max maxList\n            maxList += maxValue\n\
    \        }\n        maxList.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoodx7mbr.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795282
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex < acc.length\
    \ - 1) {\n                acc :+ acc.apply(maxIndex + 1)\n            } else {\n\
    \                acc :+ x\n            }\n        })\n        rollingMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq8sljhbj.scala:21)\n\tat Problem.main(tmpq8sljhbj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795287
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(number\
    \ => {\n            val maxNumber = number\n            numbers.foreach(number2\
    \ => {\n                if (number2 > maxNumber) {\n                    maxNumber\
    \ = number2\n                }\n            })\n            maxList += maxNumber\n\
    \        })\n        maxList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0v9nj48c.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp0v9nj48c.scala:14:30 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                    maxNumber = number2\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \              Reassignment to val maxNumber\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = max max number\n            max += number -> maxKey\n\
    \        }\n        val maxList = max max numbers.last\n        val maxList =\
    \ maxList.map { case (number, maxKey) => (number, maxKey) }\n        val maxList\
    \ = maxList.sortBy(_._1).reverse\n        val maxList = maxList.take(numbers.size)\n\
    \        maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo653enqr.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = maxList.map\
    \ { \e[33mcase\e[0m (number, maxKey) => (number, maxKey) }\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxList is already defined as \e[33mvalue\e[0m \e[35mmaxList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo653enqr.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = maxList.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxList is already defined as \e[33mvalue\e[0m \e[35mmaxList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo653enqr.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = maxList.take(numbers.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxList is already defined as \e[33mvalue\e[0m \e[35mmaxList\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpo653enqr.scala:9:22 -------------------------\e[0m\e[0m\n\e[31m9 |\e\
    [0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\
    \e[31m  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            val maxValue\
    \ = rollingMax(maxIndex).max(number)\n            rollingMax :+ maxValue\n   \
    \     })\n        rollingMax.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4cyaqbd9.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795286
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, n) => {\n        \
    \    val maxIndex = acc.indexWhere(x => x > n)\n            if (maxIndex == acc.length\
    \ - 1) {\n                acc :+ n\n            } else {\n                acc\
    \ :+ acc.apply(maxIndex + 1)\n            }\n        })\n        rollingMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppqojyrp4.scala:21)\n\tat Problem.main(tmppqojyrp4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            val maxValue\
    \ = rollingMax(maxIndex)\n            if (number > maxValue) {\n             \
    \   rollingMax :+ number\n            } else {\n                rollingMax\n \
    \           }\n        })\n        rollingMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpftr6j23j.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795286
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max.max.key\n            if (maxKey == null ||\
    \ maxKey > n)\n                max.put(n, n)\n            else\n             \
    \   max.put(maxKey, max.get(maxKey) + n)\n        }\n        max.values.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp73myrfqn.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach{\
    \ number =>\n            rollingMax.append(number)\n        }\n        rollingMax.reverse.takeWhile(number\
    \ => number < numbers.last).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprt7akoa2.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = maxList.getOrElse(number, 0L)\n      \
    \      if (number > maxValue) {\n                maxList += number\n         \
    \   }\n        }\n        maxList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv8toil0n.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795285
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxElement = maxList.head._2\n        val maxElementList = maxList.tail\n\
    \        val maxElementListWithMaxElement = maxElementList.map(x => (x, maxElement))\n\
    \        val maxElementListWithMaxElementWithMaxElement = maxElementListWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElement.map(x => (x, maxElement))\n   \
    \     val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElement.map(x => (x, maxElement))\n\
    \        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWith\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr_v_dndr.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\e\
    [0m = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWith\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpr_v_dndr.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr_v_dndr.scala:24:5\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.updated(maxIndex + 1,\
    \ number)\n            } else {\n                val maxValue = rollingMax(maxIndex\
    \ + 1)\n                if (number > maxValue) {\n                    rollingMax.updated(maxIndex\
    \ + 1, number)\n                }\n            }\n            rollingMax\n   \
    \     })\n        rollingMax.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmq9nu1gh.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795288
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max max n\n            max += n -> maxKey\n   \
    \     }\n        val maxList = max max 0\n        val maxListCopy = maxList.asInstanceOf[List[Long]]\n\
    \        val maxListCopy2 = maxListCopy.tail\n        val maxListCopy3 = maxListCopy2.tail\n\
    \        val maxListCopy4 = maxListCopy3.tail\n        val maxListCopy5 = maxListCopy4.tail\n\
    \        val maxListCopy6 = maxListCopy5.tail\n        val maxListCopy7 = maxListCopy6.tail\n\
    \        val maxListCopy8 = maxListCopy7.tail\n        val maxListCopy9 = maxListCopy8.tail\n\
    \        val maxListCopy10 = maxListCopy9.tail\n        val maxListCopy11 = maxListCopy10.tail\n\
    \        val maxListCopy12 = maxListCopy11.tail\n        val maxListCopy13 = maxListCopy12.tail\n\
    \        val maxListCopy14 = maxListCopy13.tail\n        val maxListCopy15 = maxListCopy14.tail\n\
    \        val maxListCopy16 = maxListCopy15.tail\n        val maxListCopy17 = maxListCopy16.tail\n\
    \        val maxListCopy18 = maxListCopy17.tail\n        val maxListCopy19 = maxListCopy18.tail\n\
    \        val maxListCopy20 = maxListCopy19.tail\n        val maxListCopy21 = maxListCopy20.tail\n\
    \        val maxListCopy22 = maxListCopy21.tail\n        val maxListCopy23 = maxListCopy22.tail\n\
    \        val maxListCopy24 = maxListCopy23.tail\n        val maxListCopy25 = maxListCopy24.tail\n\
    \        val maxListCopy26 = maxListCopy25.tail\n        val maxListCopy27 = maxListCopy26.tail\n\
    \        val maxListCopy28 = maxListCopy27.tail\n        val maxListCopy29 = maxListCopy28.tail\n\
    \        val maxListCopy30 = maxListCopy29.tail\n        val maxListCopy31 = maxListCopy30.tail\n\
    \        val maxListCopy32 = maxListCopy31.tail\n        val maxListCopy33 = maxListCopy32.tail\n\
    \        val maxListCopy34 = maxListCopy33.tail\n        val maxListCopy35 = maxListCopy34.tail\n\
    \        val maxListCopy36 = maxListCopy35.tail\n        val maxList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwnkfh8kp.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwnkfh8kp.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwnkfh8kp.scala:52:5 ---------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { n\
    \ =>\n            val maxIndex = numbers.indexWhere(_ == n)\n            if (maxIndex\
    \ == 0) maxes += n\n            else {\n                val maxValue = numbers(maxIndex\
    \ - 1)\n                if (maxValue > maxes.get) maxes += maxValue\n        \
    \    }\n        }\n        maxes\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphlw2xagu.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795286
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => acc :+ Math.max(acc(0),\
    \ x))\n        rollingMax.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp28nx1w79.scala:9)\n\tat Problem$.$anonfun$adapted$1(tmp28nx1w79.scala:9)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.rollingMax(tmp28nx1w79.scala:9)\n\
    \tat Problem$.main(tmp28nx1w79.scala:14)\n\tat Problem.main(tmp28nx1w79.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795291
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, number) => {\n   \
    \         val maxIndex = acc.indexWhere(x => x > number).toInt\n            if\
    \ (maxIndex == acc.length - 1) {\n                acc :+ number\n            }\
    \ else {\n                acc :+ max(acc(maxIndex + 1), number)\n            }\n\
    \        })\n        rollingMax.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpki8njor8.scala:21)\n\tat Problem.main(tmpki8njor8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => maxList += x)\n        val maxIndex = maxList.lastIndex\n        val maxValue\
    \ = maxList(maxIndex)\n        val maxList2 = maxList.drop(maxIndex + 1)\n   \
    \     val maxValue2 = maxList2.last\n        val maxList3 = maxList2.dropRight(1)\n\
    \        val maxValue3 = maxList3.last\n        val maxList4 = maxList3.dropRight(2)\n\
    \        val maxValue4 = maxList4.last\n        val maxList5 = maxList4.dropRight(3)\n\
    \        val maxValue5 = maxList5.last\n        val maxList6 = maxList5.dropRight(4)\n\
    \        val maxValue6 = maxList6.last\n        val maxList7 = maxList6.dropRight(5)\n\
    \        val maxValue7 = maxList7.last\n        val maxList8 = maxList7.dropRight(6)\n\
    \        val maxValue8 = maxList8.last\n        val maxList9 = maxList8.dropRight(7)\n\
    \        val maxValue9 = maxList9.last\n        val maxList10 = maxList9.dropRight(8)\n\
    \        val maxValue10 = maxList10.last\n        val maxList11 = maxList10.dropRight(9)\n\
    \        val maxValue11 = maxList11.last\n        val maxList12 = maxList11.dropRight(10)\n\
    \        val maxValue12 = maxList12.last\n        val maxList13 = maxList12.dropRight(11)\n\
    \        val maxValue13 = maxList13.last\n        val maxList14 = maxList13.dropRight(12)\n\
    \        val maxValue14 = maxList14.last\n        val maxList15 = maxList14.dropRight(13)\n\
    \        val maxValue15 = maxList15.last\n        val maxList16 = maxList15.dropRight(14)\n\
    \        val maxValue16 = maxList16.last\n        val maxList17 = maxList16.dropRight(15)\n\
    \        val maxValue17 = maxList17.last\n        val maxList18 = maxList17.dropRight(16)\n\
    \        val maxValue18 = maxList18.last\n        val maxList19 = maxList18.dropRight(17)\n\
    \        val maxValue19 = maxList19.last\n        val maxList20 = maxList19.dropRight(18)\n\
    \        val maxValue20 = maxList20.last\n        val maxList21 = maxList20.dropRight(19)\n\
    \        val maxValue21 = maxList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiuaa5rau.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpiuaa5rau.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795290
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => max.append(x))\n        max.reverse.foreach(x =>\
    \ rollingMax.append(x))\n        rollingMax.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0tp0gtsk.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0tp0gtsk.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795287
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = numbers.indexWhere(x => x > number)\n\
    \            if (maxIndex == numbers.length - 1) {\n                maxList +=\
    \ number\n            } else {\n                maxList += numbers(maxIndex +\
    \ 1)\n            }\n        }\n        maxList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt8sqr3l0.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795288
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length\
    \ - 1) {\n                acc :+ x\n            } else {\n                acc\
    \ :+ max(acc(maxIndex), x)\n            }\n        })\n        rollingMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpwh4c1iuk.scala:14)\n\tat Problem$.$anonfun$adapted$1(tmpwh4c1iuk.scala:16)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.rollingMax(tmpwh4c1iuk.scala:16)\n\
    \tat Problem$.main(tmpwh4c1iuk.scala:21)\n\tat Problem.main(tmpwh4c1iuk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795292
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val maxIndex = acc.indexWhere(x => x > x)\n            if (maxIndex == acc.length\
    \ - 1)\n                acc :+ x\n            else\n                acc :+ max(acc(maxIndex\
    \ + 1), x)\n        })\n        rollingMax.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0nk1t0pq.scala:20)\n\tat Problem.main(tmp0nk1t0pq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach{ n =>\n\
    \            val maxIndex = maxes.indexWhere(x => x > n)\n            if (maxIndex\
    \ == -1) {\n                maxes += n\n            } else {\n               \
    \ maxes(maxIndex) = maxes(maxIndex) > n ? maxes(maxIndex) : n\n            }\n\
    \        }\n        maxes.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpci52404d.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { n =>\n            rollingMax.clear()\n            rollingMax.push(n)\n\
    \            while (rollingMax.nonEmpty) {\n                val m = rollingMax.last\n\
    \                if (m > max) {\n                    max.clear()\n           \
    \         max.push(m)\n                }\n                rollingMax.dropRight(1)\n\
    \            }\n        }\n        max.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwom83wcc.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \      ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found: mutable\n\e\
    [31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwom83wcc.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ max.put(n, max.getOrElse(n, n) + n))\n        val res = new mutable.ListBuffer[Long]()\n\
    \        val cur = max.get(numbers.head)\n        res += numbers.head\n      \
    \  while (cur != 0l) {\n            val curMax = max.get(cur)\n            val\
    \ nextMax = max.get(curMax + 1l)\n            if (nextMax != 0l) {\n         \
    \       res += nextMax\n                max.put(nextMax, curMax + 1l)\n      \
    \      } else {\n                max.put(cur, curMax + 1l)\n            }\n  \
    \          cur = nextMax\n        }\n        res.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpil619lg4.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpil619lg4.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mres\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpil619lg4.scala:23:16 -----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            cur = nextMax\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val cur\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach { case (k, v) => result += k until v }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5xy14rql.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5xy14rql.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max += (x, x))\n        val maxes = max.toList.sortBy(_._1).reverse\n      \
    \  val maxesList = maxes.map(x => x._2)\n        val maxesList2 = maxes.map(x\
    \ => x._1)\n        val maxesList3 = maxes.map(x => x._2)\n        val maxesList4\
    \ = maxes.map(x => x._2)\n        val maxesList5 = maxes.map(x => x._2)\n    \
    \    val maxesList6 = maxes.map(x => x._2)\n        val maxesList7 = maxes.map(x\
    \ => x._2)\n        val maxesList8 = maxes.map(x => x._2)\n        val maxesList9\
    \ = maxes.map(x => x._2)\n        val maxesList10 = maxes.map(x => x._2)\n   \
    \     val maxesList11 = maxes.map(x => x._2)\n        val maxesList12 = maxes.map(x\
    \ => x._2)\n        val maxesList13 = maxes.map(x => x._2)\n        val maxesList14\
    \ = maxes.map(x => x._2)\n        val maxesList15 = maxes.map(x => x._2)\n   \
    \     val maxesList16 = maxes.map(x => x._2)\n        val maxesList17 = maxes.map(x\
    \ => x._2)\n        val maxesList18 = maxes.map(x => x._2)\n        val maxesList19\
    \ = maxes.map(x => x._2)\n        val maxesList20 = maxes.map(x => x._2)\n   \
    \     val maxesList21 = maxes.map(x => x._2)\n        val maxesList22 = maxes.map(x\
    \ => x._2)\n        val maxesList23 = maxes.map(x => x._2)\n        val maxesList24\
    \ = maxes.map(x => x._2)\n        val maxesList25 = maxes.map(x => x._2)\n   \
    \     val maxesList26 = maxes.map(x => x._2)\n        val maxesList27 = maxes.map(x\
    \ => x._2)\n        val maxesList28 = maxes.map(x => x._2)\n        val maxesList29\
    \ = maxes.map(x => x._2)\n        val maxesList30 = maxes.map(x => x._2)\n   \
    \     val maxesList3\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzgi1pxyn.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzgi1pxyn.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzgi1pxyn.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = numbers.indexWhere(_\
    \ > numbers.max)\n        numbers.drop(maxIndex).foreach { number =>\n       \
    \     val maxValue = numbers.take(maxIndex).max\n            maxList += number\n\
    \            if (number > maxValue) maxList += maxValue\n        }\n        maxList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxy4xrzz4.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val rollingMaxNumber = rollingMax.last\n          \
    \  if (number > rollingMaxNumber) {\n                rollingMax.clear()\n    \
    \            rollingMax += number\n            } else {\n                rollingMax\
    \ += number\n            }\n        }\n        rollingMax.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4ovewth7.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val max = number.toLong\n            if (max.isDefined) {\n\
    \                val max = max.get\n                if (max.isDefined) {\n   \
    \                 max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get\
    \ :: max.get :: \n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbm57la0r.scala:15:1713 -------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                    max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: \n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                                                                            \
    \                                           "
  stdout: ''
  timestamp: 1659795295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val result: List[Long] = new\
    \ mutable.ListBuffer[Long]()\n        max.foreach { case (k, v) => if (k > 0)\
    \ result += v }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0yl69eou.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0yl69eou.scala:11:37\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        val maxIndex = numbers.indexOf(0)\n\
    \        numbers.foreach { number =>\n            if (number > maxList[maxIndex])\
    \ {\n                maxList += number\n                maxIndex += 1\n      \
    \      }\n        }\n        maxList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphwbj9ezp.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphwbj9ezp.scala:12:33 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m            \e[33mif\e[0m (number > maxList[\e[35mmaxIndex\e\
    [0m]) {\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Not found: type maxIndex\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphwbj9ezp.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                maxIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value\
    \ += is not a member of Int - did you mean maxIndex.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659795296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.lastOption :: number\n\
    \            } else {\n                rollingMax.drop(maxIndex + 1) :+ number\n\
    \            }\n        })\n        rollingMax.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6c1v98z4.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6c1v98z4.scala:12:38 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m                rollingMax.lastOption :: number\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      value :: is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795297
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = number max maxList\n            maxList\
    \ += maxValue\n        }\n        maxList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz7ds20az.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = number.toLong\n            val maxValue = max.getOrElseUpdate(maxKey,\
    \ 0l)\n            val newMaxValue = maxValue + number\n            max.put(maxKey,\
    \ newMaxValue)\n        }\n        max.values.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp28gubgl_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ {\n            if (max.containsKey(x)) {\n                max.put(x, max(x)\
    \ + x)\n            } else {\n                max.put(x, x)\n            }\n \
    \       })\n        val result: List[Long] = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result += x)\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps00wyhon.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps00wyhon.scala:17:37\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        var max = 0\n        var\
    \ maxIndex = 0\n        var index = 0\n        numbers.foreach{\n            number\
    \ =>\n                max = number\n                maxIndex = index\n       \
    \ }\n        numbers.foreach{\n            number =>\n                if (number\
    \ > max) {\n                    max = number\n                    maxIndex = index\n\
    \                }\n                index += 1\n        }\n        maxList +=\
    \ max\n        numbers.take(maxIndex).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptptny9_7.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmptptny9_7.scala:15:22 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                max = number\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    (number : Long)\n\e[31m   |\e[0m                      Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptptny9_7.scala:21:26 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    max = number\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \      Found:    (number : Long)\n\e[31m   |\e[0m                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += number\n            } else {\n        \
    \        maxList += maxList(maxIndex + 1)\n            }\n        })\n       \
    \ maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxqlp9ij5.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList\n\
    \        val maxListWithIndex = numbers.zipWithIndex.map(x => (x._2, x._1)).toList\n\
    \        val maxListWithIndexSortedByIndex = maxListWithIndex.sortBy(x => x._1).reverse\n\
    \        val maxListWithIndexSortedByIndexWithMax = maxListWithIndexSortedByIndex.takeWhile(x\
    \ => x._2 != maxListWithIndexSortedByIndex.last._2)\n        val maxListWithIndexSortedByIndexWithMaxWithIndex\
    \ = maxListWithIndexSortedByIndexWithMax.map(x => (x._2, x._1)).toList\n     \
    \   val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndex = maxListWithIndexSortedByIndexWithMaxWithIndex.sortBy(x\
    \ => x._1).reverse\n        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.takeWhile(x =>\
    \ x._2 != maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.last._2)\n\
    \        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndex\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax.map(x =>\
    \ (x._2, x._1)).toList\n        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.sortBy(x\
    \ => x._1).reverse\n        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.takeWhile(x\
    \ => x._2 != maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.last._2)\n\
    \        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndex\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax.map(x\
    \ => (x._2, x._1)).toList\n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9yqqhopr.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9yqqhopr.scala:19:102\
    \ --------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex\e\
    [0m = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.sortBy(\e\
    [36mx\e[0m => x._1).reverse\n\e[31m\e[31m   |\e[0m                           \
    \                                                                           ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9yqqhopr.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = new mutable.ListBuffer[Long]()\n        numbers.foreach(x =>\
    \ maxes += x)\n        val maxIndex = maxes.indexOf(0l)\n        val maxValue\
    \ = maxes.get(maxIndex)\n        maxes.remove(maxIndex)\n        maxes.reverse.foreach(x\
    \ => maxes += x)\n        maxes.reverse.takeWhile(x => x <= maxValue).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpclhi7k_a.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \          ^^^^^^^\e[0m\n\e[31m  |\e[0m                        Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = number match {\n                case x\
    \ if x > maxList.length => x\n                case x => maxList(x)\n         \
    \   }\n            maxList += maxValue\n        }\n        maxList.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi0xbs39j.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { n\
    \ =>\n            val maxIndex = maxes.indexWhere(_ > n)\n            if (maxIndex\
    \ == -1) {\n                maxes += n\n            } else {\n               \
    \ maxes(maxIndex) = maxes(maxIndex) + n\n            }\n        }\n        maxes.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7n16ypbm.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == -1) {\n                rollingMax += number\n            } else\
    \ {\n                val maxValue = rollingMax(maxIndex)\n                if (number\
    \ > maxValue) {\n                    rollingMax += number\n                }\n\
    \            }\n        }\n        rollingMax.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp77l_dvo6.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) rollingMax else rollingMax.updated(maxIndex, number)\n\
    \        })\n        rollingMax.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwy_0cnk2.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach{ n\
    \ =>\n            val maxKey = max.max.key\n            val maxValue = max.max.value\n\
    \            val newMaxValue = if (maxKey < n) maxValue else n\n            max.put(maxKey,\
    \ newMaxValue)\n        }\n        max.toList.sortBy(_._1).reverse\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9_dq7y_p.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) {\n                maxList += number\n            } else {\n        \
    \        maxList += maxList(maxIndex - 1)\n            }\n        }\n        maxList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp83rewu01.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxList\
    \ += x)\n        val maxIndex = maxList.lastIndex\n        maxList.drop(maxIndex).reverse.takeWhile(x\
    \ => x <= numbers(maxIndex)).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptiwc0pmz.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795297
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, n) => {\n        \
    \    val maxIndex = acc.lastIndexWhere(x => x > n)\n            if (maxIndex ==\
    \ -1) acc :+ n\n            else acc :+ acc.apply(maxIndex)\n        })\n    \
    \    rollingMax.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwvllv1c9.scala:18)\n\tat Problem.main(tmpwvllv1c9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ {\n            val max = max.getOrElse(x, x)\n            max.update(x, max.get(x)\
    \ + 1)\n        })\n        val maxList = max.toList.sortBy(_._2).reverse\n  \
    \      val rollingMax = maxList.takeWhile(_._2 > numbers.size).map(_._1)\n   \
    \     rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzj7cufj9.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach{ n\
    \ =>\n            val maxKey = max.max.key\n            if (maxKey == null ||\
    \ n > maxKey) {\n                max.put(n, n)\n            } else {\n       \
    \         max.put(maxKey, max)\n                max.remove(maxKey)\n         \
    \   }\n        }\n        max.values.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2m__72nu.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxNumber = maxList.max\n            if (number > maxNumber)\
    \ {\n                maxList += number\n            }\n        })\n        maxList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1lud3tw3.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max.max.key\n            if (maxKey < n) max.updated(maxKey,\
    \ n)\n        }\n        val maxList = max.values.toList\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp27_jxcvv.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp27_jxcvv.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListSize\e[0m = maxList.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSize is already defined as \e[33mvalue\e[0m \e[35mmaxListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp27_jxcvv.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxListIndex\e[0m = maxListSize - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListIndex is already defined as \e[33mvalue\e[0m \e[35mmaxListIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp27_jxcvv.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxListElement\e[0m = maxList(maxListIndex)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxListElement is already defined as \e[33mvalue\e[0m \e[35mmaxListElement\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp27_jxcvv.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxListSize\e[0m = maxList.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxListSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListSize\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp27_jxcvv.scala:22:12\
    \ ---------------------"
  stdout: ''
  timestamp: 1659795302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = max.values.toList\n\
    \        val maxIndex = max.keys.toList.sortWith(_.compareTo(_) < 0).reverse.head\n\
    \        val maxElement = maxList(maxIndex)\n        val maxElements = maxList.take(maxIndex\
    \ + 1)\n        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprtb8e8jg.scala:57:30 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mmaxElementsIndex\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m\
    \                              expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprtb8e8jg.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxElementsIndex\e[0m = maxList.lastIndex\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxElementsIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxElementsIndex\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprtb8e8jg.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxElementsIndex\e[0m = maxList.lastIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxElementsIndex is already defined as \e[33mvalue\e[0m \e[35mmaxElementsIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprtb8e8jg.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxElementsIndex\e[0m = maxList.lastIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxElementsIndex is already defined as \e[33mvalue\e[0m \e[35mmaxElementsIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprtb8e8jg.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxElementsIndex\e[0m = maxList.lastIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxElementsI"
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        var max = 0\n      \
    \  numbers.foreach { n =>\n            if (n > max) {\n                max = n\n\
    \            }\n            maxes += max\n        }\n        maxes\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf5k6oref.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpf5k6oref.scala:13:22 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m                max = n\n\e[31m\e[31m   |\e[0m      \
    \                ^\e[0m\n\e[31m   |\e[0m                      Found:    (n : Long)\n\
    \e[31m   |\e[0m                      Required: Int\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = max max number\n            if (maxKey > number)\
    \ {\n                max += number -> number\n            }\n        }\n     \
    \   val result = new mutable.ListBuffer[Long]()\n        max foreach { case (k,\
    \ v) =>\n            result += k\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfpve8gsw.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfpve8gsw.scala:16:25\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(x => x > number)\n         \
    \   if (maxIndex == -1) {\n                maxes += number\n            } else\
    \ {\n                maxes(maxIndex) = max(maxes(maxIndex), number)\n        \
    \    }\n        }\n        maxes.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp58zy3hhh.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList\n\
    \        val maxIndex = max.keys.toList.sortWith(_ < _).last\n        val maxElement\
    \ = maxList[maxIndex]\n        val maxElementList = List(maxElement)\n       \
    \ val maxElementListSize = maxElementList.size\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val max\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcr6usbwz.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcr6usbwz.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxElementListSize\e[0m = maxElementListSize + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxElementListSize is already defined as \e[33mvalue\e[0m \e[35mmaxElementListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcr6usbwz.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxElementListSize\e[0m = maxElementListSize\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxElementListSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxElementListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcr6usbwz.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxElementListSize\e[0m\
    \ = maxElementListSize + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxElementListSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxElementListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcr6usbwz.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxElementListSize\e[0m\
    \ = maxElementListSize + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxElementListSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxElementListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659795304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = new mutable.ListBuffer[Long]()\n        var max = 0L\n     \
    \   var i = 0\n        while(i < numbers.size) {\n            max = max(numbers(i),\
    \ max)\n            maxes += max\n            i += 1\n        }\n        maxes\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgq5hc0lv.scala:9:24 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m              \
    \          ^^^^^^^\e[0m\n\e[31m  |\e[0m                        Not found: mutable\n\
    \e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpgq5hc0lv.scala:13:18 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            max = max(numbers(i), max)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  \e[33mvariable\e\
    [0m \e[35mmax\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795301
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val rollingMax = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => {\n            val max = max.getOrElse(x,\
    \ 0l)\n            val rollingMax = rollingMax.getOrElse(x, 0l)\n            if\
    \ (rollingMax < max) {\n                rollingMax = max\n            }\n    \
    \    })\n        rollingMax.keys.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr_p4lgy6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr_p4lgy6.scala:11:29\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpr_p4lgy6.scala:16:27 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                rollingMax = max\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val rollingMax\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795301
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayBuffer[Long]()\n        numbers.foreach { number =>\n         \
    \   val maxKey = max get number\n            if (maxKey == null) {\n         \
    \       max += number -> number\n            } else {\n                max +=\
    \ number -> maxKey\n            }\n        }\n        max foreach { case (number,\
    \ maxKey) =>\n            rollingMax += maxKey\n        }\n        rollingMax.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpramvyq5k.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpramvyq5k.scala:10:29\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mrollingMax\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795301
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach {\n            case (k, v) => result += k\n        }\n  \
    \      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprvv98dlr.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprvv98dlr.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795302
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        val maxIndex = new\
    \ mutable.HashMap[Long, Int]()\n        numbers.foreach { number =>\n        \
    \    val maxValue = max.getOrElse(number, 0L)\n            val maxIndex = maxIndex.getOrElse(number,\
    \ 0)\n            val newMaxValue = number + maxValue\n            val newMaxIndex\
    \ = maxIndex + 1\n            max.put(newMaxValue, newMaxValue)\n            maxIndex.put(newMaxValue,\
    \ newMaxIndex)\n        }\n        val maxValues = max.values.toList\n       \
    \ val maxIndexes = maxIndex.values.toList\n        val maxIndexesSorted = maxIndexes.sortBy(_._1)\n\
    \        val maxIndexesSortedReversed = maxIndexesSorted.reverse\n        val\
    \ maxIndexesSortedReversedSorted = maxIndexesSortedReversed.sortBy(_._1)\n   \
    \     val maxIndexesSortedReversedSortedWithIndex = maxIndexesSortedReversedSorted.zipWithIndex.map\
    \ { case (maxIndex, index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndex.sortBy(_._1)\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndex\
    \ = maxIndexesSortedReversedSortedWithIndexSorted.zipWithIndex.map { case (maxIndex,\
    \ index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndex.sortBy(_._1)\n    \
    \    val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndexSorted.zipWithIndex.map\
    \ { case (maxIndex, index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1)\n\
    \        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted.zipWithIndex.map\
    \ { case (maxIndex, index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbilwa0ww.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbilwa0ww.scala:10:27\
    \ ------------------------\e[0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxIndex\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbilwa0ww.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(x => x > number)\n         \
    \   if (maxIndex == -1) {\n                maxes += number\n            } else\
    \ {\n                maxes(maxIndex) = max(maxes(maxIndex), number)\n        \
    \    }\n        }\n        maxes.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp58zy3hhh.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val max = number.max(max)\n        }\n        max.values.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6mtir0_y.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6mtir0_y.scala:11:33\
    \ ---------------------------\e[0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e\
    [0m \e[36mmax\e[0m = number.max(max)\n\e[31m\e[31m   |\e[0m                  \
    \               ^\e[0m\n\e[31m   |\e[0m                                 Recursive\
    \ \e[33mvalue\e[0m \e[35mmax\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val rollingMax = numbers.map(x =>\
    \ max.getOrElse(x, 0l))\n        rollingMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppwf10xgi.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val max = max.getOrElseUpdate(n, n)\n        }\n        val\
    \ maxList = max\n            .entrySet\n            .map(x => x._1 -> x._2)\n\
    \            .sortBy(x => x._2)\n            .takeWhile(x => x._2 > 0)\n     \
    \       .map(x => x._1)\n        val maxList2 = maxList\n            .entrySet\n\
    \            .map(x => x._1 -> x._2)\n            .sortBy(x => x._2)\n       \
    \     .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n        val maxList3\
    \ = maxList2\n            .entrySet\n            .map(x => x._1 -> x._2)\n   \
    \         .sortBy(x => x._2)\n            .takeWhile(x => x._2 > 0)\n        \
    \    .map(x => x._1)\n        val maxList4 = maxList3\n            .entrySet\n\
    \            .map(x => x._1 -> x._2)\n            .sortBy(x => x._2)\n       \
    \     .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n        val maxList5\
    \ = maxList4\n            .entrySet\n            .map(x => x._1 -> x._2)\n   \
    \         .sortBy(x => x._2)\n            .takeWhile(x => x._2 > 0)\n        \
    \    .map(x => x._1)\n        val maxList6 = maxList5\n            .entrySet\n\
    \            .map(x => x._1 -> x._2)\n            .sortBy(x => x._2)\n       \
    \     .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n        val maxList7\
    \ = maxList6\n            .entrySet\n            .map(x => x._1 -> x._2)\n   \
    \         .sortBy(x => x._2)\n            .takeWhile(x => x._2 > 0)\n        \
    \    .map(x => x._1)\n        val maxList8 = maxList7\n            .entrySet\n\
    \            .map(x => x._1 -> x._2)\n            .sortBy(x => x._2)\n       \
    \     .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n        val maxList9\
    \ = maxList8\n            .entrySet\n            .map(x => x._1 -> x._2)\n   \
    \         .sortBy(x => x._2)\n            .takeWhile(x => x._2 > 0)\n        \
    \    .map(\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0v0ilj1t.scala:66:17 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m            .map(\n\e[31m\e[31m   |\e[0m            \
    \     ^\e[0m\n\e[31m   |\e[0m                 expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0v0ilj1t.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36mmax\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\
    \e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m  |\e[0m       \
    \               Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0v0ilj1t.scala:67:5 ---------------------\e[0m\e[0m\n\e[31m67\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => {\n            val max = max.getOrElse(x, 0l)\n\
    \            val newMax = max + x\n            max.put(newMax, max)\n        \
    \    result.add(newMax)\n        })\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr1tcya0l.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr1tcya0l.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListElementIndex\
    \ = maxList.indexOf(maxListElement)\n        val maxListElementSize = maxListElementIndex\
    \ + 1\n        val maxListElement = maxList(maxListElementIndex)\n        val\
    \ maxListElementIndex = maxList.indexOf(maxListElement)\n        val maxListElementSize\
    \ = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_nsyavtr.scala:48:33 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mmaxListElementIndex\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_nsyavtr.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListElement\e[0m = maxList(maxListElementIndex)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxListElement is already defined as \e[33mvalue\e[0m \e[35mmaxListElement\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_nsyavtr.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxListElementIndex\e[0m = maxList.indexOf(maxListElement)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListElementIndex is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxListElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_nsyavtr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxListElementSize\e[0m\
    \ = maxListElementIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListElementSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxListElementSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_nsyavtr.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxListElement\e[0m = maxList(maxListElementIn"
  stdout: ''
  timestamp: 1659795307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == numbers.size) {\n                rollingMax :+ number\n            } else\
    \ {\n                val maxValue = rollingMax(maxIndex + 1)\n               \
    \ rollingMax :+ maxValue\n            }\n        })\n        rollingMax.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6s00p26b.scala:10:38 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m            \e[33mval\e[0m \e[36mmaxIndex\e[0m = rollingMax.lastIndex\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean rollingMax.lastIndexOf?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxNumber = maxList.getOrElse(number).max(number).getOrElse(number)\n\
    \            maxList += maxNumber\n        }\n        maxList.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvvcob7mc.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result += x)\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp42_uey2_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp42_uey2_.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => {\n\
    \            val maxValue = maxList.getOrElse(x - 1)\n            if (maxValue\
    \ < x) maxList += x\n        })\n        maxList.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0pkf46bf.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val result: List[Long] = numbers.map(x\
    \ => max.getOrElse(x, 0l))\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmf9ruzx8.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = numbers.indexWhere(_ > number)\n            if\
    \ (maxIndex == numbers.size) {\n                maxes += number\n            }\
    \ else {\n                maxes += numbers(maxIndex + 1)\n            }\n    \
    \    }\n        maxes\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpavdmvw8m.scala:9:20 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                    ^^^^^^^\e[0m\n\e[31m \
    \ |\e[0m                    Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => rollingMax.append(x))\n        rollingMax.takeWhile(x => x <= numbers.last).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpssq_t8tb.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795306
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, element) => {\n  \
    \          val maxIndex = acc.indexWhere(x => x > element)\n            if (maxIndex\
    \ == acc.length - 1) {\n                acc :+ element\n            } else {\n\
    \                acc :+ max(acc(maxIndex + 1), element)\n            }\n     \
    \   })\n        rollingMax.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpt_1bixcz.scala:21)\n\tat Problem.main(tmpt_1bixcz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val result: List[Long] = new mutable.ArrayBuffer[Long]()\n        val\
    \ currentMax = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMax\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbuqpjas_.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuqpjas_.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcurrentMaxIndex\e[0m = maxList.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurrentMaxIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxIndex\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuqpjas_.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcurrentMaxValue\e[0m = maxList(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurrentMaxValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mcurrentMaxValue\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuqpjas_.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcurrentMaxIndex\e[0m = maxList.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurrentMaxIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mcurrentMaxIndex\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuqpjas_.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcurrentMaxValue\e[0m = maxList(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcurrentMaxValue is\
    \ already defined as \e[33mvalue\e[0m \e[35mcurrentMaxValue\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E16"
  stdout: ''
  timestamp: 1659795310
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, number) => {\n   \
    \         val rollingMax = acc.lastOption.map(_ + number).getOrElse(number)\n\
    \            acc :+ rollingMax\n        })\n        rollingMax.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vv4ith_.scala:17)\n\tat Problem.main(tmp1vv4ith_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxList\
    \ += x)\n        val maxIndex = maxList.indexOf(maxList.max)\n        maxList.drop(maxIndex).takeRight(numbers.size\
    \ - maxIndex).reverse.foldLeft(maxList)(_++_)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1e8mxbzy.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max.max.key\n            if (maxKey == null ||\
    \ n < maxKey) {\n                max.put(n, n)\n            } else {\n       \
    \         val maxValue = max.max.value\n                if (maxValue < n) {\n\
    \                    max.put(n, maxValue)\n                } else {\n        \
    \            max.remove(maxKey)\n                    max.put(n, maxValue)\n  \
    \              }\n            }\n        }\n        max.values.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxazt2doz.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            rollingMax += number\n        })\n        rollingMax.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp34aj24j5.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max max n\n            if (maxKey > n) max += n\
    \ -> maxKey\n        }\n        max map { case (k, v) => k -> v }.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6m0que7.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxList.lastIndex\n            if (maxIndex\
    \ == -1) maxList += number\n            else {\n                val maxValue =\
    \ maxList(maxIndex)\n                if (number > maxValue) maxList += number\n\
    \            }\n        }\n        maxList.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp971cnrb2.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result.add(x))\n        result.sortWith(_ < _)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzz38jnto.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzz38jnto.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = numbers.indexWhere(_\
    \ > numbers.last)\n        numbers.drop(maxIndex).foreach { number =>\n      \
    \      val maxValue = numbers.take(maxIndex).max\n            maxList += maxValue\n\
    \        }\n        maxList.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppyg6vxjs.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = numbers.foldLeft(List[Long]())((acc, x) => {\n        \
    \    val maxIndex = acc.indexWhere(x => x > x)\n            val maxValue = acc.get(maxIndex)\n\
    \            val newMaxValue = if (maxValue > x) x else maxValue\n           \
    \ acc :+ newMaxValue\n        })\n        rollingMax.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuuh6ls8_.scala:11:31 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m            \e[33mval\e[0m \e[36mmaxValue\e[0m = acc.get(maxIndex)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \         value get is not a member of List[Long] - did you mean acc.seq?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach {\n            case (k, v) => result.append((k - v).max(0l))\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3zzwbuu.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo3zzwbuu.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n\
    \ =>\n            val maxKey = max(n, n)\n            val maxValue = max(n, n)\n\
    \            max.put(maxKey, maxValue)\n        }\n        max.values.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp87dz1yo1.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \        })\n        rollingMax.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
    \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
    \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
    \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5lecenmi.scala:9:25 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mrollingMax\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m  |\e[0m                         Not found: mutable\n\e[31m  |\e[0m\n\e[31m\
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxElement = maxList.toList.max\n            if (number\
    \ > maxElement) {\n                maxList += number\n            }\n        }\n\
    \        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprz6hcysn.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxRollingNumbers = mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            val maxRollingNumber = maxRollingNumbers.max\n    \
    \        if (number > maxRollingNumber) {\n                maxRollingNumbers +=\
    \ number\n            }\n        }\n        maxRollingNumbers.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp96y6601g.scala:9:32 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxRollingNumbers\e[0m =\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m                \
    \                ^^^^^^^\e[0m\n\e[31m  |\e[0m                                Not\
    \ found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = maxList.toList.max\n            if (number\
    \ > maxValue) {\n                maxList += number\n            }\n        }\n\
    \        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3tck0_9s.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxList.size\n \
    \           maxList += number\n            maxIndex += index\n        }\n    \
    \    val maxIndex = maxIndex.toList\n        val maxList = maxList.toList\n  \
    \      val maxIndex = maxIndex.sortBy(-_)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.last)\n\
    \        val maxIndex = maxIndex.take(maxIndex.last)\n        val maxIndex = maxIndex.drop\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqbyc_9dc.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqbyc_9dc.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = maxList.toList\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxList is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxList\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqbyc_9dc.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxIndex\e[0m = maxIndex.sortBy(-_)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqbyc_9dc.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex.drop(maxIndex.last)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqbyc_9dc.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex.take(maxIndex.last)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35m"
  stdout: ''
  timestamp: 1659795312
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => maxList += x)\n        maxList.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxhacox_4.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxhacox_4.scala:11:26\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => maxList += x)\n        val maxIndex = maxList.lastIndex\n        val maxElement\
    \ = maxList(maxIndex)\n        val maxList = maxList.drop(maxIndex + 1)\n    \
    \    val maxListWithMaxElement = maxList :+ maxElement\n        rollingMax(maxListWithMaxElement)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvvz06yiz.scala:13:12 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = maxList.drop(maxIndex\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxList is already defined as \e[33mvalue\e[0m \e[35mmaxList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpvvz06yiz.scala:9:22 -------------------------\e[0m\e[0m\n\
    \e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m  |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \  |\e[0m                      Not found: mutable\n\e[31m  |\e[0m\n\e[31m  |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795311
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    //\
    \ (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong,\
    \ 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0l)))\n        val maxList = max.toList.sortBy(-_._1).reverse\n\
    \        val maxElement = maxList.head._2\n        val maxElements = maxList.tail.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMoment = maxElements.takeWhile(_._1\
    \ < moment)\n        val maxElementsUntilMomentList = maxElementsUntilMoment.toList\n\
    \        val maxElementsUntilMomentListWithMax = maxElementsUntilMomentList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxList = maxElementsUntilMomentListWithMax.toList\n\
    \        val maxElementsUntilMomentListWithMaxListWithMax = maxElementsUntilMomentListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxList\
    \ = maxElementsUntilMomentListWithMaxListWithMax.toList\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMax\
    \ = maxElementsUntilMomentListWithMaxListWithMaxList.reverse.takeWhile(_._2 !=\
    \ maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxList\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMax.toList\n        val\
    \ maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMax = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxList\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxListWithMax\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxListWithMax\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMax\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
    \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
    \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong,\
    \ 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong,\
    \ 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp853cvu52.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp853cvu52.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxListWithMax\e\
    [0m = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxListWithMax\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxListWithMax\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp853cvu52.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m  |\e[0m                      Not found:\
    \ mutable\n\e[31m  |\e[0m\n\e[31m  |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp853cvu52.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795312
