name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers\
  \ : List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.clear()\n            rollingMax.push(number)\n\
    \            rollingMax.foreach { rollingMax =>\n                if (rollingMax.compareTo(_)\
    \ > 0) {\n                    rollingMax.clear()\n                    rollingMax.push(number)\n\
    \                }\n            }\n        }\n        rollingMax.toList", "  \
    \      val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max += ((x, x)))\n        val maxList = max.toList.sortWith(_._2 > _._2)\n\
    \        val result = new mutable.ArrayList[Long]()\n        for(i <- 0 until\
    \ maxList.size) {\n            val max = maxList(i)\n            val rollingMax\
    \ = maxList.drop(i).takeWhile(_._2 > max).last\n            result += rollingMax\n\
    \        }\n        result.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            if (max.containsKey(n))\
    \ {\n                max.update(n, max(n) + 1)\n            } else {\n       \
    \         max.put(n, 1l)\n            }\n        }\n        val maxList = max.values.toList\n\
    \        val maxListWithIndex = maxList.zipWithIndex.sortBy(_._1).reverse\n  \
    \      val maxListWithIndex = maxListWithIndex.takeWhile(_._2 <= numbers.size).reverse\n\
    \        val maxListWithIndex = maxListWithIndex.map(_._1).toList\n        maxListWithIndex",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(number\
    \ => {\n            val maxValue = number match {\n                case x if x\
    \ > maxList.length => x\n                case x => maxList(x)\n            }\n\
    \            maxList += maxValue\n        })\n        maxList.toList", "     \
    \   val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) => {\n\
    \            val maxIndex = rollingMax.lastIndex\n            if (maxIndex ==\
    \ rollingMax.size - 1) {\n                rollingMax.head :: rollingMax\n    \
    \        } else {\n                rollingMax.head :: rollingMax.tail.max\n  \
    \          }\n        })\n        rollingMax", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        numbers.foreach { number =>\n            max =\
    \ math.max(max, number)\n            maxList += number\n        }\n        maxList.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach(x => {\n            if (max.size\
    \ < x) {\n                max += x\n                rollingMax += x\n        \
    \    }\n        })\n        rollingMax.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            val maxNumber = numbers.max\n\
    \            if (number > maxNumber) {\n                maxList += maxNumber\n\
    \            }\n        })\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => {\n            val maxKey = max.minKey\n\
    \            if (maxKey == null || n < maxKey) {\n                max.put(n, n)\n\
    \            } else {\n                val maxValue = max.getOrElse(n, n)\n  \
    \              max.put(n, maxValue + 1)\n            }\n        })\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        max.values.foreach(n => result\
    \ += n)\n        result.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val rollingMax = acc.lastOption.map(_ + x)\n          \
    \  rollingMax.getOrElse(acc.head + x)\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = number.toLong\n            val maxValue\
    \ = max.getOrElseUpdate(maxKey, 0l)\n            val newMaxValue = maxValue +\
    \ number\n            max.put(maxKey, newMaxValue)\n        }\n        val maxList\
    \ = max.toList.sortBy(_._2).reverse\n        val maxListWithMax = maxList.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMax = maxList.takeWhile(_._2 == 0l).reverse\n\
    \        val maxListWithMaxAndMax = maxListWithMax.takeWhile(_._2 != 0l).reverse\n\
    \        val maxListWithoutMaxAndMax = maxListWithoutMax.takeWhile(_._2 == 0l).reverse\n\
    \        val maxListWithMaxAndMaxAndMax = maxListWithMaxAndMax.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMax = maxListWithoutMaxAndMax.takeWhile(_._2\
    \ == 0l).reverse\n        val maxListWithMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMax.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMaxAndMax = maxListWithoutMaxAndMaxAndMax.takeWhile(_._2\
    \ == 0l).reverse\n        val maxListWithMaxAndMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMaxAndMax.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMaxAndMaxAndMax = maxListWithoutMaxAndMaxAndMaxAndMax.takeWhile(_._2\
    \ == 0l).reverse\n        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMaxAndMaxAndMax.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithoutMaxAndMaxAndMaxAndMaxAndMax.takeWhile(_._2 == 0l).reverse\n\
    \        val maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithMaxAndMaxAndMaxAndMaxAndMaxAndMax.takeWhile(_._2\
    \ != 0l).reverse\n        val maxListWithoutMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithoutMaxAnd", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        max.values.foreach(x => result\
    \ += x)\n        result.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            if (max.containsKey(number))\
    \ {\n                val maxValue = max.get(number)\n                if (number\
    \ > maxValue) {\n                    max.put(number, number)\n               \
    \ } else {\n                    max.put(number, maxValue)\n                }\n\
    \            } else {\n                max.put(number, number)\n            }\n\
    \        }\n        max.values.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val res = new mutable.ListBuffer[Long]()\n        max.values.foreach(x\
    \ => res += x)\n        res", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => {\n            val max = max.getOrElseUpdate(n,\
    \ 0l)\n            val cur = max\n            val curMax = if (cur > n) cur else\
    \ n\n            val curMaxIndex = numbers.indexOf(n)\n            val curMaxIndex\
    \ = if (curMaxIndex < 0) curMaxIndex + 1 else curMaxIndex\n            max.put(curMax,\
    \ curMaxIndex)\n        })\n        val maxList = max\n        val maxListSize\
    \ = maxList.size\n        val maxListIterator = maxList.iterator\n        val\
    \ maxListIteratorSize = maxListIterator.size\n        val maxListIteratorIterator\
    \ = maxListIterator.iterator\n        val maxListIteratorIteratorSize = maxListIteratorIterator.size\n\
    \        val maxListIteratorIteratorIterator = maxListIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorSize = maxListIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIterator = maxListIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorSize = maxListIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIterator = maxListIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorSize = maxListIteratorIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIterator = maxListIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorSize = maxListIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIterator =\
    \ maxListIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val\
    \ maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = maxListIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\
    \        val maxListIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\
    \ = maxListIteratorIteratorIteratorIteratorIteratorIterator", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n => {\n      \
    \      if (max.containsKey(n)) {\n                max.update(n, max(max(n), n))\n\
    \            } else {\n                max.put(n, n)\n            }\n        })\n\
    \        val result = new mutable.ListBuffer[Long]()\n        max.values.foreach(n\
    \ => result += n)\n        result.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val max = number.toLong\n\
    \            if (max.isDefined) {\n                val maxKey = max.key\n    \
    \            if (maxKey > max.value) {\n                    max.value = maxKey\n\
    \                }\n            }\n        }\n        numbers.toList.map(_.toLong)",
  "        val maxRollingNumbers = mutable.ListBuffer.empty[Long]\n        val rollingNumbers\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach{ number =>\n     \
    \       rollingNumbers += number\n            val maxRollingNumber = rollingNumbers.max\n\
    \            if (maxRollingNumber > maxRollingNumbers.last)\n                maxRollingNumbers\
    \ += maxRollingNumber\n        }\n        maxRollingNumbers", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach{ n =>\n       \
    \     val maxKey = max.max.key\n            if (maxKey < n) max.put(n, maxKey)\n\
    \            else max.remove(n)\n        }\n        max.toList.sortBy(_._1).reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max += ((x, x)))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListElementIndex\
    \ = maxListIndex - 1\n        val maxListElementSize = maxListElement.length\n\
    \        val maxListElementIndexSize = maxListElementIndex.length\n        val\
    \ maxListElementIndexLast = maxListElementIndex.last\n        val maxListElementIndexLastSize\
    \ = maxListElementIndexLast.length\n        val maxListElementIndexLastLast =\
    \ maxListElementIndexLast.last\n        val maxListElementIndexLastLastSize =\
    \ maxListElementIndexLastLast.length\n        val maxListElementIndexLastLastLast\
    \ = maxListElementIndexLastLast.last\n        val maxListElementIndexLastLastLastSize\
    \ = maxListElementIndexLastLastLast.length\n        val maxListElementIndexLastLastLastLast\
    \ = maxListElementIndexLastLastLast.last\n        val maxListElementIndexLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLast.last\n        val maxListElementIndexLastLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLastLast.last\n        val maxListElementIndexLastLastLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLastLastLastLast.last\n        val maxListElementIndexLastLastLastLastLastLastLastSize\
    \ = maxListElementIndexLastLastLastLastLastLastLastLast.length\n        val maxListElementIndexLastLastLastLastLastLastLastLast\
    \ = maxListElementIndexLastLastLastLastLastLastLastLastLast.last\n        val\
    \ maxListElementIndexLastLastLastLastLastLastLastLastSize = maxListElementIndexLastLastLastLastLastLastLastLastLast.length\n\
    \        val maxListElementIndexLastLastLastLastLastLastLastLastLast = maxListElementIndexLastLastLastLastLastLastLastLastLastLastLast.last\n\
    \        val maxListElementIndexLastLastLastLastLastLastLastLast", "        val\
    \ maxList = mutable.ListBuffer[Long]()\n        val maxIndex = numbers.indexOf(0)\n\
    \        numbers.foreach { n =>\n            if (n >= maxIndex) {\n          \
    \      maxList += maxIndex\n                maxIndex += 1\n            }\n   \
    \     }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val result: List[Long] = new\
    \ mutable.ListBuffer[Long]()\n        val maxKey = max.keys.max\n        val maxValue\
    \ = max.get(maxKey)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n     \
    \   val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKeyIndex = numbers.indexOf(maxKey)\n        val maxValueIndex\
    \ = numbers.indexOf(maxValue)\n        val maxKeyIndex = numbers.indexOf(maxKey)\n\
    \        val maxValueIndex = numbers.indexOf(maxValue)\n        val maxKeyIndex\
    \ = numbers.indexOf(maxKey)\n        val maxValueIndex = numbers.indexOf(maxValue)\n\
    \        val maxKey", "        val max = new mutable.ListBuffer[Long]()\n    \
    \    numbers.foreach { x =>\n            val maxIndex = max.indexOf(x)\n     \
    \       if (maxIndex == -1) {\n                max += x\n            } else {\n\
    \                max += max(maxIndex - 1)\n            }\n        }\n        max.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.values.toList.sortWith(_\
    \ > _)\n        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListValue = maxList(maxListIndex)\n        val maxListIndex\
    \ = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n     \
    \   val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxListValue = maxList(maxListIndex)\n\
    \        val maxListIndex = maxListIndex - 1\n        val maxList", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x,\
    \ max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortWith(_.key\
    \ < _.key).reverse\n        val maxListWithMax = maxList.takeWhile(x => x.key\
    \ < numbers.last).reverse\n        val maxListWithoutMax = maxList.dropWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithMax = maxListWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMax =\
    \ maxListWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n        val\
    \ maxListWithoutMaxWithoutMaxWithMax = maxListWithoutMaxWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithMax = maxListWithoutMaxWithoutMaxWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax.takeWhile(x\
    \ => x.key < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax.takeWhile(x => x.key\
    \ < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMax.dropWhile(x => x.key < numbers.last).reverse\n\
    \        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithMax\
    \ = maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax.takeWhile(x => x.key\
    \ < numbers.last).reverse\n        val maxListWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMaxWithoutMax\
    \ = maxListWithoutMaxWithout", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val maxIndex = acc.lastIndexWhere(y => y > x)\n       \
    \     if (maxIndex == -1)\n                acc :+ x\n            else\n      \
    \          acc :+ max(acc(maxIndex), x)\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortWith(_.key\
    \ < _.key)\n        val maxListSize = maxList.size\n        val maxListTail =\
    \ maxList.tail\n        val maxListTailSize = maxListTail.size\n        val maxListTailTail\
    \ = maxListTail.tail\n        val maxListTailTailSize = maxListTailTail.size\n\
    \        val maxListTailTailTail = maxListTailTail.tail\n        val maxListTailTailTailSize\
    \ = maxListTailTailTail.size\n        val maxListTailTailTailTail = maxListTailTailTail.tail\n\
    \        val maxListTailTailTailTailSize = maxListTailTailTailTail.size\n    \
    \    val maxListTailTailTailTailTail = maxListTailTailTailTailTail.tail\n    \
    \    val maxListTailTailTailTailTailSize = maxListTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailTailTail = maxListTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxListTailTailTailTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTailTailTailTailTailSize\n\
    \        val maxListTailTailTailTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTailTailTailTailTail.tail\n\
    \        val maxList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxValue = number match\
    \ {\n                case x if x > maxList.length => x\n                case x\
    \ => maxList(x)\n            }\n            maxList += maxValue\n        }\n \
    \       maxList.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n            rollingMax.append(number)\n\
    \        }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val result = new mutable.ListBuffer[Long]()\n        max.values.foreach(x\
    \ => result.add(x)) // add all elements to result\n        result.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        })\n        val maxList = max.toList.sortWith((x, y) => x._2 > y._2)\n\
    \        val maxListWithIndex = maxList.zipWithIndex.filter(_._2 != 0).map(_._1)\n\
    \        val maxListWithIndexAndMax = maxListWithIndex.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMax = maxListWithIndexAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMax = maxListWithIndexAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMax = maxListWithIndexAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2 == _._2).map(_._1)\n\
    \        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMax = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax\
    \ = maxListWithIndexAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMaxAndMax.zip(maxList).filter(_._2\
    \ == _._2).map(_._1)\n        val maxListWithIndexAnd", "        val rollingMax\
    \ = numbers.foldLeft(List[Long]())((acc, x) => {\n            val maxIndex = acc.indexWhere(x\
    \ => x > x)\n            if (maxIndex == acc.length - 1) {\n                acc\
    \ :+ x\n            } else {\n                acc :+ max(acc(maxIndex + 1), x)\n\
    \            }\n        })\n        rollingMax.reverse", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0l) + x))\n        val result: List[Long] = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => if (x > result.last) result += x)\n        result",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        val maxKey = max.keySet().iterator().next()\n        val maxValue = max.get(maxKey)\n\
    \        val maxKeyList = List(maxKey)\n        val maxValueList = List(maxValue)\n\
    \        val maxKeySet = max.keySet()\n        val maxValueSet = max.values\n\
    \        while(maxKeySet.hasNext) {\n            val maxKey = maxKeySet.next()\n\
    \            val maxValue = maxValueSet.next()\n            val maxKeyList = List(maxKey)\n\
    \            val maxValueList = List(maxValue)\n            val maxKeySet = max.keySet()\n\
    \            val maxValueSet = max.values\n            val maxKeySetIterator =\
    \ maxKeySet.iterator()\n            val maxValueSetIterator = maxValueSet.iterator()\n\
    \            while(maxKeySetIterator.hasNext && maxValueSetIterator.hasNext) {\n\
    \                val maxKeyValue = maxKeySetIterator.next()\n                val\
    \ maxValueValue = maxValueSetIterator.next()\n                val maxKeyList =\
    \ List(maxKeyValue)\n                val maxValueList = List(maxValueValue)\n\
    \                val maxKeySetIterator = maxKeySet.iterator()\n              \
    \  val maxValueSetIterator = maxValueSet.iterator()\n                while(maxKeySetIterator.hasNext\
    \ && maxValueSetIterator.hasNext) {\n                    val maxKeyValue = maxKeySetIterator.next()\n\
    \                    val maxValueValue = maxValueSetIterator.next()\n        \
    \            val maxKeyList = List(maxKeyValue)\n                    val maxValueList\
    \ = List(maxValueValue)\n                    val maxKeySetIterator = maxKeySet.iterator()\n\
    \                    val maxValueSetIterator = maxValueSet.iterator()\n      \
    \              while(maxKeySetIterator.hasNext && maxValueSetIterator.hasNext)\
    \ {\n                        val maxKeyValue = maxKeySetIterator.next()\n    \
    \                    val maxValueValue = maxValueSetIterator.next()\n        \
    \                val maxKeyList = List(maxKeyValue)\n                        val\
    \ maxValueList = List(maxValueValue)\n                        val maxKeySetIterator\
    \ = maxKeySet.iterator()\n                        val maxValueSetIterator = maxValueSet.iterator()\n\
    \                        while(maxKeySetIterator.hasNext && maxValueSetIterator.hasNext)\
    \ {\n                            val maxKeyValue = maxKeySetIterator.next()\n\
    \                            val maxValueValue = maxValueSetIterator.next()\n\
    \                            val ", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == rollingMax.size - 1) {\n                rollingMax.last\n     \
    \       } else {\n                if (number > rollingMax(maxIndex)) {\n     \
    \               rollingMax(maxIndex)\n                } else {\n             \
    \       number\n                }\n            }\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.containsKey(n)) {\n                val max = max.getOrElseUpdate(n,\
    \ n)\n                max.toLong\n            } else {\n                val max\
    \ = n\n                max.toLong\n            }\n        }", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n => max.put(n,\
    \ max.getOrElse(n, n) + n))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val rollingMax = maxList.takeWhile(n => n < numbers(numbers.size - 1))\n\
    \        rollingMax.map(n => numbers(numbers.size - 1 - n))", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max += (x,\
    \ x))\n        val result = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            val max = max get x\n            if (max > x) result += max\n\
    \            max += x\n        })\n        result.toList", "        val rollingMax\
    \ = numbers.foldLeft(List[Long]())((acc, number) => {\n            val rollingMax\
    \ = acc.lastOption.map { max =>\n                if (number > max) number else\
    \ max\n            }.getOrElse(number)\n            acc :+ rollingMax\n      \
    \  })\n        rollingMax.reverse", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            if (rollingMax.last.isDefined && rollingMax.last.get.compareTo(_)\
    \ > 0) {\n                rollingMax.last\n            } else {\n            \
    \    rollingMax :+ number\n            }\n        })\n        rollingMax", " \
    \       val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxIndex = maxes.indexWhere(_ > number)\n       \
    \     if (maxIndex == -1) {\n                maxes += number\n            } else\
    \ {\n                maxes(maxIndex) = max(maxes(maxIndex), number)\n        \
    \    }\n        }\n        maxes.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val maxKey = number.toLong\n\
    \            val maxValue = max.getOrElseUpdate(maxKey, 0l)\n            val newMaxValue\
    \ = maxValue + 1\n            max.put(maxKey, newMaxValue)\n        }\n      \
    \  val maxList = mutable.ListBuffer.empty[Long]\n        max.foreach { case (key,\
    \ value) =>\n            maxList += key\n        }\n        maxList.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = max max number\n            max += number\
    \ -> maxKey\n        }\n        max max numbers.lastOption.getOrElse(numbers.last)",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex\
    \ + 1, number)\n        })\n        rollingMax.reverse", "        val maxList\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        val maxIndex = maxList.lastIndex\n            if (maxIndex == -1) {\n\
    \                maxList += number\n            } else {\n                maxList\
    \ += maxList(maxIndex - 1)\n            }\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxListWithIndex = maxList.zipWithIndex.filter(_._2 % 2 == 0)\n \
    \       val maxListWithoutIndex = maxList.filter(_._2 % 2 == 0)\n        val maxListWithIndex\
    \ = maxListWithIndex.map(_._1)\n        val maxListWithoutIndex = maxListWithoutIndex.map(_._1)\n\
    \        val maxListWithoutIndexWithIndex = maxListWithoutIndex.zip(maxListWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndex = maxListWithoutIndex.zip(maxListWithoutIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithIndex = maxListWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndex = maxListWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithIndex).filter(_._2\
    \ % 2 == 0)\n        val maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex\
    \ = maxListWithoutIndexWithoutIndexWithoutIndexWithoutIndexWithoutIndex.zip(maxListWithoutIndexWithoutIndexWithoutIndex",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach(x => max.put(x, max(x.getOrElse(x,\
    \ 0l) + 1)));\n        max.values.foreach(x => maxList += x);\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val maxKey = max.keys.max\n        val maxValue = max.values.max\n  \
    \      val currentMax = max.getOrElse(maxKey, 0L)\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val currentMaxKey =\
    \ maxKey\n        val currentMaxValue = maxValue\n        val current", "    \
    \    val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach{ number\
    \ =>\n            val maxNumber = maxList.toList.max\n            if (number >\
    \ maxNumber) {\n                maxList += number\n            }\n        }\n\
    \        maxList.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == rollingMax.size - 1) {\n                rollingMax.updated(maxIndex\
    \ + 1, number)\n            } else {\n                rollingMax.updated(maxIndex\
    \ + 1, rollingMax(maxIndex + 1) + number)\n            }\n        })\n       \
    \ rollingMax.reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxValue = number match\
    \ {\n                case x if x > maxList.length => x\n                case x\
    \ => maxList(x)\n            }\n            maxList += maxValue\n        }\n \
    \       maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxList = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => max.put(x, max(x.getOrElse(x, 0l) + 1)));\n        max.foreach(x => maxList\
    \ += x)\n        maxList.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach(n\
    \ => {\n            if (n > maxValue) {\n                maxValue = n\n      \
    \          maxIndex = 0\n            }\n            if (n == maxValue) {\n   \
    \             max += maxIndex\n            }\n            maxIndex += 1\n    \
    \    })\n        max += maxIndex\n        max.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n       \
    \     val maxKey = max max number\n            max += number -> (maxKey + 1)\n\
    \        }\n        val maxList = max.values.toList\n        val maxListCopy =\
    \ maxList.clone()\n        val maxListCopy.sortWith(_ < _)\n        val maxListCopy.tail",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n\
    \ => {\n            val maxKey = max.getOrElseUpdate(n, 0)\n            max.update(n,\
    \ (maxKey + 1))\n        })\n        max.values.toList", "        val rollingMax\
    \ = numbers.foldLeft(List[Long]())((rollingMax, number) => {\n            val\
    \ maxIndex = rollingMax.lastIndex\n            if (number > rollingMax(maxIndex))\
    \ {\n                rollingMax :+ number\n            } else {\n            \
    \    rollingMax\n            }\n        })\n        rollingMax.reverse", "   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(n =>\
    \ {\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1l)\n            }\n\
    \        })\n        val maxList = max.toList.sortBy(_._2).reverse\n        val\
    \ maxElement = maxList.head._1\n        val maxCount = maxList.head._2\n     \
    \   val rollingMax = maxList.take(maxCount)\n        rollingMax.map(n => max(n)\
    \ - maxElement)", "        val max = new mutable.HashMap[Long, Long]()\n     \
    \   numbers.foreach(n => {\n            val maxKey = max.getOrElseUpdate(n, 0l)\n\
    \            if (maxKey > n) max.put(n, maxKey)\n        })\n        val maxList\
    \ = max\n            .filter(_._2 > numbers.last)\n            .map(_._1)\n  \
    \      val maxListWithLast = maxList :+ numbers.last\n        val maxListWithLastAndRest\
    \ = maxListWithLast :+ numbers.drop(numbers.size - 1)\n        val maxListWithLastAndRestWithLast\
    \ = maxListWithLastAndRest :+ numbers.last\n        val maxListWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLast :+ numbers.drop(numbers.size - 1)\n       \
    \ val maxListWithLastAndRestWithLastAndRestWithLast = maxListWithLastAndRestWithLastAndRest\
    \ :+ numbers.last\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLast :+ numbers.drop(numbers.size\
    \ - 1)\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRest :+ numbers.last\n   \
    \     val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLast :+ numbers.drop(numbers.size\
    \ - 1)\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest :+ numbers.last\n\
    \        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ :+ numbers.drop(numbers.size - 1)\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLast\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ :+ numbers.last\n        val maxListWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRestWithLastAndRest\
    \ = maxListWithLastAndRestWithLastAndRestWithLastAnd", "        val maxList =\
    \ mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n      \
    \      val maxNumber = maxList.max\n            if (maxNumber < number) {\n  \
    \              maxList += number\n            }\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result: List[Long] = numbers.map(x\
    \ => max.getOrElse(x, 0l))\n        result", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val max = number.toLong\n\
    \            val maxKey = max.toLong\n            max.foreach { maxValue =>\n\
    \                if (maxValue > maxKey) {\n                    max.remove(maxValue)\n\
    \                    max.put(maxValue, maxKey)\n                }\n          \
    \  }\n        }\n        max.values.toList", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.size\
    \ - 1\n        val maxValue = maxList(maxIndex)\n        val maxIndexList = maxList.drop(maxIndex)\n\
    \        val maxIndexListSize = maxIndexList.size\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val maxIndexListSize = maxIndexListSize + 1\n\
    \        val maxIndexListSize = maxIndexListSize + 1\n        val maxIndexListSize\
    \ = maxIndexListSize + 1\n        val max", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            val\
    \ maxValue = rollingMax(maxIndex)\n            if (number > maxValue) {\n    \
    \            rollingMax :+ number\n            } else {\n                rollingMax\n\
    \            }\n        })\n        rollingMax.reverse", "        val maxes =\
    \ mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n      \
    \      val maxIndex = maxes.indexWhere(x => x > number)\n            if (maxIndex\
    \ == -1) {\n                maxes += number\n            } else {\n          \
    \      maxes(maxIndex) = max(maxes(maxIndex), number)\n            }\n       \
    \ }\n        maxes.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach { n =>\n            val maxKey = max(n, n)\n        \
    \    max += n -> maxKey\n        }\n        max.values.toList", "        val rollingMax\
    \ = numbers.foldLeft(List[Long]())((rollingMax, number) => {\n            if (rollingMax.head\
    \ < number) {\n                rollingMax :+ number\n            } else {\n  \
    \              rollingMax.head :+ rollingMax.last\n            }\n        })\n\
    \        rollingMax", "        val max = new mutable.HashMap[Long, Long]()\n \
    \       numbers.foreach { n =>\n            if (max.containsKey(n)) {\n      \
    \          max.put(n, max(n) + 1)\n            } else {\n                max.put(n,\
    \ 1l)\n            }\n        }\n        val maxList = max.values.toList.sortBy(-_)\n\
    \        val result = new mutable.ArrayList[Long]()\n        val lastMax = maxList(0)\n\
    \        val lastMaxIndex = numbers.indexOf(lastMax)\n        result.add(lastMax)\n\
    \        numbers.drop(lastMaxIndex).foreach { n =>\n            if (max(n) > lastMax)\
    \ {\n                result.add(max(n))\n            }\n        }\n        result",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.max.key\n            if (maxKey < n) max.updated(maxKey,\
    \ n)\n            else max\n        }\n        max.values.toList", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x,\
    \ max.getOrElse(x, 0l)))\n        val rollingMax = numbers.map(x => max.getOrElse(x,\
    \ 0l)).toList\n        rollingMax", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            if (max.contains(n)) {\n\
    \                max += (n, max(n))\n            } else {\n                max\
    \ += (n, n)\n            }\n        }\n        max.values.toList", "        val\
    \ maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x => {\n \
    \           val maxValue = maxList.max\n            if (x > maxValue) {\n    \
    \            maxList += x\n            }\n        })\n        maxList.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        var max = 0L\n  \
    \      var index = 0\n        numbers.foreach{number =>\n            max = math.max(max,\
    \ number)\n            maxList += number\n            index += 1\n           \
    \ if(index > numbers.length) maxList += max\n        }\n        maxList.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val rollingMaxNumber = rollingMax.lastOption.map {\
    \ max =>\n                if (number > max) number else max\n            }.getOrElse(number)\n\
    \            rollingMax += rollingMaxNumber\n        }\n        rollingMax.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val currentMax = numbers.head\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxValue\
    \ = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n        val\
    \ currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.last\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxValue = numbers.", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxValue = maxList.getOrElse(number,\
    \ 0l)\n            if (number > maxValue) {\n                maxList += number\n\
    \            }\n        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { x =>\n            val maxKey = max max x\n\
    \            if (maxKey > x) max += x -> maxKey\n        }\n        max max numbers.lastOption.getOrElse(numbers.last)",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        var max = 0L\n  \
    \      var currentMax = 0L\n        numbers.foreach{\n            number =>\n\
    \                if (number > max) {\n                    maxList.clear()\n  \
    \                  max = 0L\n                }\n                max += number\n\
    \                if (number > currentMax) {\n                    currentMax =\
    \ number\n                }\n                maxList += number\n        }\n  \
    \      maxList.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            val maxKey = number.toLong\n            val maxValue\
    \ = max.getOrElse(maxKey, 0L)\n            max.put(maxKey, maxValue + 1)\n   \
    \         rollingMax.append(maxValue)\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ArrayList[Long]()\n\
    \        val keys = max.keySet\n        val maxKeys = keys.toList\n        val\
    \ maxValues = maxKeys.map(x => max.get(x))\n        val maxIndex = maxKeys.indexOf(0)\n\
    \        val maxValue = maxValues.head\n        val maxIndex = maxKeys.indexOf(maxValue)\n\
    \        val maxIndex = maxIndex + 1\n        val maxIndex = maxIndex - 1\n  \
    \      val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n    \
    \    val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n      \
    \  val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val\
    \ maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex\
    \ = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex =\
    \ maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex\
    \ - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex -\
    \ 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n\
    \        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n  \
    \      val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n    \
    \    val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n      \
    \  val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val\
    \ maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex\
    \ = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex =\
    \ maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex\
    \ - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex -\
    \ 1\n        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n\
    \        val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n  \
    \      val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n    \
    \    val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n      \
    \  val maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val\
    \ maxIndex = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex\
    \ = maxIndex - 1\n        val maxIndex = maxIndex - 1\n        val maxIndex =\
    \ maxIndex - 1\n        ", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxValue = maxList.foldLeft(number)(_\
    \ + _)\n            if (number > maxValue) {\n                maxList += number\n\
    \            }\n        }\n        maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                val maxValue = maxList(maxIndex) + 1\n      \
    \          if (number > maxValue) {\n                    maxList += number\n \
    \               }\n            }\n        }\n        maxList.toList", "      \
    \  val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n\
    \            val max = max.getOrElseUpdate(n, 0l)\n            val curMax = max\
    \ max n\n            max.put(curMax, n)\n        }\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val maxList = maxList.takeWhile(_._2 > numbers.size).reverse\n      \
    \  maxList", "        val max = new mutable.ListBuffer[Long]()\n        val maxIndex\
    \ = new mutable.ListBuffer[Int]()\n        numbers.foreach(x => {\n          \
    \  val index = max.indexOf(x)\n            if (index == -1) {\n              \
    \  max += x\n                maxIndex += 0\n            } else {\n           \
    \     max += x(index + 1)\n                maxIndex += index + 1\n           \
    \ }\n        })\n        max.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => {\n            val maxIndex = rollingMax.lastIndex\n\
    \            rollingMax.last = x\n            rollingMax.updated(maxIndex + 1,\
    \ x)\n        })\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => {\n            if (max.containsKey(n))\
    \ {\n                max(n) = max(n) + n\n            } else {\n             \
    \   max.put(n, n)\n            }\n        })\n        val maxList = new mutable.ListBuffer[Long]()\n\
    \        max.foreach(m => {\n            if (m._2 > maxList.lastOption.getOrElse(0l))\
    \ {\n                maxList += m._2\n            }\n        })\n        maxList.toList",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.init :+ number\n     \
    \       } else {\n                rollingMax.init :+ rollingMax(maxIndex + 1)\n\
    \            }\n        })\n        rollingMax", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val maxIndex = acc.indexWhere(x => x > x)\n           \
    \ if (maxIndex == acc.length - 1) acc :+ x\n            else acc :+ acc.apply(maxIndex\
    \ + 1)\n        })\n        rollingMax.reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val max = max.getOrElseUpdate(n,\
    \ n)\n        }\n        val result = new mutable.ListBuffer[Long]()\n       \
    \ max.foreach { n =>\n            result += n\n        }\n        result.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val numbers_copy = numbers.toList\n\
    \        var maxIndex = 0\n        var maxValue = numbers_copy(maxIndex)\n   \
    \     while(numbers_copy.nonEmpty) {\n            val value = numbers_copy(numbers_copy.size\
    \ - 1)\n            numbers_copy.remove(value)\n            val newMax = if (value\
    \ > maxValue) value else maxValue\n            if (newMax > maxValue) {\n    \
    \            maxValue = newMax\n                maxIndex = numbers_copy.size -\
    \ 1\n            }\n            max.append(newMax)\n        }\n        max.toList",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, n) => {\n       \
    \     val maxIndex = acc.zipWithIndex.maxBy(_._1)._2\n            val maxValue\
    \ = acc.max\n            val newMax = if (maxIndex < acc.length) maxValue else\
    \ n\n            val newAcc = acc :+ newMax\n            newAcc\n        })\n\
    \        rollingMax.reverse", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            val maxValue = max.getOrElse(number, 0L)\n        \
    \    val newMaxValue = maxValue + number\n            max.put(number, newMaxValue)\n\
    \            rollingMax += newMaxValue\n        }\n        rollingMax.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n          \
    \  if (number.toLong > max.lastOption.getOrElse(0l)) {\n                max +=\
    \ number\n            }\n            else {\n                rollingMax += number\n\
    \            }\n        }\n        rollingMax.toList", "        val max = new\
    \ mutable.ListBuffer[Long]()\n        val maxIndex = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach(x => {\n            if (max.length < x) max += x\n  \
    \          else if (max.last < x) max += x\n            else {\n             \
    \   val index = max.lastIndex\n                if (max.last == x) maxIndex +=\
    \ index\n                else {\n                    maxIndex += index\n     \
    \               max += x\n                }\n            }\n        })\n     \
    \   val result = new mutable.ListBuffer[Long]()\n        val index = new mutable.ListBuffer[Int]()\n\
    \        val indexMap = new mutable.HashMap[Int, Int]()\n        val indexMap2\
    \ = new mutable.HashMap[Int, Int]()\n        val indexMap3 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap4 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap5 = new mutable.HashMap[Int, Int]()\n        val indexMap6 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap7 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap8 = new mutable.HashMap[Int, Int]()\n        val indexMap9 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap10 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap11 = new mutable.HashMap[Int, Int]()\n        val indexMap12 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap13 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap14 = new mutable.HashMap[Int, Int]()\n        val indexMap15 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap16 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap17 = new mutable.HashMap[Int, Int]()\n        val indexMap18 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap19 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap20 = new mutable.HashMap[Int, Int]()\n        val indexMap21 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap22 = new mutable.HashMap[Int, Int]()\n        val\
    \ indexMap23 = new mutable.HashMap[Int, Int]()\n        val indexMap24 = new mutable.HashMap[Int,\
    \ Int]()\n        val indexMap25 = new mutable.HashMap[In", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0l) + x))\n        val maxList = max.values.toList\n        val maxListLength\
    \ = maxList.size\n        val maxListIndex = maxList.indexOf(0)\n        val maxListTail\
    \ = maxList.drop(maxListIndex).reverse\n        val maxListTailLength = maxListTail.size\n\
    \        val maxListTailIndex = maxListTail.indexOf(0)\n        val maxListTailTail\
    \ = maxListTail.drop(maxListTailIndex).reverse\n        val maxListTailTailLength\
    \ = maxListTailTail.size\n        val maxListTailTailIndex = maxListTailTail.indexOf(0)\n\
    \        val maxListTailTailTail = maxListTailTail.drop(maxListTailTailIndex).reverse\n\
    \        val maxListTailTailTailLength = maxListTailTailTail.size\n        val\
    \ maxListTailTailTailIndex = maxListTailTailTail.indexOf(0)\n        val maxListTailTailTailTail\
    \ = maxListTailTailTail.drop(maxListTailTailTailIndex).reverse\n        val maxListTailTailTailLength\
    \ = maxListTailTailTailTail.size\n        val maxListTailTailTailIndex = maxListTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTail = maxListTailTailTailTail.drop(maxListTailTailTailTailIndex).reverse\n\
    \        val maxListTailTailTailTailLength = maxListTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailIndex = maxListTailTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTailTail = maxListTailTailTailTailTail.drop(maxListTailTailTailTailTailIndex).reverse\n\
    \        val maxListTailTailTailTailLength = maxListTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailIndex = maxListTailTailTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTailTail = maxListTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailIndex).reverse\n\
    \        val maxListTailTailTailTailTailLength = maxListTailTailTailTailTailTailTail.size\n\
    \        val maxListTailTailTailTailTailIndex = maxListTailTailTailTailTailTailTail.indexOf(0)\n\
    \        val maxListTailTailTailTailTailTail = maxListTailTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailTailIndex).",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            if (max.contains(number)) {\n                val maxValue\
    \ = max.get(number)\n                if (number > maxValue) {\n              \
    \      max.put(number, number)\n                }\n            } else {\n    \
    \            max.put(number, number)\n            }\n        }\n        max.values.toList",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val rollingMax = rollingMax.lastOption.orElse(rollingMax.lastOption.getOrElse(0l))\n\
    \            rollingMax max number\n        })\n        rollingMax", "       \
    \ val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) => {\n\
    \            val maxIndex = rollingMax.lastIndex\n            if (number > rollingMax(maxIndex))\
    \ {\n                rollingMax :+ number\n            } else {\n            \
    \    rollingMax\n            }\n        })\n        rollingMax", "        val\
    \ maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n\
    \            val maxIndex = maxList.lastIndex\n            val maxValue = maxList(maxIndex)\n\
    \            if (number > maxValue) {\n                maxList += number\n   \
    \         }\n        }\n        maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val maxIndex = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            number match {\n                case x if x > maxList.length\
    \ => maxList += x\n                case x if x == maxList.length => maxIndex +=\
    \ x\n                case x => maxList += x\n            }\n        }\n      \
    \  maxIndex.toList", "        val max = new mutable.ListBuffer[Long]()\n     \
    \   numbers.foreach { n =>\n            val maxIndex = max.indexOf(n)\n      \
    \      if (maxIndex == -1) {\n                max += n\n            } else {\n\
    \                max += max(maxIndex + 1, n)\n            }\n        }\n     \
    \   max.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n     \
    \   var max = 0\n        var currentMax = 0\n        var currentIndex = 0\n  \
    \      numbers.foreach { number =>\n            max = math.max(max, number)\n\
    \            currentMax = math.max(currentMax, number)\n            currentIndex\
    \ += 1\n            if (currentIndex == numbers.size)\n                maxList\
    \ += currentMax\n        }\n        return maxList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l)))\n        val result:\
    \ List[Long] = numbers.map(x => max.getOrElse(x, 0l))\n        result", "    \
    \    val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            val maxValue = number max maxList\n            maxList += maxValue\n\
    \        }\n        maxList.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val maxIndex = acc.indexWhere(x => x > x)\n           \
    \ if (maxIndex < acc.length - 1) {\n                acc :+ acc.apply(maxIndex\
    \ + 1)\n            } else {\n                acc :+ x\n            }\n      \
    \  })\n        rollingMax.reverse", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(number => {\n            val maxNumber = number\n   \
    \         numbers.foreach(number2 => {\n                if (number2 > maxNumber)\
    \ {\n                    maxNumber = number2\n                }\n            })\n\
    \            maxList += maxNumber\n        })\n        maxList.toList", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val maxKey = max max number\n            max += number -> maxKey\n\
    \        }\n        val maxList = max max numbers.last\n        val maxList =\
    \ maxList.map { case (number, maxKey) => (number, maxKey) }\n        val maxList\
    \ = maxList.sortBy(_._1).reverse\n        val maxList = maxList.take(numbers.size)\n\
    \        maxList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            val\
    \ maxValue = rollingMax(maxIndex).max(number)\n            rollingMax :+ maxValue\n\
    \        })\n        rollingMax.reverse", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ n) => {\n            val maxIndex = acc.indexWhere(x => x > n)\n           \
    \ if (maxIndex == acc.length - 1) {\n                acc :+ n\n            } else\
    \ {\n                acc :+ acc.apply(maxIndex + 1)\n            }\n        })\n\
    \        rollingMax.reverse", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            val\
    \ maxValue = rollingMax(maxIndex)\n            if (number > maxValue) {\n    \
    \            rollingMax :+ number\n            } else {\n                rollingMax\n\
    \            }\n        })\n        rollingMax", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.max.key\n\
    \            if (maxKey == null || maxKey > n)\n                max.put(n, n)\n\
    \            else\n                max.put(maxKey, max.get(maxKey) + n)\n    \
    \    }\n        max.values.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach{ number =>\n            rollingMax.append(number)\n \
    \       }\n        rollingMax.reverse.takeWhile(number => number < numbers.last).reverse",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = maxList.getOrElse(number, 0L)\n      \
    \      if (number > maxValue) {\n                maxList += number\n         \
    \   }\n        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val maxList = max.toList.sortBy(_._1).reverse\n        val maxElement\
    \ = maxList.head._2\n        val maxElementList = maxList.tail\n        val maxElementListWithMaxElement\
    \ = maxElementList.map(x => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElement.map(x => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElement.map(x => (x, maxElement))\n   \
    \     val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElement.map(x => (x, maxElement))\n\
    \        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement.map(x\
    \ => (x, maxElement))\n        val maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElement\
    \ = maxElementListWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWithMaxElementWith",
  "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (maxIndex\
    \ == rollingMax.size - 1) {\n                rollingMax.updated(maxIndex + 1,\
    \ number)\n            } else {\n                val maxValue = rollingMax(maxIndex\
    \ + 1)\n                if (number > maxValue) {\n                    rollingMax.updated(maxIndex\
    \ + 1, number)\n                }\n            }\n            rollingMax\n   \
    \     })\n        rollingMax.reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max max n\n\
    \            max += n -> maxKey\n        }\n        val maxList = max max 0\n\
    \        val maxListCopy = maxList.asInstanceOf[List[Long]]\n        val maxListCopy2\
    \ = maxListCopy.tail\n        val maxListCopy3 = maxListCopy2.tail\n        val\
    \ maxListCopy4 = maxListCopy3.tail\n        val maxListCopy5 = maxListCopy4.tail\n\
    \        val maxListCopy6 = maxListCopy5.tail\n        val maxListCopy7 = maxListCopy6.tail\n\
    \        val maxListCopy8 = maxListCopy7.tail\n        val maxListCopy9 = maxListCopy8.tail\n\
    \        val maxListCopy10 = maxListCopy9.tail\n        val maxListCopy11 = maxListCopy10.tail\n\
    \        val maxListCopy12 = maxListCopy11.tail\n        val maxListCopy13 = maxListCopy12.tail\n\
    \        val maxListCopy14 = maxListCopy13.tail\n        val maxListCopy15 = maxListCopy14.tail\n\
    \        val maxListCopy16 = maxListCopy15.tail\n        val maxListCopy17 = maxListCopy16.tail\n\
    \        val maxListCopy18 = maxListCopy17.tail\n        val maxListCopy19 = maxListCopy18.tail\n\
    \        val maxListCopy20 = maxListCopy19.tail\n        val maxListCopy21 = maxListCopy20.tail\n\
    \        val maxListCopy22 = maxListCopy21.tail\n        val maxListCopy23 = maxListCopy22.tail\n\
    \        val maxListCopy24 = maxListCopy23.tail\n        val maxListCopy25 = maxListCopy24.tail\n\
    \        val maxListCopy26 = maxListCopy25.tail\n        val maxListCopy27 = maxListCopy26.tail\n\
    \        val maxListCopy28 = maxListCopy27.tail\n        val maxListCopy29 = maxListCopy28.tail\n\
    \        val maxListCopy30 = maxListCopy29.tail\n        val maxListCopy31 = maxListCopy30.tail\n\
    \        val maxListCopy32 = maxListCopy31.tail\n        val maxListCopy33 = maxListCopy32.tail\n\
    \        val maxListCopy34 = maxListCopy33.tail\n        val maxListCopy35 = maxListCopy34.tail\n\
    \        val maxListCopy36 = maxListCopy35.tail\n        val maxList", "     \
    \   val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { n =>\n\
    \            val maxIndex = numbers.indexWhere(_ == n)\n            if (maxIndex\
    \ == 0) maxes += n\n            else {\n                val maxValue = numbers(maxIndex\
    \ - 1)\n                if (maxValue > maxes.get) maxes += maxValue\n        \
    \    }\n        }\n        maxes", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ Math.max(acc(0), x))\n        rollingMax.reverse", "        val\
    \ rollingMax = numbers.foldLeft(List[Long]())((acc, number) => {\n           \
    \ val maxIndex = acc.indexWhere(x => x > number).toInt\n            if (maxIndex\
    \ == acc.length - 1) {\n                acc :+ number\n            } else {\n\
    \                acc :+ max(acc(maxIndex + 1), number)\n            }\n      \
    \  })\n        rollingMax.reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        val maxValue = maxList(maxIndex)\n        val maxList2 = maxList.drop(maxIndex\
    \ + 1)\n        val maxValue2 = maxList2.last\n        val maxList3 = maxList2.dropRight(1)\n\
    \        val maxValue3 = maxList3.last\n        val maxList4 = maxList3.dropRight(2)\n\
    \        val maxValue4 = maxList4.last\n        val maxList5 = maxList4.dropRight(3)\n\
    \        val maxValue5 = maxList5.last\n        val maxList6 = maxList5.dropRight(4)\n\
    \        val maxValue6 = maxList6.last\n        val maxList7 = maxList6.dropRight(5)\n\
    \        val maxValue7 = maxList7.last\n        val maxList8 = maxList7.dropRight(6)\n\
    \        val maxValue8 = maxList8.last\n        val maxList9 = maxList8.dropRight(7)\n\
    \        val maxValue9 = maxList9.last\n        val maxList10 = maxList9.dropRight(8)\n\
    \        val maxValue10 = maxList10.last\n        val maxList11 = maxList10.dropRight(9)\n\
    \        val maxValue11 = maxList11.last\n        val maxList12 = maxList11.dropRight(10)\n\
    \        val maxValue12 = maxList12.last\n        val maxList13 = maxList12.dropRight(11)\n\
    \        val maxValue13 = maxList13.last\n        val maxList14 = maxList13.dropRight(12)\n\
    \        val maxValue14 = maxList14.last\n        val maxList15 = maxList14.dropRight(13)\n\
    \        val maxValue15 = maxList15.last\n        val maxList16 = maxList15.dropRight(14)\n\
    \        val maxValue16 = maxList16.last\n        val maxList17 = maxList16.dropRight(15)\n\
    \        val maxValue17 = maxList17.last\n        val maxList18 = maxList17.dropRight(16)\n\
    \        val maxValue18 = maxList18.last\n        val maxList19 = maxList18.dropRight(17)\n\
    \        val maxValue19 = maxList19.last\n        val maxList20 = maxList19.dropRight(18)\n\
    \        val maxValue20 = maxList20.last\n        val maxList21 = maxList20.dropRight(19)\n\
    \        val maxValue21 = maxList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => max.append(x))\n        max.reverse.foreach(x => rollingMax.append(x))\n\
    \        rollingMax.reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = numbers.indexWhere(x\
    \ => x > number)\n            if (maxIndex == numbers.length - 1) {\n        \
    \        maxList += number\n            } else {\n                maxList += numbers(maxIndex\
    \ + 1)\n            }\n        }\n        maxList.toList", "        val rollingMax\
    \ = numbers.foldLeft(List[Long]())((acc, x) => {\n            val maxIndex = acc.indexWhere(x\
    \ => x > x)\n            if (maxIndex == acc.length - 1) {\n                acc\
    \ :+ x\n            } else {\n                acc :+ max(acc(maxIndex), x)\n \
    \           }\n        })\n        rollingMax.reverse", "        val rollingMax\
    \ = numbers.foldLeft(List[Long]())((acc, x) => {\n            val maxIndex = acc.indexWhere(x\
    \ => x > x)\n            if (maxIndex == acc.length - 1)\n                acc\
    \ :+ x\n            else\n                acc :+ max(acc(maxIndex + 1), x)\n \
    \       })\n        rollingMax.reverse", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach{ n =>\n            val maxIndex = maxes.indexWhere(x\
    \ => x > n)\n            if (maxIndex == -1) {\n                maxes += n\n \
    \           } else {\n                maxes(maxIndex) = maxes(maxIndex) > n ?\
    \ maxes(maxIndex) : n\n            }\n        }\n        maxes.toList", "    \
    \    val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { n =>\n            rollingMax.clear()\n            rollingMax.push(n)\n\
    \            while (rollingMax.nonEmpty) {\n                val m = rollingMax.last\n\
    \                if (m > max) {\n                    max.clear()\n           \
    \         max.push(m)\n                }\n                rollingMax.dropRight(1)\n\
    \            }\n        }\n        max.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => max.put(n, max.getOrElse(n, n) + n))\n\
    \        val res = new mutable.ListBuffer[Long]()\n        val cur = max.get(numbers.head)\n\
    \        res += numbers.head\n        while (cur != 0l) {\n            val curMax\
    \ = max.get(cur)\n            val nextMax = max.get(curMax + 1l)\n           \
    \ if (nextMax != 0l) {\n                res += nextMax\n                max.put(nextMax,\
    \ curMax + 1l)\n            } else {\n                max.put(cur, curMax + 1l)\n\
    \            }\n            cur = nextMax\n        }\n        res.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach { case (k, v) => result += k until v }\n        result.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max += (x, x))\n        val maxes = max.toList.sortBy(_._1).reverse\n   \
    \     val maxesList = maxes.map(x => x._2)\n        val maxesList2 = maxes.map(x\
    \ => x._1)\n        val maxesList3 = maxes.map(x => x._2)\n        val maxesList4\
    \ = maxes.map(x => x._2)\n        val maxesList5 = maxes.map(x => x._2)\n    \
    \    val maxesList6 = maxes.map(x => x._2)\n        val maxesList7 = maxes.map(x\
    \ => x._2)\n        val maxesList8 = maxes.map(x => x._2)\n        val maxesList9\
    \ = maxes.map(x => x._2)\n        val maxesList10 = maxes.map(x => x._2)\n   \
    \     val maxesList11 = maxes.map(x => x._2)\n        val maxesList12 = maxes.map(x\
    \ => x._2)\n        val maxesList13 = maxes.map(x => x._2)\n        val maxesList14\
    \ = maxes.map(x => x._2)\n        val maxesList15 = maxes.map(x => x._2)\n   \
    \     val maxesList16 = maxes.map(x => x._2)\n        val maxesList17 = maxes.map(x\
    \ => x._2)\n        val maxesList18 = maxes.map(x => x._2)\n        val maxesList19\
    \ = maxes.map(x => x._2)\n        val maxesList20 = maxes.map(x => x._2)\n   \
    \     val maxesList21 = maxes.map(x => x._2)\n        val maxesList22 = maxes.map(x\
    \ => x._2)\n        val maxesList23 = maxes.map(x => x._2)\n        val maxesList24\
    \ = maxes.map(x => x._2)\n        val maxesList25 = maxes.map(x => x._2)\n   \
    \     val maxesList26 = maxes.map(x => x._2)\n        val maxesList27 = maxes.map(x\
    \ => x._2)\n        val maxesList28 = maxes.map(x => x._2)\n        val maxesList29\
    \ = maxes.map(x => x._2)\n        val maxesList30 = maxes.map(x => x._2)\n   \
    \     val maxesList3", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val maxIndex = numbers.indexWhere(_ > numbers.max)\n        numbers.drop(maxIndex).foreach\
    \ { number =>\n            val maxValue = numbers.take(maxIndex).max\n       \
    \     maxList += number\n            if (number > maxValue) maxList += maxValue\n\
    \        }\n        maxList.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val rollingMaxNumber = rollingMax.last\n\
    \            if (number > rollingMaxNumber) {\n                rollingMax.clear()\n\
    \                rollingMax += number\n            } else {\n                rollingMax\
    \ += number\n            }\n        }\n        rollingMax.toList", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n\
    \            val max = number.toLong\n            if (max.isDefined) {\n     \
    \           val max = max.get\n                if (max.isDefined) {\n        \
    \            max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: max.get :: max.get :: max.get :: max.get :: max.get :: max.get ::\
    \ max.get :: ", "        val max = new mutable.HashMap[Long, Long]()\n       \
    \ numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n        val result:\
    \ List[Long] = new mutable.ListBuffer[Long]()\n        max.foreach { case (k,\
    \ v) => if (k > 0) result += v }\n        result.toList", "        val maxList\
    \ = mutable.ListBuffer[Long]()\n        val maxIndex = numbers.indexOf(0)\n  \
    \      numbers.foreach { number =>\n            if (number > maxList[maxIndex])\
    \ {\n                maxList += number\n                maxIndex += 1\n      \
    \      }\n        }\n        maxList.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == rollingMax.size - 1) {\n                rollingMax.lastOption ::\
    \ number\n            } else {\n                rollingMax.drop(maxIndex + 1)\
    \ :+ number\n            }\n        })\n        rollingMax.reverse", "       \
    \ val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxValue = number max maxList\n            maxList += maxValue\n\
    \        }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val maxKey = number.toLong\n\
    \            val maxValue = max.getOrElseUpdate(maxKey, 0l)\n            val newMaxValue\
    \ = maxValue + number\n            max.put(maxKey, newMaxValue)\n        }\n \
    \       max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => {\n            if (max.containsKey(x)) {\n     \
    \           max.put(x, max(x) + x)\n            } else {\n                max.put(x,\
    \ x)\n            }\n        })\n        val result: List[Long] = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result += x)\n        result.toList", "     \
    \   val maxList = mutable.ListBuffer[Long]()\n        var max = 0\n        var\
    \ maxIndex = 0\n        var index = 0\n        numbers.foreach{\n            number\
    \ =>\n                max = number\n                maxIndex = index\n       \
    \ }\n        numbers.foreach{\n            number =>\n                if (number\
    \ > max) {\n                    max = number\n                    maxIndex = index\n\
    \                }\n                index += 1\n        }\n        maxList +=\
    \ max\n        numbers.take(maxIndex).reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                maxList += maxList(maxIndex + 1)\n          \
    \  }\n        })\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val maxList = max.values.toList\n        val maxListWithIndex = numbers.zipWithIndex.map(x\
    \ => (x._2, x._1)).toList\n        val maxListWithIndexSortedByIndex = maxListWithIndex.sortBy(x\
    \ => x._1).reverse\n        val maxListWithIndexSortedByIndexWithMax = maxListWithIndexSortedByIndex.takeWhile(x\
    \ => x._2 != maxListWithIndexSortedByIndex.last._2)\n        val maxListWithIndexSortedByIndexWithMaxWithIndex\
    \ = maxListWithIndexSortedByIndexWithMax.map(x => (x._2, x._1)).toList\n     \
    \   val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndex = maxListWithIndexSortedByIndexWithMaxWithIndex.sortBy(x\
    \ => x._1).reverse\n        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.takeWhile(x =>\
    \ x._2 != maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.last._2)\n\
    \        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndex\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax.map(x =>\
    \ (x._2, x._1)).toList\n        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.sortBy(x\
    \ => x._1).reverse\n        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.takeWhile(x\
    \ => x._2 != maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndex.last._2)\n\
    \        val maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndex\
    \ = maxListWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMaxWithIndexSortedByIndexWithMax.map(x\
    \ => (x._2, x._1)).toList\n", "        val maxes = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => maxes += x)\n        val maxIndex = maxes.indexOf(0l)\n\
    \        val maxValue = maxes.get(maxIndex)\n        maxes.remove(maxIndex)\n\
    \        maxes.reverse.foreach(x => maxes += x)\n        maxes.reverse.takeWhile(x\
    \ => x <= maxValue).reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxValue = number match\
    \ {\n                case x if x > maxList.length => x\n                case x\
    \ => maxList(x)\n            }\n            maxList += maxValue\n        }\n \
    \       maxList.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { n =>\n            val maxIndex = maxes.indexWhere(_\
    \ > n)\n            if (maxIndex == -1) {\n                maxes += n\n      \
    \      } else {\n                maxes(maxIndex) = maxes(maxIndex) + n\n     \
    \       }\n        }\n        maxes.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = rollingMax.lastIndex\n\
    \            if (maxIndex == -1) {\n                rollingMax += number\n   \
    \         } else {\n                val maxValue = rollingMax(maxIndex)\n    \
    \            if (number > maxValue) {\n                    rollingMax += number\n\
    \                }\n            }\n        }\n        rollingMax.toList", "  \
    \      val rollingMax = numbers.foldLeft(List[Long]())((rollingMax, number) =>\
    \ {\n            val maxIndex = rollingMax.lastIndex\n            if (number >\
    \ rollingMax(maxIndex)) rollingMax else rollingMax.updated(maxIndex, number)\n\
    \        })\n        rollingMax.reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach{ n =>\n            val maxKey = max.max.key\n\
    \            val maxValue = max.max.value\n            val newMaxValue = if (maxKey\
    \ < n) maxValue else n\n            max.put(maxKey, newMaxValue)\n        }\n\
    \        max.toList.sortBy(_._1).reverse", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxList += number\n      \
    \      } else {\n                maxList += maxList(maxIndex - 1)\n          \
    \  }\n        }\n        maxList.toList", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        maxList.drop(maxIndex).reverse.takeWhile(x => x <= numbers(maxIndex)).reverse",
  "        val rollingMax = numbers.foldLeft(List[Long]())((acc, n) => {\n       \
    \     val maxIndex = acc.lastIndexWhere(x => x > n)\n            if (maxIndex\
    \ == -1) acc :+ n\n            else acc :+ acc.apply(maxIndex)\n        })\n \
    \       rollingMax.reverse", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => {\n            val max = max.getOrElse(x, x)\n \
    \           max.update(x, max.get(x) + 1)\n        })\n        val maxList = max.toList.sortBy(_._2).reverse\n\
    \        val rollingMax = maxList.takeWhile(_._2 > numbers.size).map(_._1)\n \
    \       rollingMax", "        val max = new mutable.HashMap[Long, Long]()\n  \
    \      numbers.foreach{ n =>\n            val maxKey = max.max.key\n         \
    \   if (maxKey == null || n > maxKey) {\n                max.put(n, n)\n     \
    \       } else {\n                max.put(maxKey, max)\n                max.remove(maxKey)\n\
    \            }\n        }\n        max.values.toList", "        val maxList =\
    \ mutable.ListBuffer.empty[Long]\n        numbers.foreach(number => {\n      \
    \      val maxNumber = maxList.max\n            if (number > maxNumber) {\n  \
    \              maxList += number\n            }\n        })\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.max.key\n            if (maxKey < n) max.updated(maxKey,\
    \ n)\n        }\n        val maxList = max.values.toList\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement = maxList(maxListIndex)\n        val maxListSize\
    \ = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListElement\
    \ = maxList(maxListIndex)\n        val maxListSize = maxList.size\n        val\
    \ maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListSize = maxList.size\n        val maxListIndex = maxListSize\
    \ - 1\n        val maxListElement", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0L) + x))\n\
    \        val maxList = max.values.toList\n        val maxIndex = max.keys.toList.sortWith(_.compareTo(_)\
    \ < 0).reverse.head\n        val maxElement = maxList(maxIndex)\n        val maxElements\
    \ = maxList.take(maxIndex + 1)\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n    \
    \    val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex =\
    \ maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n      \
    \  val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex = maxList.lastIndex\n\
    \        val maxElementsIndex = maxList.lastIndex\n        val maxElementsIndex\
    \ = ", "        val maxes = mutable.ListBuffer.empty[Long]\n        var max =\
    \ 0\n        numbers.foreach { n =>\n            if (n > max) {\n            \
    \    max = n\n            }\n            maxes += max\n        }\n        maxes",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = max max number\n            if (maxKey >\
    \ number) {\n                max += number -> number\n            }\n        }\n\
    \        val result = new mutable.ListBuffer[Long]()\n        max foreach { case\
    \ (k, v) =>\n            result += k\n        }\n        result.toList", "   \
    \     val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(x => x > number)\n         \
    \   if (maxIndex == -1) {\n                maxes += number\n            } else\
    \ {\n                maxes(maxIndex) = max(maxes(maxIndex), number)\n        \
    \    }\n        }\n        maxes.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val maxList = max.values.toList\n        val maxIndex = max.keys.toList.sortWith(_\
    \ < _).last\n        val maxElement = maxList[maxIndex]\n        val maxElementList\
    \ = List(maxElement)\n        val maxElementListSize = maxElementList.size\n \
    \       val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val maxElementListSize = maxElementListSize\
    \ + 1\n        val maxElementListSize = maxElementListSize + 1\n        val maxElementListSize\
    \ = maxElementListSize + 1\n        val max", "        val maxes = new mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        var i = 0\n        while(i < numbers.size) {\n\
    \            max = max(numbers(i), max)\n            maxes += max\n          \
    \  i += 1\n        }\n        maxes", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l)))\n  \
    \      val rollingMax = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => {\n            val max = max.getOrElse(x, 0l)\n            val rollingMax\
    \ = rollingMax.getOrElse(x, 0l)\n            if (rollingMax < max) {\n       \
    \         rollingMax = max\n            }\n        })\n        rollingMax.keys.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayBuffer[Long]()\n        numbers.foreach { number =>\n         \
    \   val maxKey = max get number\n            if (maxKey == null) {\n         \
    \       max += number -> number\n            } else {\n                max +=\
    \ number -> maxKey\n            }\n        }\n        max foreach { case (number,\
    \ maxKey) =>\n            rollingMax += maxKey\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach {\n            case (k, v) => result += k\n        }\n  \
    \      result.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxIndex = new mutable.HashMap[Long, Int]()\n        numbers.foreach\
    \ { number =>\n            val maxValue = max.getOrElse(number, 0L)\n        \
    \    val maxIndex = maxIndex.getOrElse(number, 0)\n            val newMaxValue\
    \ = number + maxValue\n            val newMaxIndex = maxIndex + 1\n          \
    \  max.put(newMaxValue, newMaxValue)\n            maxIndex.put(newMaxValue, newMaxIndex)\n\
    \        }\n        val maxValues = max.values.toList\n        val maxIndexes\
    \ = maxIndex.values.toList\n        val maxIndexesSorted = maxIndexes.sortBy(_._1)\n\
    \        val maxIndexesSortedReversed = maxIndexesSorted.reverse\n        val\
    \ maxIndexesSortedReversedSorted = maxIndexesSortedReversed.sortBy(_._1)\n   \
    \     val maxIndexesSortedReversedSortedWithIndex = maxIndexesSortedReversedSorted.zipWithIndex.map\
    \ { case (maxIndex, index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndex.sortBy(_._1)\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndex\
    \ = maxIndexesSortedReversedSortedWithIndexSorted.zipWithIndex.map { case (maxIndex,\
    \ index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndex.sortBy(_._1)\n    \
    \    val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndexSorted.zipWithIndex.map\
    \ { case (maxIndex, index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1)\n\
    \        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted.zipWithIndex.map\
    \ { case (maxIndex, index) => (maxIndex._1, index) }\n        val maxIndexesSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = maxIndexesSortedReversedSortedWithIndex", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxes.indexWhere(x\
    \ => x > number)\n            if (maxIndex == -1) {\n                maxes +=\
    \ number\n            } else {\n                maxes(maxIndex) = max(maxes(maxIndex),\
    \ number)\n            }\n        }\n        maxes.toList", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n   \
    \         val max = number.max(max)\n        }\n        max.values.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l)))\n        val rollingMax = numbers.map(x\
    \ => max.getOrElse(x, 0l))\n        rollingMax", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val max = max.getOrElseUpdate(n,\
    \ n)\n        }\n        val maxList = max\n            .entrySet\n          \
    \  .map(x => x._1 -> x._2)\n            .sortBy(x => x._2)\n            .takeWhile(x\
    \ => x._2 > 0)\n            .map(x => x._1)\n        val maxList2 = maxList\n\
    \            .entrySet\n            .map(x => x._1 -> x._2)\n            .sortBy(x\
    \ => x._2)\n            .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n\
    \        val maxList3 = maxList2\n            .entrySet\n            .map(x =>\
    \ x._1 -> x._2)\n            .sortBy(x => x._2)\n            .takeWhile(x => x._2\
    \ > 0)\n            .map(x => x._1)\n        val maxList4 = maxList3\n       \
    \     .entrySet\n            .map(x => x._1 -> x._2)\n            .sortBy(x =>\
    \ x._2)\n            .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n\
    \        val maxList5 = maxList4\n            .entrySet\n            .map(x =>\
    \ x._1 -> x._2)\n            .sortBy(x => x._2)\n            .takeWhile(x => x._2\
    \ > 0)\n            .map(x => x._1)\n        val maxList6 = maxList5\n       \
    \     .entrySet\n            .map(x => x._1 -> x._2)\n            .sortBy(x =>\
    \ x._2)\n            .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n\
    \        val maxList7 = maxList6\n            .entrySet\n            .map(x =>\
    \ x._1 -> x._2)\n            .sortBy(x => x._2)\n            .takeWhile(x => x._2\
    \ > 0)\n            .map(x => x._1)\n        val maxList8 = maxList7\n       \
    \     .entrySet\n            .map(x => x._1 -> x._2)\n            .sortBy(x =>\
    \ x._2)\n            .takeWhile(x => x._2 > 0)\n            .map(x => x._1)\n\
    \        val maxList9 = maxList8\n            .entrySet\n            .map(x =>\
    \ x._1 -> x._2)\n            .sortBy(x => x._2)\n            .takeWhile(x => x._2\
    \ > 0)\n            .map(", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l)))\n        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach(x => {\n         \
    \   val max = max.getOrElse(x, 0l)\n            val newMax = max + x\n       \
    \     max.put(newMax, max)\n            result.add(newMax)\n        })\n     \
    \   result.toList", "        val max = new mutable.HashMap[Long, Long]()\n   \
    \     numbers.foreach(x => max.put(x, max.getOrElse(x, 0l)))\n        val maxList\
    \ = max.toList.sortBy(_._1).reverse\n        val maxListSize = maxList.size\n\
    \        val maxListIndex = maxListSize - 1\n        val maxListElement = maxList(maxListIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = maxList.indexOf(maxListElement)\n        val\
    \ maxListElementSize = maxListElementIndex + 1\n        val maxListElement = maxList(maxListElementIndex)\n\
    \        val maxListElementIndex = ", "        val rollingMax = numbers.foldLeft(List[Long]())((rollingMax,\
    \ number) => {\n            val maxIndex = rollingMax.lastIndex\n            if\
    \ (maxIndex == numbers.size) {\n                rollingMax :+ number\n       \
    \     } else {\n                val maxValue = rollingMax(maxIndex + 1)\n    \
    \            rollingMax :+ maxValue\n            }\n        })\n        rollingMax.reverse",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxNumber = maxList.getOrElse(number).max(number).getOrElse(number)\n\
    \            maxList += maxNumber\n        }\n        maxList.toList", "     \
    \   val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result += x)\n        result.toList", "     \
    \   val maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => {\n\
    \            val maxValue = maxList.getOrElse(x - 1)\n            if (maxValue\
    \ < x) maxList += x\n        })\n        maxList.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0l)))\n        val result: List[Long] = numbers.map(x => max.getOrElse(x, 0l))\n\
    \        result", "        val maxes = mutable.ListBuffer.empty[Long]\n      \
    \  numbers.foreach { number =>\n            val maxIndex = numbers.indexWhere(_\
    \ > number)\n            if (maxIndex == numbers.size) {\n                maxes\
    \ += number\n            } else {\n                maxes += numbers(maxIndex +\
    \ 1)\n            }\n        }\n        maxes", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => rollingMax.append(x))\n        rollingMax.takeWhile(x\
    \ => x <= numbers.last).reverse", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ element) => {\n            val maxIndex = acc.indexWhere(x => x > element)\n\
    \            if (maxIndex == acc.length - 1) {\n                acc :+ element\n\
    \            } else {\n                acc :+ max(acc(maxIndex + 1), element)\n\
    \            }\n        })\n        rollingMax.reverse", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x,\
    \ 0L) + x))\n        val maxList = max.toList.sortBy(_._1).reverse\n        val\
    \ result: List[Long] = new mutable.ArrayBuffer[Long]()\n        val currentMax\
    \ = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n        val\
    \ currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMaxIndex = maxList.indexOf(0)\n\
    \        val currentMaxValue = maxList(0)\n        val currentMax", "        val\
    \ rollingMax = numbers.foldLeft(List[Long]())((acc, number) => {\n           \
    \ val rollingMax = acc.lastOption.map(_ + number).getOrElse(number)\n        \
    \    acc :+ rollingMax\n        })\n        rollingMax.reverse", "        val\
    \ maxList = mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxList +=\
    \ x)\n        val maxIndex = maxList.indexOf(maxList.max)\n        maxList.drop(maxIndex).takeRight(numbers.size\
    \ - maxIndex).reverse.foldLeft(maxList)(_++_)", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.max.key\n\
    \            if (maxKey == null || n < maxKey) {\n                max.put(n, n)\n\
    \            } else {\n                val maxValue = max.max.value\n        \
    \        if (maxValue < n) {\n                    max.put(n, maxValue)\n     \
    \           } else {\n                    max.remove(maxKey)\n               \
    \     max.put(n, maxValue)\n                }\n            }\n        }\n    \
    \    max.values.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            rollingMax += number\n     \
    \   })\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max max n\n\
    \            if (maxKey > n) max += n -> maxKey\n        }\n        max map {\
    \ case (k, v) => k -> v }.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            if (maxIndex == -1) maxList += number\n            else {\n     \
    \           val maxValue = maxList(maxIndex)\n                if (number > maxValue)\
    \ maxList += number\n            }\n        }\n        maxList.toList", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0L) + x))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.values.foreach(x => result.add(x))\n        result.sortWith(_ < _)",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = numbers.indexWhere(_\
    \ > numbers.last)\n        numbers.drop(maxIndex).foreach { number =>\n      \
    \      val maxValue = numbers.take(maxIndex).max\n            maxList += maxValue\n\
    \        }\n        maxList.toList", "        val rollingMax = numbers.foldLeft(List[Long]())((acc,\
    \ x) => {\n            val maxIndex = acc.indexWhere(x => x > x)\n           \
    \ val maxValue = acc.get(maxIndex)\n            val newMaxValue = if (maxValue\
    \ > x) x else maxValue\n            acc :+ newMaxValue\n        })\n        rollingMax.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l)))\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach {\n            case (k, v) => result.append((k - v).max(0l))\n\
    \        }\n        result.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max(n, n)\n\
    \            val maxValue = max(n, n)\n            max.put(maxKey, maxValue)\n\
    \        }\n        max.values.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            rollingMax.append(number)\n\
    \            rollingMax.append(number)\n        })\n        rollingMax.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxElement = maxList.toList.max\n            if (number\
    \ > maxElement) {\n                maxList += number\n            }\n        }\n\
    \        maxList.toList", "        val maxRollingNumbers = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val maxRollingNumber = maxRollingNumbers.max\n\
    \            if (number > maxRollingNumber) {\n                maxRollingNumbers\
    \ += number\n            }\n        }\n        maxRollingNumbers.toList", "  \
    \      val maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach {\
    \ number =>\n            val maxValue = maxList.toList.max\n            if (number\
    \ > maxValue) {\n                maxList += number\n            }\n        }\n\
    \        maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        val maxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            val index = maxList.size\n            maxList += number\n\
    \            maxIndex += index\n        }\n        val maxIndex = maxIndex.toList\n\
    \        val maxList = maxList.toList\n        val maxIndex = maxIndex.sortBy(-_)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.last)\n        val maxIndex = maxIndex.take(maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0l) + x))\n\
    \        val maxList = new mutable.ListBuffer[Long]()\n        max.values.foreach(x\
    \ => maxList += x)\n        maxList.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxList += x)\n        val maxIndex = maxList.lastIndex\n\
    \        val maxElement = maxList(maxIndex)\n        val maxList = maxList.drop(maxIndex\
    \ + 1)\n        val maxListWithMaxElement = maxList :+ maxElement\n        rollingMax(maxListWithMaxElement)",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0l)))\n        val maxList = max.toList.sortBy(-_._1).reverse\n\
    \        val maxElement = maxList.head._2\n        val maxElements = maxList.tail.filter(_._2\
    \ == maxElement)\n        val maxElementsUntilMoment = maxElements.takeWhile(_._1\
    \ < moment)\n        val maxElementsUntilMomentList = maxElementsUntilMoment.toList\n\
    \        val maxElementsUntilMomentListWithMax = maxElementsUntilMomentList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxList = maxElementsUntilMomentListWithMax.toList\n\
    \        val maxElementsUntilMomentListWithMaxListWithMax = maxElementsUntilMomentListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxList\
    \ = maxElementsUntilMomentListWithMaxListWithMax.toList\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMax\
    \ = maxElementsUntilMomentListWithMaxListWithMaxList.reverse.takeWhile(_._2 !=\
    \ maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxList\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMax.toList\n        val\
    \ maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMax = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxList\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxListWithMax\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxListWithMax\
    \ = maxElementsUntilMomentListWithMaxListWithMaxListWithMaxListWithMaxList.reverse.takeWhile(_._2\
    \ != maxElement)\n        val maxElementsUntilMomentListWithMaxListWithMax"]
stop_tokens:
- "\n    }\n"
