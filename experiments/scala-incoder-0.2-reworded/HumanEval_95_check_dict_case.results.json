{
  "language": "scala",
  "name": "HumanEval_95_check_dict_case",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty)\n            return false\n        var lower = true\n        var upper = true\n        for (key <- dict.keySet) {\n            if (key.isLower)\n                lower = false\n            if (key.isUpper)\n                upper = false\n        }\n        return lower || upper\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkrkpfao1.scala:24:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (key.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkrkpfao1.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (key.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800202
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val isAllLowerCase = lower.forall(_.isLower)\n        val isAllUpperCase = upper.forall(_.isUpper)\n        isAllLowerCase && isAllUpperCase && both.forall(_.toString.toLowerCase == _.toString.toUpperCase)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptlp1mmf3.scala:23:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllLowerCase\u001b[0m = lower.forall(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptlp1mmf3.scala:24:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllUpperCase\u001b[0m = upper.forall(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmptlp1mmf3.scala:25:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        isAllLowerCase && isAllUpperCase && both.forall(_.toString.toLowerCase == _.toString.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return true\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        return lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpewoj0zvh.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpewoj0zvh.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpewoj0zvh.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpewoj0zvh.scala:25:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mreturn\u001b[0m lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxpj26tsl.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800202
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.isEmpty == upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqn8kxq9e.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqn8kxq9e.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val isLower = lower.forall(_.isInstanceOf[String])\n        val isUpper = upper.forall(_.isInstanceOf[String])\n        isLower && isUpper\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmple553x09.scala:28)\n\tat Problem.main(tmple553x09.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val result = lower.forall(x => upper.contains(x))\n        !result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm9tp8kq4.scala:22:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = lower.forall(\u001b[36mx\u001b[0m => upper.contains(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800202
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp53o4i63c.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp53o4i63c.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp53o4i63c.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp53o4i63c.scala:25:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt51ql4wx.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val upperCaseKeys = keys.filter(_.isUpper)\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val allKeys = upperCaseKeys ++ lowerCaseKeys\n        allKeys.forall(key => dict.get(key).isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpedoda_1w.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpedoda_1w.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val upperCaseKeys = keys.filter(_.isUpper)\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeySet = upperCaseKeys.toSet\n        val lowerCaseKeySet = lowerCaseKeys.toSet\n        if(upperCaseKeySet.isEmpty && lowerCaseKeySet.isEmpty)\n            return true\n        if(upperCaseKeySet.isEmpty || lowerCaseKeySet.isEmpty)\n            return false\n        if(upperCaseKeySet.size != lowerCaseKeySet.size)\n            return false\n        val upperCaseKeySetIterator = upperCaseKeySet.iterator\n        val lowerCaseKeySetIterator = lowerCaseKeySet.iterator\n        while(upperCaseKeySetIterator.hasNext && lowerCaseKeySetIterator.hasNext) {\n            val upperCaseKey = upperCaseKeySetIterator.next\n            val lowerCaseKey = lowerCaseKeySetIterator.next\n            if(upperCaseKey.toString.toLowerCase != lowerCaseKey.toString.toLowerCase || upperCaseKey.toString.toUpperCase != lowerCaseKey.toString.toUpperCase)\n                return false\n        }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsk4ell8m.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsk4ell8m.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt51ql4wx.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys.contains)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys.contains)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpolvdop_m.scala:22:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpolvdop_m.scala:23:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.isEmpty) false\n        else if(keys.forall(_.isInstanceOf[String])) true\n        else false\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5mpbwx1p.scala:26)\n\tat Problem.main(tmp5mpbwx1p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains)\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3yseakvx.scala:28)\n\tat Problem.main(tmp3yseakvx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lowerKeys = keys.map(_.toLowerCase)\n        val upperKeys = keys.map(_.toUpperCase)\n        lowerKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7geihrt2.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = lowerCaseKeys.toSet\n        val upperCaseDict = upperCaseKeys.toSet\n        val allKeys = lowerCaseKeys ++ upperCaseKeys\n        val allDict = lowerCaseDict ++ upperCaseDict\n        val isAllKeysString = allKeys.forall(_.isInstanceOf[String])\n        val isAllDictString = allDict.forall(_.isInstanceOf[String])\n        val isAllKeysStringOrAllDictString = isAllKeysString || isAllDictString\n        val isAllKeysStringOrAllDictStringOrBothEmpty = isAllKeysStringOrAllDictString || keys.isEmpty\n        val isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmpty = isAllKeysStringOrAllDictStringOrBothEmpty || allKeys.forall(_.isInstanceOf[String])\n        val isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothEmpty = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmpty || keys.isEmpty\n        val isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmpty = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothEmpty\n        val isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\n        val isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmpty = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmpty\n        val isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\n        val isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothNot\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpzmxhj122.scala:33:95 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\u001b[0m = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpzmxhj122.scala:34:98 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmpty\u001b[0m = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmpty\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmpty\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpzmxhj122.scala:35:109 --------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\u001b[0m = isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  isAllKeysStringOrAllDictStringOrBothEmptyOrBothNotEmptyOrBothNotEmptyOrBothNotEmptyOrBothEmpty\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   ",
      "stdout": "",
      "timestamp": 1659800201
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) &&\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqn0x9a44.scala:28)\n\tat Problem.main(tmpqn0x9a44.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.keys.toSet.toList.forall(_.isInstanceOf[String]) && dict.keys.toSet.toList.forall(_.isInstanceOf[String]) && dict.keys.toSet.toList.forall(_.toLowerCase == _.toLowerCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpsyhws01b.scala:20:158 --------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.keys.toSet.toList.forall(_.isInstanceOf[String]) && dict.keys.toSet.toList.forall(_.isInstanceOf[String]) && dict.keys.toSet.toList.forall(_.toLowerCase == _.toLowerCase))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800199
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val allLowerCaseKeys = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val allUpperCaseKeys = upperCaseKeys.forall(_.isInstanceOf[String])\n        allLowerCaseKeys && allUpperCaseKeys\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3kocs_do.scala:28)\n\tat Problem.main(tmp3kocs_do.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allKeys = upperCaseKeys ++ lowerCaseKeys\n        allKeys.forall(key => dict.get(key) != null)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptk07t5e9.scala:27)\n\tat Problem.main(tmptk07t5e9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.keys.toSet.toList.map(_.toLowerCase).toSet == dict.keys.toSet.toList.map(_.toUpperCase).toSet)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwm3nva0_.scala:23)\n\tat Problem.main(tmpwm3nva0_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800214
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.forall(_.isLetter))\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.forall(_.isLetter))\n        val lowerCaseDictSize = lowerCaseDict.size\n        val upperCaseDictSize = upperCaseDict.size\n        val isDictCase = lowerCaseDictSize == upperCaseDictSize && lowerCaseKeys == upperCaseKeys\n        isDictCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgong_9hw.scala:30)\n\tat Problem.main(tmpgong_9hw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val isAllUpper = upperCaseKeys.forall(_.equals(keys))\n        val isAllLower = lowerCaseKeys.forall(_.equals(keys))\n        isAllUpper && isAllLower\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpohhszjb1.scala:27)\n\tat Problem.main(tmpohhszjb1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.isEmpty  || upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwvwym6im.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwvwym6im.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800214
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val isLowerCase = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val isUpperCase = upperCaseKeys.forall(_.isInstanceOf[String])\n        val isAllLowerCase = isLowerCase && isUpperCase\n        val isAllUpperCase = isUpperCase && isLowerCase\n        isAllLowerCase || isAllUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9b8rjk04.scala:30)\n\tat Problem.main(tmp9b8rjk04.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.forall(_.isLetter))\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.forall(_.isLetter))\n        lowerCaseKeys.isEmpty  ||  upperCaseKeys.isEmpty  ||  lowerCaseDict.size == upperCaseDict.size || lowerCaseDict.size == keys.size || upperCaseDict.size == keys.size\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_834buw8.scala:28)\n\tat Problem.main(tmp_834buw8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val isAllUpperCase = upperCaseKeys.forall(_.equals(keys))\n        val isAllLowerCase = lowerCaseKeys.forall(_.equals(keys))\n        isAllUpperCase && isAllLowerCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3268v11y.scala:27)\n\tat Problem.main(tmp3268v11y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.forall(key => upperCaseKeys.contains(key)) || upperCaseKeys.forall(key => lowerCaseKeys.contains(key))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:22:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => upperCaseKeys.contains(key)) || upperCaseKeys.forall(\u001b[36mkey\u001b[0m => lowerCaseKeys.contains(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:22:110 -----------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => upperCaseKeys.contains(key)) || upperCaseKeys.forall(\u001b[36mkey\u001b[0m => lowerCaseKeys.contains(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return true\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        return lowerCaseDict.isEmpty && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjtp8bybl.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjtp8bybl.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjtp8bybl.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.forall(key => upperCaseKeys.contains(key)) || upperCaseKeys.forall(key => lowerCaseKeys.contains(key))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:22:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => upperCaseKeys.contains(key)) || upperCaseKeys.forall(\u001b[36mkey\u001b[0m => lowerCaseKeys.contains(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:22:110 -----------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => upperCaseKeys.contains(key)) || upperCaseKeys.forall(\u001b[36mkey\u001b[0m => lowerCaseKeys.contains(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val isLowerOrUpper = lower ++ upper.forall(_.contains(_))\n        !isLowerOrUpper.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp5ecxddob.scala:22:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misLowerOrUpper\u001b[0m = lower ++ upper.forall(_.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800210
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = lowerCaseKeys.toMap\n        val upperCaseDict = upperCaseKeys.toMap\n        val keysSet = keys.toSet\n        val lowerCaseKeysSet = lowerCaseKeys.toSet\n        val upperCaseKeysSet = upperCaseKeys.toSet\n        val lowerCaseDictSet = lowerCaseDict.toSet\n        val upperCaseDictSet = upperCaseDict.toSet\n        val keysSetSet = keysSet.toSet\n        val lowerCaseKeysSetSet = lowerCaseKeysSet.toSet\n        val upperCaseKeysSetSet = upperCaseKeysSet.toSet\n        val lowerCaseDictSetSet = lowerCaseDictSet.toSet\n        val upperCaseDictSetSet = upperCaseDictSet.toSet\n        val keysSetSetSet = keysSetSet.toSet\n        val lowerCaseKeysSetSetSet = lowerCaseKeysSetSet.toSet\n        val upperCaseKeysSetSetSet = upperCaseKeysSetSet.toSet\n        val lowerCaseDictSetSetSet = lowerCaseDictSetSet.toSet\n        val upperCaseDictSetSetSet = upperCaseDictSetSet.toSet\n        val keysSetSetSetSet = keysSetSetSet.toSet\n        val lowerCaseKeysSetSetSetSet = lowerCaseKeysSetSetSet.toSet\n        val upperCaseKeysSetSetSetSet = upperCaseKeysSetSetSet.toSet\n        val lowerCaseDictSetSetSetSet = lowerCaseDictSetSetSet.toSet\n        val upperCaseDictSetSetSetSet = upperCaseDictSetSetSet.toSet\n        val keysSetSetSetSetSet = keysSetSetSetSet.toSet\n        val lowerCaseKeysSetSetSetSetSet = lowerCaseKeysSetSetSetSet.toSet\n        val upperCaseKeysSetSetSetSetSet = upperCaseKeysSetSetSetSet.toSet\n        val lowerCaseDictSetSetSetSetSet = lowerCaseDictSetSetSetSet.toSet\n        val upperCaseDictSetSetSetSetSet = upperCaseDictSetSetSetSet.toSet\n        val keysSetSetSetSetSetSet = keysSetSetSetSetSet.toSet\n        val lowerCaseKeysSetSetSetSetSetSet = lowerCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpx5qtorts.scala:22:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = lowerCaseKeys.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Cannot prove that String <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                     where:    K is a type variable\n\u001b[31m   |\u001b[0m                                               V is a type variable\n\u001b[31m   |\u001b[0m                                     .\n\u001b[31m\u001b[31m-- Error: /tmp/tmpx5qtorts.scala:23:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = upperCaseKeys.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Cannot prove that String <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                     where:    K is a type variable\n\u001b[31m   |\u001b[0m                                               V is a type variable\n\u001b[31m   |\u001b[0m                                     .\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx5qtorts.scala:50:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeysSetSetSetSetSetSet\u001b[0m = lowerCase\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: lowerCase\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpx5qtorts.scala:51:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        val isAllLowerCase = lowerCaseKeys.forall(_.equals(dict))\n        val isAllUpperCase = upperCaseKeys.forall(_.equals(dict))\n        isAllLowerCase && isAllUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf5qlmgne.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf5qlmgne.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800214
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt51ql4wx.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val all = lower ++ upper\n        val result = all forall keys.contains(\"String\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpk5_88zh2.scala:23:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = all forall keys.contains(\u001b[31m\"String\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800214
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys.contains)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys.contains)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:22:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:23:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val notBoth = keys.filter(!both.contains(_))\n        notBoth.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyr5htf9i.scala:23:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotBoth\u001b[0m = keys.filter(!both.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val upperCaseKeys = keys.filter(_.isUpper)\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val isAllUpper = upperCaseKeys.size == keys.size\n        val isAllLower = lowerCaseKeys.size == keys.size\n        val isAllCase = isAllUpper && isAllLower\n        val isAllSameCase = upperCaseKeys.size == lowerCaseKeys.size && upperCaseKeys.size == keys.size\n        isAllCase || isAllSameCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaw6esifl.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaw6esifl.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.forall(key => upperCaseKeys.contains(key)) || upperCaseKeys.forall(key => lowerCaseKeys.contains(key))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:22:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => upperCaseKeys.contains(key)) || upperCaseKeys.forall(\u001b[36mkey\u001b[0m => lowerCaseKeys.contains(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt76b84be.scala:22:110 -----------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => upperCaseKeys.contains(key)) || upperCaseKeys.forall(\u001b[36mkey\u001b[0m => lowerCaseKeys.contains(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys.contains)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys.contains)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:22:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:23:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = lowerCaseKeys.toSet\n        val upperCaseDict = upperCaseKeys.toSet\n        lowerCaseDict.isEmpty || upperCaseDict.isEmpty || lowerCaseDict.subsetOf(upperCaseDict)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsr7wp51d.scala:27)\n\tat Problem.main(tmpsr7wp51d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase)\n        lowerCaseKeys.forall(lowerCaseDict.contains) &&\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf4y8nsue.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(_.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    String\n\u001b[31m   |\u001b[0m                                            Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf4y8nsue.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(_.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    String\n\u001b[31m   |\u001b[0m                                            Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val isAllLowerOrUpper = both.forall(_.equals(keys.toSet))\n        isAllLowerOrUpper || dict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbayph9cf.scala:27)\n\tat Problem.main(tmpbayph9cf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val isAllLowerCase = lowerCaseKeys.forall(_.equals(keys))\n        val isAllUpperCase = upperCaseKeys.forall(_.equals(keys))\n        isAllLowerCase && isAllUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0h25pgna.scala:27)\n\tat Problem.main(tmp0h25pgna.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val result = both.forall(x => dict.get(x) == x)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpnxw1hobg.scala:23:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = both.forall(\u001b[36mx\u001b[0m => dict.get(x) == x)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Option[String] and String cannot be compared with == or !=\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        if(lowerCaseDict.isEmpty) lowerCaseDict.size == upperCaseDict.size\n        else upperCaseDict.size == lowerCaseDict.size\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp788eqz0_.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp788eqz0_.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp788eqz0_.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val isStringInLowerCase = keys.forall(_.toLowerCase.contains(\"a\"))\n        val isStringInUpperCase = keys.forall(_.toUpperCase.contains(\"A\"))\n        isStringInLowerCase && isStringInUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc3300mft.scala:25)\n\tat Problem.main(tmpc3300mft.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800217
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys.contains)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys.contains)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:22:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:23:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return true\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        return lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpewoj0zvh.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpewoj0zvh.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpewoj0zvh.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpewoj0zvh.scala:25:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mreturn\u001b[0m lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else {\n            val keys = dict.keys\n            val lower = keys.map(_.toLowerCase)\n            val upper = keys.map(_.toUpperCase)\n            val both = keys.map(k => k -> dict.get(k).toString.toLowerCase == dict.get(k).toString.toUpperCase)\n            val result = lower == upper || both\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpeoyi4amv.scala:24:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mboth\u001b[0m = keys.map(\u001b[36mk\u001b[0m => k -> dict.get(k).toString.toLowerCase == dict.get(k).toString.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types (String, String) and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeoyi4amv.scala:25:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = lower == upper || both\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (both : Iterable[Boolean])\n\u001b[31m   |\u001b[0m                                    Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800223
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.filter(_.isUpper)\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeysSet = upperCaseKeys.toSet\n        val lowerCaseKeysSet = lowerCaseKeys.toSet\n        val result = upperCaseKeysSet.union(lowerCaseKeysSet).isEmpty\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp21hkb3jg.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp21hkb3jg.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.forall(_.isLetter))\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.forall(_.isLetter))\n        val lowerCaseDictKeys = lowerCaseDict.keys\n        val upperCaseDictKeys = upperCaseDict.keys\n        val lowerCaseDictValues = lowerCaseDict.values\n        val upperCaseDictValues = upperCaseDict.values\n        val lowerCaseDictKeysSet = lowerCaseKeys.toSet\n        val upperCaseDictKeysSet = upperCaseKeys.toSet\n        val lowerCaseDictValuesSet = lowerCaseValues.toSet\n        val upperCaseDictValuesSet = upperCaseValues.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSet = keys.toSet\n        \n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh7em8dm.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mkeysSet\u001b[0m = keys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mkeysSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mkeysSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh7em8dm.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mvaluesSet\u001b[0m = values.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvaluesSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mvaluesSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh7em8dm.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mkeysSet\u001b[0m = keys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mkeysSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mkeysSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh7em8dm.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mvaluesSet\u001b[0m = values.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvaluesSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mvaluesSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjh7em8dm.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mkeysSet\u001b[0m = keys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mkeysSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mkeysSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same",
      "stdout": "",
      "timestamp": 1659800225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n            upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpti5mlow0.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp40a13s5y.scala:20:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toLowerCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp40a13s5y.scala:20:61 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => _$3.toLowerCase.\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp40a13s5y.scala:20:98 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toUpperCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp40a13s5y.scala:20:127 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$6 of expanded function:\n\u001b[31m   |\u001b[0m   _$6 => _$6.toUpperCase.\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = lowerCaseKeys.toSet\n        val upperCaseDict = upperCaseKeys.toSet\n        lowerCaseDict.isEmpty || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp99rz5kr9.scala:27)\n\tat Problem.main(tmp99rz5kr9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val all = lower ++ upper\n        val result = all forall (x => keys.contains(x))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprqzj9ax0.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprqzj9ax0.scala:24:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = all forall (\u001b[36mx\u001b[0m => keys.contains(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val allLower = lower.forall(_.isInstanceOf[String])\n        val allUpper = upper.forall(_.isInstanceOf[String])\n        allLower && allUpper\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprc1b5wjo.scala:28)\n\tat Problem.main(tmprc1b5wjo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.forall(_.isLetter))\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.forall(_.isLetter))\n        lowerCaseKeys.isEmpty  ||  upperCaseKeys.isEmpty  ||  lowerCaseDict.size == upperCaseDict.size || lowerCaseDict.size == keys.size\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpy2r815_m.scala:28)\n\tat Problem.main(tmpy2r815_m.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeysSet = lowerCaseKeys.toSet\n        val upperCaseKeysSet = upperCaseKeys.toSet\n        val allKeysSet = lowerCaseKeysSet.union(upperCaseKeysSet)\n        val isAllKeysSet = allKeysSet.isEmpty\n        val isAllKeysLowerCase = allKeysSet.size == lowerCaseKeysSet.size\n        val isAllKeysUpperCase = allKeysSet.size == upperCaseKeysSet.size\n        val isAllKeysAllCase = allKeysSet.size == keys.size\n        val isAllKeysNotEmpty = allKeysSet.isDefined\n        val isAllKeysNotEmptyOrAllCase = allKeysSet.isDefined || allKeysSet.size == keys.size\n        val isAllKeysNotEmptyOrAllCaseOrNotAllKeysSet = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty\n        val isAllKeysNotEmptyOrAllCaseOrNotAllKeysSetOrNotAllKeysSet = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty || allKeysSet.size != keys.size\n        val isAllKeysNotEmptyOrAllCaseOrNotAllKeysSetOrNotAllKeysSetOrNotAllKeysSet = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty || allKeysSet.size != keys.size || allKeysSet.isEmpty\n        val isAllKeysNotEmptyOrAllCaseOrNotAllKeysSetOrNotAllKeysSetOrNotAllKeysSetOrNotAllKeysSet = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty || allKeysSet.size != keys.size || allKeysSet.isEmpty || allKeysSet.isEmpty\n        val isAllKeysNotEmptyOrAllCaseOrNotAllKeysSetOrNotAllKeysSetOrNotAllKeysSetOrNotAllKeysSetOrNotAllKeysSet = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty || all\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv98ok29q.scala:29:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysNotEmpty\u001b[0m = allKeysSet.isDefined\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value isDefined is not a member of Set[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv98ok29q.scala:30:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysNotEmptyOrAllCase\u001b[0m = allKeysSet.isDefined || allKeysSet.size == keys.size\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value isDefined is not a member of Set[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv98ok29q.scala:31:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysNotEmptyOrAllCaseOrNotAllKeysSet\u001b[0m = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value isDefined is not a member of Set[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv98ok29q.scala:32:82 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysNotEmptyOrAllCaseOrNotAllKeysSetOrNotAllKeysSet\u001b[0m = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty || allKeysSet.size != keys.size\n\u001b[31m\u001b[31m   |\u001b[0m                                                                       ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value isDefined is not a member of Set[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv98ok29q.scala:33:97 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllKeysNotEmptyOrAllCaseOrNotAllKeysSetOrNotAllKeysSetOrNotAllKeysSet\u001b[0m = allKeysSet.isDefined || allKeysSet.size == keys.size || allKeysSet.isEmpty || allKeysSet.size != keys.size || allKeysSet.isEmpty\n\u001b[31m\u001b[31m ",
      "stdout": "",
      "timestamp": 1659800227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = keys.map(k => (k.toLowerCase, k.toUpperCase))\n        val all = lower ++ upper ++ both\n        val empty = keys.isEmpty\n        val equal = keys.size == all.length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ both).length\n        val equal = keys.size == (lower ++ upper ++ \n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpandp8ewu.scala:55:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mequal\u001b[0m = keys.size == (lower ++ upper ++ \n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpandp8ewu.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mequal\u001b[0m = keys.size == (lower ++ upper ++ both).length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mequal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mequal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpandp8ewu.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mequal\u001b[0m = keys.size == (lower ++ upper ++ both).length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mequal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mequal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpandp8ewu.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mequal\u001b[0m = keys.size == (lower ++ upper ++ both).length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mequal is already defined as \u001b[33mvalue\u001b[0m \u001b[35mequal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpandp8ewu.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mequal\u001b[0m = keys.size == (lower ++ upper ++ both).length",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val isLowerOrUpper = lower ++ upper\n        val isAllLowerOrUpper = isLowerOrUpper.forall(_.isInstanceOf[String])\n        val isAllUpper = isLowerOrUpper.forall(_.isInstanceOf[String])\n        isAllLowerOrUpper && isAllUpper\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpoeo93k1l.scala:29)\n\tat Problem.main(tmpoeo93k1l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800229
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt51ql4wx.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase)\n        val lowerCaseDictKeys = lowerCaseDict.keys\n        val upperCaseDictKeys = upperCaseDict.keys\n        val lowerCaseDictValues = lowerCaseDict.values\n        val upperCaseDictValues = upperCaseDict.values\n        val lowerCaseDictValuesKeys = lowerCaseDictValues.map(_.toLowerCase)\n        val upperCaseDictValuesKeys = upperCaseDictValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValues = lowerCaseDictValues.map(_.toLowerCase)\n        val upperCaseDictValuesValues = upperCaseDictValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesKeys = lowerCaseDictValuesValues.map(_.toLowerCase)\n        val upperCaseDictValuesValuesKeys = upperCaseDictValuesValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesValues = lowerCaseDictValuesValues.map(_.toLowerCase)\n        val upperCaseDictValuesValuesValues = upperCaseDictValuesValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesValuesKeys = lowerCaseDictValuesValuesValues.map(_.toLowerCase)\n        val upperCaseDictValuesValuesValuesKeys = upperCaseDictValuesValuesValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesValuesValues = lowerCaseDictValuesValuesValues.map(_.toLowerCase)\n        val upperCaseDictValuesValuesValuesValues = upperCaseDictValuesValuesValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesValuesValuesKeys = lowerCaseDictValuesValuesValuesValues.map(_.toLowerCase)\n        val upperCaseDictValuesValuesValuesValuesKeys = upperCaseDictValuesValuesValuesValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesValuesValuesValues = lowerCaseDictValuesValuesValuesValues.map(_.toLowerCase)\n        val upperCaseDictValuesValuesValuesValuesValues = upperCaseDictValuesValuesValuesValuesValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesValuesValuesValuesKeys = lowerCaseDictValuesValuesValuesValuesValues.map(_.toLowerCase)\n        val upperCaseDictValuesValuesValuesValuesValuesKeys = upperCaseDictValuesValuesValuesValuesValues.map(_.toUpperCase)\n        val lowerCaseDictValuesValuesValues\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqrn0rro7.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqrn0rro7.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(_.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    String\n\u001b[31m   |\u001b[0m                                            Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqrn0rro7.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(_.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    String\n\u001b[31m   |\u001b[0m                                            Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpqrn0rro7.scala:43:58 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDictValuesValuesValuesValuesValues\u001b[0m = upperCaseDictValuesValuesValuesValuesValues.map(_.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m  Recursive \u001b[33mvalue\u001b[0m \u001b[35mupperCaseDictValuesValuesValuesValuesValues\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqrn0rro7.scala:47:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val allLowerCaseKeys = keys.forall(_.toLowerCase.equalsIgnoreCase)\n        val allUpperCaseKeys = keys.forall(_.toUpperCase.equalsIgnoreCase)\n        val allKeys = lowerCaseKeys ++ upperCaseKeys\n        allKeys.forall(_.equalsIgnoreCase(dict.getOrElse(\"key\", null))) \n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprh3_gzx8.scala:22:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallLowerCaseKeys\u001b[0m = keys.forall(_.toLowerCase.equalsIgnoreCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    \u001b[1m\u001b[31mString\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m=\u001b[0m\u001b[1m\u001b[31m>\u001b[0m\u001b[1m\u001b[31m \u001b[0mBoolean\n\u001b[31m   |\u001b[0m                                           Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprh3_gzx8.scala:23:43 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallUpperCaseKeys\u001b[0m = keys.forall(_.toUpperCase.equalsIgnoreCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    \u001b[1m\u001b[31mString\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m=\u001b[0m\u001b[1m\u001b[31m>\u001b[0m\u001b[1m\u001b[31m \u001b[0mBoolean\n\u001b[31m   |\u001b[0m                                           Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        val lowerCaseDictKeys = lowerCaseDict.keys\n        val upperCaseDictKeys = upperCaseDict.keys\n        val lowerCaseDictValues = lowerCaseDict.values\n        val upperCaseDictValues = upperCaseDict.values\n        val lowerCaseDictKeysSet = lowerCaseKeys.toSet\n        val upperCaseDictKeysSet = upperCaseKeys.toSet\n        val lowerCaseDictValuesSet = lowerCaseValues.toSet\n        val upperCaseDictValuesSet = upperCaseValues.toSet\n        val keysSet = keys.toSet\n        val valuesSet = values.toSet\n        val keysSetKeys = keysSet.map(_.toLowerCase)\n        val keysSetValues = keysSet.map(_.toUpperCase)\n        val valuesSetKeys = valuesSet.map(_.toLowerCase)\n        val valuesSetValues = valuesSet.map(_.toUpperCase)\n        val keysSetKeysSet = keysSetKeys.toSet\n        val keysSetValuesSet = keysSetValues.toSet\n        val valuesSetKeysSet = valuesSetKeys.toSet\n        val valuesSetValuesSet = valuesSetValues.toSet\n        val keysSetKeysSetKeys = keysSetKeysSet.map(_.toLowerCase)\n        val keysSetKeysSetValues = keysSetValuesSet.map(_.toUpperCase)\n        val keysSetValuesSetKeys = keysSetValuesSet.map(_.toLowerCase)\n        val keysSetValuesSetValues = keysSetValuesSet.map(_.toUpperCase)\n        val keysSetKeysSetKeysSet = keysSetKeysSetKeys.map(_.toLowerCase)\n        val keysSetKeysSetValuesSet = keysSetValuesSetKeys.map(_.toUpperCase)\n        val keysSetValuesSetKeysSet = keysSetValuesSetValues.map(_.toLowerCase)\n        val keysSetValuesSetValuesSet = keysSetValuesSetValues.map(_.toUpperCase)\n        val keysSetKeysSetKeysSetKeys = keysSetKeysSetKeysSet.map(_.toLowerCase)\n        val keysSetKeysSetKeysSetValues = keysSetKeysSetValuesSet.map(_.toUpperCase)\n        val keysSet\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp04ayynoo.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp04ayynoo.scala:30:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDictValuesSet\u001b[0m = lowerCaseValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: lowerCaseValues\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp04ayynoo.scala:31:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDictValuesSet\u001b[0m = upperCaseValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: upperCaseValues\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp04ayynoo.scala:33:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mvaluesSet\u001b[0m = values.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: values\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp04ayynoo.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659800227
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (\n            dict.keys.toSet.toList.forall(_.isInstanceOf[String]) &&\n            dict.keys.toSet.toList.forall(_.isInstanceOf[String]) &&\n            dict.keys.toSet.toList.forall(_.toString.toLowerCase() == _.toString.toLowerCase()) &&\n            dict.keys.toSet.toList.forall(_.toString.toUpperCase() == _.toString.toUpperCase())\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp30m7_dy8.scala:23:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            dict.keys.toSet.toList.forall(_.toString.toLowerCase() == _.toString.toLowerCase()) &&\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp30m7_dy8.scala:24:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            dict.keys.toSet.toList.forall(_.toString.toUpperCase() == _.toString.toUpperCase())\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lowerKeys = keys.map(_.toLowerCase)\n        val upperKeys = keys.map(_.toUpperCase)\n        lowerKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7geihrt2.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys.contains)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys.contains)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:22:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpagesp2_n.scala:23:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.isEmpty) false\n        else if(keys.forall(_.isInstanceOf[String])) true\n        else false\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5mpbwx1p.scala:26)\n\tat Problem.main(tmp5mpbwx1p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val upperCaseKeys = keys.filter(_.toString.toUpperCase == _.toString.toUpperCase)\n        val lowerCaseKeys = keys.filter(_.toString.toLowerCase == _.toString.toLowerCase)\n        upperCaseKeys.isEmpty  || lowerCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpiz487s3o.scala:20:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.toString.toUpperCase == _.toString.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpiz487s3o.scala:21:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.toString.toLowerCase == _.toString.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return true\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val low = lower.toSet\n        val up = upper.toSet\n        val all = low union up\n        val notAll = all - low\n        val notAll2 = all - up\n        val notAll3 = all - low\n        val notAll4 = all - upper\n        val notAll5 = all - lower\n        val notAll6 = all - keys\n        val notAll7 = all - keys\n        val notAll8 = all - keys\n        val notAll9 = all - keys\n        val notAll10 = all - keys\n        val notAll11 = all - keys\n        val notAll12 = all - keys\n        val notAll13 = all - keys\n        val notAll14 = all - keys\n        val notAll15 = all - keys\n        val notAll16 = all - keys\n        val notAll17 = all - keys\n        val notAll18 = all - keys\n        val notAll19 = all - keys\n        val notAll20 = all - keys\n        val notAll21 = all - keys\n        val notAll22 = all - keys\n        val notAll23 = all - keys\n        val notAll24 = all - keys\n        val notAll25 = all - keys\n        val notAll26 = all - keys\n        val notAll27 = all - keys\n        val notAll28 = all - keys\n        val notAll29 = all - keys\n        val notAll30 = all - keys\n        val notAll31 = all - keys\n        val notAll32 = all - keys\n        val notAll33 = all - keys\n        val notAll34 = all - keys\n        val notAll35 = all - keys\n        val notAll36 = all - keys\n        val notAll37 = all - keys\n        val notAll38 = all - keys\n        val notAll39 = all - keys\n        val notAll40 = all - keys\n        val notAll41 = all - keys\n        val notAll42 = all - keys\n        val notAll43 = all - keys\n        val notAll44 = all - keys\n        val notAll45 = all - keys\n        val notAll46 = all - keys\n        val notAll47 = \n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpniszp6fh.scala:72:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m72 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotAll47\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpniszp6fh.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpniszp6fh.scala:26:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotAll\u001b[0m = all - low\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (low : Set[String])\n\u001b[31m   |\u001b[0m                           Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpniszp6fh.scala:27:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotAll2\u001b[0m = all - up\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (up : Set[String])\n\u001b[31m   |\u001b[0m                            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpniszp6fh.scala:28:28 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotAll3\u001b[0m = all - low\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (low : Set[String])\n\u001b[31m   |\u001b[0m                            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpniszp6fh.scala:29:28 ----------",
      "stdout": "",
      "timestamp": 1659800233
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allStrings = keys.forall(_.isInstanceOf[String])\n        val allStringsOrAllUpper = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String])\n        val allStringsOrAllLower = keys.forall(_.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLower = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLower = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLowerOrAllStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || _.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLowerOrAllStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || _.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLowerOrAllStringsOrAllStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || _.isInstanceOf[String] || _.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLowerOrAllStringsOrAllStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || _.isInstanceOf[String] || _.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLowerOrAllStringsOrAllStringsOrAllStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || _.isInstanceOf[String] || _.isInstanceOf[String] || _.isInstanceOf[String])\n        val allStringsOrAllUpperOrAllLowerOrAllStringsOrAllStringsOrAllStringsOrAllStrings = keys.forall(_.isInstanceOf\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0pl11e3q.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0pl11e3q.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallStringsOrAllUpperOrAllLower\u001b[0m = keys.forall(_.isInstanceOf[\u001b[35mString\u001b[0m] || _.toUpperCase.isInstanceOf[\u001b[35mString\u001b[0m] || _.toLowerCase.isInstanceOf[\u001b[35mString\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mallStringsOrAllUpperOrAllLower is already defined as \u001b[33mvalue\u001b[0m \u001b[35mallStringsOrAllUpperOrAllLower\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0pl11e3q.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallStringsOrAllUpperOrAllLowerOrAllStrings\u001b[0m = keys.forall(_.isInstanceOf[\u001b[35mString\u001b[0m] || _.toUpperCase.isInstanceOf[\u001b[35mString\u001b[0m] || _.toLowerCase.isInstanceOf[\u001b[35mString\u001b[0m] || _.isInstanceOf[\u001b[35mString\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mallStringsOrAllUpperOrAllLowerOrAllStrings is already defined as \u001b[33mvalue\u001b[0m \u001b[35mallStringsOrAllUpperOrAllLowerOrAllStrings\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0pl11e3q.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallStringsOrAllUpperOrAllLowerOrAllStringsOrAllStrings\u001b[0m = keys.forall(_.isInstanceOf[\u001b[35mString\u001b[0m] || _.toUpperCase.isInstanceOf[\u001b[35mString",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.isEmpty) false\n        else if(keys.forall(_.isInstanceOf[String])) true\n        else false\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5mpbwx1p.scala:26)\n\tat Problem.main(tmp5mpbwx1p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = lowerCaseKeys.toSet\n        val upperCaseDict = upperCaseKeys.toSet\n        lowerCaseDict.isEmpty || upperCaseDict.isEmpty || lowerCaseDict.subsetOf(upperCaseDict)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsr7wp51d.scala:27)\n\tat Problem.main(tmpsr7wp51d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (\n            val keys = dict.keys\n            val lower = keys.map(_.toLowerCase)\n            val upper = keys.map(_.toUpperCase)\n            lower.forall(x => upper.contains(x))\n            || upper.forall(x => lower.contains(x))\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptv086788.scala:20:14 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (\n\u001b[31m\u001b[31m   |\u001b[0m              ^\u001b[0m\n\u001b[31m   |\u001b[0m              expression expected but \u001b[31mval\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800225
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else {\n            val keys = dict.keys\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n            val upperCaseDict = dict.filterKeys(upperCaseKeys)\n            lowerCaseDict.forall(lowerCaseKeys contains _) && upperCaseDict.forall(upperCaseKeys contains _)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvnm775rf.scala:24:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvnm775rf.scala:25:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvnm775rf.scala:26:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            lowerCaseDict.forall(lowerCaseKeys contains _) && upperCaseDict.forall(upperCaseKeys contains _)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvnm775rf.scala:26:97 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            lowerCaseDict.forall(lowerCaseKeys contains _) && upperCaseDict.forall(upperCaseKeys contains _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                  ",
      "stdout": "",
      "timestamp": 1659800229
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) || upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpq8oztqdv.scala:29)\n\tat Problem.main(tmpq8oztqdv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800229
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val lowerSet = lower.toSet\n        val upperSet = upper.toSet\n        val result = lowerSet.subsetOf(upperSet)\n        result && keys.forall(_.isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp12ptr27x.scala:28)\n\tat Problem.main(tmp12ptr27x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800230
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.forall(_.isLetter))\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.forall(_.isLetter))\n        val lowerCaseDictSize = lowerCaseDict.size\n        val upperCaseDictSize = upperCaseDict.size\n        val keysSize = keys.size\n        val isDictAllCase = keysSize == lowerCaseDictSize && keysSize == upperCaseDictSize && lowerCaseDictSize == upperCaseDictSize\n        isDictAllCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp909_gc5c.scala:32)\n\tat Problem.main(tmp909_gc5c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800237
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.isEmpty  ||  upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfic6o26g.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfic6o26g.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800237
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n            upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpti5mlow0.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.keys.toSet.size == dict.keys.toSet.size) && dict.keys.toSet.forall(_.isLower) && dict.keys.toSet.forall(_.isUpper)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv_nazomf.scala:20:88 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.keys.toSet.size == dict.keys.toSet.size) && dict.keys.toSet.forall(_.isLower) && dict.keys.toSet.forall(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv_nazomf.scala:20:125 -----------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.keys.toSet.size == dict.keys.toSet.size) && dict.keys.toSet.forall(_.isLower) && dict.keys.toSet.forall(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                           ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800238
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val allLower = lower.forall(_.isInstanceOf[String])\n        val allUpper = upper.forall(_.isInstanceOf[String])\n        allLower && allUpper\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmprc1b5wjo.scala:28)\n\tat Problem.main(tmprc1b5wjo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800228
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.keySet.toSeq.map(_.toLowerCase).forall(_.equals(dict.keySet.toSeq.map(_.toLowerCase).head))\n            || dict.keySet.toSeq.map(_.toUpperCase).forall(_.equals(dict.keySet.toSeq.map(_.toUpperCase).head))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpai7hz2_6.scala:22:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800233
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        val lowerCaseKeysSet = lowerCaseKeys.toSet\n        val upperCaseKeysSet = upperCaseKeys.toSet\n        val keysSet = keys.toSet\n        lowerCaseDict.forall { case (k,v) => keysSet.contains(k) && lowerCaseKeysSet.contains(k) && v != upperCaseDict.get(k) }\n        || upperCaseDict.forall { case (k,v) => keysSet.contains(k) && upperCaseKeysSet.contains(k) && v != lowerCaseDict.get(k) }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpctn0rcga.scala:27:100 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        lowerCaseDict.forall { \u001b[33mcase\u001b[0m (k,v) => keysSet.contains(k) && lowerCaseKeysSet.contains(k) && v != upperCaseDict.get(k) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types String and Option[String] cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpctn0rcga.scala:28:103 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        || upperCaseDict.forall { \u001b[33mcase\u001b[0m (k,v) => keysSet.contains(k) && upperCaseKeysSet.contains(k) && v != lowerCaseDict.get(k) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types String and Option[String] cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800237
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n            upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpti5mlow0.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val isLower = lower.forall(_.isInstanceOf[String])\n        val isUpper = upper.forall(_.isInstanceOf[String])\n        val isAll = isLower && isUpper\n        !isAll\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpkwoux9kx.scala:28)\n\tat Problem.main(tmpkwoux9kx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800239
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.filter(_.toString.toLowerCase == _.toString.toLowerCase)\n        val upperCaseKeys = keys.filter(_.toString.toUpperCase == _.toString.toUpperCase)\n        lowerCaseKeys.isEmpty  || upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpabe6c652.scala:20:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.toString.toLowerCase == _.toString.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpabe6c652.scala:21:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.toString.toUpperCase == _.toString.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800234
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allStrings = upperCaseKeys.union(lowerCaseKeys)\n        val isAllStrings = allStrings.forall(_.isInstanceOf[String])\n        val isAllUpperCase = allStrings.forall(_.isInstanceOf[String])\n        val isAllLowerCase = allStrings.forall(_.isInstanceOf[String])\n        val isAllStringsOrUpperCase = isAllStrings || isAllUpperCase\n        val isAllStringsOrLowerCase = isAllStrings || isAllLowerCase\n        val isAllStringsOrBoth = isAllStringsOrUpperCase || isAllStringsOrLowerCase\n        val isAllStringsOrBothOrEmpty = isAllStringsOrBoth || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmpty = isAllStringsOrBothOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n        val isAllStringsOrBothOrEmptyOrEmptyOrEmpty = isAllStringsOrBothOrEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jchtmf.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllStringsOrBothOrEmptyOrEmptyOrEmpty\u001b[0m = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0misAllStringsOrBothOrEmptyOrEmptyOrEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35misAllStringsOrBothOrEmptyOrEmptyOrEmpty\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jchtmf.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllStringsOrBothOrEmptyOrEmptyOrEmpty\u001b[0m = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0misAllStringsOrBothOrEmptyOrEmptyOrEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35misAllStringsOrBothOrEmptyOrEmptyOrEmpty\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jchtmf.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllStringsOrBothOrEmptyOrEmptyOrEmpty\u001b[0m = isAllStringsOrBothOrEmptyOrEmptyOrEmpty || isAllStrings\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0misAllStringsOrBothOrEmptyOrEmptyOrEmpty is already defined as \u001b[33mvalue\u001b[0m \u001b[35misAllStringsOrBothOrEmptyOrEmptyOrEmpty\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jchtmf.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllStringsOrBothOrEmp",
      "stdout": "",
      "timestamp": 1659800238
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else keys.forall(_.isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4l6xvtdp.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800238
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.isEmpty  || upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwvwym6im.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwvwym6im.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800214
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) false\n        else if(keys.forall(_.isInstanceOf[String])) true\n        else false\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8x4w7wp9.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800237
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val allLowerCaseKeys = lowerCaseKeys.forall(_.equals(keys))\n        val allUpperCaseKeys = upperCaseKeys.forall(_.equals(keys))\n        allLowerCaseKeys && allUpperCaseKeys\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd4xz8_7o.scala:27)\n\tat Problem.main(tmpd4xz8_7o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800240
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lowerCaseKeys = keys.filter(_.toString.toLowerCase.contains(\"a\"))\n        val upperCaseKeys = keys.filter(_.toString.toUpperCase.contains(\"A\"))\n        lowerCaseKeys.isEmpty  && upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpv3_radni.scala:29)\n\tat Problem.main(tmpv3_radni.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800241
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key).isInstanceOf[String])\n        upperCaseKeys.forall(key => dict.get(key).isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5in7p83j.scala:26)\n\tat Problem.main(tmp5in7p83j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800241
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val upperCaseKeys = keys.filter(_.toString.toUpperCase == _.toString.toUpperCase)\n        val lowerCaseKeys = keys.filter(_.toString.toLowerCase == _.toString.toLowerCase)\n        val isAllUpperCase = upperCaseKeys.size == keys.size\n        val isAllLowerCase = lowerCaseKeys.size == keys.size\n        isAllUpperCase && isAllLowerCase && keys.size == dict.size\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpr_bsi_ma.scala:20:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.toString.toUpperCase == _.toString.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpr_bsi_ma.scala:21:40 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.toString.toLowerCase == _.toString.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800237
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val isLowerOrUpper = lower ++ upper.forall(_.isInstanceOf[String])\n        val isAllStrings = keys.forall(_.isInstanceOf[String])\n        isLowerOrUpper && isAllStrings\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphpsjefbt.scala:22:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misLowerOrUpper\u001b[0m = lower ++ upper.forall(_.isInstanceOf[\u001b[35mString\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    Boolean\n\u001b[31m   |\u001b[0m                                      Required: IterableOnce[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphpsjefbt.scala:24:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        isLowerOrUpper && isAllStrings\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value && is not a member of Iterable[String]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800241
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val isStringInLowerCase = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val isStringInUpperCase = upperCaseKeys.forall(_.isInstanceOf[String])\n        val isAllStringInLowerCase = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val isAllStringInUpperCase = upperCaseKeys.forall(_.isInstanceOf[String])\n        isAllStringInLowerCase && isAllStringInUpperCase && isStringInLowerCase && isStringInUpperCase && isAllStringInLowerCase && isAllStringInUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg7bu7lxl.scala:30)\n\tat Problem.main(tmpg7bu7lxl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800242
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val result = both.forall(key => dict.get(key).isInstanceOf[String])\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg4dotxpk.scala:27)\n\tat Problem.main(tmpg4dotxpk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800242
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allKeysAreStrings = keys.forall(_.isInstanceOf[String])\n        val allKeysAreStringsOrUpperCase = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String])\n        val allKeysAreStringsOrLowerCase = keys.forall(_.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String])\n        val allKeysAreStringsOrUpperCaseOrLowerCase = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String])\n        val allKeysAreStringsOrUpperCaseOrLowerCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrLowerCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrUpperCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrLowerCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrUpperCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrLowerCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrUpperCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toUpperCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrLowerCaseOrAllOthersAreStrings = keys.forall(_.isInstanceOf[String] || _.toLowerCase.isInstanceOf[String] || allKeysAreStrings)\n        val allKeysAreStringsOrUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3lv9t43m.scala:35:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3lv9t43m.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallKeysAreStringsOrLowerCaseOrAllOthersAreStrings\u001b[0m = keys.forall(_.isInstanceOf[\u001b[35mString\u001b[0m] || _.toLowerCase.isInstanceOf[\u001b[35mString\u001b[0m] || allKeysAreStrings)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mallKeysAreStringsOrLowerCaseOrAllOthersAreStrings is already defined as \u001b[33mvalue\u001b[0m \u001b[35mallKeysAreStringsOrLowerCaseOrAllOthersAreStrings\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3lv9t43m.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallKeysAreStringsOrUpperCaseOrAllOthersAreStrings\u001b[0m = keys.forall(_.isInstanceOf[\u001b[35mString\u001b[0m] || _.toUpperCase.isInstanceOf[\u001b[35mString\u001b[0m] || allKeysAreStrings)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mallKeysAreStringsOrUpperCaseOrAllOthersAreStrings is already defined as \u001b[33mvalue\u001b[0m \u001b[35mallKeysAreStringsOrUpperCaseOrAllOthersAreStrings\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3lv9t43m.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallKeysAreStringsOrLowerCaseOrAllOthersAreStrings\u001b[0m = keys.forall(_.isInstanceOf[\u001b[35mString\u001b[0m] || _.toLowerCase.isInstanceOf[\u001b[35mString\u001b[0m] || allKeysAreStrings)\n\u001b[31m\u001b[31m   |\u001b[0m  ",
      "stdout": "",
      "timestamp": 1659800240
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = keys.map(key => (key.toLowerCase, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key => (key, key.toUpperCase))\n        val bothLower = keys.map(key => (key.toLowerCase, key))\n        val bothUpper = keys.map(key \n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwj2_mxh4.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwj2_mxh4.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbothLower\u001b[0m = keys.map(\u001b[36mkey\u001b[0m => (key.toLowerCase, key))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbothLower is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbothLower\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwj2_mxh4.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbothUpper\u001b[0m = keys.map(\u001b[36mkey\u001b[0m => (key, key.toUpperCase))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbothUpper is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbothUpper\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwj2_mxh4.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbothLower\u001b[0m = keys.map(\u001b[36mkey\u001b[0m => (key.toLowerCase, key))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbothLower is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbothLower\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpwj2_mxh4.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbothUpper\u001b[0m = keys.map(\u001b[36mkey\u001b[0m => (key, key.toUpperCase))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mbothUpper is already defined as \u001b[33mvalue\u001b[0m \u001b[35mbothUpper\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote",
      "stdout": "",
      "timestamp": 1659800241
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) || upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpq8oztqdv.scala:29)\n\tat Problem.main(tmpq8oztqdv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800229
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        if (keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzls7n684.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of scala.collection.Set[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800241
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.isEmpty  || upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwvwym6im.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwvwym6im.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800214
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val isLowerOrUpper = lower ++ upper.forall(_.isInstanceOf[String])\n        !isLowerOrUpper && keys.forall(_.isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvp3m4vlb.scala:22:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misLowerOrUpper\u001b[0m = lower ++ upper.forall(_.isInstanceOf[\u001b[35mString\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    Boolean\n\u001b[31m   |\u001b[0m                                      Required: IterableOnce[String]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvp3m4vlb.scala:23:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        !isLowerOrUpper && keys.forall(_.isInstanceOf[\u001b[35mString\u001b[0m])\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value unary_! is not a member of Iterable[String]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800241
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxpj26tsl.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800202
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.keySet.toList.map(_.toLowerCase).toSet == dict.keySet.toList.map(_.toUpperCase).toSet)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzwsh0xps.scala:23)\n\tat Problem.main(tmpzwsh0xps.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800243
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return true\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpydvvss7y.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpydvvss7y.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpydvvss7y.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpydvvss7y.scala:25:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800245
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains)\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3yseakvx.scala:28)\n\tat Problem.main(tmp3yseakvx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) &&\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqn0x9a44.scala:28)\n\tat Problem.main(tmpqn0x9a44.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains)\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3yseakvx.scala:28)\n\tat Problem.main(tmp3yseakvx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n            upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpti5mlow0.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(_.equals(upperCaseKeys))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_q5083_x.scala:25)\n\tat Problem.main(tmp_q5083_x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800247
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = lowerCaseKeys.toSet\n        val upperCaseDict = upperCaseKeys.toSet\n        lowerCaseDict.isEmpty || upperCaseDict.isEmpty || lowerCaseDict.subsetOf(upperCaseDict)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsr7wp51d.scala:27)\n\tat Problem.main(tmpsr7wp51d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800216
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == key) && upperCaseKeys.forall(key => dict.get(key) == key)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp4jsdco3d.scala:22:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key) && upperCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Option[String] and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4jsdco3d.scala:22:89 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key) && upperCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                         ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Option[String] and String cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800246
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = keys.map(k => (k.toLowerCase, k.toUpperCase))\n        val result = lower == upper || both == keys\n        result && dict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpts1shw6g.scala:27)\n\tat Problem.main(tmpts1shw6g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800250
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key).isInstanceOf[String])\n            upperCaseKeys.forall(key => dict.get(key).isInstanceOf[String])\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp626eeria.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800247
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) &&\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqn0x9a44.scala:28)\n\tat Problem.main(tmpqn0x9a44.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        if (keys.isEmpty) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key).toLowerCase == dict.get(key))\n            upperCaseKeys.forall(key => dict.get(key).toUpperCase == dict.get(key))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2l9fn6wc.scala:24:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key).toLowerCase == dict.get(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value toLowerCase is not a member of Option[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2l9fn6wc.scala:25:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            upperCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key).toUpperCase == dict.get(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value toUpperCase is not a member of Option[String]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800248
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allUpperCase = upperCaseKeys.forall(_.equals(keys.head))\n        val allLowerCase = lowerCaseKeys.forall(_.equals(keys.head))\n        allUpperCase || allLowerCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqrg2acif.scala:27)\n\tat Problem.main(tmpqrg2acif.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800251
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else keys.forall(_.isInstanceOf[String]) && keys.forall(_.toString.toLowerCase == _.toString.toLowerCase || _.toString.toUpperCase == _.toString.toUpperCase)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpp51dxu7s.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpp51dxu7s.scala:21:64 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33melse\u001b[0m keys.forall(_.isInstanceOf[String]) && keys.forall(_.toString.toLowerCase == _.toString.toLowerCase || _.toString.toUpperCase == _.toString.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800247
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val allLowerCaseKeys = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val allUpperCaseKeys = upperCaseKeys.forall(_.isInstanceOf[String])\n        allLowerCaseKeys && allUpperCaseKeys\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3kocs_do.scala:28)\n\tat Problem.main(tmp3kocs_do.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.isEmpty) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n            upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxi_n2cke.scala:30)\n\tat Problem.main(tmpxi_n2cke.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800251
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allKeysAreString = keys.forall(_.isInstanceOf[String])\n        val allKeysAreStringInLowerCase = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val allKeysAreStringInUpperCase = upperCaseKeys.forall(_.isInstanceOf[String])\n        allKeysAreString && allKeysAreStringInLowerCase && allKeysAreStringInUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcwn0hwvn.scala:29)\n\tat Problem.main(tmpcwn0hwvn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800251
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerKeys = keys.map(_.toLowerCase)\n        val upperKeys = keys.map(_.toUpperCase)\n        val lowerDict = lowerKeys.toSet\n        val upperDict = upperKeys.toSet\n        if (lowerDict.isEmpty) true\n        else if (upperDict.isEmpty) false\n        else if (lowerDict.intersect(upperDict).isEmpty) false\n        else true\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphfsqpy_k.scala:30)\n\tat Problem.main(tmphfsqpy_k.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800252
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else keys.forall(_.isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4l6xvtdp.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800238
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) &&\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqn0x9a44.scala:28)\n\tat Problem.main(tmpqn0x9a44.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeysSet = upperCaseKeys.toSet\n        val lowerCaseKeysSet = lowerCaseKeys.toSet\n        val keysSet = keys.toSet\n        val keysSetUpper = keysSet.filter(x => upperCaseKeysSet.contains(x))\n        val keysSetLower = keysSet.filter(x => lowerCaseKeysSet.contains(x))\n        val keysSetBoth = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x))\n        val keysSetAll = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x))\n        val keysSetAllUpper = keysSet.filter(x => upperCaseKeysSet.contains(x))\n        val keysSetAllLower = keysSet.filter(x => lowerCaseKeysSet.contains(x))\n        val keysSetAllBoth = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x))\n        val keysSetAllUpperLower = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x))\n        val keysSetAllUpperLowerBoth = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x))\n        val keysSetAllUpperLowerBothUpper = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x) || upperCaseKeysSet.contains(x))\n        val keysSetAllUpperLowerBothUpperLower = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x) || upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x))\n        val keysSetAllUpperLowerBothUpperLowerUpper = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x) || upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x) || upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x))\n        val keysSetAllUpperLowerBothUpperLowerUpperUpper = keysSet.filter(x => upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x) || upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x) || upperCaseKeysSet.contains(x) || lowerCaseKeysSet.contains(x) || upperCaseKeysSet.contains(x\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdaosvuq7.scala:38:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdaosvuq7.scala:38:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800251
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val isLowerOrUpper = both.forall(x => x.contains(x.toLowerCase) || x.contains(x.toUpperCase))\n        !isLowerOrUpper && dict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpks2mi49t.scala:27)\n\tat Problem.main(tmpks2mi49t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800253
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val isAllUpper = upperCaseKeys.forall(_.equals(keys))\n        val isAllLower = lowerCaseKeys.forall(_.equals(keys))\n        isAllUpper && isAllLower\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpohhszjb1.scala:27)\n\tat Problem.main(tmpohhszjb1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800215
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val result = both.forall(x => dict(x) == dict(x))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: key not found: P\n\tat scala.collection.MapOps.default(Map.scala:274)\n\tat scala.collection.MapOps.default$(Map.scala:273)\n\tat scala.collection.AbstractMap.default(Map.scala:405)\n\tat scala.collection.mutable.HashMap.apply(HashMap.scala:425)\n\tat Problem$.$anonfun$3(tmp8_w4j_n1.scala:23)\n\tat scala.collection.immutable.Set$Set4.forall(Set.scala:313)\n\tat Problem$.checkDictCase(tmp8_w4j_n1.scala:23)\n\tat Problem$.main(tmp8_w4j_n1.scala:27)\n\tat Problem.main(tmp8_w4j_n1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800253
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val all = lower ++ upper\n        val none = keys.filterNot(_.isInstanceOf[String])\n        val result = all.forall(x => none.contains(x))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpogq75928.scala:24:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = all.forall(\u001b[36mx\u001b[0m => none.contains(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800251
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerKeys = keys.map(_.toLowerCase)\n        val upperKeys = keys.map(_.toUpperCase)\n        val lowerDict = lowerKeys.toMap\n        val upperDict = upperKeys.toMap\n        val keys = lowerKeys.union(upperKeys)\n        val result = keys.forall(key => lowerDict.contains(key) || upperDict.contains(key))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbntqx25f.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mkeys\u001b[0m = lowerKeys.union(upperKeys)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mkeys is already defined as \u001b[33mvalue\u001b[0m \u001b[35mkeys\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbntqx25f.scala:22:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerDict\u001b[0m = lowerKeys.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Cannot prove that String <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                     where:    K is a type variable\n\u001b[31m   |\u001b[0m                                               V is a type variable\n\u001b[31m   |\u001b[0m                                     .\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbntqx25f.scala:23:39 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperDict\u001b[0m = upperKeys.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Cannot prove that String <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                     where:    K is a type variable\n\u001b[31m   |\u001b[0m                                               V is a type variable\n\u001b[31m   |\u001b[0m                                     .\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659800253
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) &&\n            upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7rp1stwd.scala:28)\n\tat Problem.main(tmp7rp1stwd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800254
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerKeys = keys.map(_.toLowerCase)\n        val upperKeys = keys.map(_.toUpperCase)\n        lowerKeys.forall(key => dict.get(key) == key.toUpperCase)\n        upperKeys.forall(key => dict.get(key) == key.toLowerCase)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpt760i54m.scala:22:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Option[String] and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpt760i54m.scala:23:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        upperKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Option[String] and String cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800253
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val isLowerCase = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val isUpperCase = upperCaseKeys.forall(_.isInstanceOf[String])\n        isLowerCase && isUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgz9u3mui.scala:28)\n\tat Problem.main(tmpgz9u3mui.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800254
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else keys.forall(_.isInstanceOf[String]) && keys.forall(_.toString.toLowerCase() == _.toString.toLowerCase)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbz0z5zky.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpbz0z5zky.scala:21:64 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33melse\u001b[0m keys.forall(_.isInstanceOf[String]) && keys.forall(_.toString.toLowerCase() == _.toString.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800252
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.filter(_.isLower)\n        val upperCaseKeys = keys.filter(_.isUpper)\n        lowerCaseKeys.isEmpty  ||  upperCaseKeys.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphs2kxcly.scala:20:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseKeys\u001b[0m = keys.filter(_.isLower)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isLower is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphs2kxcly.scala:21:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseKeys\u001b[0m = keys.filter(_.isUpper)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value isUpper is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800253
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.toList.map(_.toLowerCase).forall(_.isLower) || dict.toList.map(_.toUpperCase).forall(_.isUpper))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi2p5cgo4.scala:20:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.isLower) || dict.toList.map(_.toUpperCase).forall(_.isUpper))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toLowerCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi2p5cgo4.scala:20:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.isLower) || dict.toList.map(_.toUpperCase).forall(_.isUpper))\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isLower is not a member of Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi2p5cgo4.scala:20:84 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.isLower) || dict.toList.map(_.toUpperCase).forall(_.isUpper))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                  ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toUpperCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi2p5cgo4.scala:20:106 -----------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.isLower) || dict.toList.map(_.toUpperCase).forall(_.isUpper))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value isUpper is not a member of Any\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800254
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = lower ++ upper\n        val isAllLowerOrUpper = both.forall(x => keys.contains(x))\n        isAllLowerOrUpper || dict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2to0i_n5.scala:23:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllLowerOrUpper\u001b[0m = both.forall(\u001b[36mx\u001b[0m => keys.contains(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800255
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        lowerCaseKeys.forall(lowerCaseDict.contains) &&\n        upperCaseKeys.forall(upperCaseDict.contains)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpqn0x9a44.scala:28)\n\tat Problem.main(tmpqn0x9a44.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1lwzr6yx.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val result = lower == upper || lower == upper\n        if(!result) false\n        else true\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphrkrmkk4.scala:27)\n\tat Problem.main(tmphrkrmkk4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800258
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.keySet.forall(_.isInstanceOf[String]) || dict.keySet.forall(_.isInstanceOf[String]) && dict.values.forall(_.isInstanceOf[String]))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmputazl1v3.scala:24)\n\tat Problem.main(tmputazl1v3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800259
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return true\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp95u0qt30.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp95u0qt30.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp95u0qt30.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659800258
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(_.equals(upperCaseKeys)) || upperCaseKeys.forall(_.equals(lowerCaseKeys))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpy0zm1rwa.scala:25)\n\tat Problem.main(tmpy0zm1rwa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800260
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase)\n        val lowerCaseDictSize = lowerCaseDict.size\n        val upperCaseDictSize = upperCaseDict.size\n        val keysSize = keys.size\n        val lowerCaseDictKeys = lowerCaseDict.keys\n        val upperCaseDictKeys = upperCaseDict.keys\n        val lowerCaseDictValues = lowerCaseDict.values\n        val upperCaseDictValues = upperCaseDict.values\n        val lowerCaseDictKeysSize = lowerCaseDictKeys.size\n        val upperCaseDictKeysSize = upperCaseDictKeys.size\n        val lowerCaseDictValuesSize = lowerCaseDictValues.size\n        val upperCaseDictValuesSize = upperCaseDictValues.size\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n        val keysEqual = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKey\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9nns68ju.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mkeysEqual\u001b[0m = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mkeysEqual is already defined as \u001b[33mvalue\u001b[0m \u001b[35mkeysEqual\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9nns68ju.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mkeysEqual\u001b[0m = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mkeysEqual is already defined as \u001b[33mvalue\u001b[0m \u001b[35mkeysEqual\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9nns68ju.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mkeysEqual\u001b[0m = keysSize == lowerCaseDictKeysSize && keysSize == upperCaseDictKeysSize && keysSize == lowerCaseDictValuesSize && keysSize == upperCaseDictValuesSize\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mkeysEqual is already defined as \u001b[33mvalue\u001b[0m \u001b[35mkeysEqual\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in th",
      "stdout": "",
      "timestamp": 1659800260
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(_.toLowerCase.nonEmpty)\n        val upperCaseDict = dict.filterKeys(_.toUpperCase.nonEmpty)\n        val lowerCaseDictSize = lowerCaseDict.size\n        val upperCaseDictSize = upperCaseDict.size\n        val isAllLowerCase = lowerCaseKeys.forall(_.nonEmpty)\n        val isAllUpperCase = upperCaseKeys.forall(_.nonEmpty)\n        val isAllDict = lowerCaseDictSize == upperCaseDictSize && lowerCaseDictSize == keys.size\n        val isAllDictCase = isAllDict && isAllLowerCase && isAllUpperCase\n        isAllDictCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbpxqsx8g.scala:34)\n\tat Problem.main(tmpbpxqsx8g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.toSeq.map(_.toLowerCase).forall(_.isLowercase) || dict.toSeq.map(_.toUpperCase).forall(_.isUppercase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4d3u0tp4.scala:20:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toSeq.map(_.toLowerCase).forall(_.isLowercase) || dict.toSeq.map(_.toUpperCase).forall(_.isUppercase))\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toLowerCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4d3u0tp4.scala:20:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toSeq.map(_.toLowerCase).forall(_.isLowercase) || dict.toSeq.map(_.toUpperCase).forall(_.isUppercase))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value isLowercase is not a member of Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4d3u0tp4.scala:20:86 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toSeq.map(_.toLowerCase).forall(_.isLowercase) || dict.toSeq.map(_.toUpperCase).forall(_.isUppercase))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                    ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toUpperCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4d3u0tp4.scala:20:108 -----------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toSeq.map(_.toLowerCase).forall(_.isLowercase) || dict.toSeq.map(_.toUpperCase).forall(_.isUppercase))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isUppercase is not a member of Any\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800262
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val lowerSet = lower.toSet\n        val upperSet = upper.toSet\n        val result = lowerSet.size == upperSet.size && lowerSet.size == keys.size\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp67qq5sp0.scala:29)\n\tat Problem.main(tmp67qq5sp0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800264
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp40a13s5y.scala:20:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toLowerCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp40a13s5y.scala:20:61 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => _$3.toLowerCase.\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp40a13s5y.scala:20:98 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toUpperCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp40a13s5y.scala:20:127 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) || dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$6 of expanded function:\n\u001b[31m   |\u001b[0m   _$6 => _$6.toUpperCase.\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        else {\n            val lowerCaseKeys = keys.map(_.toLowerCase)\n            val upperCaseKeys = keys.map(_.toUpperCase)\n            lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n            upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpti5mlow0.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800226
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = keys.zip(lower).zip(upper)\n        val result = both.forall(x => x._1 == x._2)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmphrprj8zp.scala:23:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = both.forall(\u001b[36mx\u001b[0m => x._1 == x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types (String, String) and String cannot be compared with == or !=\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800262
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeySet = lowerCaseKeys.toSet\n        val upperCaseKeySet = upperCaseKeys.toSet\n        val allKeysSet = lowerCaseKeySet.union(upperCaseKeySet)\n        val isAllKeysSet = allKeysSet.isEmpty\n        val isAllKeysLowerCase = lowerCaseKeySet.isEmpty\n        val isAllKeysUpperCase = upperCaseKeySet.isEmpty\n        isAllKeysSet && isAllKeysLowerCase && isAllKeysUpperCase && allKeysSet.isSubset(keys)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbnby6quv.scala:28:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        isAllKeysSet && isAllKeysLowerCase && isAllKeysUpperCase && allKeysSet.isSubset(keys)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue isSubset is not a member of Set[String] - did you mean allKeysSet.subsets?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800262
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val both = keys.map(key => (key, key.toLowerCase, key.toUpperCase))\n        val all = lower ++ upper ++ both\n        val notAll = keys.filter(!keys.contains(_))\n        val notBoth = keys.filter(!keys.contains(_).contains(_))\n        val notAllLower = keys.filter(!keys.contains(_).contains(_).toLowerCase)\n        val notAllUpper = keys.filter(!keys.contains(_).contains(_).toUpperCase)\n        val notBothLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notAllUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothLower = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n        val notBothUpper = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpqu5k66o7.scala:45:90 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotBothUpper\u001b[0m = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqu5k66o7.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotAllLower\u001b[0m = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnotAllLower is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnotAllLower\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqu5k66o7.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotAllUpper\u001b[0m = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnotAllUpper is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnotAllUpper\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpqu5k66o7.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotBothLower\u001b[0m = keys.filter(!keys.contains(_).contains(_).toLowerCase.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnotBothLower is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnotBothLower\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m",
      "stdout": "",
      "timestamp": 1659800264
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return true\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1p277a5_.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800263
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsg7e82bo.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsg7e82bo.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsg7e82bo.scala:24:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpsg7e82bo.scala:25:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        lowerCaseDict.isEmpty() && upperCaseDict.isEmpty()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        \u001b[33mmethod\u001b[0m \u001b[35misEmpty\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800264
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys)\n        lowerCaseDict.isEmpty  || upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:22:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (lowerCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbzh0_7i5.scala:23:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    (upperCaseKeys : Iterable[String])\n\u001b[31m   |\u001b[0m                            Required: String => Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) &&\n            dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkhnvfa4t.scala:20:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) &&\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toLowerCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpkhnvfa4t.scala:20:61 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) &&\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => _$3.toLowerCase.\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkhnvfa4t.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toUpperCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpkhnvfa4t.scala:21:59 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$6 of expanded function:\n\u001b[31m   |\u001b[0m   _$6 => _$6.toUpperCase.\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800264
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val isLowerCase = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val isUpperCase = upperCaseKeys.forall(_.isInstanceOf[String])\n        val isAllStrings = isLowerCase && isUpperCase\n        isAllStrings\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjly1wg02.scala:29)\n\tat Problem.main(tmpjly1wg02.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800265
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.isEmpty) false\n        else if(keys.forall(_.isInstanceOf[String])) true\n        else false\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5mpbwx1p.scala:26)\n\tat Problem.main(tmp5mpbwx1p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty)\n            return false\n        val keys = dict.keys\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val low = lower.toSet\n        val up = upper.toSet\n        val both = low + up\n        val notBoth = keys.filter(!both.contains(_))\n        val notLower = keys.filter(!low.contains(_))\n        val notUpper = keys.filter(!up.contains(_))\n        val notBothNotLower = keys.filter(!both.contains(_) && !low.contains(_))\n        val notBothNotUpper = keys.filter(!both.contains(_) && !up.contains(_))\n        val notLowerNotUpper = keys.filter(!low.contains(_) && !up.contains(_))\n        val notLowerNotBoth = keys.filter(!low.contains(_) && !both.contains(_))\n        val notUpperNotBoth = keys.filter(!up.contains(_) && !both.contains(_))\n        val notLowerNotUpperNotBoth = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_))\n        val notLowerNotUpperNotBothNotLower = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_) && !low.contains(_))\n        val notLowerNotUpperNotBothNotUpper = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_) && !up.contains(_))\n        val notLowerNotUpperNotBothNotUpperNotLower = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_) && !up.contains(_) && !low.contains(_))\n        val notLowerNotUpperNotBothNotUpperNotUpper = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_) && !up.contains(_) && !up.contains(_))\n        val notLowerNotUpperNotBothNotUpperNotUpperNotLower = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_) && !up.contains(_) && !up.contains(_) && !low.contains(_))\n        val notLowerNotUpperNotBothNotUpperNotUpperNotUpper = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_) && !up.contains(_) && !up.contains(_) && !up.contains(_))\n        val notLowerNotUpperNotBothNotUpperNotUpperNotUpperNotLower = keys.filter(!low.contains(_) && !up.contains(_) && !both.contains(_) && !up.contains(_) && !up.contains(_) && !up.contains(_) && !low.contains(_))\n        val notLowerNotUpperNotBothNot\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo2sj3wvl.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo2sj3wvl.scala:26:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mboth\u001b[0m = low + up\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (up : Set[String])\n\u001b[31m   |\u001b[0m                         Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpo2sj3wvl.scala:30:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotBothNotLower\u001b[0m = keys.filter(!both.contains(_) && !low.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpo2sj3wvl.scala:31:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotBothNotUpper\u001b[0m = keys.filter(!both.contains(_) && !up.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpo2sj3wvl.scala:32:43 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotLowerNotUpper\u001b[0m = keys.filter(!low.contains(_) && !up.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpo2sj3wvl.scala:33:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnotLowerNotBoth\u001b[0m = keys.filter(!low.contains(_) && !both.contains(_))\n\u001b[31m\u001b[31m   |\u001b[0m                 ",
      "stdout": "",
      "timestamp": 1659800265
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7_59v94e.scala:27)\n\tat Problem.main(tmp7_59v94e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800204
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allStringKeys = keys.toSet\n        val allStringKeysUpper = upperCaseKeys.toSet\n        val allStringKeysLower = lowerCaseKeys.toSet\n        val allStringKeysAll = allStringKeys.toSet\n        val allStringKeysAllUpper = allStringKeysAll.filter(x => allStringKeysUpper.contains(x))\n        val allStringKeysAllLower = allStringKeysAll.filter(x => allStringKeysLower.contains(x))\n        val allStringKeysAllAll = allStringKeysAll.filter(x => allStringKeysAll.contains(x))\n        val allStringKeysAllAllUpper = allStringKeysAllAll.filter(x => allStringKeysAllUpper.contains(x))\n        val allStringKeysAllAllLower = allStringKeysAllAll.filter(x => allStringKeysAllLower.contains(x))\n        val allStringKeysAllAllAll = allStringKeysAllAll.filter(x => allStringKeysAllAll.contains(x))\n        val allStringKeysAllAllAllUpper = allStringKeysAllAllAll.filter(x => allStringKeysAllAllUpper.contains(x))\n        val allStringKeysAllAllAllLower = allStringKeysAllAllAll.filter(x => allStringKeysAllAllLower.contains(x))\n        val allStringKeysAllAllAllAll = allStringKeysAllAllAll.filter(x => allStringKeysAllAllAll.contains(x))\n        val allStringKeysAllAllAllAllUpper = allStringKeysAllAllAllAll.filter(x => allStringKeysAllAllAllUpper.contains(x))\n        val allStringKeysAllAllAllAllLower = allStringKeysAllAllAllAll.filter(x => allStringKeysAllAllAllLower.contains(x))\n        val allStringKeysAllAllAllAllAll = allStringKeysAllAllAllAll.filter(x => allStringKeysAllAllAllAll.contains(x))\n        val allStringKeysAllAllAllAllAllUpper = allStringKeysAllAllAllAllAll.filter(x => allStringKeysAllAllAllAllUpper.contains(x))\n        val allStringKeysAllAllAllAllAll\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptzwsap10.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptzwsap10.scala:40:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800265
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (\n            dict.keys.toSet.size == dict.keys.toSet.filter(_.isLetter).size &&\n            dict.keys.toSet.size == dict.keys.toSet.filter(_.isLetterOrDigit).size\n        )\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpunyibxr5.scala:21:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            dict.keys.toSet.size == dict.keys.toSet.filter(_.isLetter).size &&\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isLetter is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpunyibxr5.scala:22:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            dict.keys.toSet.size == dict.keys.toSet.filter(_.isLetterOrDigit).size\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value isLetterOrDigit is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800264
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val allStrings = keys.forall(_.isInstanceOf[String])\n        val allStringsUpper = upperCaseKeys.forall(_.isInstanceOf[String])\n        val allStringsLower = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val allStringsAll = allStrings && allStringsUpper && allStringsLower\n        allStringsAll\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp80e9c5tr.scala:30)\n\tat Problem.main(tmp80e9c5tr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800266
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key).toLowerCase == dict.get(key))\n        upperCaseKeys.forall(key => dict.get(key).toUpperCase == dict.get(key))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpckpmqp56.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpckpmqp56.scala:23:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key).toLowerCase == dict.get(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value toLowerCase is not a member of Option[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpckpmqp56.scala:24:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        upperCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key).toUpperCase == dict.get(key))\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value toUpperCase is not a member of Option[String]\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpckpmqp56.scala:20:30 ----------------\u001b[0m\u001b[0m\n\u001b[33m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[31mfalse\u001b[0m\n\u001b[33m\u001b[33m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659800266
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == key.toLowerCase)\n        upperCaseKeys.forall(key => dict.get(key) == key.toUpperCase)\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpj07awuby.scala:22:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        lowerCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Option[String] and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpj07awuby.scala:23:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        upperCaseKeys.forall(\u001b[36mkey\u001b[0m => dict.get(key) == key.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Option[String] and String cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800266
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val lower = keys.map(_.toLowerCase)\n        val upper = keys.map(_.toUpperCase)\n        val all = lower ++ upper\n        val result = all forall (key => key.isInstanceOf[String])\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpuj8raluq.scala:28)\n\tat Problem.main(tmpuj8raluq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800266
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val allLowerCase = lowerCaseKeys.forall(_.isInstanceOf[String])\n        val allUpperCase = upperCaseKeys.forall(_.isInstanceOf[String])\n        allLowerCase || allUpperCase\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3kfiv36d.scala:28)\n\tat Problem.main(tmp3kfiv36d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800266
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if (keys.length == 0) return true\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7g31u_oe.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m (keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mtrue\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800266
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        if (dict.isEmpty) false\n        else (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) &&\n            dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkhnvfa4t.scala:20:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) &&\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toLowerCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpkhnvfa4t.scala:20:61 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33melse\u001b[0m (dict.toList.map(_.toLowerCase).forall(_.equals(_.toLowerCase)) &&\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => _$3.toLowerCase.\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkhnvfa4t.scala:21:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toUpperCase is not a member of (String, String)\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpkhnvfa4t.scala:21:59 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            dict.toList.map(_.toUpperCase).forall(_.equals(_.toUpperCase)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$6 of expanded function:\n\u001b[31m   |\u001b[0m   _$6 => _$6.toUpperCase.\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659800264
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.length == 0) return false\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key) == dict.get(key.toLowerCase))\n        upperCaseKeys.forall(key => dict.get(key) == dict.get(key.toUpperCase))\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxpj26tsl.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mif\u001b[0m(keys.length == \u001b[31m0\u001b[0m) \u001b[33mreturn\u001b[0m \u001b[31mfalse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value length is not a member of Iterable[String]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659800202
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keySet\n        val isAllStrings = keys.forall(_.isInstanceOf[String])\n        val isAllUpper = keys.forall(_.toUpperCase == _.toUpperCase)\n        val isAllLower = keys.forall(_.toLowerCase == _.toLowerCase)\n        !isAllStrings && !isAllUpper && !isAllLower\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp0fpof457.scala:21:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllUpper\u001b[0m = keys.forall(_.toUpperCase == _.toUpperCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp0fpof457.scala:22:37 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36misAllLower\u001b[0m = keys.forall(_.toLowerCase == _.toLowerCase)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800266
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        lowerCaseKeys.forall(key => dict.get(key).isInstanceOf[String])\n        upperCaseKeys.forall(key => dict.get(key).isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5in7p83j.scala:26)\n\tat Problem.main(tmp5in7p83j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800241
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        val lowerCaseKeys = keys.map(_.toLowerCase)\n        val upperCaseKeys = keys.map(_.toUpperCase)\n        val lowerCaseDict = dict.filterKeys(lowerCaseKeys.contains)\n        val upperCaseDict = dict.filterKeys(upperCaseKeys.contains)\n        lowerCaseDict.isEmpty  && upperCaseDict.isEmpty\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpolvdop_m.scala:22:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlowerCaseDict\u001b[0m = dict.filterKeys(lowerCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value contains is not a member of Iterable[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpolvdop_m.scala:23:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mupperCaseDict\u001b[0m = dict.filterKeys(upperCaseKeys.contains)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue contains is not a member of Iterable[String], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659800203
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a map, return true if all keys are strings in lower \n    // case or all keys are strings in upper case, else return false.\n    // The function should return false is the given map is empty.\n    // Examples:\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"b\" -> \"banana\")))\n    // (true)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", \"A\" -> \"banana\", \"B\" -> \"banana\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"a\" -> \"apple\", 8l -> \"banana\", \"a\" -> \"apple\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\")))\n    // (false)\n    // >>> checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\")))\n    // (true)\n    def checkDictCase(dict : Map[String,String]) : Boolean = {\n        val keys = dict.keys\n        if(keys.isEmpty) false else keys.forall(_.isInstanceOf[String])\n    }\n    def main(args: Array[String]) = {\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"b\" -> \"banana\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"A\" -> \"banana\", \"B\" -> \"banana\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"p\" -> \"pineapple\", \"5\" -> \"banana\", \"a\" -> \"apple\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"Name\" -> \"John\", \"Age\" -> \"36\", \"City\" -> \"Houston\"))) == (false));\n    assert(checkDictCase((Map[String,String](\"STATE\" -> \"NC\", \"ZIP\" -> \"12345\"))) == (true));\n    assert(checkDictCase((Map[String,String](\"fruit\" -> \"Orange\", \"taste\" -> \"Sweet\"))) == (true));\n    assert(checkDictCase((Map[String,String]())) == (false));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5cb551tn.scala:24)\n\tat Problem.main(tmp5cb551tn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659800267
    }
  ]
}