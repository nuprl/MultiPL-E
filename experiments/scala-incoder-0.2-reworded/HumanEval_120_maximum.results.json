{
  "language": "scala",
  "name": "HumanEval_120_maximum",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv3iswvvf.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv3iswvvf.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxKList = mutable.ListBuffer.empty[Long]\n        val maxKLength = maxKList.length\n        val maxKK = maxKLength / 2\n        val maxKKList = mutable.ListBuffer.empty[Long]\n        val maxKKLength = maxKKList.length\n        val maxKKK = maxKKLength / 2\n        val maxKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKLength = maxKKKList.length\n        val maxKKKK = maxKKKLength / 2\n        val maxKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKLength = maxKKKKList.length\n        val maxKKKKK = maxKKKKLength / 2\n        val maxKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKLength = maxKKKKKList.length\n        val maxKKKKKK = maxKKKKKLength / 2\n        val maxKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKLength = maxKKKKKKList.length\n        val maxKKKKKKK = maxKKKKKKLength / 2\n        val maxKKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKKLength = maxKKKKKKKList.length\n        val maxKKKKKKKK = maxKKKKKKKKLength / 2\n        val maxKKKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKKKLength = maxKKKKKKKKKList.length\n        val maxKKKKKKKKK = maxKKKKKKKKKLength / 2\n        val maxKKKKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKKKKLength = maxKKKKKKKKKKList.length\n        val maxKK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpz2f2v792.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2f2v792.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2f2v792.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2f2v792.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2f2v792.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz2f2v792.scala:32:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not ",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5tp2audi.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLength\u001b[0m = arr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5tp2audi.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxK\u001b[0m = k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxK is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxK\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5tp2audi.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxValue\u001b[0m = arr(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5tp2audi.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = arr.indexOf(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5tp2audi.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLength\u001b[0m = arr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of to",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxLength = arr.length\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cgzkz8a.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLength\u001b[0m = arr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cgzkz8a.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxK\u001b[0m = k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxK is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxK\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cgzkz8a.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxValue\u001b[0m = arr(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cgzkz8a.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = arr.indexOf(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cgzkz8a.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLength\u001b[0m = arr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of to",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val maxElem = arr.max\n        val maxIndex = arr.indexWhere(elem => elem == maxElem)\n        val maxIndexList = arr.take(maxIndex).toList\n        val maxIndexListLength = maxIndexList.length\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_vocdw1t.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_vocdw1t.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_vocdw1t.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_vocdw1t.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_vocdw1t.scala:29:12 ---------------------------\u001b[0m\u001b[",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            var maxIndex = 0\n            var maxValue = arr(0)\n            var j = 0\n            while (j < len) {\n                if (arr(j) > maxValue) {\n                    maxValue = arr(j)\n                    maxIndex = j\n                }\n                j += 1\n            }\n            max += maxIndex\n            i += 1\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsauh4042.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsauh4042.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsauh4042.scala:35:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            max += maxIndex\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Array[Long] - did you mean max.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_).reverse\n        val max = new mutable.PriorityQueue[Long]()\n        val maxSize = new mutable.PriorityQueue[Long]()\n        var i = 0\n        while (i < arr.length) {\n            if (max.size < k) {\n                max += arr(i)\n                maxSize += arr(i)\n                i += 1\n            } else {\n                if (arr(i) > max.head) {\n                    max += arr(i)\n                    maxSize += arr(i)\n                    i += 1\n                } else {\n                    maxSize += arr(i)\n                }\n            }\n        }\n        val result = new mutable.PriorityQueue[Long]()\n        while (maxSize.size > 0) {\n            result += maxSize.dequeue()\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp9n8mbqbd.scala:20:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => arr.sortBy(_$1).reverse.\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9n8mbqbd.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9n8mbqbd.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9n8mbqbd.scala:22:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxSize\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9n8mbqbd.scala:39:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793672
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val maxK = arr.take(k).toList\n        val maxKIndex = arr.lastIndexWhere(_ == maxK(0))\n        val maxKIndexList = maxKIndex.until(maxKIndex.drop(1))\n        val maxKList = maxKIndexList.map(_ - 1).map(arr(_))\n        val maxKListIndex = maxKList.lastIndexWhere(_ == maxK(0))\n        val maxKListIndexList = maxKListIndex.until(maxKListIndex.drop(1))\n        val maxKListList = maxKListIndexList.map(_ - 1).map(arr(_))\n        val maxKListListIndex = maxKListList.lastIndexWhere(_ == maxK(0))\n        val maxKListListIndexList = maxKListListIndex.until(maxKListListIndex.drop(1))\n        val maxKListListList = maxKListListIndexList.map(_ - 1).map(arr(_))\n        val maxKListListListIndex = maxKListListList.lastIndexWhere(_ == maxK(0))\n        val maxKListListListIndexList = maxKListListListIndex.until(maxKListListListIndex.drop(1))\n        val maxKListListListList = maxKListListListIndexList.map(_ - 1).map(arr(_))\n        val maxKListListListListIndex = maxKListListListList.lastIndexWhere(_ == maxK(0))\n        val maxKListListListListIndexList = maxKListListListListIndex.until(maxKListListListListIndex.drop(1))\n        val maxKListListListListList = maxKListListListListIndexList.map(_ - 1).map(arr(_))\n        val maxKListListListListIndexList = maxKListListListListIndex.until(maxKListListListListIndex.drop(1))\n        val maxKListListListListList = maxKListListListListIndexList.map(_ - 1).map(arr(_))\n        val maxKListListListListListIndex = maxKListListListListList.lastIndexWhere(_ == maxK(0))\n        val maxKListListListListListIndexList = maxKListListListListListIndex.until(maxKListListListListListIndex.drop(1))\n        val maxKListListListListListList = maxKListListListListListIndexList.map(_ - 1).map(arr(_))\n        val maxKListListListListListIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1zhdg_yw.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1zhdg_yw.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListListListListIndexList\u001b[0m = maxKListListListListIndex.until(maxKListListListListIndex.drop(\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListListListListIndexList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListListListListIndexList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1zhdg_yw.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListListListListList\u001b[0m = maxKListListListListIndexList.map(_ - \u001b[31m1\u001b[0m).map(arr(_))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListListListListList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListListListListList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1zhdg_yw.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1zhdg_yw.scala:43:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compil",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val maxArr : List[Long] = new Array[Long](k)\n        var i = 0\n        var j = 0\n        while (i < arr.length) {\n            if (j == k) {\n                maxArr(i) = arr(i)\n                i += 1\n                j = 0\n            } else {\n                if (arr(i) > arr(j)) {\n                    maxArr(i) = arr(i)\n                    i += 1\n                } else {\n                    maxArr(i) = arr(j)\n                    j += 1\n                }\n            }\n        }\n        maxArr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5syyg8gr.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5syyg8gr.scala:21:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxArr\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5syyg8gr.scala:26:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                maxArr(i) = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean maxArr.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5syyg8gr.scala:31:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                    maxArr(i) = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean maxArr.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5syyg8gr.scala:34:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                    maxArr(i) = arr(j)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean maxArr.updated?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(x => x)\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpllxjmlbk.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(\u001b[36mx\u001b[0m => x)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpllxjmlbk.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = arr.take(k).toList\n        val rest = arr.drop(k)\n        rest match {\n            case Nil => max\n            case _ => maximum(max, rest.max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpfyb39jrv.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793671
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = math.min(k, n)\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxValue = arr(0)\n        for(i <- 1 to m) {\n            if(arr(i) > maxValue) {\n                maxValue = arr(i)\n            }\n        }\n        maxList += maxValue\n        for(i <- 1 to n) {\n            if(arr(i) > maxValue) {\n                maxValue = arr(i)\n            }\n        }\n        maxList += maxValue\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5ifu8tlo.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5ifu8tlo.scala:24:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m1\u001b[0m to m) {\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (m : Long)\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5ifu8tlo.scala:26:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                maxValue = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxValue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5ifu8tlo.scala:32:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                maxValue = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxValue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuoj84dpg.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuoj84dpg.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        var maxLength = 0\n        var maxValue = 0\n        var currentLength = 0\n        var currentValue = 0\n        var currentMax = 0\n        for(i <- 0 until arr.length) {\n            currentLength = arr(i).toLong\n            currentValue = arr(i).toLong\n            currentMax = currentValue\n            for(j <- 0 until currentLength) {\n                if(currentValue > currentMax) {\n                    currentMax = currentValue\n                }\n                currentValue = currentValue * 10\n            }\n            if(currentLength > maxLength) {\n                maxLength = currentLength\n                maxValue = currentMax\n            }\n        }\n        if(maxLength < k) {\n            for(i <- 0 until k - maxLength) {\n                maxList += maxValue\n            }\n        }\n        else {\n            for(i <- 0 until maxLength) {\n                maxList += maxValue\n            }\n        }\n        return maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp79f0aj_k.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp79f0aj_k.scala:27:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            currentLength = arr(i).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Found:    Long\n\u001b[31m   |\u001b[0m                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp79f0aj_k.scala:28:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            currentValue = arr(i).toLong\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    Long\n\u001b[31m   |\u001b[0m                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp79f0aj_k.scala:42:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k - maxLength) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Long\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ > _)\n        val n = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpisqbktox.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpisqbktox.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val maxList = arr.take(k)\n        val maxList2 = arr.drop(k)\n        val maxList3 = arr.takeRight(k)\n        val maxList4 = arr.dropRight(k)\n        val maxList5 = arr.take(k)\n        val maxList6 = arr.drop(k)\n        val maxList7 = arr.takeRight(k)\n        val maxList8 = arr.dropRight(k)\n        val maxList9 = arr.take(k)\n        val maxList10 = arr.drop(k)\n        val maxList11 = arr.takeRight(k)\n        val maxList12 = arr.dropRight(k)\n        val maxList13 = arr.take(k)\n        val maxList14 = arr.drop(k)\n        val maxList15 = arr.takeRight(k)\n        val maxList16 = arr.dropRight(k)\n        val maxList17 = arr.take(k)\n        val maxList18 = arr.drop(k)\n        val maxList19 = arr.takeRight(k)\n        val maxList20 = arr.dropRight(k)\n        val maxList21 = arr.take(k)\n        val maxList22 = arr.drop(k)\n        val maxList23 = arr.takeRight(k)\n        val maxList24 = arr.dropRight(k)\n        val maxList25 = arr.take(k)\n        val maxList26 = arr.drop(k)\n        val maxList27 = arr.takeRight(k)\n        val maxList28 = arr.dropRight(k)\n        val maxList29 = arr.take(k)\n        val maxList30 = arr.drop(k)\n        val maxList31 = arr.takeRight(k)\n        val maxList32 = arr.dropRight(k)\n        val maxList33 = arr.take(k)\n        val maxList34 = arr.drop(k)\n        val maxList35 = arr.takeRight(k)\n        val maxList36 = arr.dropRight(k)\n        val maxList37 = arr.take(k)\n        val maxList38 = arr.drop(k)\n        val maxList39 = arr.takeRight(k)\n        val maxList40 = arr.dropRight(k)\n        val maxList41 = arr.take(k)\n        val maxList42 = arr.drop(k)\n        val maxList43 = arr.takeRight(k)\n        val maxList44 = arr.dropRight(k)\n        val maxList45 = arr.take\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmhyx8avt.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmhyx8avt.scala:66:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val maxK = arr.take(k).toList\n        val rest = arr.drop(k)\n        val restMaxK = maximum(rest, k)\n        restMaxK ++ maxK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9kxdq1yb.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793671
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length < k) {\n            val arr = new Array[Long](k)\n            i = 0\n            while (i < k) {\n                arr(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdtgah05a.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdtgah05a.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdtgah05a.scala:34:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNum = arr.max\n        val maxNumIndex = arr.indexWhere(x => x == maxNum)\n        val maxNums = arr.take(maxNumIndex + 1)\n        val maxNumsIndex = arr.indexWhere(x => x == maxNums)\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n        val maxNumsIndex = maxNumsIndex - k\n        val maxNumsIndex = maxNumsIndex % arr.length\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgyuhgt5h.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgyuhgt5h.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex % arr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgyuhgt5h.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgyuhgt5h.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex % arr.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgyuhgt5h.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer(arr.head)\n        val maxK = k\n        val maxLength = arr.length\n        val maxIndex = arr.indexOfMax\n        val maxValue = arr(maxIndex)\n        val maxIndexList = arr.toList\n        val maxIndexListLength = maxIndexList.length\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmps1lg9myg.scala:64:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps1lg9myg.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps1lg9myg.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps1lg9myg.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps1lg9myg.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.size\n        val m = arr.max\n        val maxList = Array.ofDim[Long](k)\n        var maxIndex = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        while (i < n) {\n            if (arr(i) > m) {\n                maxIndex = 0\n                while (j < k) {\n                    if (arr(i) > maxList(j)) {\n                        maxList(j) = arr(i)\n                        maxIndex = j\n                    }\n                    j += 1\n                }\n                i += 1\n            } else {\n                i += 1\n            }\n        }\n        maxList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmph0zt8u2b.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph0zt8u2b.scala:43:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        maxList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (maxList : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new mutable.PriorityQueue[Long]()\n        val maxIndex = new mutable.PriorityQueue[Int]()\n        val maxIndexLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3jsh83b8.scala:44:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3jsh83b8.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3jsh83b8.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3jsh83b8.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenL",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val m = k\n        val max = new Array[Long](m)\n        var i = 0\n        var j = 0\n        var k = 0\n        var maxIndex = 0\n        var maxValue = 0\n        while (i < n) {\n            while (j < m && arr(i) < arr(j)) {\n                j += 1\n            }\n            if (j == m) {\n                max(i) = arr(i)\n                i += 1\n                j += 1\n            } else {\n                max(i) = arr(j)\n                j += 1\n            }\n        }\n        while (j < m) {\n            max(i) = arr(j)\n            j += 1\n            i += 1\n        }\n        val maxList = max.toList\n        val maxLength = maxList.length\n        if (maxLength > k) {\n            val newMax = maxList.take(k)\n            maxList = maxList.drop(k)\n            val newMaxIndex = maxList.indexOf(newMax)\n            if (newMaxIndex > maxIndex) {\n                maxIndex = newMaxIndex\n                maxValue = newMax\n            }\n        }\n        if (maxLength > k) {\n            val newMax = maxList.take(k)\n            maxList = maxList.drop(k)\n            val newMaxIndex = maxList.indexOf(newMax)\n            if (newMaxIndex > maxIndex) {\n                maxIndex = newMaxIndex\n                maxValue = newMax\n            }\n        }\n        if (maxLength > k) {\n            val newMax = maxList.take(k)\n            maxList = maxList.drop(k)\n            val newMaxIndex = maxList.indexOf(newMax)\n            if (newMaxIndex > maxIndex) {\n                maxIndex = newMaxIndex\n                maxValue = newMax\n            }\n        }\n        if (maxLength > k) {\n            val newMax = maxList.take(k)\n            maxList = maxList.drop(k)\n            val newMaxIndex = maxList.indexOf(newMax)\n            if (newMaxIndex > maxIndex) {\n                maxIndex = newMaxIndex\n                maxValue = newMax\n            }\n        }\n        if (maxLength > k) {\n            val newMax = maxList.take(k)\n            maxList = maxList.drop(k)\n            val newMaxIndex = maxList.indexOf(newMax)\n            if (newMaxIndex > maxIndex) {\n                maxIndex = newMaxIndex\n                maxValue = newMax\n            }\n        }\n        if (maxLength > k) {\n            val newMax = maxList.take(k)\n            maxList = maxList.drop(k)\n            val newMaxIndex = maxList.indexOf(newMax)\n            if (newMaxIndex > maxIndex) {\n                maxIndex = newMaxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5kd847s0.scala:116:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m116 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5kd847s0.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5kd847s0.scala:51:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m            maxList = maxList.drop(k)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val maxList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5kd847s0.scala:55:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m                maxValue = newMax\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (newMax : List[Long])\n\u001b[31m   |\u001b[0m                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5kd847s0.scala:60:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m            maxList = maxList.drop(k)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val maxList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5kd847s0.scala:64:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m                maxValue = newMax\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (newMax : List[Long])\n\u001b[31m   |\u001b[0m                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation avail",
      "stdout": "",
      "timestamp": 1659793679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = 0\n        var maxIndex2 = 0\n        var maxValue2 = 0\n        var i = 0\n        var j = 0\n        while (i < len) {\n            val value = arr(i)\n            if (maxIndex < k) {\n                if (maxIndex2 < k) {\n                    if (maxIndex == k) {\n                        maxIndex2 = 0\n                        maxValue2 = maxValue\n                    }\n                    if (maxIndex2 == k) {\n                        maxIndex2 = k\n                        maxValue2 = value\n                    }\n                    if (maxValue2 < value) {\n                        maxIndex2 = k\n                        maxValue2 = value\n                    }\n                }\n                if (maxIndex2 == k) {\n                    maxIndex2 = k\n                    maxValue2 = value\n                }\n                if (maxValue2 < value) {\n                    maxIndex2 = k\n                    maxValue2 = value\n                }\n            }\n            if (maxIndex2 == k) {\n                maxIndex2 = k\n                maxValue2 = value\n            }\n            if (maxValue2 < value) {\n                maxIndex2 = k\n                maxValue2 = value\n            }\n            maxIndex += 1\n            maxValue += value\n            i += 1\n        }\n        val result = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            result(i) = maxValue2\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn31groes.scala:68:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpn31groes.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn31groes.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn31groes.scala:38:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                        maxIndex2 = k\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn31groes.scala:42:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                        maxIndex2 = k\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation availabl",
      "stdout": "",
      "timestamp": 1659793679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLen = arr.length\n        val maxK = k\n        val maxKList = mutable.ListBuffer.empty[Long]\n        val maxKLen = maxKList.length\n        val maxKK = maxKList(0)\n        val maxKKList = mutable.ListBuffer.empty[Long]\n        val maxKKLen = maxKKList.length\n        val maxKKK = maxKKList(0)\n        val maxKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKLen = maxKKKList.length\n        val maxKKKK = maxKKKList(0)\n        val maxKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKLen = maxKKKKList.length\n        val maxKKKKK = maxKKKKList(0)\n        val maxKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKLen = maxKKKKKList.length\n        val maxKKKKKK = maxKKKKKList(0)\n        val maxKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKLen = maxKKKKKKList.length\n        val maxKKKKKKK = maxKKKKKKList(0)\n        val maxKKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKKLen = maxKKKKKKKList.length\n        val maxKKKKKKKK = maxKKKKKKKList(0)\n        val maxKKKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKKKLen = maxKKKKKKKKList.length\n        val maxKKKKKKKKK = maxKKKKKKKKList(0)\n        val maxKKKKKKKKKList = mutable.ListBuffer.empty[Long]\n        val maxKKKKKKKKKLen = maxKKKKKKKKKList.length\n        val maxKKKK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplebioho0.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplebioho0.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplebioho0.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplebioho0.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplebioho0.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplebioho0.scala:32:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKKList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not ",
      "stdout": "",
      "timestamp": 1659793677
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNum = arr.max\n        val maxNumIndex = arr.indexWhere(x => x == maxNum)\n        val maxNumList = arr.take(maxNumIndex + 1)\n        val maxNumListIndex = maxNumList.indexWhere(x => x == maxNum)\n        val maxNumListIndex = maxNumListIndex + 1\n        val maxNumListLength = maxNumListIndex - maxNumListIndex\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNumListLength - 1\n        val maxNumListLength = maxNum\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp57ojir_b.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListIndex\u001b[0m = maxNumListIndex + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp57ojir_b.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp57ojir_b.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp57ojir_b.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp57ojir_b.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLe",
      "stdout": "",
      "timestamp": 1659793679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ > _)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpevj3n1vl.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpevj3n1vl.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793680
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        while (i < len) {\n            if (arr(i) > arr(maxIndex)) {\n                maxIndex = i\n            }\n            i += 1\n        }\n        val maxList = arr.take(maxIndex).toList\n        val maxLen = maxList.length\n        var j = 0\n        while (j < maxLen) {\n            if (maxList[j] > arr(maxIndex)) {\n                maxIndex += 1\n            }\n            j += 1\n        }\n        val maxList2 = arr.take(maxIndex).toList\n        val maxLen2 = maxList2.length\n        var k = 0\n        while (k <= maxLen2) {\n            if (maxList2(k) > arr(maxIndex)) {\n                maxIndex += 1\n            }\n            k += 1\n        }\n        val maxList3 = arr.take(maxIndex).toList\n        val maxLen3 = maxList3.length\n        var l = 0\n        while (l<maxLen3) {\n            if (maxList3(l) > arr(maxIndex)) {\n                maxIndex += 1\n            }\n            l += 1\n        }\n        val maxList4 = arr.take(maxIndex).toList\n        val maxLen4 = maxList4.length\n        var m = 0\n        while (m<maxLen4) {\n            if (maxList4(m) > arr(maxIndex)) {\n                maxIndex += 1\n            }\n            m += 1\n        }\n        val maxList5 = arr.take(maxIndex).toList\n        val maxLen5 = maxList5.length\n        var n = 0\n        while (n<maxLen5) {\n            if (maxList5(n) > arr(maxIndex)) {\n                maxIndex += 1\n            }\n            n += 1\n        }\n        val maxList6 = arr.take(maxIndex).toList\n        val maxLen6 = maxList6.length\n        var o = 0\n        while (o<maxLen6) {\n            if (maxList6(o) > arr(maxIndex)) {\n                maxIndex += 1\n            }\n            o += 1\n        }\n        val maxList7 = arr.take(maxIndex).toList\n        val maxLen7 = maxList7.length\n        var p = 0\n        while (p<maxLen7) {\n            if (maxList7(p) > arr(maxIndex)) {\n                maxIndex += 1\n            }\n            p += 1\n        }\n        val maxList8 = arr.take(maxIndex).toList\n        val maxLen8 = maxList8.length\n        var q = 0\n        while (q<maxLen8) {\n            if (max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6v026pz3.scala:100:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m100 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6v026pz3.scala:116:0 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m116 |\u001b[0m\n\u001b[31m\u001b[31m    |\u001b[0m^\u001b[0m\n\u001b[31m    |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6v026pz3.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6v026pz3.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6v026pz3.scala:36:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            \u001b[33mif\u001b[0m (maxList[\u001b[35mj\u001b[0m] > arr(maxIndex)) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type j\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6v026pz3.scala:99:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m99 |\u001b[0m            \u001b[33mif\u001b[0m (max\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    (max : Array[Long])\n\u001b[31m   |\u001b[0m                Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6v026pz3.scala:115:1 --------------------\u001b[0m\u001b[0m\n\u001b[31m115 |\u001b[0m}\n\u001b[31m\u001b[31m    |\u001b[0m ^\u001b[0m\n\u001b[31m    |\u001b[0m Found:    Unit\n\u001b[31m   ",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val maxArr : List[Long] = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            maxArr(i) = arr(i)\n            i += 1\n        }\n        maxArr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxs0do4cv.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxs0do4cv.scala:21:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxArr\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxs0do4cv.scala:24:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            maxArr(i) = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean maxArr.updated?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793680
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        var i = 0\n        var j = 0\n        var k = 0\n        var maxIndex = 0\n        var maxIndex2 = 0\n        var maxIndexMap = 0\n        var maxIndexMap2 = 0\n        var maxIndexMap3 = 0\n        var maxIndexMap4 = 0\n        var maxIndexMap5 = 0\n        var maxIndexMap6 = 0\n        var maxIndexMap7 = 0\n        var maxIndexMap8 = 0\n        var maxIndexMap9 = 0\n        var maxIndexMap10 = 0\n        var maxIndexMap11 = 0\n        var maxIndexMap12 = 0\n        var maxIndexMap13 = 0\n        var maxIndexMap14 = 0\n        var maxIndexMap15 = 0\n        var maxIndexMap16 = 0\n        var maxIndexMap17 = 0\n        var maxIndexMap18 = 0\n        var maxIndexMap19 = 0\n        var maxIndexMap20 = 0\n        var maxIndexMap21 = 0\n        var maxIndexMap22 = 0\n        var maxIndexMap23 = 0\n        var maxIndexMap24 = 0\n        var maxIndexMap25 = 0\n        var maxIndexMap26 = 0\n        var maxIndexMap27 = 0\n        var maxIndexMap28 = 0\n        var maxIndexMap29 = 0\n        var maxIndexMap30 = 0\n        var maxIndexMap31 = 0\n        var maxIndexMap32 = 0\n        var maxIndexMap33 = 0\n        var maxIndexMap34 = 0\n        var maxIndexMap35 = 0\n        var maxIndexMap36 = 0\n        var maxIndexMap37 = 0\n        var maxIndexMap38 = 0\n        var maxIndexMap39 = 0\n        var maxIndexMap40 = 0\n        var maxIndexMap41 = 0\n        var maxIndexMap42 = 0\n        var maxIndexMap43 = 0\n        var maxIndexMap44 = 0\n        var maxIndexMap45 = 0\n        var maxIndexMap46 = 0\n        var maxIndexMap47 = 0\n        var maxIndexMap48 = 0\n        var maxIndexMap49 = 0\n        var maxIndexMap50 = 0\n        var maxIndexMap51 = 0\n        var maxIndexMap52 = 0\n        var maxIndexMap53 = 0\n        var maxIndexMap54 = 0\n        var maxIndexMap55 = 0\n        var maxIndexMap56 = 0\n        var maxIndexMap57 = 0\n        var maxIndexMap58 = 0\n        var maxIndexMap59 = 0\n        var maxIndexMap60 = 0\n        var maxIndexMap\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpc4an7rcv.scala:92:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m92 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc4an7rcv.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc4an7rcv.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc4an7rcv.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexMap2 is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexMap2\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpc4an7rcv.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc4an7rcv.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ",
      "stdout": "",
      "timestamp": 1659793680
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val n = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        var i = 0\n        while (i < k) {\n            if (maxIndexMap.contains(arr(i))) {\n                maxIndex(maxIndexMap(arr(i))) = i\n            } else {\n                maxIndexMap(arr(i)) = i\n            }\n            i += 1\n        }\n        var j = 0\n        while (j < n) {\n            if (maxIndexMap.contains(arr(j))) {\n                val index = maxIndexMap(arr(j))\n                val maxValue = arr(j)\n                val maxIndex = index\n                val maxIndex = index\n                val maxValue = arr(j)\n                maxIndex(maxIndex) = j\n                maxIndexMap(maxValue) = maxIndex\n                max(i) = maxValue\n                j += 1\n            } else {\n                j += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv5ym8h11.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5ym8h11.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv5ym8h11.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv5ym8h11.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv5ym8h11.scala:40:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = index\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35m",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxK = k\n        val maxLen = arr.length\n        val maxNum = arr.max\n        val maxNumIndex = arr.indexWhere(x => x == maxNum)\n        val maxNumIndex = maxNumIndex.toInt\n        val maxNum = arr(maxNumIndex)\n        val maxNumIndex = maxNumIndex + 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex - 1\n        val maxNumIndex = maxNumIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpr4ykbt7p.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumIndex\u001b[0m = maxNumIndex.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpr4ykbt7p.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNum\u001b[0m = arr(maxNumIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNum is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpr4ykbt7p.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumIndex\u001b[0m = maxNumIndex + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpr4ykbt7p.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumIndex\u001b[0m = maxNumIndex - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpr4ykbt7p.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumIndex\u001b[0m = maxNumIndex - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumIndex is already defined as \u001b[33",
      "stdout": "",
      "timestamp": 1659793680
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr.max\n        val maxIndex = arr.indexWhere(x => x == maxValue)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK).toList\n        val maxIndex = maxIndex.map(x => x + 1)\n        val maxIndex = maxIndex.map(x => x - 1)\n        val maxIndex = maxIndex.take(maxK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdss5x5gv.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdss5x5gv.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = maxIndex.map(\u001b[36mx\u001b[0m => x - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdss5x5gv.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = maxIndex.take(maxK).toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdss5x5gv.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = maxIndex.map(\u001b[36mx\u001b[0m => x + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdss5x5gv.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = maxIndex.map(\u001b[36mx\u001b[0m => x - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming ",
      "stdout": "",
      "timestamp": 1659793680
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        var max = 0\n        var maxIndex = 0\n        var i = 0\n        while (i < arr.length) {\n            if (arr(i) > max) {\n                max = arr(i)\n                maxIndex = i\n            }\n            i += 1\n        }\n        val maxLength = arr.length - maxIndex\n        if (maxLength < k) {\n            while (maxLength < k) {\n                val newMax = arr(maxIndex + 1)\n                if (newMax > max) {\n                    max = newMax\n                    maxIndex = maxIndex + 1\n                }\n                maxLength += 1\n            }\n        }\n        val newArr = arr.take(maxIndex + 1).reverse\n        result.addAll(newArr)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdzauzb0o.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdzauzb0o.scala:26:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdzauzb0o.scala:36:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                    max = newMax\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (newMax : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdzauzb0o.scala:39:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m                maxLength += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean maxLength.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = new mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < arr.length && arr.length > 0) {\n            if (arr(i) > arr(i + 1)) {\n                max += arr(i + 1)\n                i += 1\n            } else {\n                max += arr(i)\n                i += 1\n            }\n        }\n        if (arr.length > 0) {\n            max += arr(i)\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1h156jib.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1h156jib.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793679
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.size\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = 0\n        for(i <- 0 until k) {\n            val index = arr.indexOfMax\n            if(index > -1) {\n                maxIndex = i\n                maxValue = arr(index)\n            }\n        }\n        val result = new Array[Long](k)\n        for(i <- 0 until k) {\n            result(i) = arr(maxIndex)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmi4jww3p.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmi4jww3p.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmi4jww3p.scala:25:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmi4jww3p.scala:32:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmi4jww3p.scala:33:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNum = arr.sortWith(_ > _).take(k).toList\n        val maxNumIndex = arr.lastIndexWhere(_ == maxNum.max)\n        val maxNumList = arr.take(maxNumIndex).toList\n        val maxNumListIndex = arr.lastIndexWhere(_ == maxNumList)\n        val maxNumListLength = maxNumListIndex - maxNumIndex\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNumListLength = maxNumListLength + maxNumListLength\n        val maxNum\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0k0hnnq4.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0k0hnnq4.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength + maxNumListLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0k0hnnq4.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength + maxNumListLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0k0hnnq4.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength + maxNumListLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0k0hnnq4.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength + maxNumListLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumLi",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = 0\n        var i = 0\n        var j = 0\n        while (i < len) {\n            val value = arr(i)\n            if (value > maxValue) {\n                maxValue = value\n                maxIndex = i\n            }\n            i += 1\n        }\n        val result = new Array[Long](k)\n        for (i <- 0 until k) {\n            result(i) = arr(maxIndex)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0vo_4_92.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0vo_4_92.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0vo_4_92.scala:35:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0vo_4_92.scala:36:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0vo_4_92.scala:39:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available ",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        while (i < len) {\n            if (arr(i) > arr(j)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(j) = arr(j)\n                j += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp68hk5jlq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp68hk5jlq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793680
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr.max\n        val minValue = arr.min\n        val maxIndex = 0\n        val minIndex = 0\n        val maxValueIndex = arr.indexWhere(x => x == maxValue)\n        val minValueIndex = arr.indexWhere(x => x == minValue)\n        val maxValueIndex2 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex2 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex3 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex3 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex4 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex4 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex5 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex5 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex6 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex6 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex7 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex7 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex8 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex8 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex9 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex9 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex10 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex10 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex11 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex11 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex12 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex12 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex13 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex13 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex14 = arr.indexWhere(x => x == maxValue)\n        val minValueIndex14 = arr.indexWhere(x => x == minValue)\n        val maxValueIndex15 = arr.index\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmploifs90c.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmploifs90c.scala:55:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxValueIndex15\u001b[0m = arr.index\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value index is not a member of List[Long] - did you mean arr.indexOf?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmploifs90c.scala:56:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val maxList = arr.take(k)\n        val maxList2 = arr.drop(k)\n        val maxList3 = arr.takeRight(k)\n        val maxList4 = arr.dropRight(k)\n        val maxList5 = arr.take(k)\n        val maxList6 = arr.drop(k)\n        val maxList7 = arr.takeRight(k)\n        val maxList8 = arr.dropRight(k)\n        val maxList9 = arr.take(k)\n        val maxList10 = arr.drop(k)\n        val maxList11 = arr.takeRight(k)\n        val maxList12 = arr.dropRight(k)\n        val maxList13 = arr.take(k)\n        val maxList14 = arr.drop(k)\n        val maxList15 = arr.takeRight(k)\n        val maxList16 = arr.dropRight(k)\n        val maxList17 = arr.take(k)\n        val maxList18 = arr.drop(k)\n        val maxList19 = arr.takeRight(k)\n        val maxList20 = arr.dropRight(k)\n        val maxList21 = arr.take(k)\n        val maxList22 = arr.drop(k)\n        val maxList23 = arr.takeRight(k)\n        val maxList24 = arr.dropRight(k)\n        val maxList25 = arr.take(k)\n        val maxList26 = arr.drop(k)\n        val maxList27 = arr.takeRight(k)\n        val maxList28 = arr.dropRight(k)\n        val maxList29 = arr.take(k)\n        val maxList30 = arr.drop(k)\n        val maxList31 = arr.takeRight(k)\n        val maxList32 = arr.dropRight(k)\n        val maxList33 = arr.take(k)\n        val maxList34 = arr.drop(k)\n        val maxList35 = arr.takeRight(k)\n        val maxList36 = arr.dropRight(k)\n        val maxList37 = arr.take(k)\n        val maxList38 = arr.drop(k)\n        val maxList39 = arr.takeRight(k)\n        val maxList40 = arr.dropRight(k)\n        val maxList41 = arr.take(k)\n        val maxList42 = arr.drop(k)\n        val maxList43 = arr.takeRight(k)\n        val maxList44 = arr.dropRight(k)\n        val maxList45 = arr.take(\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp4wyhodau.scala:65:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList45\u001b[0m = arr.take(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4wyhodau.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4wyhodau.scala:66:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.size\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = arr(0)\n        for(i <- 0 until k) {\n            for(j <- 0 until n) {\n                if(arr(j) > maxValue) {\n                    maxValue = arr(j)\n                    maxIndex = j\n                }\n            }\n            max += maxValue\n            maxValue = arr(maxIndex)\n            maxIndex = 0\n        }\n        max += maxValue\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv3094jhv.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv3094jhv.scala:24:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv3094jhv.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            max += maxValue\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Array[Long] - did you mean max.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv3094jhv.scala:35:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        max += maxValue\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of Array[Long] - did you mean max.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv3094jhv.scala:36:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (max : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        var maxIndex = 0\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var maxVal = 0\n        var maxIndex = 0\n        var \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpchv25zx2.scala:120:11 --------------------------\u001b[0m\u001b[0m\n\u001b[31m120 |\u001b[0m        \u001b[33mvar\u001b[0m \n\u001b[31m\u001b[31m    |\u001b[0m           ^\u001b[0m\n\u001b[31m    |\u001b[0m           pattern expected\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpchv25zx2.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpchv25zx2.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpchv25zx2.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpchv25zx2.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxVal\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxVal is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmaxVal\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpchv25zx2.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mv",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val maxNum = arr.max\n        val maxIndex = arr.indexWhere(x => x == maxNum)\n        val maxNums = arr.take(maxIndex)\n        val maxNumsCount = maxNums.size\n        val maxNumsCountInRange = maxNumsCount - k\n        val maxNumsCountInRangeInRange = maxNumsCountInRange / 2\n        val maxNumsCountInRangeInRangeInRange = maxNumsCountInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxNumsCountInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsCountInRangeInRangeInRangeInRangeInRangeInRangeInRange \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp79xd3scw.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsCountInRangeInRangeInRangeInRange\u001b[0m = maxNumsCountInRangeInRangeInRange / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsCountInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsCountInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp79xd3scw.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsCountInRangeInRangeInRangeInRangeInRange\u001b[0m = maxNumsCountInRangeInRangeInRangeInRange / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsCountInRangeInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsCountInRangeInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp79xd3scw.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsCountInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m = maxNumsCountInRangeInRangeInRangeInRangeInRange / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsCountInRangeInRangeInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsCountInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp79xd3scw.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val n = arr.length\n        val m = math.min(k, n)\n        val result = new Array[Long](m)\n        var i = 0\n        while (i < m) {\n            result(i) = arr(i)\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9s51vydq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9s51vydq.scala:29:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793681
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxLen = arr.length\n        val maxK = k\n        val maxKList = mutable.ArrayBuffer.empty[Long]\n        val maxKLen = maxKList.length\n        val maxKK = maxKLen / 2\n        val maxKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKLen = maxKKList.length\n        val maxKKK = maxKKLen / 2\n        val maxKKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKKLen = maxKKKList.length\n        val maxKKKK = maxKKKLen / 2\n        val maxKKKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKKKLen = maxKKKKList.length\n        val maxKKKKK = maxKKKKLen / 2\n        val maxKKKKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKKKKLen = maxKKKKKList.length\n        val maxKKKKKK = maxKKKKKLen / 2\n        val maxKKKKKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKKKKKLen = maxKKKKKKList.length\n        val maxKKKKKKK = maxKKKKKKLen / 2\n        val maxKKKKKKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKKKKKKLen = maxKKKKKKKList.length\n        val maxKKKKKKKK = maxKKKKKKKKLen / 2\n        val maxKKKKKKKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKKKKKKKLen = maxKKKKKKKKList.length\n        val maxKKKKKKKKK = maxKKKKKKKKKLen / 2\n        val maxKKKKKKKKKList = mutable.ArrayBuffer.empty[Long]\n        val maxKKKKKKKKKLen = maxKKKKKKKKK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsdm6r12p.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsdm6r12p.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsdm6r12p.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsdm6r12p.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsdm6r12p.scala:32:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKKList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsdm6r12p.scala:35:27 -----------------",
      "stdout": "",
      "timestamp": 1659793684
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val max = new mutable.PriorityQueue[Long](k)\n        arr.foreach(x => max.enqueue(x))\n        val res = new mutable.PriorityQueue[Long](k)\n        while(max.nonEmpty) {\n            res.enqueue(max.dequeue())\n        }\n        res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6zb73s7.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6zb73s7.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793683
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        for(x <- arr) {\n            if(i < k) {\n                if(x > max(i)) {\n                    max(i) = x\n                }\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2ptwisb.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2ptwisb.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793685
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0pnhkqxf.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0pnhkqxf.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793685
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(x => x)\n        val max = arr.take(k)\n        val rest = arr.drop(k)\n        rest match {\n            case Nil => max\n            case x :: xs => x :: maximum(Array(xs ++ rest), k)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpun_cabqw.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(\u001b[36mx\u001b[0m => x)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpun_cabqw.scala:25:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mcase\u001b[0m x :: xs => x :: maximum(Array(xs ++ rest), k)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Not found: xs\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpun_cabqw.scala:25:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mcase\u001b[0m x :: xs => x :: maximum(Array(xs ++ rest), k)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793683
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = math.min(k, n)\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        var maxValue = arr(0)\n        var maxIndex = 0\n        for (i <- 0 until m) {\n            if (arr(i) > maxValue) {\n                maxValue = arr(i)\n                maxIndex = i\n            }\n        }\n        maxList += maxValue\n        for (i <- 0 until n) {\n            if (i != maxIndex) {\n                maxList += arr(i)\n            }\n        }\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpq6ak4dt_.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq6ak4dt_.scala:25:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (m : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793686
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new mutable.PriorityQueue[Long]()\n        val maxIndex = new mutable.PriorityQueue[Int]()\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Int, Long]()\n        val maxIndexMap3 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Int, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Int, \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5uy5cj92.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5uy5cj92.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5uy5cj92.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5uy5cj92.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5uy5cj92.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5uy5cj92.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ",
      "stdout": "",
      "timestamp": 1659793686
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = arr.sortWith(_ > _)\n        val maxLength = arr.length\n        val maxK = math.min(k, maxLength)\n        val maxList = maxList.take(maxK)\n        val maxListLength = maxList.length\n        val maxListK = math.min(maxListLength, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxListK, maxLength)\n        val maxListK = math.min(maxList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppy1259uj.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppy1259uj.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = maxList.take(maxK)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppy1259uj.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListK\u001b[0m = math.min(maxListK, maxLength)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListK is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListK\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppy1259uj.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListK\u001b[0m = math.min(maxListK, maxLength)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListK is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListK\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppy1259uj.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListK\u001b[0m = math.min(maxListK, maxLength)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListK is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListK\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppy1259uj.scala:29:12 --------",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNums = arr.take(k).toList\n        val maxNumsSet = maxNums.toSet\n        val maxNumsSetIterator = maxNumsSet.iterator\n        val maxNumsSetIteratorResult = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult2 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult3 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult4 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult5 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult6 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult7 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult8 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult9 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult10 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult11 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult12 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult13 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult14 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult15 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult16 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult17 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult18 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult19 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult20 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult21 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult22 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult23 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult24 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult25 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult26 = maxNumsSetIterator.next\n        val maxNumsSetIteratorResult27 = maxNumsSetIterator.next\n\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpogr27nt7.scala:20:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNums\u001b[0m = arr.take(k).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (k : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpogr27nt7.scala:51:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        while (i < arr.length) {\n            if (j == k) {\n                maxIndex = i\n                while (j < k) {\n                    if (arr(j) > arr(maxIndex)) {\n                        maxIndex = j\n                    }\n                    j += 1\n                }\n            }\n            if (arr(i) > arr(maxIndex)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                i += 1\n            }\n        }\n        arr.toList.sortBy(-_)\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5mhbtyxs.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5mhbtyxs.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793686
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = arr.max\n        val maxList = arr.filter(_ <= m).sortWith(_ > _)\n        val maxListLength = maxList.length\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        val maxListLength = maxListLength + k\n        val maxListLength = maxListLength - k\n        \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptbkylrea.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptbkylrea.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength + k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptbkylrea.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptbkylrea.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength + k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptbkylrea.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   ",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length < k) {\n            val arr = new Array[Long](k)\n            i = 0\n            while (i < k) {\n                arr(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdtgah05a.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdtgah05a.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdtgah05a.scala:34:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = arr.max\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) < m) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = m\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3yabi5v1.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = math.min(k, n)\n        val max = new mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < m) {\n            if (arr(i) > arr(i + 1)) {\n                max += arr(i + 1)\n                i += 1\n            } else {\n                max += arr(i)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwn17mzr6.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793685
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        while (i < len) {\n            if (arr(i) > arr(maxIndex)) {\n                maxIndex = i\n            }\n            i += 1\n        }\n        val maxList = arr.take(maxIndex).toList\n        val maxLen = maxList.length\n        var j = 0\n        while (j < maxLen) {\n            if (arr(j) > arr(maxIndex)) {\n                maxIndex(j)\n            }\n            j += 1\n        }\n        maxList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjbb01sv4.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjbb01sv4.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjbb01sv4.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpjbb01sv4.scala:37:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                maxIndex(j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                \u001b[33mvariable\u001b[0m \u001b[35mmaxIndex\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793686
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        while (i < len) {\n            if (arr(i) > arr(maxIndex)) {\n                maxIndex += 1\n                max(i) = arr(maxIndex)\n            }\n            i += 1\n        }\n        val newArr = new Array[Long](maxIndex + 1)\n        val newArrIndex = 0\n        var k = 0\n        while (j < maxIndex) {\n            if (arr(j) > arr(k)) {\n                newArrIndex += 1\n                newArr(newArrIndex) = arr(j)\n            }\n            j += 1\n        }\n        newArr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpe7z5mly8.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe7z5mly8.scala:38:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                newArrIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean newArrIndex.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpe7z5mly8.scala:43:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        newArr\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (newArr : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNum = arr.sortWith(_ > _).take(k).toList\n        val maxNumList = maxNum.map(_.toLong)\n        val maxNumListSorted = maxNumList.sortWith(_ > _)\n        val maxNumListSortedReversed = maxNumListSorted.reverse\n        val maxNumListSortedReversedList = maxNumListSortedReversed.map(_.toLong)\n        val maxNumListSortedReversedListSorted = maxNumListSortedReversedList.sortWith(_ > _)\n        val maxNumListSortedReversedListSortedReversed = maxNumListSortedReversedListSorted.reverse\n        val maxNumListSortedReversedListSortedReversedList = maxNumListSortedReversedListSortedReversed.map(_.toLong)\n        val maxNumListSortedReversedListSortedReversedListSorted = maxNumListSortedReversedListSortedReversedListSorted.sortWith(_ > _)\n        val maxNumListSortedReversedListSortedReversedListSortedReversed = maxNumListSortedReversedListSortedReversedListSortedReversed.reverse\n        val maxNumListSortedReversedListSortedReversedListSortedReversedList = maxNumListSortedReversedListSortedReversedListSortedReversedListSorted.map(_.toLong)\n        val maxNumListSortedReversedListSortedReversedListSortedReversedListSorted = maxNumListSortedReversedListSortedReversedListSortedReversedListSorted.sortWith(_ > _)\n        val maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversed = maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversed.reverse\n        val maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversedList = maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSorted.map(_.toLong)\n        val maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSorted = maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSortedReversed.sortWith(_ > _)\n        val maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSortedReversedList = maxNumListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSorted.map(_.toLong)\n        val maxNumList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjbm5ac4d.scala:37:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjbm5ac4d.scala:20:46 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNum\u001b[0m = arr.sortWith(_ > _).take(k).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjbm5ac4d.scala:28:67 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListSortedReversedListSortedReversedListSorted\u001b[0m = maxNumListSortedReversedListSortedReversedListSorted.sortWith(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListSortedReversedListSortedReversedListSorted\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjbm5ac4d.scala:29:75 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListSortedReversedListSortedReversedListSortedReversed\u001b[0m = maxNumListSortedReversedListSortedReversedListSortedReversed.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListSortedReversedListSortedReversedListSortedReversed\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpjbm5ac4d.scala:31:85 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListSortedReversedListSortedReversedListSortedReversedListSorted\u001b[0m = maxNumLis",
      "stdout": "",
      "timestamp": 1659793688
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ > _)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpevj3n1vl.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpevj3n1vl.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793680
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxIndex = arr.indexWhere(x => x > 0)\n        val maxValue = arr(maxIndex)\n        val maxIndexList = arr.indexWhere(x => x > maxValue)\n        val maxIndexListLength = maxIndexList.length\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexListLength = maxIndexListLength - 1\n        val maxIndexList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7t3f2998.scala:64:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7t3f2998.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7t3f2998.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7t3f2998.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7t3f2998.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexListLength\u001b[0m = maxIndexListLength - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val maxValue = arr.max\n        val maxIndex = arr.indexWhere(x => x == maxValue)\n        val maxIndexInRange = maxIndex - k\n        val maxIndexInRangeInRange = maxIndexInRange / 2\n        val maxIndexInRangeInRangeInRange = maxIndexInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange / 2\n        val maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxIndexIn\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpns7y8keo.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m = maxIndexInRangeInRangeInRangeInRangeInRange / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexInRangeInRangeInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpns7y8keo.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m = maxIndexInRangeInRangeInRangeInRangeInRangeInRange / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpns7y8keo.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m = maxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange / \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overl",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val max = new mutable.PriorityQueue[Long](k)\n        arr.foreach(x => max.enqueue(x))\n        val res = new mutable.PriorityQueue[Long](k)\n        while(max.nonEmpty) {\n            res.enqueue(max.dequeue())\n        }\n        res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6zb73s7.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf6zb73s7.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793683
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxValue = arr.head\n        val maxIndex = arr.indexOfMax\n        val maxLength = arr.length\n        val maxK = k\n        val maxKIndex = maxIndex - maxK\n        val maxKLength = maxLength - maxK\n        val maxKValue = arr(maxKIndex)\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val maxKValueLength = maxKLength - maxKLength\n        val maxKValueIndex = maxKIndex - maxKLength\n        val max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpcul0fxw0.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcul0fxw0.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueIndex\u001b[0m = maxKIndex - maxKLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValueIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcul0fxw0.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueLength\u001b[0m = maxKLength - maxKLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValueLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValueLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcul0fxw0.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueIndex\u001b[0m = maxKIndex - maxKLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValueIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcul0fxw0.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueLength\u001b[0m = maxKLength - maxKLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValueLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValueLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel defin",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = arr.max\n        val maxIndex = arr.indexWhere(x => x == max)\n        val maxIndex2 = maxIndex + 1\n        val maxIndex3 = maxIndex2 + 1\n        val maxIndex4 = maxIndex3 + 1\n        val maxIndex5 = maxIndex4 + 1\n        val maxIndex6 = maxIndex5 + 1\n        val maxIndex7 = maxIndex6 + 1\n        val maxIndex8 = maxIndex7 + 1\n        val maxIndex9 = maxIndex8 + 1\n        val maxIndex10 = maxIndex9 + 1\n        val maxIndex11 = maxIndex10 + 1\n        val maxIndex12 = maxIndex11 + 1\n        val maxIndex13 = maxIndex12 + 1\n        val maxIndex14 = maxIndex13 + 1\n        val maxIndex15 = maxIndex14 + 1\n        val maxIndex16 = maxIndex15 + 1\n        val maxIndex17 = maxIndex16 + 1\n        val maxIndex18 = maxIndex17 + 1\n        val maxIndex19 = maxIndex18 + 1\n        val maxIndex20 = maxIndex19 + 1\n        val maxIndex21 = maxIndex20 + 1\n        val maxIndex22 = maxIndex21 + 1\n        val maxIndex23 = maxIndex22 + 1\n        val maxIndex24 = maxIndex23 + 1\n        val maxIndex25 = maxIndex24 + 1\n        val maxIndex26 = maxIndex25 + 1\n        val maxIndex27 = maxIndex26 + 1\n        val maxIndex28 = maxIndex27 + 1\n        val maxIndex29 = maxIndex28 + 1\n        val maxIndex30 = maxIndex29 + 1\n        val maxIndex31 = maxIndex30 + 1\n        val maxIndex32 = maxIndex31 + 1\n        val maxIndex33 = maxIndex32 + 1\n        val maxIndex34 = maxIndex33 + 1\n        val maxIndex35 = maxIndex34 + 1\n        val maxIndex36 = maxIndex35 + 1\n        val maxIndex37 = maxIndex36 + 1\n        val maxIndex38 = maxIndex37 + 1\n        val maxIndex39 = maxIndex38 + 1\n        val maxIndex40 = maxIndex39 + 1\n        val maxIndex41 = maxIndex40 + 1\n        val maxIndex42 = maxIndex41 + 1\n        val maxIndex43 = maxIndex42 + 1\n        val maxIndex44 = maxIndex43 + 1\n        val maxIndex45 = maxIndex44 + 1\n        val maxIndex4\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4aztnnt8.scala:69:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4aztnnt8.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4aztnnt8.scala:69:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while(i < k) {\n            var maxIndex = 0\n            var maxValue = arr(0)\n            for(i <- 0 until len) {\n                if(arr(i) > maxValue) {\n                    maxValue = arr(i)\n                    maxIndex = i\n                }\n            }\n            max += maxIndex\n            i += 1\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp9275c08o.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp9275c08o.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9275c08o.scala:33:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            max += maxIndex\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Array[Long] - did you mean max.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793688
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val maxValue = arr.max\n        val maxIndex = arr.indexWhere(x => x == maxValue)\n        val maxLength = arr.length - maxIndex\n        val maxK = math.min(k, maxLength)\n        val maxValues = arr.take(maxK)\n        result.addAll(maxValues)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps1h3pt7v.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps1h3pt7v.scala:25:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxValues\u001b[0m = arr.take(maxK)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (maxK : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.size\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp5zesxgqi.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5zesxgqi.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5zesxgqi.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp5zesxgqi.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5zesxgqi.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793688
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = arr.sortBy(-_)\n        val maxLength = maxList.size\n        val maxList2 = maxList.take(k)\n        val maxList3 = maxList2.sortBy(-_)\n        val maxList4 = maxList3.take(k)\n        val maxList5 = maxList4.sortBy(-_)\n        val maxList6 = maxList5.take(k)\n        val maxList7 = maxList6.sortBy(-_)\n        val maxList8 = maxList7.take(k)\n        val maxList9 = maxList8.sortBy(-_)\n        val maxList10 = maxList9.take(k)\n        val maxList11 = maxList10.sortBy(-_)\n        val maxList12 = maxList11.take(k)\n        val maxList13 = maxList12.sortBy(-_)\n        val maxList14 = maxList13.take(k)\n        val maxList15 = maxList14.sortBy(-_)\n        val maxList16 = maxList15.take(k)\n        val maxList17 = maxList16.sortBy(-_)\n        val maxList18 = maxList17.take(k)\n        val maxList19 = maxList18.sortBy(-_)\n        val maxList20 = maxList19.take(k)\n        val maxList21 = maxList20.sortBy(-_)\n        val maxList22 = maxList21.take(k)\n        val maxList23 = maxList22.sortBy(-_)\n        val maxList24 = maxList23.take(k)\n        val maxList25 = maxList24.sortBy(-_)\n        val maxList26 = maxList25.take(k)\n        val maxList27 = maxList26.sortBy(-_)\n        val maxList28 = maxList27.take(k)\n        val maxList29 = maxList28.sortBy(-_)\n        val maxList30 = maxList29.take(k)\n        val maxList31 = maxList30.sortBy(-_)\n        val maxList32 = maxList31.take(k)\n        val maxList33 = maxList32.sortBy(-_)\n        val maxList34 = maxList33.take(k)\n        val maxList35 = maxList34.sortBy(-_)\n        val maxList36 = maxList35.take(k)\n        val maxList37 = maxList36.sortBy(-_)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu5hjbcfd.scala:22:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList2\u001b[0m = maxList.take(k)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu5hjbcfd.scala:24:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList4\u001b[0m = maxList3.take(k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu5hjbcfd.scala:26:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList6\u001b[0m = maxList5.take(k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu5hjbcfd.scala:28:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList8\u001b[0m = maxList7.take(k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu5hjbcfd.scala:30:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList10\u001b[0m = maxList9.take(k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[3",
      "stdout": "",
      "timestamp": 1659793691
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxElement = arr.max\n        val maxIndex = arr.indexOf(maxElement)\n        val maxElementIndex = maxIndex\n        val maxElementLength = maxIndex\n        val maxElementK = maxElementIndex\n        val maxElementElement = maxElement\n        val maxElementElementIndex = maxElementIndex\n        val maxElementElementLength = maxElementIndex\n        val maxElementElementK = maxElementElementIndex\n        val maxElementElementElement = maxElementElement\n        val maxElementElementElementIndex = maxElementElementIndex\n        val maxElementElementElementLength = maxElementElementIndex\n        val maxElementElementElementK = maxElementElementElementIndex\n        val maxElementElementElementElement = maxElementElementElement\n        val maxElementElementElementElementIndex = maxElementElementElementIndex\n        val maxElementElementElementElementLength = maxElementElementElementIndex\n        val maxElementElementElementElementK = maxElementElementElementElementIndex\n        val maxElementElementElementElementElement = maxElementElementElementElement\n        val maxElementElementElementElementElementIndex = maxElementElementElementElementElementIndex\n        val maxElementElementElementElementElementLength = maxElementElementElementElementElementIndex\n        val maxElementElementElementElementElementK = maxElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElement = maxElementElementElementElementElementElement\n        val maxElementElementElementElementElementElementIndex = maxElementElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElementLength = maxElementElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElementK = maxElementElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElementElement = maxElementElementElementElementElementElementElement\n        val maxElementElementElementElementElementElementElementIndex = maxElementElementElementElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElementElementLength = maxElementElementElementElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElementElementK = maxElementElementElementElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElementElementElement = maxElementElementElementElementElementElementElementElementElementIndex\n        val maxElementElementElementElementElementElementElementElementIndex = maxElementElementElementElementElementElementElementElementElementLength\n        val maxElementElementElementElementElementElementElementElementK = maxElementElement\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcemgtc9b.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcemgtc9b.scala:41:58 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxElementElementElementElementElementIndex\u001b[0m = maxElementElementElementElementElementIndex\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m  Recursive \u001b[33mvalue\u001b[0m \u001b[35mmaxElementElementElementElementElementIndex\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcemgtc9b.scala:44:60 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxElementElementElementElementElementElement\u001b[0m = maxElementElementElementElementElementElement\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mmaxElementElementElementElementElementElement\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcemgtc9b.scala:45:65 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxElementElementElementElementElementElementIndex\u001b[0m = maxElementElementElementElementElementElementIndex\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mmaxElementElementElementElementElementElementIndex\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcemgtc9b.scala:48:67 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m",
      "stdout": "",
      "timestamp": 1659793689
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = arr.max\n        val maxIndex = arr.indexWhere(x => x == max)\n        val maxIndex2 = maxIndex + 1\n        val maxIndex3 = maxIndex2 + 1\n        val maxIndex4 = maxIndex3 + 1\n        val maxIndex5 = maxIndex4 + 1\n        val maxIndex6 = maxIndex5 + 1\n        val maxIndex7 = maxIndex6 + 1\n        val maxIndex8 = maxIndex7 + 1\n        val maxIndex9 = maxIndex8 + 1\n        val maxIndex10 = maxIndex9 + 1\n        val maxIndex11 = maxIndex10 + 1\n        val maxIndex12 = maxIndex11 + 1\n        val maxIndex13 = maxIndex12 + 1\n        val maxIndex14 = maxIndex13 + 1\n        val maxIndex15 = maxIndex14 + 1\n        val maxIndex16 = maxIndex15 + 1\n        val maxIndex17 = maxIndex16 + 1\n        val maxIndex18 = maxIndex17 + 1\n        val maxIndex19 = maxIndex18 + 1\n        val maxIndex20 = maxIndex19 + 1\n        val maxIndex21 = maxIndex20 + 1\n        val maxIndex22 = maxIndex21 + 1\n        val maxIndex23 = maxIndex22 + 1\n        val maxIndex24 = maxIndex23 + 1\n        val maxIndex25 = maxIndex24 + 1\n        val maxIndex26 = maxIndex25 + 1\n        val maxIndex27 = maxIndex26 + 1\n        val maxIndex28 = maxIndex27 + 1\n        val maxIndex29 = maxIndex28 + 1\n        val maxIndex30 = maxIndex29 + 1\n        val maxIndex31 = maxIndex30 + 1\n        val maxIndex32 = maxIndex31 + 1\n        val maxIndex33 = maxIndex32 + 1\n        val maxIndex34 = maxIndex33 + 1\n        val maxIndex35 = maxIndex34 + 1\n        val maxIndex36 = maxIndex35 + 1\n        val maxIndex37 = maxIndex36 + 1\n        val maxIndex38 = maxIndex37 + 1\n        val maxIndex39 = maxIndex38 + 1\n        val maxIndex40 = maxIndex39 + 1\n        val maxIndex41 = maxIndex40 + 1\n        val maxIndex42 = maxIndex41 + 1\n        val maxIndex43 = maxIndex42 + 1\n        val maxIndex44 = maxIndex43 + 1\n        val maxIndex45 = maxIndex44 + 1\n        val maxIndex4\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4aztnnt8.scala:69:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4aztnnt8.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4aztnnt8.scala:69:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = k\n        val max = new Array[Long](m)\n        var i = 0\n        while (i < m) {\n            var maxIndex = 0\n            var maxValue = arr(0)\n            for (j <- 0 until n) {\n                if (arr(j) > maxValue) {\n                    maxValue = arr(j)\n                    maxIndex = j\n                }\n            }\n            max.update(i, maxValue)\n            i += 1\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1f6qivj3.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793690
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_).reverse\n        val maxList = arr.take(k)\n        val maxList2 = arr.drop(k)\n        val maxList3 = arr.takeRight(k)\n        val maxList4 = arr.dropRight(k)\n        val maxList5 = arr.take(k)\n        val maxList6 = arr.drop(k)\n        val maxList7 = arr.takeRight(k)\n        val maxList8 = arr.dropRight(k)\n        val maxList9 = arr.take(k)\n        val maxList10 = arr.drop(k)\n        val maxList11 = arr.takeRight(k)\n        val maxList12 = arr.dropRight(k)\n        val maxList13 = arr.take(k)\n        val maxList14 = arr.drop(k)\n        val maxList15 = arr.takeRight(k)\n        val maxList16 = arr.dropRight(k)\n        val maxList17 = arr.take(k)\n        val maxList18 = arr.drop(k)\n        val maxList19 = arr.takeRight(k)\n        val maxList20 = arr.dropRight(k)\n        val maxList21 = arr.take(k)\n        val maxList22 = arr.drop(k)\n        val maxList23 = arr.takeRight(k)\n        val maxList24 = arr.dropRight(k)\n        val maxList25 = arr.take(k)\n        val maxList26 = arr.drop(k)\n        val maxList27 = arr.takeRight(k)\n        val maxList28 = arr.dropRight(k)\n        val maxList29 = arr.take(k)\n        val maxList30 = arr.drop(k)\n        val maxList31 = arr.takeRight(k)\n        val maxList32 = arr.dropRight(k)\n        val maxList33 = arr.take(k)\n        val maxList34 = arr.drop(k)\n        val maxList35 = arr.takeRight(k)\n        val maxList36 = arr.dropRight(k)\n        val maxList37 = arr.take(k)\n        val maxList38 = arr.drop(k)\n        val maxList39 = arr.takeRight(k)\n        val maxList40 = arr.dropRight(k)\n        val maxList41 = arr.take(k)\n        val maxList42 = arr.drop(k)\n        val maxList43 = arr.takeRight(k)\n        val maxList44 = arr.dropRight(k)\n        val maxList45 = arr.take(\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpwbtasyoq.scala:65:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList45\u001b[0m = arr.take(\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpwbtasyoq.scala:20:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => arr.sortBy(_$1).reverse.\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwbtasyoq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwbtasyoq.scala:66:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793691
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val n = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt0xq50vf.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt0xq50vf.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793692
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        while(i < len) {\n            while(j < k && arr(i) < arr(j)) {\n                j += 1\n            }\n            while(j < k && arr(i) == arr(j)) {\n                j += 1\n            }\n            if(j == k) {\n                max(i) = arr(i)\n                i += 1\n                j += 1\n                maxIndex += 1\n            } else {\n                max(i) = arr(j)\n                j += 1\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwfo_5_vs.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwfo_5_vs.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793692
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val max = arr.take(k)\n        val rest = arr.drop(k)\n        rest ++ max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpufcd01em.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793690
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        while(i < len) {\n            while(j < k) {\n                if(arr(i) > arr(j)) {\n                    maxIndex = j\n                    arr(maxIndex) = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) = arr(maxIndex)\n                }\n                j+=1\n            }\n            i+=1\n            j = 0\n        }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpm915uk5e.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm915uk5e.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793692
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpj5tg_tky.scala:20:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => arr.sortBy(_$1).\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpj5tg_tky.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj5tg_tky.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793692
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        var maxVal = 0\n        while(i < len) {\n            while(j < k) {\n                if(arr(i) > arr(j)) {\n                    maxVal = arr(i)\n                    maxIndex = i\n                    maxIndex(0) = j\n                    maxIndex(1) = j\n                    maxIndex(2) = j\n                    i = j\n                    j = j + 1\n                } else {\n                    maxVal = arr(j)\n                    maxIndex = j\n                    maxIndex(0) = i\n                    maxIndex(1) = i\n                    maxIndex(2) = i\n                    j = i + 1\n                }\n            }\n            i = i + 1\n        }\n        val result = new Array[Long](k)\n        for(i <- 0 until k) {\n            result(i) = arr(maxIndex(i))\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpucr4k5f0.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpucr4k5f0.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(\u001b[36mx\u001b[0m => x)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpucr4k5f0.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpucr4k5f0.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpucr4k5f0.scala:32:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                    maxIndex = i\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (i : Int)\n\u001b[31m   |\u001b[0m                         ",
      "stdout": "",
      "timestamp": 1659793693
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer[Long]()\n        val maxLength = arr.length\n        val maxK = k\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        for(i <- 1 to maxLength) {\n            val value = arr(i)\n            if(value > maxValue) {\n                maxValue = value\n                maxIndex = i\n            }\n        }\n        val maxListLength = maxIndex - maxK + 1\n        val maxList = new Array[Long](maxListLength)\n        for(i <- 0 until maxListLength) {\n            maxList(i) = arr(maxIndex + i)\n        }\n        maxList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz9zn951g.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](maxListLength)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz9zn951g.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpz9zn951g.scala:28:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                maxValue = value\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxValue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpz9zn951g.scala:29:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                maxIndex = i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz9zn951g.scala:34:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until maxListLength) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (maxListLength : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793693
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val m = arr.take(k).max\n        val maxList = arr.take(k).filter(_ == m).toList\n        val maxList2 = arr.take(k).filter(_ != m).toList\n        val maxList3 = arr.take(k).filter(_ != m).filter(_ != m).toList\n        val maxList4 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList5 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList6 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList7 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList8 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList9 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList10 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList11 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList12 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).filter(_ != m).toList\n        val maxList13 = arr.take(k).filter(_ != m).filter(_ != m).filter(_ != m\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfyoddh5q.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpfyoddh5q.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfyoddh5q.scala:36:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793693
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = arr.max\n        val maxIndex = arr.indexWhere(x => x == max)\n        val maxIndexList = arr.take(maxIndex).toList\n        val maxIndexListLen = maxIndexList.length\n        val maxIndexListLenMinusOne = maxIndexListLen - 1\n        val maxIndexListLenMinusTwo = maxIndexListLen - 2\n        val maxIndexListLenMinusThree = maxIndexListLen - 3\n        val maxIndexListLenMinusFour = maxIndexListLen - 4\n        val maxIndexListLenMinusFive = maxIndexListLen - 5\n        val maxIndexListLenMinusSix = maxIndexListLen - 6\n        val maxIndexListLenMinusSeven = maxIndexListLen - 7\n        val maxIndexListLenMinusEight = maxIndexListLen - 8\n        val maxIndexListLenMinusNine = maxIndexListLen - 9\n        val maxIndexListLenMinusTen = maxIndexListLen - 10\n        val maxIndexListLenMinusEleven = maxIndexListLen - 11\n        val maxIndexListLenMinusTwelve = maxIndexListLen - 12\n        val maxIndexListLenMinusThirteen = maxIndexListLen - 13\n        val maxIndexListLenMinusFourteen = maxIndexListLen - 14\n        val maxIndexListLenMinusFifteen = maxIndexListLen - 15\n        val maxIndexListLenMinusSixteen = maxIndexListLen - 16\n        val maxIndexListLenMinusSeventeen = maxIndexListLen - 17\n        val maxIndexListLenMinusEighteen = maxIndexListLen - 18\n        val maxIndexListLenMinusNineteen = maxIndexListLen - 19\n        val maxIndexListLenMinusTwenty = maxIndexListLen - 20\n        val maxIndexListLenMinusThirty = maxIndexListLen - 30\n        val maxIndexListLenMinusFourty = maxIndexListLen - 40\n        val maxIndexListLenMinusFifty = maxIndexListLen - 50\n        val maxIndexListLenMinusSixty = maxIndexListLen - 60\n        val maxIndexListLenMinusSeventy = maxIndexListLen - 70\n        val maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6hcxk9j_.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6hcxk9j_.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6hcxk9j_.scala:52:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val arr = arr.toList\n        val len = arr.length\n        val max = arr.max\n        val maxIndex = arr.indexWhere(x => x == max)\n        val maxIndex1 = maxIndex - 1\n        val maxIndex2 = maxIndex + 1\n        val maxIndex3 = maxIndex + 2\n        val maxIndex4 = maxIndex + 3\n        val maxIndex5 = maxIndex + 4\n        val maxIndex6 = maxIndex + 5\n        val maxIndex7 = maxIndex + 6\n        val maxIndex8 = maxIndex + 7\n        val maxIndex9 = maxIndex + 8\n        val maxIndex10 = maxIndex + 9\n        val maxIndex11 = maxIndex + 10\n        val maxIndex12 = maxIndex + 11\n        val maxIndex13 = maxIndex + 12\n        val maxIndex14 = maxIndex + 13\n        val maxIndex15 = maxIndex + 14\n        val maxIndex16 = maxIndex + 15\n        val maxIndex17 = maxIndex + 16\n        val maxIndex18 = maxIndex + 17\n        val maxIndex19 = maxIndex + 18\n        val maxIndex20 = maxIndex + 19\n        val maxIndex21 = maxIndex + 20\n        val maxIndex22 = maxIndex + 21\n        val maxIndex23 = maxIndex + 22\n        val maxIndex24 = maxIndex + 23\n        val maxIndex25 = maxIndex + 24\n        val maxIndex26 = maxIndex + 25\n        val maxIndex27 = maxIndex + 26\n        val maxIndex28 = maxIndex + 27\n        val maxIndex29 = maxIndex + 28\n        val maxIndex30 = maxIndex + 29\n        val maxIndex31 = maxIndex + 30\n        val maxIndex32 = maxIndex + 31\n        val maxIndex33 = maxIndex + 32\n        val maxIndex34 = maxIndex + 33\n        val maxIndex35 = maxIndex + 34\n        val maxIndex36 = maxIndex + 35\n        val maxIndex37 = maxIndex + 36\n        val maxIndex38 = maxIndex + 37\n        val maxIndex39 = maxIndex + 38\n        val maxIndex40 = maxIndex + 39\n        val maxIndex41 = maxIndex + 40\n        val maxIndex42 = maxIndex + 41\n        val maxIndex43 = maxIndex + 42\n        val maxIndex44 = maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmsar83xt.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmsar83xt.scala:21:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmsar83xt.scala:69:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val m = arr.take(k).max\n        val max = arr.filter(_ <= m).sortBy(-_).take(k)\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp25yx3q1f.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793691
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuoj84dpg.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuoj84dpg.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNums = arr.take(k)\n        val maxNumsSet = maxNums.toSet\n        val maxNumsSortedSet = maxNums.sort\n        val maxNumsSortedSetSet = maxNumsSortedSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSet.subsets(k)\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = maxNumsSortedSetSet.toSet\n        val maxNumsSortedSetSet = \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpfme24fyc.scala:49:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSortedSetSet\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfme24fyc.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSortedSetSet\u001b[0m = maxNumsSortedSet.subsets(k)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsSortedSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsSortedSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfme24fyc.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSortedSetSet\u001b[0m = maxNumsSortedSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsSortedSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsSortedSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfme24fyc.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSortedSetSet\u001b[0m = maxNumsSortedSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsSortedSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsSortedSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfme24fyc.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSortedSetSet\u001b[0m = maxNumsSortedS",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = math.min(k, n)\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxIndex = mutable.ArrayBuffer.empty[Int]\n        val maxValue = mutable.ArrayBuffer.empty[Long]\n        \n        for(i <- 0 until m) {\n            val index = arr.indexOfMax(arr(i))\n            maxIndex += index\n            maxValue += arr(i)\n            maxList += arr(i)\n        }\n        \n        maxIndex.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppj8il0qi.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppj8il0qi.scala:23:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppj8il0qi.scala:24:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxValue\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppj8il0qi.scala:26:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (m : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppj8il0qi.scala:27:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mindex\u001b[0m = arr.indexOfMax(arr(i))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue indexOfMax is not a member of List[Long] - did you mean arr.indexOf?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = math.min(k, n)\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        var max = 0\n        var i = 0\n        while (i < m) {\n            max = arr(i)\n            i += 1\n        }\n        while (i < n) {\n            if (max < arr(i)) {\n                max = arr(i)\n            }\n            i += 1\n        }\n        maxList += max\n        val newList = maxList.sortWith(_ > _)\n        if (newList.length == k) {\n            newList\n        } else {\n            maximum(newList, k)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2zuuxdeg.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2zuuxdeg.scala:26:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2zuuxdeg.scala:31:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpj5tg_tky.scala:20:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => arr.sortBy(_$1).\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpj5tg_tky.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj5tg_tky.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793692
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val m = arr.take(k).toList\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.Hash\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpo1efwp0w.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo1efwp0w.scala:23:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpo1efwp0w.scala:24:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo1efwp0w.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo1efwp0w.scala:26:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        ",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length < k) {\n            val len = arr.length\n            val max = new Array[Long](k)\n            var i = 0\n            while (i < k) {\n                if (arr(i) > arr(i + 1)) {\n                    max(i) = arr(i)\n                    i += 1\n                } else {\n                    max(i) = arr(i + 1)\n                    i += 1\n                }\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpon72ny1p.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpon72ny1p.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpon72ny1p.scala:35:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = math.min(k, n)\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        var max = 0\n        var i = 0\n        while (i < m) {\n            val cur = arr(i)\n            if (cur > max) {\n                max = cur\n                maxList += max\n            }\n            i += 1\n        }\n        if (max == 0) maxList += 0\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr696e_pt.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr696e_pt.scala:28:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                max = cur\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (cur : Long)\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        var maxNum : Long = arr(0)\n        var i : Long = 1\n        while (i < arr.length) {\n            if (arr(i) > maxNum) {\n                maxNum = arr(i)\n            }\n            i += 1\n        }\n        val maxListLength = k - maxList.size\n        if (maxListLength > 0) {\n            maxList ++= arr.take(maxListLength)\n        }\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbbwwx0mo.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbbwwx0mo.scala:24:20 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mif\u001b[0m (arr(i) > maxNum) {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Found:    (i : Long)\n\u001b[31m   |\u001b[0m                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbbwwx0mo.scala:25:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                maxNum = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (i : Long)\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val n = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt0xq50vf.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt0xq50vf.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793692
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        var i = 0\n        var j = 0\n        var k = 0\n        var maxIndex = 0\n        var maxIndex2 = 0\n        var maxIndex3 = 0\n        var maxIndex4 = 0\n        var maxIndex5 = 0\n        var maxIndex6 = 0\n        var maxIndex7 = 0\n        var maxIndex8 = 0\n        var maxIndex9 = 0\n        var maxIndex10 = 0\n        var maxIndex11 = 0\n        var maxIndex12 = 0\n        var maxIndex13 = 0\n        var maxIndex14 = 0\n        var maxIndex15 = 0\n        var maxIndex16 = 0\n        var maxIndex17 = 0\n        var maxIndex18 = 0\n        var maxIndex19 = 0\n        var maxIndex20 = 0\n        var maxIndex21 = 0\n        var maxIndex22 = 0\n        var maxIndex23 = 0\n        var maxIndex24 = 0\n        var maxIndex25 = 0\n        var maxIndex26 = 0\n        var maxIndex27 = 0\n        var maxIndex28 = 0\n        var maxIndex29 = 0\n        var maxIndex30 = 0\n        var maxIndex31 = 0\n        var maxIndex32 = 0\n        var maxIndex33 = 0\n        var maxIndex34 = 0\n        var maxIndex35 = 0\n        var maxIndex36 = 0\n        var maxIndex37 = 0\n        var maxIndex38 = 0\n        var maxIndex39 = 0\n        var maxIndex40 = 0\n        var maxIndex41 = 0\n        var maxIndex42 = 0\n        var maxIndex43 = 0\n        var maxIndex44 = 0\n        var maxIndex45 = 0\n        var maxIndex46 = 0\n        var maxIndex47 = 0\n        var maxIndex48 = 0\n        var maxIndex49 = 0\n        var maxIndex50 = 0\n        var maxIndex51 = 0\n        var maxIndex52 = 0\n        var maxIndex53 = 0\n        var maxIndex54 = 0\n        var maxIndex55 = 0\n        var maxIndex56 = 0\n        var maxIndex57 = 0\n        var maxIndex58 = 0\n        var maxIndex59 = 0\n        var maxIndex60 = 0\n        var maxIndex61 = 0\n        var maxIndex62 = 0\n        var maxIndex63 = 0\n        var maxIndex64 = 0\n        var maxIndex65 = 0\n        var maxIndex66 = 0\n        var maxIndex67 = 0\n        var maxIndex68 = 0\n        var maxIndex69 = 0\n        var maxIndex70 = 0\n        var maxIndex71 = 0\n        var maxIndex72 = 0\n        var maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgtb0z_nt.scala:102:4 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m102 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m    ^\u001b[0m\n\u001b[31m    |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgtb0z_nt.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgtb0z_nt.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgtb0z_nt.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgtb0z_nt.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgtb0z_nt.scala:102:5 --------------------\u001b[0m\u001b[0m\n\u001b[31m102 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m     ^\u001b[0m\n\u001b[31m    |\u001b[0m     Found:    Unit\n\u001b[31m    |\u001b[0m     Required: List[Long]\n\u001b",
      "stdout": "",
      "timestamp": 1659793694
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        var max = 0\n        var maxIndex = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > max) {\n                max = arr(i)\n                maxIndex = i\n            }\n        }\n        for (i <- 0 until arr.length) {\n            if (arr(i) == max) {\n                result += arr(maxIndex)\n            }\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7xir8d8v.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7xir8d8v.scala:25:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793696
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = arr.take(k).toList\n        val rest = arr.drop(k)\n        val restSorted = maximum(rest, k)\n        restSorted.zip(max).map(x => x._1 :: x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6z42jjg4.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6z42jjg4.scala:24:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        restSorted.zip(max).map(\u001b[36mx\u001b[0m => x._1 :: x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value :: is not a member of Nothing\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793696
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.size\n        val max = new mutable.PriorityQueue[Long]()\n        val maxSize = new mutable.PriorityQueue[Long]()\n        val maxIndex = new mutable.PriorityQueue[Long]()\n        val maxIndexSize = new mutable.PriorityQueue[Long]()\n        val maxIndexSize2 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize3 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize4 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize5 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize6 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize7 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize8 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize9 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize10 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize11 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize12 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize13 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize14 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize15 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize16 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize17 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize18 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize19 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize20 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize21 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize22 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize23 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize24 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize25 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize26 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize27 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize28 = new mutable.PriorityQueue[Long]()\n        val maxIndexSize29 = new mutable.Priority\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0ek7qex1.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ek7qex1.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ek7qex1.scala:23:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxSize\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ek7qex1.scala:24:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ek7qex1.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexSize\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0ek7",
      "stdout": "",
      "timestamp": 1659793697
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexSet = new HashSet[Int]()\n        val maxIndexSetSet = new HashSet[Int]()\n        var i = 0\n        while (i < k) {\n            if (maxIndexSet.contains(i)) {\n                maxIndexSetSet.add(maxIndex(i))\n            } else {\n                maxIndexSetSet.add(i)\n            }\n            if (maxIndexSetSet.size == k) {\n                maxIndexSetSet.remove(0)\n            }\n            val maxIndex = maxIndexSetSet.iterator\n            if (maxIndex.hasNext) {\n                max(i) = arr(maxIndex.next())\n                maxIndexSetSet.remove(maxIndex.next())\n                maxIndexSetSet.add(maxIndex.next())\n                i += 1\n            } else {\n                max(i) = arr(len)\n                maxIndexSetSet.add(len)\n                i += 1\n            }\n        }\n        val maxList = List(max: _*)\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp80i9fc98.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp80i9fc98.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp80i9fc98.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp80i9fc98.scala:29:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                maxIndexSetSet.add(maxIndex(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793697
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = new Array[Long](k)\n        var i = 0\n        while(i < k) {\n            val cur = arr(i)\n            val j = i\n            while(j < k) {\n                if(arr(j) < cur) {\n                    val tmp = arr(j)\n                    arr(j) = cur\n                    cur = tmp\n                }\n                j+=1\n            }\n            max(i) = cur\n            i+=1\n        }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpaqthtw74.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaqthtw74.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpaqthtw74.scala:30:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    cur = tmp\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Reassignment to val cur\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaqthtw74.scala:32:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                j+=\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean j.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793698
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.size\n        val m = math.min(k, n)\n        val maxList = arr.take(m).sortWith(_ > _)\n        val maxListSize = maxList.size\n        val maxListIndex = maxListSize - 1\n        val maxListTail = maxList.drop(maxListIndex).reverse\n        val maxListTailSize = maxListTail.size\n        val maxListTailIndex = maxListTailSize - 1\n        val maxListTailTail = maxListTail.drop(maxListTailIndex).reverse\n        val maxListTailTailSize = maxListTailTail.size\n        val maxListTailTailIndex = maxListTailTailSize - 1\n        val maxListTailTailTail = maxListTailTail.drop(maxListTailTailIndex).reverse\n        val maxListTailTailTailSize = maxListTailTailTail.size\n        val maxListTailTailTailIndex = maxListTailTailTailSize - 1\n        val maxListTailTailTailTail = maxListTailTailTail.drop(maxListTailTailTailIndex).reverse\n        val maxListTailTailTailTailSize = maxListTailTailTailTail.size\n        val maxListTailTailTailTailIndex = maxListTailTailTailTailSize - 1\n        val maxListTailTailTailTailTail = maxListTailTailTailTailTail.drop(maxListTailTailTailTailTailIndex).reverse\n        val maxListTailTailTailTailTailSize = maxListTailTailTailTailTailTail.size\n        val maxListTailTailTailTailTailIndex = maxListTailTailTailTailTailSize - 1\n        val maxListTailTailTailTailTailTail = maxListTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailIndex).reverse\n        val maxListTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTail.size\n        val maxListTailTailTailTailTailTailIndex = maxListTailTailTailTailTailTailTailSize - 1\n        val maxListTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailTailIndex).reverse\n        val maxListTailTailTailTailTailTailTailSize = maxListTailTailTailTailTailTailTailTail.size\n        val maxListTailTailTailTailTailTailTailIndex = maxListTailTailTailTailTailTailTailTailSize - 1\n        val maxListTailTailTailTailTailTailTailTail = maxListTailTailTailTailTailTailTailTail.drop(max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptx53sez7.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptx53sez7.scala:22:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = arr.take(m).sortWith(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (m : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptx53sez7.scala:37:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListTailTailTailTailTail\u001b[0m = maxListTailTailTailTailTail.drop(maxListTailTailTailTailTailIndex).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35mmaxListTailTailTailTailTail\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptx53sez7.scala:40:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListTailTailTailTailTailTail\u001b[0m = maxListTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailIndex).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m              Recursive \u001b[33mvalue\u001b[0m \u001b[35mmaxListTailTailTailTailTailTail\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmptx53sez7.scala:43:50 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListTailTailTailTailTailTailTail\u001b[0m = maxListTailTailTailTailTailTailTail.drop(maxListTailTailTailTailTailTailTailIndex).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m          Recursive \u001b[33mva",
      "stdout": "",
      "timestamp": 1659793699
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val m = arr.take(k).max\n        val max = arr.take(k)\n        val maxList = arr.take(k).sortWith(_ > _).take(k)\n        val maxList2 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList3 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList4 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList5 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList6 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList7 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList8 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList9 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList10 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList11 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList12 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList13 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList14 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList15 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList16 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList17 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList18 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList19 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList20 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList21 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList22 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList23 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList24 = arr.take(k).sortWith(_ > _).take(k)\n        val maxList25 = arr.take(k).sortWith(_ > _\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj631ies_.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpj631ies_.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj631ies_.scala:49:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793698
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new mutable.PriorityQueue[(Long, Long)](len * 2 - 1)\n        for (i <- 0 until len) {\n            val curr = arr(i)\n            if (curr <= 0) continue\n            if (curr <= max.head._1) {\n                max.dequeue()\n                max.enqueue((curr, i))\n            } else if (curr <= max.head._2) {\n                max.enqueue((curr, i))\n            }\n        }\n        val res = new mutable.PriorityQueue[(Long, Long)](k)\n        for (i <- 0 until k) {\n            val curr = max.dequeue()\n            res.enqueue(curr)\n        }\n        res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp40023z_i.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp40023z_i.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)](len * \u001b[31m2\u001b[0m - \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp40023z_i.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mif\u001b[0m (curr <= \u001b[31m0\u001b[0m) continue\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: continue\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp40023z_i.scala:33:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)](k)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp40023z_i.scala:34:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793698
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        var maxValue = arr(0)\n        while (i < len) {\n            while (j < k) {\n                if (arr(i) > arr(j)) {\n                    maxValue = arr(i)\n                    maxIndex = j\n                }\n                j += 1\n            }\n            i += 1\n            max(i) = maxValue\n            j += 1\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplj7gi0u0.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplj7gi0u0.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793698
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = k\n        val max = new Array[Long](m)\n        val maxIndex = new Array[Int](m)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpiys_05k5.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiys_05k5.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpiys_05k5.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](m)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiys_05k5.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiys_05k5.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiys",
      "stdout": "",
      "timestamp": 1659793699
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val m = k\n        val max = new Array[Long](m)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        var maxVal = 0\n        while (i < n) {\n            if (j == m) {\n                maxIndex = i\n                maxVal = arr(i)\n                j = 0\n            }\n            if (arr(i) > maxVal) {\n                maxIndex = i\n                maxVal = arr(i)\n            }\n            i += 1\n            j += 1\n        }\n        val result = new Array[Long](k)\n        for (i <- 0 until k) {\n            result(i) = arr(maxIndex)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpfufzvn63.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfufzvn63.scala:23:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (m : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfufzvn63.scala:41:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfufzvn63.scala:42:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfufzvn63.scala:45:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available ",
      "stdout": "",
      "timestamp": 1659793700
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new Array[Long](k)\n        var max = 0\n        var index = 0\n        for(i <- 0 until arr.length) {\n            if(arr(i) > max) {\n                max = arr(i)\n                index = i\n            }\n        }\n        for(i <- 0 until k) {\n            result(i) = arr(index)\n            index++\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmprra9tv3u.scala:31:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            index++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprra9tv3u.scala:20:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprra9tv3u.scala:25:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprra9tv3u.scala:29:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprra9tv3u.scala:33:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793700
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length < k) {\n            val diff = len - k\n            val rem = len - diff\n            val arr = new Array[Long](rem)\n            for (i <- 0 until diff) {\n                arr(i) = arr(i + 1)\n            }\n            arr(diff) = arr(diff + 1)\n        }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmppv2f9slj.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppv2f9slj.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793700
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexSet = new mutable.HashSet[Int]()\n        val maxIndexSetSet = new mutable.HashSet[Int]()\n        var i = 0\n        while (i < k) {\n            if (maxIndexSet.contains(i)) {\n                maxIndexSetSet.remove(i)\n                maxIndexSetSet.add(i, 1)\n            } else {\n                maxIndexSetSet.add(i, 1)\n            }\n            val maxIndex = maxIndexSet.max\n            val maxValue = arr(maxIndex)\n            if (maxValue > max(i)) {\n                max(i) = maxValue\n                maxIndexSetSet(maxIndex) = maxIndexSetSet.get(maxIndex) + 1\n            }\n            i += 1\n        }\n        arr.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8sp8g7ur.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8sp8g7ur.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8sp8g7ur.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8sp8g7ur.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexSet\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8sp8g7ur.scala:25:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexSetSet\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              ",
      "stdout": "",
      "timestamp": 1659793700
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = arr(0)\n        for(i <- 0 until len) {\n            if(arr(i) > maxValue) {\n                maxValue = arr(i)\n                maxIndex = i\n            }\n        }\n        val maxList = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList2 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList3 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList4 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList5 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList6 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList7 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList8 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList9 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList10 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList11 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList12 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList13 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList14 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList15 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList16 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList17 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList18 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList19 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList20 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList21 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList22 = arr.take(maxIndex+1).sortBy(x => x)\n        val maxList23 = arr.take(maxIndex+1).sortBy(x => -x)\n        val maxList24 = arr.take(maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpzz74lekp.scala:55:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpzz74lekp.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzz74lekp.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzz74lekp.scala:55:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793701
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxVal = arr(0)\n        var i = 0\n        while (i < len) {\n            if (arr(i) > maxVal) {\n                maxIndex = i\n                maxVal = arr(i)\n            }\n            i += 1\n        }\n        val result = new Array[Long](k)\n        var j = 0\n        while (j < k) {\n            result(j) = arr(maxIndex + j)\n            j += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpje48fgp2.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpje48fgp2.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpje48fgp2.scala:33:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpje48fgp2.scala:39:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793701
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        var maxLength = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > arr(maxLength)) {\n                maxLength += 1\n                maxList += arr(i)\n            }\n        }\n        if (maxLength < k) {\n            val newList = maxList.take(k - maxLength)\n            val newLength = k - maxLength\n            val newMaxLength = maxLength\n            val newMaxList = maxList\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxLength = newMaxLength\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val newMaxList = newMaxList.take(newLength)\n            val new\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpdkzi8qbh.scala:65:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m65 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[33mnew\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpdkzi8qbh.scala:82:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m82 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdkzi8qbh.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkzi8qbh.scala:33:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewMaxList\u001b[0m = newMaxList.take(newLength)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewMaxList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnewMaxList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkzi8qbh.scala:34:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewMaxLength\u001b[0m = newMaxLength\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnewMaxLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnewMaxLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpdkzi8qbh.scala:35:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewMaxList\u001b[0m = newMaxList.take(newLength)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659793701
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new mutable.PriorityQueue[Long]()\n        val maxIndex = new mutable.PriorityQueue[Int]()\n        val maxIndexLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val maxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen = new mutable.PriorityQueue[Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3jsh83b8.scala:44:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3jsh83b8.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3jsh83b8.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLenLenLenLenLenLenLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3jsh83b8.scala:41:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLenLenLenLenLenLenLenLenLenLenLenLenL",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length == k) {\n            arr\n        } else {\n            arr ++ max.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3u0ufz7b.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3u0ufz7b.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793700
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = arr.max\n        val maxIndex = arr.indexWhere(x => x == max)\n        val maxIndex1 = maxIndex - 1\n        val maxIndex2 = maxIndex + 1\n        val maxIndex3 = maxIndex + 2\n        val maxIndex4 = maxIndex + 3\n        val maxIndex5 = maxIndex + 4\n        val maxIndex6 = maxIndex + 5\n        val maxIndex7 = maxIndex + 6\n        val maxIndex8 = maxIndex + 7\n        val maxIndex9 = maxIndex + 8\n        val maxIndex10 = maxIndex + 9\n        val maxIndex11 = maxIndex + 10\n        val maxIndex12 = maxIndex + 11\n        val maxIndex13 = maxIndex + 12\n        val maxIndex14 = maxIndex + 13\n        val maxIndex15 = maxIndex + 14\n        val maxIndex16 = maxIndex + 15\n        val maxIndex17 = maxIndex + 16\n        val maxIndex18 = maxIndex + 17\n        val maxIndex19 = maxIndex + 18\n        val maxIndex20 = maxIndex + 19\n        val maxIndex21 = maxIndex + 20\n        val maxIndex22 = maxIndex + 21\n        val maxIndex23 = maxIndex + 22\n        val maxIndex24 = maxIndex + 23\n        val maxIndex25 = maxIndex + 24\n        val maxIndex26 = maxIndex + 25\n        val maxIndex27 = maxIndex + 26\n        val maxIndex28 = maxIndex + 27\n        val maxIndex29 = maxIndex + 28\n        val maxIndex30 = maxIndex + 29\n        val maxIndex31 = maxIndex + 30\n        val maxIndex32 = maxIndex + 31\n        val maxIndex33 = maxIndex + 32\n        val maxIndex34 = maxIndex + 33\n        val maxIndex35 = maxIndex + 34\n        val maxIndex36 = maxIndex + 35\n        val maxIndex37 = maxIndex + 36\n        val maxIndex38 = maxIndex + 37\n        val maxIndex39 = maxIndex + 38\n        val maxIndex40 = maxIndex + 39\n        val maxIndex41 = maxIndex + 40\n        val maxIndex42 = maxIndex + 41\n        val maxIndex43 = maxIndex + 42\n        val maxIndex44 = maxIndex + 43\n        val maxIndex45 = maxIndex + 44\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp82h0etow.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp82h0etow.scala:69:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793701
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val maxList = arr.take(k)\n        val maxListLength = maxList.length\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val maxListLength = maxListLength + 1 // +1 because we add 1 at the end\n        val max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpo1ruy3ib.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1ruy3ib.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength + \u001b[31m1\u001b[0m \u001b[34m// +1 because we add 1 at the end\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1ruy3ib.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength + \u001b[31m1\u001b[0m \u001b[34m// +1 because we add 1 at the end\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1ruy3ib.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength + \u001b[31m1\u001b[0m \u001b[34m// +1 because we add 1 at the end\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpo1ruy3ib.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxListLength\u001b[0m = maxListLength + \u001b[31m1\u001b[0m \u001b[34m// +1 because we add 1 at the end\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxListLength is already defined as \u001b[33mvalu",
      "stdout": "",
      "timestamp": 1659793701
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuoj84dpg.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuoj84dpg.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        var max = 0\n        var i = 0\n        while (i < arr.length) {\n            if (arr(i) > max) {\n                max = arr(i)\n            }\n            i += 1\n        }\n        val maxIndex = arr.length - 1\n        var j = 0\n        while (j < k) {\n            if (arr(maxIndex - j) > max) {\n                max = arr(maxIndex - j)\n            }\n            j += 1\n        }\n        val maxIndex = arr.length - k\n        var k = 0\n        while (k <= maxIndex) {\n            if (arr(k) > max) {\n                max = arr(k)\n            }\n            k += 1\n        }\n        result.clear()\n        result.add(max)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpkcb3j8g6.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = arr.length - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkcb3j8g6.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkcb3j8g6.scala:25:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkcb3j8g6.scala:33:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m                max = arr(maxIndex - j)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkcb3j8g6.scala:41:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m                max = arr(k)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793701
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuoj84dpg.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuoj84dpg.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxLength = arr.length\n        val maxK = k\n        val maxIndex = arr.indexWhere(x => x >= 0)\n        val maxValue = arr(maxIndex)\n        val maxKValue = arr.take(maxK).max\n        val maxKIndex = arr.indexWhere(x => x == maxKValue)\n        val maxKValue = arr(maxKIndex)\n        val maxKKValue = arr.take(maxK - 1).max\n        val maxKKIndex = arr.indexWhere(x => x == maxKKValue)\n        val maxKKValue = arr(maxKKIndex)\n        val maxKKKValue = arr.take(maxK - 2).max\n        val maxKKKIndex = arr.indexWhere(x => x == maxKKKValue)\n        val maxKKKValue = arr(maxKKKIndex)\n        val maxKKKKValue = arr.take(maxK - 3).max\n        val maxKKKKIndex = arr.indexWhere(x => x == maxKKKKValue)\n        val maxKKKKValue = arr(maxKKKKIndex)\n        val maxKKKKKValue = arr.take(maxK - 4).max\n        val maxKKKKKIndex = arr.indexWhere(x => x == maxKKKKKValue)\n        val maxKKKKKValue = arr(maxKKKKKIndex)\n        val maxKKKKKKValue = arr.take(maxK - 5).max\n        val maxKKKKKKIndex = arr.indexWhere(x => x == maxKKKKKKValue)\n        val maxKKKKKKValue = arr(maxKKKKKKIndex)\n        val maxKKKKKKKValue = arr.take(maxK - 6).max\n        val maxKKKKKKKIndex = arr.indexWhere(x => x == maxKKKKKKKValue)\n        val maxKKKKKKKValue = arr(maxKKKKKKKIndex)\n        val maxKKKKKKKKValue = arr.take(maxK - 7).max\n        val maxKKKKKKKKIndex = arr.indexWhere(x => x == maxKKKKKKKKValue)\n        val maxKKKKKKKKValue = arr(maxKK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp17vy7lwx.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp17vy7lwx.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValue\u001b[0m = arr(maxKIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp17vy7lwx.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKValue\u001b[0m = arr(maxKKIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKKValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKKValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp17vy7lwx.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKValue\u001b[0m = arr(maxKKKIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKKKValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKKKValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp17vy7lwx.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKKKKValue\u001b[0m = arr(maxKKKKIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKKKKValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKKKKValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp17vy7lwx.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m ",
      "stdout": "",
      "timestamp": 1659793702
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            val max = arr(i)\n            val index = arr.indexOf(max)\n            arr.remove(max)\n            arr.remove(index)\n            i += 1\n        }\n        arr.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmdgrc9n2.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmdgrc9n2.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793701
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val max = new mutable.PriorityQueue[Long]()\n        val min = new mutable.PriorityQueue[Long]()\n        val size = arr.size\n        val max = arr.max\n        val min = arr.min\n        val mid = arr.size / 2\n        val mid2 = mid / 2\n        val mid3 = mid / 3\n        val mid4 = mid / 4\n        val mid5 = mid / 5\n        val mid6 = mid / 6\n        val mid7 = mid / 7\n        val mid8 = mid / 8\n        val mid9 = mid / 9\n        val mid10 = mid / 10\n        val mid11 = mid / 11\n        val mid12 = mid / 12\n        val mid13 = mid / 13\n        val mid14 = mid / 14\n        val mid15 = mid / 15\n        val mid16 = mid / 16\n        val mid17 = mid / 17\n        val mid18 = mid / 18\n        val mid19 = mid / 19\n        val mid20 = mid / 20\n        val mid21 = mid / 21\n        val mid22 = mid / 22\n        val mid23 = mid / 23\n        val mid24 = mid / 24\n        val mid25 = mid / 25\n        val mid26 = mid / 26\n        val mid27 = mid / 27\n        val mid28 = mid / 28\n        val mid29 = mid / 29\n        val mid30 = mid / 30\n        val mid31 = mid / 31\n        val mid32 = mid / 32\n        val mid33 = mid / 33\n        val mid34 = mid / 34\n        val mid35 = mid / 35\n        val mid36 = mid / 36\n        val mid37 = mid / 37\n        val mid38 = mid / 38\n        val mid39 = mid / 39\n        val mid40 = mid / 40\n        val mid41 = mid / 41\n        val mid42 = mid / 42\n        val mid43 = mid / 43\n        val mid44 = mid / 44\n        val mid45 = mid / 45\n        val mid46 = mid / 46\n        val mid47 = mid / 47\n        val mid48 = mid / 48\n        val mid49 = mid / 49\n        val mid50 = mid / 50\n\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6g_crhw0.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = arr.max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6g_crhw0.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin\u001b[0m = arr.min\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmin is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmin\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6g_crhw0.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6g_crhw0.scala:21:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6g_crhw0.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g_crhw0.scala:77:5 -------------",
      "stdout": "",
      "timestamp": 1659793703
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNum = arr.max\n        val maxNumIndex = arr.indexWhere(x => x == maxNum)\n        val maxNumList = arr.take(maxNumIndex + 1)\n        val maxNumListIndex = arr.indexWhere(x => x == maxNumList)\n        val maxNumListLength = maxNumListIndex - maxNumIndex\n        val maxNumListLength = maxNumListLength / k\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumListLength = maxNumListLength.toLong\n        val maxNumListLength = maxNumListLength.asInstanceOf[Long]\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumListLength = maxNumListLength.toLong\n        val maxNumListLength = maxNumListLength.asInstanceOf[Long]\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumListLength = maxNumListLength.toLong\n        val maxNumListLength = maxNumListLength.asInstanceOf[Long]\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumListLength = maxNumListLength.toLong\n        val maxNumListLength = maxNumListLength.asInstanceOf[Long]\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumListLength = maxNumListLength.toLong\n        val maxNumListLength = maxNumListLength.asInstanceOf[Long]\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumListLength = maxNumListLength.toLong\n        val maxNumListLength = maxNumListLength.asInstanceOf[Long]\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumListLength = maxNumListLength.toLong\n        val maxNumListLength = maxNumListLength.asInstanceOf[Long]\n        val maxNumListLength = maxNumListLength.toInt\n        val maxNumListLength = maxNumListLength * k\n        val maxNumList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplv_rknyq.scala:57:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplv_rknyq.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength / k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplv_rknyq.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplv_rknyq.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength * k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplv_rknyq.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumListLength\u001b[0m = maxNumListLength.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of ",
      "stdout": "",
      "timestamp": 1659793703
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = arr(0)\n        var i = 0\n        while (i < len) {\n            if (arr(i) > maxValue) {\n                maxValue = arr(i)\n                maxIndex = i\n            }\n            i += 1\n        }\n        val newArr = new Array[Long](k)\n        newArr(0) = maxValue\n        var j = 1\n        while (j < k) {\n            if (maxIndex == j) newArr(j) = arr(maxIndex)\n            else newArr(j) = arr(maxIndex)\n            j += 1\n        }\n        newArr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpao9tcxjz.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpao9tcxjz.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpao9tcxjz.scala:33:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnewArr\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpao9tcxjz.scala:41:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m        newArr\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (newArr : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793704
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = arr.max\n        val result = new Array[Long](k)\n        var i = 0\n        var j = 0\n        while (i < k) {\n            if (arr(i) > m) {\n                result(j) = arr(i)\n                j += 1\n            } else {\n                i += 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2dxkdnkx.scala:22:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2dxkdnkx.scala:33:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793704
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new mutable.PriorityQueue[Long]()\n        val maxIndex = new mutable.PriorityQueue[Int]()\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0zbojqw7.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0zbojqw7.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0zbojqw7.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0zbojqw7.scala:23:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0zbojqw7.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0zbojqw7.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ",
      "stdout": "",
      "timestamp": 1659793705
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxVal = arr(0)\n        var i = 0\n        while (i < len) {\n            if (arr(i) > maxVal) {\n                maxIndex = i\n                maxVal = arr(i)\n            }\n            i += 1\n        }\n        val newArr = new Array[Long](maxIndex + 1)\n        var j = 0\n        while (j < maxIndex) {\n            newArr(j) = arr(j)\n            j += 1\n        }\n        newArr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnfga55f1.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnfga55f1.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnfga55f1.scala:39:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        newArr\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (newArr : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793705
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNums = arr.sortWith( (a,b) => a > b )\n        val maxNumsLen = maxNums.length\n        val maxNumsCopy = maxNums.toList\n        val maxNumsCopyLen = maxNumsCopy.length\n        val maxNumsCopyCopy = maxNumsCopy.toList\n        val maxNumsCopyCopyLen = maxNumsCopyCopy.length\n        val maxNumsCopyCopyCopy = maxNumsCopyCopy.toList\n        val maxNumsCopyCopyCopyLen = maxNumsCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopy = maxNumsCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyLen = maxNumsCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopy = maxNumsCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyCopyLen = maxNumsCopyCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopyCopy = maxNumsCopyCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyCopyCopyLen = maxNumsCopyCopyCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopyCopy = maxNumsCopyCopyCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyCopyCopyLen = maxNumsCopyCopyCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopyCopyCopy = maxNumsCopyCopyCopyCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyCopyCopyCopyLen = maxNumsCopyCopyCopyCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopyCopyCopyCopy = maxNumsCopyCopyCopyCopyCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyCopyCopyCopyCopyLen = maxNumsCopyCopyCopyCopyCopyCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopyCopyCopyCopy = maxNumsCopyCopyCopyCopyCopyCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyCopyCopyCopyCopyLen = maxNumsCopyCopyCopyCopyCopyCopyCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopyCopyCopyCopyCopy = maxNumsCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.toList\n        val maxNumsCopyCopyCopyCopyCopyCopyCopyCopyLen = maxNumsCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy.length\n        val maxNumsCopyCopyCopyCopyCopyCopy\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuuwa5itd.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuuwa5itd.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsCopyCopyCopyLen\u001b[0m = maxNumsCopyCopyCopy.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsCopyCopyCopyLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsCopyCopyCopyLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuuwa5itd.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsCopyCopyCopyCopy\u001b[0m = maxNumsCopyCopyCopy.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsCopyCopyCopyCopy is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsCopyCopyCopyCopy\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuuwa5itd.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsCopyCopyCopyCopyCopy\u001b[0m = maxNumsCopyCopyCopyCopyCopy.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsCopyCopyCopyCopyCopy is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsCopyCopyCopyCopyCopy\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuuwa5itd.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsCopyCopyCopyCopyCopyLen\u001b[0m = maxNumsCopyCopyCopyCopyCopy.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b",
      "stdout": "",
      "timestamp": 1659793704
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new Array[Long](k)\n        val max = new Array[Long](k)\n        val min = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        var minIndex = 0\n        var maxValue = arr(0)\n        var minValue = arr(0)\n        for(i <- 0 until k) {\n            maxValue = arr(i)\n            minValue = arr(i)\n            for(j <- 0 until k) {\n                if(arr(j) > maxValue) {\n                    maxValue = arr(j)\n                    maxIndex = j\n                }\n                if(arr(j) < minValue) {\n                    minValue = arr(j)\n                    minIndex = j\n                }\n            }\n            result(i) = maxValue\n            max(i) = maxIndex\n            min(i) = minIndex\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp561vjaq0.scala:20:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp561vjaq0.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp561vjaq0.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp561vjaq0.scala:29:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp561vjaq0.scala:32:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mfor\u001b[0m(j <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31",
      "stdout": "",
      "timestamp": 1659793705
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxK = mutable.ListBuffer.empty[Long]\n        val maxKIndex = mutable.ListBuffer.empty[Long]\n        val maxKValue = mutable.ListBuffer.empty[Long]\n        val maxKValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueValue = mutable.ListBuffer.empty[Long]\n        val maxKValueValueValueIndex = mutable.ListBuffer.empty[Long]\n        val maxK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_qh93c5e.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_qh93c5e.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueValueValueIndex\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValueValueValueIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValueValueValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_qh93c5e.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueValueValueValue\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValueValueValueValue is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValueValueValueValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_qh93c5e.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueValueValueIndex\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKValueValueValueIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKValueValueValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_qh93c5e.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKValueValueValueValue\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659793705
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val maxList = arr.take(k)\n        val maxListLen = maxList.length\n        val maxListLenMinusOne = maxListLen - 1\n        val maxListLenMinusTwo = maxListLen - 2\n        val maxListLenMinusThree = maxListLen - 3\n        val maxListLenMinusFour = maxListLen - 4\n        val maxListLenMinusFive = maxListLen - 5\n        val maxListLenMinusSix = maxListLen - 6\n        val maxListLenMinusSeven = maxListLen - 7\n        val maxListLenMinusEight = maxListLen - 8\n        val maxListLenMinusNine = maxListLen - 9\n        val maxListLenMinusTen = maxListLen - 10\n        val maxListLenMinusEleven = maxListLen - 11\n        val maxListLenMinusTwelve = maxListLen - 12\n        val maxListLenMinusThirteen = maxListLen - 13\n        val maxListLenMinusFourteen = maxListLen - 14\n        val maxListLenMinusFifteen = maxListLen - 15\n        val maxListLenMinusSixteen = maxListLen - 16\n        val maxListLenMinusSeventeen = maxListLen - 17\n        val maxListLenMinusEighteen = maxListLen - 18\n        val maxListLenMinusNineteen = maxListLen - 19\n        val maxListLenMinusTwenty = maxListLen - 20\n        val maxListLenMinusThirty = maxListLen - 30\n        val maxListLenMinusFourty = maxListLen - 40\n        val maxListLenMinusFifty = maxListLen - 50\n        val maxListLenMinusSixty = maxListLen - 60\n        val maxListLenMinusSeventy = maxListLen - 70\n        val maxListLenMinusEighty = maxListLen - 80\n        val maxListLenMinusNinety = maxListLen - 90\n        val maxListLenMinusTwentyOne = maxListLen - 100\n        val maxListLenMinusTwentyTwo = maxListLen - 200\n        val maxListLenMinusTwentyThree\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp6oj2ui6j.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6oj2ui6j.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6oj2ui6j.scala:53:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793705
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val maxList = arr.take(k)\n        val maxList2 = arr.drop(k)\n        val maxList3 = arr.takeRight(k)\n        val maxList4 = arr.dropRight(k)\n        val maxList5 = arr.take(k)\n        val maxList6 = arr.drop(k)\n        val maxList7 = arr.takeRight(k)\n        val maxList8 = arr.dropRight(k)\n        val maxList9 = arr.take(k)\n        val maxList10 = arr.drop(k)\n        val maxList11 = arr.takeRight(k)\n        val maxList12 = arr.dropRight(k)\n        val maxList13 = arr.take(k)\n        val maxList14 = arr.drop(k)\n        val maxList15 = arr.takeRight(k)\n        val maxList16 = arr.dropRight(k)\n        val maxList17 = arr.take(k)\n        val maxList18 = arr.drop(k)\n        val maxList19 = arr.takeRight(k)\n        val maxList20 = arr.dropRight(k)\n        val maxList21 = arr.take(k)\n        val maxList22 = arr.drop(k)\n        val maxList23 = arr.takeRight(k)\n        val maxList24 = arr.dropRight(k)\n        val maxList25 = arr.take(k)\n        val maxList26 = arr.drop(k)\n        val maxList27 = arr.takeRight(k)\n        val maxList28 = arr.dropRight(k)\n        val maxList29 = arr.take(k)\n        val maxList30 = arr.drop(k)\n        val maxList31 = arr.takeRight(k)\n        val maxList32 = arr.dropRight(k)\n        val maxList33 = arr.take(k)\n        val maxList34 = arr.drop(k)\n        val maxList35 = arr.takeRight(k)\n        val maxList36 = arr.dropRight(k)\n        val maxList37 = arr.take(k)\n        val maxList38 = arr.drop(k)\n        val maxList39 = arr.takeRight(k)\n        val maxList40 = arr.dropRight(k)\n        val maxList41 = arr.take(k)\n        val maxList42 = arr.drop(k)\n        val maxList43 = arr.takeRight(k)\n        val maxList44 = arr.dropRight(k)\n        val maxList45 = arr.take\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmhyx8avt.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmhyx8avt.scala:66:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m66 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpifuflnoi.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpifuflnoi.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793706
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = arr.take(k).toList\n        val rest = arr.drop(k)\n        rest match {\n            case Nil => max\n            case x :: xs => maximum(x :: xs, k)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpd4nradar.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd4nradar.scala:25:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mcase\u001b[0m x :: xs => maximum(x :: xs, k)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Not found: xs\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793705
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1dop7prz.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1dop7prz.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793706
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuoj84dpg.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuoj84dpg.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            val max = arr(i)\n            val index = arr.indexWhere(x => x > max)\n            if (index == -1) {\n                i += 1\n            } else {\n                max(i) = arr(index)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp44hj06mi.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp44hj06mi.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793707
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val max = new mutable.PriorityQueue[Long]()\n        val maxLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLengthLengthLength = new mutable.PriorityQueue[Long]()\n        val maxLengthLengthLength\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj0a599_u.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj0a599_u.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLengthLengthLengthLength\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxLengthLengthLengthLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxLengthLengthLengthLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj0a599_u.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLengthLengthLengthLengthLength\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxLengthLengthLengthLengthLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxLengthLengthLengthLengthLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj0a599_u.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLengthLengthLengthLengthLength\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxLengthLengthLengthLengthLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxLengthLengthLengthLengthLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj0a599_u.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxLen",
      "stdout": "",
      "timestamp": 1659793707
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val max = arr.sortWith(_ > _)\n        val maxLength = arr.length\n        val maxK = math.min(k, maxLength)\n        val maxList = max.take(maxK).toList\n        val maxListLength = maxList.length\n        val maxKList = maxList.take(maxListLength).toList\n        val maxKListLength = maxKList.length\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxKListLength - k\n        val maxKList = maxKList.take(maxKListLength).toList\n        val maxKListLength = maxK\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn0cjsdiz.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListLength\u001b[0m = maxKListLength - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn0cjsdiz.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKList\u001b[0m = maxKList.take(maxKListLength).toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn0cjsdiz.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListLength\u001b[0m = maxKListLength - k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn0cjsdiz.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKList\u001b[0m = maxKList.take(maxKListLength).toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpn0cjsdiz.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListLength\u001b[0m = maxKListLength - k\n\u001b[31m\u001b[31m   |\u001b[0m        ",
      "stdout": "",
      "timestamp": 1659793707
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        var maxIndex = 0\n        var maxValue = arr(0)\n        var i = 0\n        while (i < arr.length) {\n            if (arr(i) > maxValue) {\n                maxValue = arr(i)\n                maxIndex = i\n            }\n            i += 1\n        }\n        maxList += maxValue\n        var j = 0\n        while (j < k) {\n            if (maxIndex < arr.length) {\n                maxList += arr(maxIndex)\n                maxIndex += 1\n            }\n            j += 1\n        }\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8peerkiy.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793706
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        var maxIndex = 0\n        var maxIndex2 = 0\n        var maxIndex3 = 0\n        var maxIndex4 = 0\n        var maxIndex5 = 0\n        var maxIndex6 = 0\n        var maxIndex7 = 0\n        var maxIndex8 = 0\n        var maxIndex9 = 0\n        var maxIndex10 = 0\n        var maxIndex11 = 0\n        var maxIndex12 = 0\n        var maxIndex13 = 0\n        var maxIndex14 = 0\n        var maxIndex15 = 0\n        var maxIndex16 = 0\n        var maxIndex17 = 0\n        var maxIndex18 = 0\n        var maxIndex19 = 0\n        var maxIndex20 = 0\n        var maxIndex21 = 0\n        var maxIndex22 = 0\n        var maxIndex23 = 0\n        var maxIndex24 = 0\n        var maxIndex25 = 0\n        var maxIndex26 = 0\n        var maxIndex27 = 0\n        var maxIndex28 = 0\n        var maxIndex29 = 0\n        var maxIndex30 = 0\n        var maxIndex31 = 0\n        var maxIndex32 = 0\n        var maxIndex33 = 0\n        var maxIndex34 = 0\n        var maxIndex35 = 0\n        var maxIndex36 = 0\n        var maxIndex37 = 0\n        var maxIndex38 = 0\n        var maxIndex39 = 0\n        var maxIndex40 = 0\n        var maxIndex41 = 0\n        var maxIndex42 = 0\n        var maxIndex43 = 0\n        var maxIndex44 = 0\n        var maxIndex45 = 0\n        var maxIndex46 = 0\n        var maxIndex47 = 0\n        var maxIndex48 = 0\n        var maxIndex49 = 0\n        var maxIndex50 = 0\n        var maxIndex51 = 0\n        var maxIndex52 = 0\n        var maxIndex53 = 0\n        var maxIndex54 = 0\n        var maxIndex55 = 0\n        var maxIndex56 = 0\n        var maxIndex57 = 0\n        var maxIndex58 = 0\n        var maxIndex59 = 0\n        var maxIndex60 = 0\n        var maxIndex61 = 0\n        var maxIndex62 = 0\n        var maxIndex63 = 0\n        var maxIndex64 = 0\n        var maxIndex65 = 0\n        var maxIndex66 = 0\n        var maxIndex67 = 0\n        var maxIndex68 = 0\n        var maxIndex69 = 0\n        var maxIndex70 = 0\n        var maxIndex71 = 0\n        var maxIndex72 = 0\n        var maxIndex73 = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_xa9nchd.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_xa9nchd.scala:23:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_xa9nchd.scala:24:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_xa9nchd.scala:103:5 --------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m     ^\u001b[0m\n\u001b[31m    |\u001b[0m     Found:    Unit\n\u001b[31m    |\u001b[0m     Required: List[Long]\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793707
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length < k) {\n            val newArr = new Array[Long](k)\n            i = 0\n            while (i < k) {\n                newArr(i) = arr(i)\n                i += 1\n            }\n            max = newArr\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpidea8b07.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpidea8b07.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpidea8b07.scala:34:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewArr\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpidea8b07.scala:40:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            max = newArr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793707
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.size\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap29 = new mutable.\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp31b9w08c.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp31b9w08c.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp31b9w08c.scala:22:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp31b9w08c.scala:23:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp31b9w08c.scala:24:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /",
      "stdout": "",
      "timestamp": 1659793708
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.size\n        val m = math.min(k, n)\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        var max = 0\n        var i = 0\n        while (i < m) {\n            max = arr(i)\n            if (max > maxList(0)) {\n                maxList += max\n            }\n            i += 1\n        }\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyd7hf5u9.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyd7hf5u9.scala:26:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793707
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.size\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new HashMap[Long, Int]()\n        val maxIndexMap2 = new HashMap[Int, Int]()\n        var i = 0\n        var j = 0\n        var k = 0\n        var maxIndex = 0\n        var maxIndex2 = 0\n        var maxIndex3 = 0\n        var maxIndex4 = 0\n        var maxIndex5 = 0\n        var maxIndex6 = 0\n        var maxIndex7 = 0\n        var maxIndex8 = 0\n        var maxIndex9 = 0\n        var maxIndex10 = 0\n        var maxIndex11 = 0\n        var maxIndex12 = 0\n        var maxIndex13 = 0\n        var maxIndex14 = 0\n        var maxIndex15 = 0\n        var maxIndex16 = 0\n        var maxIndex17 = 0\n        var maxIndex18 = 0\n        var maxIndex19 = 0\n        var maxIndex20 = 0\n        var maxIndex21 = 0\n        var maxIndex22 = 0\n        var maxIndex23 = 0\n        var maxIndex24 = 0\n        var maxIndex25 = 0\n        var maxIndex26 = 0\n        var maxIndex27 = 0\n        var maxIndex28 = 0\n        var maxIndex29 = 0\n        var maxIndex30 = 0\n        var maxIndex31 = 0\n        var maxIndex32 = 0\n        var maxIndex33 = 0\n        var maxIndex34 = 0\n        var maxIndex35 = 0\n        var maxIndex36 = 0\n        var maxIndex37 = 0\n        var maxIndex38 = 0\n        var maxIndex39 = 0\n        var maxIndex40 = 0\n        var maxIndex41 = 0\n        var maxIndex42 = 0\n        var maxIndex43 = 0\n        var maxIndex44 = 0\n        var maxIndex45 = 0\n        var maxIndex46 = 0\n        var maxIndex47 = 0\n        var maxIndex48 = 0\n        var maxIndex49 = 0\n        var maxIndex50 = 0\n        var maxIndex51 = 0\n        var maxIndex52 = 0\n        var maxIndex53 = 0\n        var maxIndex54 = 0\n        var maxIndex55 = 0\n        var maxIndex56 = 0\n        var maxIndex57 = 0\n        var maxIndex58 = 0\n        var maxIndex59 = 0\n        var maxIndex60 = 0\n        var maxIndex61 = 0\n        var maxIndex62 = 0\n        var maxIndex63 = 0\n        var maxIndex64 = 0\n        var maxIndex65 = 0\n        var maxIndex66 = 0\n        var maxIndex67 = 0\n        var maxIndex68 = 0\n        var maxIndex69 = 0\n        var maxIndex70 = 0\n        var maxIndex71 = 0\n        var maxIndex72 = 0\n        var maxIndex73 = 0\n        var \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpu6k083qz.scala:102:11 --------------------------\u001b[0m\u001b[0m\n\u001b[31m102 |\u001b[0m        \u001b[33mvar\u001b[0m \n\u001b[31m\u001b[31m    |\u001b[0m           ^\u001b[0m\n\u001b[31m    |\u001b[0m           pattern expected\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpu6k083qz.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpu6k083qz.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu6k083qz.scala:103:5 --------------------\u001b[0m\u001b[0m\n\u001b[31m103 |\u001b[0m    }\n\u001b[31m\u001b[31m    |\u001b[0m     ^\u001b[0m\n\u001b[31m    |\u001b[0m     Found:    Unit\n\u001b[31m    |\u001b[0m     Required: List[Long]\n\u001b[31m    |\u001b[0m\n\u001b[31m    |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793708
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n        if (k > len) throw new IllegalArgumentException(\"k should be less than or equal to length of arr\")\n        if (k == 0) arr.toList\n        else {\n            val max = new mutable.PriorityQueue[Long]()\n            var i = 0\n            while (i < len) {\n                if (max.size < k) max += arr(i)\n                i += 1\n            }\n            max.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp230rk7ym.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp230rk7ym.scala:25:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793707
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNums = arr.take(k).toList\n        val maxNumsLen = maxNums.size\n        val maxNumsIndex = maxNums.indexWhere(_ > 0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.max(0)\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2c1jm38m.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.max(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2c1jm38m.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.max(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2c1jm38m.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.max(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2c1jm38m.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.max(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2c1jm38m.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.max(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^",
      "stdout": "",
      "timestamp": 1659793710
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap29 = new mutable.\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnesx1dnz.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnesx1dnz.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnesx1dnz.scala:22:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnesx1dnz.scala:23:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnesx1dnz.scala:24:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /",
      "stdout": "",
      "timestamp": 1659793710
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexSet = new mutable.HashSet[Int]()\n        val maxIndexSetSet = new mutable.HashSet[Int]()\n        val maxIndexSetSet2 = new mutable.HashSet[Int]()\n        val maxIndexSetSet3 = new mutable.HashSet[Int]()\n        val maxIndexSetSet4 = new mutable.HashSet[Int]()\n        val maxIndexSetSet5 = new mutable.HashSet[Int]()\n        val maxIndexSetSet6 = new mutable.HashSet[Int]()\n        val maxIndexSetSet7 = new mutable.HashSet[Int]()\n        val maxIndexSetSet8 = new mutable.HashSet[Int]()\n        val maxIndexSetSet9 = new mutable.HashSet[Int]()\n        val maxIndexSetSet10 = new mutable.HashSet[Int]()\n        val maxIndexSetSet11 = new mutable.HashSet[Int]()\n        val maxIndexSetSet12 = new mutable.HashSet[Int]()\n        val maxIndexSetSet13 = new mutable.HashSet[Int]()\n        val maxIndexSetSet14 = new mutable.HashSet[Int]()\n        val maxIndexSetSet15 = new mutable.HashSet[Int]()\n        val maxIndexSetSet16 = new mutable.HashSet[Int]()\n        val maxIndexSetSet17 = new mutable.HashSet[Int]()\n        val maxIndexSetSet18 = new mutable.HashSet[Int]()\n        val maxIndexSetSet19 = new mutable.HashSet[Int]()\n        val maxIndexSetSet20 = new mutable.HashSet[Int]()\n        val maxIndexSetSet21 = new mutable.HashSet[Int]()\n        val maxIndexSetSet22 = new mutable.HashSet[Int]()\n        val maxIndexSetSet23 = new mutable.HashSet[Int]()\n        val maxIndexSetSet24 = new mutable.HashSet[Int]()\n        val maxIndexSetSet25 = new mutable.HashSet[Int]()\n        val maxIndexSetSet26 = new mutable.HashSet[Int]()\n        val maxIndexSetSet27 = new mutable.HashSet[Int]()\n        val maxIndex\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8ve1ys76.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp8ve1ys76.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8ve1ys76.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8ve1ys76.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ve1ys76.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexSet\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashSet[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8ve1ys76.scala:25:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[3",
      "stdout": "",
      "timestamp": 1659793711
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.length\n        val m = arr.max\n        val maxList = arr.take(k)\n        val maxList2 = maxList.sortWith(_ > _)\n        val maxList3 = maxList2.takeRight(k)\n        val maxList4 = maxList3.sortWith(_ > _)\n        val maxList5 = maxList4.takeRight(k)\n        val maxList6 = maxList5.sortWith(_ > _)\n        val maxList7 = maxList6.takeRight(k)\n        val maxList8 = maxList7.sortWith(_ > _)\n        val maxList9 = maxList8.takeRight(k)\n        val maxList10 = maxList9.sortWith(_ > _)\n        val maxList11 = maxList10.takeRight(k)\n        val maxList12 = maxList11.sortWith(_ > _)\n        val maxList13 = maxList12.takeRight(k)\n        val maxList14 = maxList13.sortWith(_ > _)\n        val maxList15 = maxList14.takeRight(k)\n        val maxList16 = maxList15.sortWith(_ > _)\n        val maxList17 = maxList16.takeRight(k)\n        val maxList18 = maxList17.sortWith(_ > _)\n        val maxList19 = maxList18.takeRight(k)\n        val maxList20 = maxList19.sortWith(_ > _)\n        val maxList21 = maxList20.takeRight(k)\n        val maxList22 = maxList21.sortWith(_ > _)\n        val maxList23 = maxList22.takeRight(k)\n        val maxList24 = maxList23.sortWith(_ > _)\n        val maxList25 = maxList24.takeRight(k)\n        val maxList26 = maxList25.sortWith(_ > _)\n        val maxList27 = maxList26.takeRight(k)\n        val maxList28 = maxList27.sortWith(_ > _)\n        val maxList29 = maxList28.takeRight(k)\n        val maxList30 = maxList29.sortWith(_ > _)\n        val maxList31 = maxList30.takeRight(k)\n        val maxList32 = maxList31.sortWith(_ > _)\n        val maxList33 = maxList32.takeRight(k)\n        val maxList34 = maxList33.sortWith(_ > _)\n\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6g_w5x_m.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6g_w5x_m.scala:58:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793711
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val maxNum = arr.max\n        val maxIndex = arr.indexWhere(x => x == maxNum)\n        val maxNums = arr.take(maxIndex + 1)\n        val maxNumsIndex = arr.indexWhere(x => x == maxNums)\n        val maxNumsIndex = maxNumsIndex + 1\n        val maxNumsLength = maxNumsIndex - maxIndex\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        val maxNumsLength = maxNumsLength + 1\n        \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8ihfpfkf.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8ihfpfkf.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsLength\u001b[0m = maxNumsLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8ihfpfkf.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsLength\u001b[0m = maxNumsLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8ihfpfkf.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsLength\u001b[0m = maxNumsLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8ihfpfkf.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsLength\u001b[0m = maxNumsLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659793712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = arr(0)\n        for(i <- 0 until len) {\n            val curr = arr(i)\n            if(curr > maxValue) {\n                maxValue = curr\n                maxIndex = i\n            }\n        }\n        val result = new Array[Long](k)\n        for(i <- 0 until k) {\n            result(i) = arr(maxIndex + i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpeeijg7kx.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeeijg7kx.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeeijg7kx.scala:32:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeeijg7kx.scala:33:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeeijg7kx.scala:36:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when",
      "stdout": "",
      "timestamp": 1659793712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        var max = 0\n        var maxIndex = 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) > max) {\n                max = arr(i)\n                maxIndex = i\n            }\n        }\n        for (i <- 0 until arr.length) {\n            if (arr(i) == max) {\n                result.add(arr(maxIndex))\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3cr1xhj8.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3cr1xhj8.scala:25:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793711
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        while (i < len) {\n            if (j == k) {\n                max(i) = arr(i)\n                i += 1\n                j += 1\n            } else {\n                if (arr(i) > arr(j)) {\n                    max(i) = arr(i)\n                    i += 1\n                } else {\n                    max(i) = arr(j)\n                    j += 1\n                }\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpc6tyyayy.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpc6tyyayy.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793711
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxLength = 0\n        arr.foreach { x =>\n            if (maxLength < k) {\n                maxList += x\n                maxLength += 1\n            }\n            if (maxLength == k) {\n                if (x > maxList(0)) {\n                    maxList += x\n                    maxLength += 1\n                }\n            }\n        }\n        maxList.sortWith(_ > _)\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphsxgjwjv.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphsxgjwjv.scala:25:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                maxLength += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean maxLength.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphsxgjwjv.scala:30:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    maxLength += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean maxLength.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        var i = 0\n        while (i < k) {\n            if (maxIndexMap.contains(arr(i))) {\n                maxIndexMap(arr(i)) = maxIndexMap(arr(i)) + 1\n            } else {\n                maxIndexMap(arr(i)) = 1\n            }\n            if (maxIndexMap2.contains(arr(i))) {\n                maxIndexMap2(arr(i)) = maxIndexMap2(arr(i)) + 1\n            } else {\n                maxIndexMap2(arr(i)) = 1\n            }\n            if (maxIndexMap(arr(i)) > maxIndexMap2(arr(i))) {\n                maxIndexMap(arr(i)) = maxIndexMap2(arr(i))\n            }\n            i += 1\n        }\n        val maxList = arr.map(x => if (maxIndexMap(x) == maxIndexMap2(x)) x else null).toList\n        val maxList2 = arr.map(x => if (maxIndexMap(x) == maxIndexMap2(x)) x else null).toList\n        if (maxList.length == k) {\n            return maxList\n        } else {\n            return maxList2\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpl43_n0fo.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl43_n0fo.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl43_n0fo.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl43_n0fo.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl43_n0fo.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1659793712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val maxValue = arr.max\n        val maxIndex = arr.indexWhere(x => x == maxValue)\n        val maxLength = maxIndex - k + 1\n        val maxValues = arr.take(maxLength)\n        result.addAll(maxValues)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplrcw0raj.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplrcw0raj.scala:24:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxValues\u001b[0m = arr.take(maxLength)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (maxLength : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val maxK = arr.take(k).toList\n        val maxKIndex = arr.lastIndexWhere(_ == maxK(0))\n        val maxKList = arr.take(maxKIndex).toList\n        val maxKListIndex = arr.lastIndexWhere(_ == maxKList(0))\n        val maxKListIndex = maxKListIndex + 1\n        val maxKListLength = maxKListIndex - maxKIndex\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n        val maxKListLength = maxKListLength + 1\n\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvg4chbi.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListIndex\u001b[0m = maxKListIndex + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvg4chbi.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListLength\u001b[0m = maxKListLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvg4chbi.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListLength\u001b[0m = maxKListLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvg4chbi.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListLength\u001b[0m = maxKListLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxKListLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxKListLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcvg4chbi.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxKListLength\u001b[0m = maxKListLength + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m ",
      "stdout": "",
      "timestamp": 1659793712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmponrx84rf.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmponrx84rf.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmponrx84rf.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmponrx84rf.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmponrx84rf.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    ",
      "stdout": "",
      "timestamp": 1659793713
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.size\n        val m = arr.max\n        val maxList = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) < m) {\n                maxList(i) = arr(i)\n                i += 1\n            } else {\n                maxList(i) = m\n                i += 1\n            }\n        }\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk6j89r6a.scala:22:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk6j89r6a.scala:33:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mreturn\u001b[0m maxList\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (maxList : Array[Long])\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793713
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        var maxValue = arr(0)\n        while (i < arr.length) {\n            while (j < arr.length && arr(j) < maxValue) {\n                j++\n            }\n            if (j == arr.length) {\n                maxIndex += 1\n                maxValue = arr(i)\n                max(i) = arr(i)\n                i += 1\n                j = 0\n            } else {\n                maxIndex += 1\n                maxValue = arr(i)\n                max(i) = arr(i)\n                i += 1\n                j = j + 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpsvsydlt6.scala:27:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsvsydlt6.scala:20:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793713
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxLength = Math.min(arr.length, k)\n        var i = 0\n        while (i < maxLength) {\n            val currentMax = arr(i)\n            if (currentMax > maxList(0)) {\n                maxList += currentMax\n            }\n            i += 1\n        }\n        maxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplqtqsf32.scala:20:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length == k) {\n            arr\n        } else {\n            arr ++ max.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpnu6bztoo.scala:20:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => arr.sortBy(_$1).\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnu6bztoo.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnu6bztoo.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793714
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while(i < k) {\n            val max = arr(i)\n            val j = 0\n            while(j < len) {\n                if(arr(j) > max) {\n                    max = arr(j)\n                }\n                j += 1\n            }\n            i += 1\n            max(i) = max\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplor94ohy.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmplor94ohy.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmplor94ohy.scala:29:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    max = arr(j)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplor94ohy.scala:31:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                j += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean j.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793714
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNums = arr.take(k).maxBy(_.toLong)\n        val maxNumsIndex = arr.lastIndexWhere(_.toLong == maxNums)\n        val maxNumsIndexInRange = maxNumsIndex.toLong\n        val maxNumsIndexInRangeInRange = maxNumsIndexInRange - k\n        val maxNumsIndexInRangeInRangeInRange = maxNumsIndexInRangeInRange / k\n        val maxNumsIndexInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRange % k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRange / k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRange % k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRange / k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange % k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange / k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange % k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange / k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange % k\n        val maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange / k\n        val maxNum\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpter57hgm.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpter57hgm.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndexInRangeInRangeInRangeInRangeInRange\u001b[0m = maxNumsIndexInRangeInRangeInRangeInRangeInRange % k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndexInRangeInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndexInRangeInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpter57hgm.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange / k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpter57hgm.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange\u001b[0m = maxNumsIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange % k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxN",
      "stdout": "",
      "timestamp": 1659793714
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(x => x)\n        val maxList = arr.take(k)\n        val maxList2 = arr.drop(k)\n        val maxList3 = arr.takeRight(k)\n        val maxList4 = arr.dropRight(k)\n        val maxList5 = arr.take(arr.size - k)\n        val maxList6 = arr.drop(arr.size - k)\n        val maxList7 = arr.takeRight(arr.size - k)\n        val maxList8 = arr.dropRight(arr.size - k)\n        val maxList9 = arr.take(arr.size - k)\n        val maxList10 = arr.drop(arr.size - k)\n        val maxList11 = arr.takeRight(arr.size - k)\n        val maxList12 = arr.dropRight(arr.size - k)\n        val maxList13 = arr.take(arr.size - k)\n        val maxList14 = arr.drop(arr.size - k)\n        val maxList15 = arr.takeRight(arr.size - k)\n        val maxList16 = arr.dropRight(arr.size - k)\n        val maxList17 = arr.take(arr.size - k)\n        val maxList18 = arr.drop(arr.size - k)\n        val maxList19 = arr.takeRight(arr.size - k)\n        val maxList20 = arr.dropRight(arr.size - k)\n        val maxList21 = arr.take(arr.size - k)\n        val maxList22 = arr.drop(arr.size - k)\n        val maxList23 = arr.takeRight(arr.size - k)\n        val maxList24 = arr.dropRight(arr.size - k)\n        val maxList25 = arr.take(arr.size - k)\n        val maxList26 = arr.drop(arr.size - k)\n        val maxList27 = arr.takeRight(arr.size - k)\n        val maxList28 = arr.dropRight(arr.size - k)\n        val maxList29 = arr.take(arr.size - k)\n        val maxList30 = arr.drop(arr.size - k)\n        val maxList31 = arr.takeRight(arr.size - k)\n        val maxList32 = arr.dropRight(arr.size - k)\n        val maxList33 = arr.take(arr.size - k)\n        val maxList34 = arr.drop(arr.size - k)\n        val maxList35 = arr.takeRight(arr.size - k)\n        val maxList36 = arr.dropRight(arr.size - k)\n        val maxList37 = arr.take(arr.size - k)\n        val maxList38 = arr.drop(arr.size - k)\n        val maxList39 = arr.takeRight(arr.\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsfyiwen9.scala:60:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsfyiwen9.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(\u001b[36mx\u001b[0m => x)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsfyiwen9.scala:60:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m60 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793714
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuoj84dpg.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuoj84dpg.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793673
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = new Array[Long](k)\n        var i = 0\n        var j = 0\n        var maxIndex = 0\n        while (i < arr.length && j < k) {\n            if (arr(i) > arr(j)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(j) = arr(j)\n                j += 1\n            }\n        }\n        while (i < arr.length) {\n            max(maxIndex) = arr(i)\n            i += 1\n            maxIndex += 1\n        }\n        while (j < k) {\n            max(maxIndex) = arr(j)\n            j += 1\n            maxIndex += 1\n        }\n        arr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpf9k0sbzd.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf9k0sbzd.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793714
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = arr(0)\n        for(i <- 0 until k) {\n            for(j <- 0 until n) {\n                if(arr(j) > maxValue) {\n                    maxValue = arr(j)\n                    maxIndex = j\n                }\n            }\n            max += maxValue\n            maxValue = arr(maxIndex)\n            maxIndex = 0\n        }\n        max += maxValue\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz3mu2r0l.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz3mu2r0l.scala:24:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz3mu2r0l.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            max += maxValue\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Array[Long] - did you mean max.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz3mu2r0l.scala:35:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        max += maxValue\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of Array[Long] - did you mean max.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793714
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ListBuffer.empty[Long]\n        val maxK = k\n        val maxLength = arr.length\n        val maxValue = arr(0)\n        val maxIndex = arr.indexOf(0)\n        val maxIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexK = k\n        val maxIndexLength = arr.indexOf(0)\n        val maxIndexValue = arr(0)\n        val maxIndexIndex = arr.indexOf(0)\n        val maxIndexIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexIndexK = k\n        val maxIndexIndexLength = arr.indexOf(0)\n        val maxIndexIndexValue = arr(0)\n        val maxIndexIndexIndex = arr.indexOf(0)\n        val maxIndexIndexIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexIndexIndexK = k\n        val maxIndexIndexIndexLength = arr.indexOf(0)\n        val maxIndexIndexIndexValue = arr(0)\n        val maxIndexIndexIndexIndex = arr.indexOf(0)\n        val maxIndexIndexIndexIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexIndexIndexIndexK = k\n        val maxIndexIndexIndexIndexLength = arr.indexOf(0)\n        val maxIndexIndexIndexIndexValue = arr(0)\n        val maxIndexIndexIndexIndexIndex = arr.indexOf(0)\n        val maxIndexIndexIndexIndexIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexIndexIndexIndexIndexK = k\n        val maxIndexIndexIndexIndexIndexLength = arr.indexOf(0)\n        val maxIndexIndexIndexIndexIndexValue = arr(0)\n        val maxIndexIndexIndexIndexIndexIndex = arr.indexOf(0)\n        val maxIndexIndexIndexIndexIndexIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexIndexIndexIndexIndexK = k\n        val maxIndexIndexIndexIndexIndexIndexLength = arr.indexOf(0)\n        val maxIndexIndexIndexIndexIndexIndexValue = arr(0)\n        val maxIndexIndexIndexIndexIndexIndex = arr.indexOf(0)\n        val maxIndexIndexIndexIndexIndexIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexIndexIndexIndexIndexIndexK = k\n        val maxIndexIndexIndexIndexIndexIndexIndexLength = arr.indexOf(0)\n        val maxIndexIndexIndexIndexIndexIndexValue = arr(0)\n        val maxIndexIndexIndexIndexIndexIndex = arr.indexOf(0)\n        val maxIndexIndexIndexIndexIndexIndexIndexList = mutable.ListBuffer.empty[Long]\n        val maxIndexIndexIndexIndexIndexIndexK = k\n        val max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpfz9kyuld.scala:63:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m63 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfz9kyuld.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexIndexIndexIndexIndexK\u001b[0m = k\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexIndexIndexIndexIndexK is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexIndexIndexIndexIndexK\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfz9kyuld.scala:54:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m54 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexIndexIndexIndexIndexIndex\u001b[0m = arr.indexOf(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexIndexIndexIndexIndexIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexIndexIndexIndexIndexIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfz9kyuld.scala:55:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m55 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexIndexIndexIndexIndexIndexList\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexIndexIndexIndexIndexIndexList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexIndexIndexIndexIndexIndexList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfz9kyuld.scala:58:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m58 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexIndexIndexIndexIndexIndexValue\u001b[0m = arr(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659793714
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        var maxIndex = 0\n        var maxValue = 0\n        var i = 0\n        var j = 0\n        while (i < len) {\n            val value = arr(i)\n            if (maxIndex < k) {\n                if (value > maxValue) {\n                    maxValue = value\n                    maxIndex = j\n                }\n                j += 1\n            } else {\n                if (value > maxValue) {\n                    maxValue = value\n                    maxIndex = j\n                }\n            }\n            i += 1\n        }\n        val result = new Array[Long](maxIndex)\n        var index = 0\n        var value = 0\n        while (index < maxIndex) {\n            value = maxValue\n            result(index) = value\n            index += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp2kygwj4y.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2kygwj4y.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2kygwj4y.scala:51:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793716
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val maxArr : List[Long] = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                maxArr(i) = arr(i)\n                i += 1\n            } else {\n                maxArr(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        maxArr\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp77t7bq1z.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp77t7bq1z.scala:21:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxArr\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp77t7bq1z.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                maxArr(i) = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean maxArr.updated?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp77t7bq1z.scala:28:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                maxArr(i) = arr(i + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean maxArr.updated?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = arr.max\n        val maxIndex = arr.indexWhere(x => x == max)\n        val maxIndex2 = maxIndex + 1\n        val maxIndex3 = maxIndex2 + 1\n        val maxIndex4 = maxIndex3 + 1\n        val maxIndex5 = maxIndex4 + 1\n        val maxIndex6 = maxIndex5 + 1\n        val maxIndex7 = maxIndex6 + 1\n        val maxIndex8 = maxIndex7 + 1\n        val maxIndex9 = maxIndex8 + 1\n        val maxIndex10 = maxIndex9 + 1\n        val maxIndex11 = maxIndex10 + 1\n        val maxIndex12 = maxIndex11 + 1\n        val maxIndex13 = maxIndex12 + 1\n        val maxIndex14 = maxIndex13 + 1\n        val maxIndex15 = maxIndex14 + 1\n        val maxIndex16 = maxIndex15 + 1\n        val maxIndex17 = maxIndex16 + 1\n        val maxIndex18 = maxIndex17 + 1\n        val maxIndex19 = maxIndex18 + 1\n        val maxIndex20 = maxIndex19 + 1\n        val maxIndex21 = maxIndex20 + 1\n        val maxIndex22 = maxIndex21 + 1\n        val maxIndex23 = maxIndex22 + 1\n        val maxIndex24 = maxIndex23 + 1\n        val maxIndex25 = maxIndex24 + 1\n        val maxIndex26 = maxIndex25 + 1\n        val maxIndex27 = maxIndex26 + 1\n        val maxIndex28 = maxIndex27 + 1\n        val maxIndex29 = maxIndex28 + 1\n        val maxIndex30 = maxIndex29 + 1\n        val maxIndex31 = maxIndex30 + 1\n        val maxIndex32 = maxIndex31 + 1\n        val maxIndex33 = maxIndex32 + 1\n        val maxIndex34 = maxIndex33 + 1\n        val maxIndex35 = maxIndex34 + 1\n        val maxIndex36 = maxIndex35 + 1\n        val maxIndex37 = maxIndex36 + 1\n        val maxIndex38 = maxIndex37 + 1\n        val maxIndex39 = maxIndex38 + 1\n        val maxIndex40 = maxIndex39 + 1\n        val maxIndex41 = maxIndex40 + 1\n        val maxIndex42 = maxIndex41 + 1\n        val maxIndex43 = maxIndex42 + 1\n        val maxIndex44 = maxIndex43 + 1\n        val maxIndex45 = maxIndex44 + 1\n        val maxIndex4\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4aztnnt8.scala:69:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4aztnnt8.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4aztnnt8.scala:69:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m69 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659793687
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val max = arr.take(k).toList\n        val rest = arr.drop(k)\n        rest match {\n            case Nil => max\n            case _ => maximum(max, rest.max)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpvz4fsjaj.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793715
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (len > k) {\n            val newArr = new Array[Long](len - k)\n            i = 0\n            while (i < k) {\n                newArr(i) = arr(i + k)\n                i += 1\n            }\n            max = newArr\n        }\n        max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpnoqychqr.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnoqychqr.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpnoqychqr.scala:40:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            max = newArr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnoqychqr.scala:42:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (max : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659793717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.size\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        var maxIndexIndex = 0\n        var maxIndexValue = 0\n        var maxIndexValueIndex = 0\n        var maxIndexValueValue = 0\n        var maxIndexValueValueIndex = 0\n        var maxIndexValueValueValue = 0\n        var maxIndexValueValueValueIndex = 0\n        var maxIndexValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue = 0\n        var maxIndexValueValueValueValueIndex = 0\n        var maxIndexValueValueValueValueValue\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt4syttti.scala:74:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m74 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt4syttti.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndexValueValueValueValueIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexValueValueValueValueIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmaxIndexValueValueValueValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt4syttti.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndexValueValueValueValueValue\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexValueValueValueValueValue is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmaxIndexValueValueValueValueValue\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt4syttti.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndexValueValueValueValueIndex\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexValueValueValueValueIndex is already defined as \u001b[33mvariable\u001b[0m \u001b[35mmaxIndexValueValueValueValueIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt4syttti.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndexValueValueValueValueValue\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexValueValueValueValueValue is already defined as ",
      "stdout": "",
      "timestamp": 1659793717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n        if (k > len) k else k\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) max += arr(i + 1)\n            else max += arr(i)\n            i += 1\n        }\n        max += arr(k)\n        val res = new Array[Long](k)\n        var j = 0\n        while (j < k) {\n            if (arr(j) > max) res(j) = arr(j)\n            else res(j) = max\n            j += 1\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpqfoivwxj.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfoivwxj.scala:23:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqfoivwxj.scala:26:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (arr(i) > arr(i + \u001b[31m1\u001b[0m)) max += arr(i + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Array[Long] - did you mean max.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqfoivwxj.scala:27:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33melse\u001b[0m max += arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Array[Long] - did you mean max.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqfoivwxj.scala:30:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        max += arr(k)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of Array[Long] - did you mean max.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqfoivwxj.scala:31:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Lo",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val len = arr.length\n        val maxLen = k\n        val maxNum = arr.max\n        val minNum = arr.min\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val maxNums = arr.take(maxLen)\n        val minNums = arr.take(minLen)\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val maxNumsIndex = arr.lastIndexWhere(x => x == maxNums)\n        val minNumsIndex = arr.lastIndexWhere(x => x == minNums)\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val maxNumsIndex = arr.lastIndexWhere(x => x == maxNums)\n        val minNumsIndex = arr.lastIndexWhere(x => x == minNums)\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val maxNumsIndex = arr.lastIndexWhere(x => x == maxNums)\n        val minNumsIndex = arr.lastIndexWhere(x => x == minNums)\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val maxNumsIndex = arr.lastIndexWhere(x => x == maxNums)\n        val minNumsIndex = arr.lastIndexWhere(x => x == minNums)\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val maxNumsIndex = arr.lastIndexWhere(x => x == maxNums)\n        val minNumsIndex = arr.lastIndexWhere(x => x == minNums)\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val maxNumsIndex = arr.lastIndexWhere(x => x == maxNums)\n        val minNumsIndex = arr.lastIndexWhere(x => x == minNums)\n        val maxIndex = arr.lastIndexWhere(x => x == maxNum)\n        val minIndex = arr.lastIndexWhere(x => x == minNum)\n        val max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjpq7ka9h.scala:56:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpq7ka9h.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = arr.lastIndexWhere(\u001b[36mx\u001b[0m => x == maxNum)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpq7ka9h.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mminIndex\u001b[0m = arr.lastIndexWhere(\u001b[36mx\u001b[0m => x == minNum)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mminIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mminIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpq7ka9h.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = arr.lastIndexWhere(\u001b[36mx\u001b[0m => x == maxNum)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpjpq7ka9h.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mminIndex\u001b[0m = arr.lastIndexWhere(\u001b[36mx\u001b[0m => x == minNum)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mminIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mminIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be def",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortWith(_ < _)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbgp77yad.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbgp77yad.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(-_)\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0pnhkqxf.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0pnhkqxf.scala:21:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793685
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        if (arr.length < k) {\n            val newArr = new Array[Long](k)\n            var j = 0\n            while (j < k) {\n                newArr(j) = arr(j)\n                j += 1\n            }\n            max = newArr\n        }\n        new Array[Long](k)\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdtidytsi.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdtidytsi.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdtidytsi.scala:34:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnewArr\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                         Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpdtidytsi.scala:40:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            max = newArr\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdtidytsi.scala:42:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    (k : Long)\n\u001b[31m   |\u001b[0m                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available wh",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.length\n        val m = arr.max\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpt3xfmq5m.scala:53:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt3xfmq5m.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt3xfmq5m.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt3xfmq5m.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt3xfmq5m.scala:25:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt3x",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxNums = arr.take(k).toList\n        val maxNumsSorted = arr.sortWith(_.compareTo(_) > 0).take(k).toList\n        val maxNumsSortedReverse = arr.sortWith(_.compareTo(_) < 0).take(k).toList\n        val maxNumsSortedReverse2 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse\n        val maxNumsSortedReverse3 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse\n        val maxNumsSortedReverse4 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse\n        val maxNumsSortedReverse5 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse.reverse\n        val maxNumsSortedReverse6 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse.reverse\n        val maxNumsSortedReverse7 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse.reverse.reverse\n        val maxNumsSortedReverse8 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse.reverse.reverse.reverse\n        val maxNumsSortedReverse9 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse.reverse.reverse.reverse\n        val maxNumsSortedReverse10 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse.reverse.reverse.reverse.reverse\n        val maxNumsSortedReverse11 = arr.sortWith(_.compareTo(_) < 0).take(k).toList.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyc5ru1xi.scala:20:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNums\u001b[0m = arr.take(k).toList\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (k : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyc5ru1xi.scala:21:66 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSorted\u001b[0m = arr.sortWith(_.compareTo(_) > \u001b[31m0\u001b[0m).take(k).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyc5ru1xi.scala:22:73 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSortedReverse\u001b[0m = arr.sortWith(_.compareTo(_) < \u001b[31m0\u001b[0m).take(k).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpyc5ru1xi.scala:23:74 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsSortedReverse2\u001b[0m = arr.sortWith(_.compareTo(_) < \u001b[31m0\u001b[0m).take(k).toList.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                                    R",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val n = arr.size\n        val m = arr.max\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        var maxIndex = 0\n        var maxValue = m\n        var i = 0\n        while (i < n) {\n            if (arr(i) > maxValue) {\n                maxValue = arr(i)\n                maxIndex = i\n            }\n            i += 1\n        }\n        if (maxIndex == k) {\n            maxList += maxValue\n        }\n        else {\n            val leftList = arr.take(maxIndex)\n            val rightList = arr.drop(maxIndex + 1)\n            val leftMax = maximum(leftList, k)\n            val rightMax = maximum(rightList, k)\n            val maxList = leftMax + rightMax\n        }\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpll0sc7bv.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpll0sc7bv.scala:41:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = leftMax + rightMax\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexLen = new Array[Int](k)\n        val maxIndexLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLenLenLen = new Array[Int](k)\n        val maxIndexLen\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpgaq_rxg6.scala:59:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m59 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgaq_rxg6.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgaq_rxg6.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgaq_rxg6.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgaq_rxg6.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexLenLenLen\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxIndexLenLenLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxIndexLenLenLen\u001b[0m\n\u001b[31m  ",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val n = arr.size\n        val m = arr.max\n        val max = new mutable.PriorityQueue[Long]()\n        for (i <- 0 until n) {\n            if (arr(i) > m) {\n                max.enqueue(arr(i))\n            }\n        }\n        val result = new mutable.PriorityQueue[Long]()\n        for (i <- 0 until k) {\n            if (max.isEmpty) {\n                break\n            }\n            result.enqueue(max.dequeue())\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpajk2ep8h.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajk2ep8h.scala:23:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajk2ep8h.scala:29:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpajk2ep8h.scala:30:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until k) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (k : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpajk2ep8h.scala:32:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m                break\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val maxList = mutable.ArrayBuffer.empty[Long]\n        val maxLen = arr.length\n        val maxK = k\n        val maxNum = arr.max\n        val maxNumIndex = arr.indexWhere(x => x == maxNum)\n        val maxNumIndex = maxNumIndex.min(maxK - maxNumIndex.size)\n        val maxNums = arr.take(maxNumIndex.toInt)\n        val maxNumsIndex = maxNums.indexWhere(x => x == maxNum)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.min(maxLen)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.min(maxLen)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.min(maxLen)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.min(maxLen)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.min(maxLen)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.min(maxLen)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = maxNumsIndex.min(maxLen)\n        val maxNumsIndex = maxNumsIndex.min(maxK - maxNumsIndex.size)\n        val maxNumsIndex = maxNumsIndex.max(0)\n        val maxNumsIndex = max\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzkwub2wv.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumIndex\u001b[0m = maxNumIndex.min(maxK - maxNumIndex.size)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzkwub2wv.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.min(maxK - maxNumsIndex.size)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzkwub2wv.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.max(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzkwub2wv.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsIndex\u001b[0m = maxNumsIndex.min(maxLen)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxNumsIndex is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmaxNumsIndex\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzkwub2wv.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumsInde",
      "stdout": "",
      "timestamp": 1659793718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.toList\n        val len = arr.length\n        val max = new Array[Long](k)\n        val maxIndex = new Array[Int](k)\n        val maxIndexMap = new mutable.HashMap[Long, Int]()\n        val maxIndexMap2 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap3 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap4 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap5 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap6 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap7 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap8 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap9 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap10 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap11 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap12 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap13 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap14 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap15 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap16 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap17 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap18 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap19 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap20 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap21 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap22 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap23 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap24 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap25 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap26 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap27 = new mutable.HashMap[Long, Int]()\n        val maxIndexMap28 = new mutable.HashMap[Long, Int]()\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpt2vzfkeq.scala:52:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpt2vzfkeq.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.toList\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt2vzfkeq.scala:23:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt2vzfkeq.scala:24:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b",
      "stdout": "",
      "timestamp": 1659793674
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        val maxNum = arr.max\n        val maxIndex = arr.indexWhere(x => x == maxNum)\n        val maxNums = arr.take(maxIndex)\n        result.addAll(maxNums)\n        val rest = arr.drop(maxIndex)\n        result.addAll(maximum(rest, k - maxNums.size))\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyjhbzjoe.scala:20:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659793717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Given a list arr of integers and a positive integer k, return a sorted list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n    // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong, 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n    // Note:\n    // 1. The length of the list will be in the range of [1, 1000].\n    // 2. The elements in the list will be in the range of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long] = {\n        val arr = arr.sortBy(_.toLong)\n        val len = arr.length\n        val max = new Array[Long](k)\n        var i = 0\n        while (i < k) {\n            if (arr(i) > arr(i + 1)) {\n                max(i) = arr(i)\n                i += 1\n            } else {\n                max(i) = arr(i + 1)\n                i += 1\n            }\n        }\n        max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong, 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong, 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong, 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong, 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong, -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong, 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong, 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong, -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong, -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong, 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp1dop7prz.scala:20:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marr\u001b[0m = arr.sortBy(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  Recursive \u001b[33mvalue\u001b[0m \u001b[35marr\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1dop7prz.scala:22:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mLong\u001b[0m](k)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (k : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659793706
    }
  ]
}