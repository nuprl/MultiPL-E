language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n \
    \       val isBalanced = maxSum - maxWeight < 0\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbxqezaho.scala:27)\n\tat Problem.main(tmpbxqezaho.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcv13urtn.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x.toLong == x)\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, elem) => sum + elem }\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isPalindromic = palindromic\n        val isFlippable = isBalanced\
    \ && isPalindromic && sumOfElements <= maxSum\n        isFlippable\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4obct5j7.scala:31)\n\tat Problem.main(tmp4obct5j7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        isBalanced && isPalindromic\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppgbnnhey.scala:27)\n\tat Problem.main(tmppgbnnhey.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ val isFlippableAndLessThanMaxWeight = isFlippable && maxWeight < maxSum\n  \
    \      isFlippableAndLessThanMaxWeight\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp8xxtrwld.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1659800617
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphzctx5x1.scala:28)\n\tat Problem.main(tmphzctx5x1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == q.sum\n        val isLessThanMaxWeight = maxWeight < q.sum\n   \
    \     val isLessThanMaxSum = maxSum < w\n        val isLessThanMaxSumAndBalanced\
    \ = isLessThanMaxWeight && isLessThanMaxSum\n        val isLessThanMaxSumAndPalindromic\
    \ = isLessThanMaxWeight && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic\n   \
    \     val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic && !isPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxSumAndBalancedAndPalindromicAndNot\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprzwzzlm7.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmprzwzzlm7.scala:21:35 --------------------\e[0m\e[0m\n\e[31m21 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmprzwzzlm7.scala:35:5 ---------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x.toLong)\n        val isBalanced = sums.size == q.length && sums.forall(x\
    \ => x <= maxSum)\n        val isPalindromic = sums.reverse == sums\n        isBalanced\
    \ && isPalindromic\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo5jdvtmy.scala:30)\n\tat Problem.main(tmpo5jdvtmy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)((sum, elem) =>\
    \ sum + elem)\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6pmz75qy.scala:27)\n\tat Problem.main(tmp6pmz75qy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum,\
    \ element) => sum + element }\n        sumOfElements <= maxWeight\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzkzwu822.scala:26)\n\tat Problem.main(tmpzkzwu822.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n    \
    \    val isNotFly = !isFly\n        isFly\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps2kkv51_.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum == maxWeight\n        val isFlippable = q.tail.forall(_ < q.head)\n \
    \       isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvmpy9x1i.scala:28)\n\tat Problem.main(tmpvmpy9x1i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqualToMaxWeight = maxSum < maxWeight\n \
    \       val isLessOrEqualToMaxSum = maxSum == maxWeight\n        isBalanced &&\
    \ isPalindromic && isLessOrEqualToMaxWeight && isLessOrEqualToMaxSum\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzwaqcl8z.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val sumOfElements = q.sum\n    \
    \    val isBalanced = sumOfElements <= maxWeight\n        val isFlippable = palindromic\
    \ && isBalanced\n        val isFlippable = maxSum - sumOfElements <= maxWeight\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpizp3xah_.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = maxSum\
    \ - sumOfElements <= maxWeight\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659800617
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q.reduceRight(_ + _))\n        val\
    \ isBalanced = maxSum - maxWeight < 0\n        isPalindromic && isBalanced\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph2khc_ee.scala:27)\n\tat Problem.main(tmph2khc_ee.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlippableAndLessThanMaxWeight = isFlippable && maxWeight < maxSum\n\
    \        isFlippableAndLessThanMaxWeight\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu3lgh7ri.scala:29)\n\tat Problem.main(tmpu3lgh7ri.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList\
    \ = q.reverse\n        val maxListSum = maxList.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = maxListSum == maxWeight\n        val isBalanced = maxListSum\
    \ == maxSum && maxListSum == maxList.reduceLeft(_ + _)\n        isPalindromic\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5q4nrcn.scala:23:45\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e\
    [0m = maxList.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m           \
    \                                  ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                              Found:    Long\n\e[31m   |\e[0m               \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l)(_ + _)\n\
    \        val isBalanced = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq7t0n5vg.scala:28)\n\tat Problem.main(tmpq7t0n5vg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < q.foldLeft(0l){ (sum, e)\
    \ => sum + e }\n        isBalanced && isPalindromic && isLessThanMaxWeight &&\
    \ isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5rjdiqxa.scala:29)\n\tat Problem.main(tmp5rjdiqxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList\
    \ = q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val\
    \ isBalanced = maxListSum == maxSum\n        val isPalindromic = maxList.reduceLeft(_\
    \ + _) == maxList.reduceRight(_ + _)\n        val isLessThanMaxWeight = maxListSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxListSum < maxSum\n        isBalanced\
    \ && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmxyqavwi.scala:31)\n\tat Problem.main(tmpmxyqavwi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxPalindromic = maxSum < maxWeight && isPalindromic\n\
    \        val isLessThanMaxPalindromicAndBalanced = maxSum < maxWeight && isPalindromic\
    \ && isBalanced\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax\n     \
    \   val isLessThanMaxPalindromicAndLessThanMax = maxSum < maxWeight && isPalindromic\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic\n  \
    \      val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndBalanced = maxSum\
    \ < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isBalanced\n\
    \        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isBalanced\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isLessThanMax\n\
    \        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndBalanced\
    \ = maxSum < maxWeight && isPalindromic && isLess\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp85yh_e8j.scala:34:139 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndBalanced\e\
    [0m = maxSum < maxWeight && isPalindromic && isLess\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                                                            ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                       Not found: isLess\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp85yh_e8j.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = w.toLong\n        val\
    \ maxSumOfElements = w.toLong\n        val maxSumOfElementsOfList = w.toLong\n\
    \        val maxSumOfElementsOfListOfList = w.toLong\n        val maxSumOfElementsOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfList = w.toLong\n\
    \        val maxSumOfElementsOfListOfListOfListOfListOfList = w.toLong\n     \
    \   val maxSumOfElementsOfListOfListOfListOfListOfListOfList = w.toLong\n    \
    \    val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfList = w.toLong\n\
    \        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpojl1h9aw.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpojl1h9aw.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800620
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsblz5ia7.scala:28)\n\tat Problem.main(tmpsblz5ia7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.foldLeft(0L)(_\
    \ + _)\n        sumOfElements <= maxWeight && q.isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjdye2pcs.scala:22:40 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        sumOfElements <= maxWeight && q.isBalanced\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          value isBalanced is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800627
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcdpkfehu.scala:28)\n\tat Problem.main(tmpcdpkfehu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800629
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x => x !=\
    \ q(0))\n        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpumozb0om.scala:28)\n\tat Problem.main(tmpumozb0om.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l)((acc, x)\
    \ => acc + x)\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphdoug12p.scala:27)\n\tat Problem.main(tmphdoug12p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * q.length\n        val maxWeightSumPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromic = w.toLong\
    \ * q.length\n        val maxWeightSumPalindromicPalindromicPalindromic = w.toLong\
    \ * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicP\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpexotw3u5.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpexotw3u5.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && maxSum - x <= maxWeight)\n        isPalindromic\
    \ && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphb9btc1o.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.isEmpty || q.head == q.reverse.head\n\
    \        val isBalanced = maxSum == maxWeight\n        val isFlipped = q.head\
    \ != q.reverse.head\n        isPalindromic && isBalanced && isFlipped\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmsq172l4.scala:28)\n\tat Problem.main(tmpmsq172l4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && isBalanced\n        val isLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && isPalindromic\n        val isLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isLessThanMaxWeight\n        val isLessThanMaxSumAndLessThanMaxSum\
    \ = maxSum < maxWeight && isLessThanMaxSum\n        val isLessThanMaxSumAndLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && isLessThanMaxSum && isBalanced\n        val isLessThanMaxSumAndLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && isLessThanMaxSum && isPalindromic\n        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxWeight\n        val\
    \ isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSum = maxSum < maxWeight && isLessThanMaxSum\
    \ && isLessThanMaxSum\n        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isBalanced\n\
    \        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isPalindromic\n\
    \        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSum\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isLessThan\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1yeu73n8.scala:37:144 -----------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSum\e\
    [0m = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isLessThan\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                   Not found: isLessThan\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp1yeu73n8.scala:38:5 ---------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElements = w.toLong\n        val maxSumOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxSumOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElements\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo3ykrwxn.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpo3ykrwxn.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800630
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsblz5ia7.scala:28)\n\tat Problem.main(tmpsblz5ia7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9tkkvw5g.scala:27)\n\tat Problem.main(tmp9tkkvw5g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindrome = q.reverse.forall(x => x ==\
    \ x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindrome && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk85azfbd.scala:29)\n\tat Problem.main(tmpk85azfbd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic\n        val isLessThanMaxPalindromicAndBalanced\
    \ = maxSum < maxWeight && isPalindromic && isBalanced\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax\n     \
    \   val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromic = maxSum\
    \ < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax && isPalindromic\n      \
    \  val is\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdgcy3ahd.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpdgcy3ahd.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        (isPalindromic && isBalanced)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpibfmbg4a.scala:27)\n\tat Problem.main(tmpibfmbg4a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlippable = q.forall(x => x == q.reverse.head)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_qfp4297.scala:28)\n\tat Problem.main(tmp_qfp4297.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlippable\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8rbj13uq.scala:28)\n\tat Problem.main(tmp8rbj13uq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x.toLong)\n        sums.last <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5a1tt68e.scala:26)\n\tat Problem.main(tmp5a1tt68e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isWon = isPalindromic && isBalanced\n        isWon\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl8ik1gsr.scala:28)\n\tat Problem.main(tmpl8ik1gsr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum,\
    \ elem) => sum + elem }\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7_3qukd7.scala:26)\n\tat Problem.main(tmp7_3qukd7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlippable\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8rbj13uq.scala:28)\n\tat Problem.main(tmp8rbj13uq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp001cv8y0.scala:28)\n\tat Problem.main(tmp001cv8y0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n   \
    \     val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessThanMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpybxj44kw.scala:28)\n\tat Problem.main(tmpybxj44kw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x.toLong\
    \ == x)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp241_5irs.scala:29)\n\tat Problem.main(tmp241_5irs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val balanced = maxSum < maxWeight\n        val palindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = balanced && palindromic && isPalindromic\n        isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr2gh_xyx.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ghp9u2s.scala:28)\n\tat Problem.main(tmp8ghp9u2s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight < 0\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqt44mntv.scala:27)\n\tat Problem.main(tmpqt44mntv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800638
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l){ (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isFlippable = q.forall(e =>\
    \ e != q(0))\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isFlippable && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsr6xg6s9.scala:29)\n\tat Problem.main(tmpsr6xg6s9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800640
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isBalanced = q.length == maxSum && q.forall(x => x == maxWeight)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isLessThanMaxWeight\
    \ = maxWeight < q.reduce(_ + _)\n        isBalanced && isPalindromic && isLessThanMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaba0_59x.scala:28)\n\tat Problem.main(tmpaba0_59x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum - q.sum < maxWeight\n        isPalindromic && isBalanced\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfsug9wlk.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = maxSum / q.length\n        val maxWeightSumAbs = Math.abs(maxWeightSum)\n\
    \        val maxWeightSumAbsAbs = Math.abs(maxWeightSumAbs)\n        val maxWeightSumAbsAbsAbs\
    \ = Math.abs(maxWeightSumAbsAbs)\n        val maxWeightSumAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAb\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk6418lbb.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk6418lbb.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs\e[0m = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpk6418lbb.scala:27:51 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumAbsAbsAbsAbsAbs\e[0m = Math.abs(maxWeightSumAbsAbsAbsAbsAbs)\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mmaxWeightSumAbsAbsAbsAbsAbs\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk6418lbb.scala:28:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumAbsAbsAbsAbsAbsAbs\e[0m = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbs)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m               Recursive \e[33mvalue\e[0m \e[35mmaxWeightSumAbsAbsAbsAbsAbsAbs\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk6418lbb.scala:30:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs\e[0m = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \e[31m\e["
  stdout: ''
  timestamp: 1659800639
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7h8wkcc5.scala:28)\n\tat Problem.main(tmp7h8wkcc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdvqazj_b.scala:28)\n\tat Problem.main(tmpdvqazj_b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = isLessThanMax && !isBalanced\n        isFlippable || isLessThanMaxButNotBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp3nnlle0.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sum = palindromic.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sum <= maxSum && palindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplwun5jxq.scala:23:30 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = palindromic.foldLeft(\e\
    [31m0l\e[0m) { (\e[36msum\e[0m, \e[36melement\e[0m) => sum + element }\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \              value foldLeft is not a member of Boolean\n1 error found\n"
  stdout: ''
  timestamp: 1659800641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFly = isPalindromic && isBalanced\n        val isNotFly\
    \ = !isPalindromic || !isBalanced\n        isFly\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpik5rtzux.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1659800638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphi8ccgvx.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val maxList =\
    \ q.reverse\n        val maxListSum = maxList.sum\n        val maxListWeight =\
    \ maxList.sum\n        val maxListWeightDiff = maxListWeight - maxWeight\n   \
    \     val maxListSumDiff = maxListSum - maxSum\n        val maxListWeightDiffAbs\
    \ = maxListWeightDiff < 0 ? -maxListWeightDiff : maxListWeightDiff\n        val\
    \ maxListSumDiffAbs = maxListSumDiff < 0 ? -maxListSumDiff : maxListSumDiff\n\
    \        val maxListWeightDiffAbsLessOrEqual = maxListWeightDiffAbs <= 0 ? false\
    \ : true\n        val maxListSumDiffAbsLessOrEqual = maxListSumDiffAbs <= 0 ?\
    \ false : true\n        val maxListWeightDiffLessOrEqual = maxListWeightDiffAbsLessOrEqual\
    \ || maxListWeightDiffAbsLessOrEqual\n        val maxListSumDiffLessOrEqual =\
    \ maxListSumDiffAbsLessOrEqual || maxListSumDiffAbsLessOrEqual\n        val maxListWeightDiffLessOrEqual\
    \ = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n        val\
    \ maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkersgfiw.scala:43:42 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightDiffLessOrEqual\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                          ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkersgfiw.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListWeightDiffLessOrEqual\e[0m = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWeightDiffLessOrEqual is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListWeightDiffLessOrEqual\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkersgfiw.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumDiffLessOrEqual\e\
    [0m = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumDiffLessOrEqual is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListSumDiffLessOrEqual\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkersgfiw.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightDiffLessOrEqual\e\
    [0m = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWeightDiffLessOrEqual is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListWeightDi"
  stdout: ''
  timestamp: 1659800643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxPalindromic = q.reverse.forall(e => e == q(0))\n   \
    \     isBalanced && isPalindromic && isLessThanMax && isLessThanMaxPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbmd5cmvs.scala:29)\n\tat Problem.main(tmpbmd5cmvs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlipped = q.forall(x => x == q.reverse.head)\n\
    \        isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu89mz9_x.scala:28)\n\tat Problem.main(tmpu89mz9_x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q.reduceRight(_ + _))\n        val isLessOrEqual = maxSum <= maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy_j7dme0.scala:28)\n\tat Problem.main(tmpy_j7dme0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.isEmpty\n        val isBalanced = maxSum == maxWeight\n  \
    \      val isFlippable = isPalindromic && isBalanced\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n\
    \        val isLessThanMaxSumAndBalanced = isLessThanMaxWeight && isBalanced\n\
    \        val isLessThanMaxSumAndFlippable = isLessThanMaxWeight && isFlippable\n\
    \        isLessThanMaxSumAndBalanced || isLessThanMaxSumAndFlippable\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx79g3_e1.scala:32)\n\tat Problem.main(tmpx79g3_e1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isFlippable = maxWeight < maxSum\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndBalancedAndPalindromic\
    \ = isFlippableAndBalanced && isPalindromic\n        val isFlippableAndBalancedAndPalindromicAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight != 0\n        val isFlippableAndBalancedAndPalindromicAndNotNegative\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight < 0\n        val isFlippableAndBalancedAndPalindromicAndNotPositive\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight > 0\n        val isFlippableAndBalancedAndPalindromicAndNotNegativeOrZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight >= 0\n        val isFlippableAndBalancedAndPalindromicAndNotPositiveOrZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight <= 0\n        val isFlippableAndBalancedAndPalindromicAndNotNegativeOrZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight >= 0 && maxWeight != 0\n\
    \        val isFlippableAndBalancedAndPalindromicAndNotPositiveOrZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight <= 0 && maxWeight != 0\n\
    \        val isFlippableAndBalancedAndPalindromicAndNotNegativeOrZeroAndNotZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight >= 0 && maxWeight != 0 &&\
    \ maxWeight != 0\n        val isFlippableAndBalancedAndPalindromicAndNotPositiveOrZeroAndNotZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight <= 0 && maxWeight != 0 &&\
    \ maxWeight \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp49pvmbmb.scala:35:167\
    \ -------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36misFlippableAndBalancedAndPalindromicAndNotPositiveOrZeroAndNotZeroAndNotZero\e\
    [0m = isFlippableAndBalancedAndPalindromic && maxWeight <= \e[31m0\e[0m && maxWeight\
    \ != \e[31m0\e[0m && maxWeight \n\e[31m\e[31m   |\e[0m                       \
    \                                                                            \
    \                                                                    ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    (maxWeight\
    \ : Long)\n\e[31m   |\e[0m                                            Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp49pvmbmb.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.isReverse.forall(x => x == q(0))\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = isPalindromic && isBalanced\n      \
    \  isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2tbnooua.scala:22:30 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isReverse.forall(\e\
    [36mx\e[0m => x == q(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value isReverse is not a member of\
    \ List[Long] - did you mean q.reverse?\n1 error found\n"
  stdout: ''
  timestamp: 1659800642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong\n        val maxWeight = w.toLong\n        val\
    \ maxList = q.reverse\n        val maxListSum = maxList.foldLeft(0)(_ + _)\n \
    \       val maxListWeight = maxList.foldLeft(0)(_ + _)\n        val isBalanced\
    \ = maxListSum == maxWeight && maxListWeight <= maxSum\n        val isPalindromic\
    \ = maxList.reverse == maxList\n        val isFlippable = maxList.reverse == maxList.reverse\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndPalindromic\
    \ = isFlippable && isPalindromic\n        val isFlippableAndFlippable = isFlippable\
    \ && isFlippable\n        val isFlippableAndFlippableAndBalanced = isFlippable\
    \ && isFlippable && isBalanced\n        val isFlippableAndFlippableAndPalindromic\
    \ = isFlippable && isFlippable && isPalindromic\n        val isFlippableAndFlippableAndFlippable\
    \ = isFlippable && isFlippable && isFlippable\n        val isFlippableAndFlippableAndFlippableAndBalanced\
    \ = isFlippable && isFlippable && isFlippable && isBalanced\n        val isFlippableAndFlippableAndFlippableAndPalindromic\
    \ = isFlippable && isFlippable && isFlippable && isPalindromic\n        val isFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippable && isFlippable && isFlippable && isFlippable\n        val isFlippableAndFlippableAndFlippableAndFlippableAndBalanced\
    \ = isFlippable && isFlippable && isFlippable && isFlippable && isBalanced\n \
    \       val isFlippableAndFlippableAndFlippableAndFlippableAndPalindromic = isFlippable\
    \ && isFlippable && isFlippable \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprthgi_3h.scala:23:45\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e\
    [0m = maxList.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m           \
    \                                  ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                              Found:    Long\n\e[31m   |\e[0m               \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmprthgi_3h.scala:24:48 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeight\e[0m = maxList.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \           Found:    Long\n\e[31m   |\e[0m                                  \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprthgi_3h.scala:39:5 ---------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659800642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphzctx5x1.scala:28)\n\tat Problem.main(tmphzctx5x1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = maxSum / q.length\n        val maxWeightSumAbs = maxWeightSum.abs\n\
    \        val maxWeightSumAbsRemainder = maxWeightSumAbs % 1\n        val maxWeightSumAbsRemainderAbs\
    \ = maxWeightSumAbsRemainder.abs\n        val maxWeightSumAbsRemainderAbsRemainder\
    \ = maxWeightSumAbsRemainderAbs % 1\n        val maxWeightSumAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainder.abs\n        val maxWeightSumAbsRemainderAbsRemainderAbsRemainder\
    \ = maxWeightSumAbsRemainderAbsRemainderAbs % 1\n        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainder.abs\n        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainder\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbs % 1\n        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainder.abs\n       \
    \ val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs % 1\n    \
    \    val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder.abs\n\
    \        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder.abs\n\
    \        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAb\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa70bcetq.scala:34:99 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder\e\
    [0m = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder.abs\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa70bcetq.scala:35:114\
    \ -----------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs\e\
    [0m = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAb\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAb\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa70bcetq.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum < maxWeight\n        (isPalindromic && isBalanced)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpukve2dh5.scala:27)\n\tat Problem.main(tmpukve2dh5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sumOfElements <= maxWeight\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps6ah23p1.scala:26)\n\tat Problem.main(tmps6ah23p1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFly = isPalindromic && isBalanced\n   \
    \     val isNotFly = !isPalindromic || !isBalanced\n        isFly\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps274942b.scala:29)\n\tat Problem.main(tmps274942b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800644
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.foldLeft(0l) { (sum, element) =>\
    \ sum + element }\n        sumOfElements <= maxWeight && palindromic\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr5wmplgy.scala:27)\n\tat Problem.main(tmpr5wmplgy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlipped = q.tail.reverse.forall(_ == q.head)\n\
    \        isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzlhx4l0z.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessThanMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp93flmx5v.scala:28)\n\tat Problem.main(tmp93flmx5v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800651
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val balanced = palindromic && maxSum\
    \ < maxWeight\n        val unbalanced = palindromic && !balanced\n        (balanced\
    \ && unbalanced)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgvccfdzd.scala:28)\n\tat Problem.main(tmpgvccfdzd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight <= 0\n        val isFlipped = q.forall(_ < maxWeight)\n        (isPalindromic\
    \ && isBalanced && isFlipped)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp087abg9p.scala:28)\n\tat Problem.main(tmp087abg9p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFly = isPalindromic && isBalanced\n\
    \        val isNotFly = !isPalindromic && !isBalanced\n        isFly\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmti1fek8.scala:29)\n\tat Problem.main(tmpmti1fek8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ % 10 == 0)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlippable = palindromic && isBalanced\n        isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyy51kzxt.scala:28)\n\tat Problem.main(tmpyy51kzxt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm3h8cgj8.scala:28)\n\tat Problem.main(tmpm3h8cgj8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6cy3o_l4.scala:27)\n\tat Problem.main(tmp6cy3o_l4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        isBalanced && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl0ucybda.scala:29)\n\tat Problem.main(tmpl0ucybda.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q.reduceRight(_ + _))\n        (isBalanced && isPalindromic)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiw_8lp5u.scala:27)\n\tat Problem.main(tmpiw_8lp5u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        (isBalanced && isPalindromic)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0twd03cb.scala:27)\n\tat Problem.main(tmp0twd03cb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        q.reverse.foldLeft(true)(_\
    \ && {\n            val sum = 0\n            q.foreach(x => sum += x)\n      \
    \      sum < maxSum\n        })\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpmibg3eqo.scala:21:33 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        q.reverse.foldLeft(\e[31mtrue\e[0m)(_ && {\n\e\
    [31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m  \
    \                               Wrong number of parameters, expected: 2\n\e[31m22\
    \ |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = \e[31m0\e[0m\n\e[31m23 |\e\
    [0m            q.foreach(\e[36mx\e[0m => sum += x)\n\e[31m24 |\e[0m          \
    \  sum < maxSum\n\e[31m25 |\e[0m        })\n1 error found\n"
  stdout: ''
  timestamp: 1659800650
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q.reduceLeft(_ + _))\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < q.reduceLeft(_ + _)\n        isBalanced\
    \ && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0yu2jldn.scala:29)\n\tat Problem.main(tmp0yu2jldn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val maxList =\
    \ new mutable.ListBuffer[Long]()\n        q.foreach(x => maxList += x)\n     \
    \   val isPalindromic = maxList.reverse.forall(x => x == maxList(0))\n       \
    \ val isBalanced = maxList.sum == maxWeight\n        val isLessThanMax = maxSum\
    \ < maxWeight\n        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n\
    \        val isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n  \
    \      val isLessThanMaxAndNotPalindromic = isLessThanMax && !isPalindromic\n\
    \        val isLessThanMaxAndNotBalanced = isLessThanMax && !isBalanced\n    \
    \    val isLessThanMaxAndNotPalindromicAndNotBalanced = isLessThanMax && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic\n       \
    \ val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isBalanced\n        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isBalanced && !isPalindromic\n        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfcxpjc5y.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxList\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfcxpjc5y.scala:36:206\
    \ -----------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36misLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                                                            \
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0m                                                            Not\
    \ found: !\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfcxpjc5y.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sum = 0\n        for (i\
    \ <- 0 until q.length) {\n            sum += q(i)\n        }\n        sum < maxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprrtmbk80.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += q(i)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659800652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isWightBalanced = isPalindromic && isBalanced\n   \
    \     isWightBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6jmb8ip9.scala:28)\n\tat Problem.main(tmp6jmb8ip9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isLessThanMaxWeight = maxSum <\
    \ maxWeight\n        isBalanced && isPalindromic && isLessThanMaxWeight\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplymjojh1.scala:28)\n\tat Problem.main(tmplymjojh1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlippable = q.forall(x => x < maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7k0_zbka.scala:28)\n\tat Problem.main(tmp7k0_zbka.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n      \
    \  isBalanced && isPalindromic && isLessThanMaxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpolpl3s54.scala:28)\n\tat Problem.main(tmpolpl3s54.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        (isPalindromic && isBalanced)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdr0rsxs3.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList\
    \ = q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val\
    \ isBalanced = maxListSum == maxSum\n        val isPalindromic = maxList.reduceLeft(_\
    \ + _) == maxListSum\n        val isFlippable = maxList.reduceLeft(_ + _) <= maxWeight\n\
    \        isBalanced && isPalindromic && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpymn9qyfu.scala:30)\n\tat Problem.main(tmpymn9qyfu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800654
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isFlippable = q.forall(e =>\
    \ e != q(0))\n        isBalanced && isPalindromic && isFlippable\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1vul7c5_.scala:28)\n\tat Problem.main(tmp1vul7c5_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800655
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n   \
    \     val isPalindromic = q.reverse.forall(_ == q.head)\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3vcp27ys.scala:28)\n\tat Problem.main(tmp3vcp27ys.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800660
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        (isPalindromic && isBalanced)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5t_im8d7.scala:27)\n\tat Problem.main(tmp5t_im8d7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        val\
    \ isFlippableAndBalanced = isFlippable && isBalanced\n        isFlippableAndBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5p_4zh4v.scala:30)\n\tat Problem.main(tmp5p_4zh4v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800662
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < q.sum\n        isPalindromic && isBalanced && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpru_02qc9.scala:29)\n\tat Problem.main(tmpru_02qc9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n       \
    \ val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && maxWeight == maxSum\n        val isLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic = maxSum\
    \ < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isPalindromic && !isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isPalindromic && !isBalanced && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isPalindromic && !isBalanced && !isPalindromic && !isPalindromic\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isP\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7im9739m.scala:33:215 -----------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\e\
    [0m = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic\
    \ && !isP\n\e[31m\e[31m   |\e[0m                                             \
    \                                                                            \
    \                                                                            \
    \                  ^^^\e[0m\n\e[31m   |\e[0m                                 \
    \                         Not found: isP\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp7im9739m.scala:34:5 ---------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isBalanced = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isFlippable = q.forall(_ < maxWeight)\n        isBalanced\
    \ && isPalindromic && isFlippable\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcjqa8f70.scala:28)\n\tat Problem.main(tmpcjqa8f70.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum - maxWeight < 0\n        (isPalindromic && isBalanced)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpktu7bc70.scala:27)\n\tat Problem.main(tmpktu7bc70.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum,\
    \ elem) => sum + elem }\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7_3qukd7.scala:26)\n\tat Problem.main(tmp7_3qukd7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        (isPalindromic && isBalanced)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5t_im8d7.scala:27)\n\tat Problem.main(tmp5t_im8d7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfw73uwtw.scala:27)\n\tat Problem.main(tmpfw73uwtw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isLessOrEqualToMaxWeight = maxSum\
    \ < maxWeight\n        isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyi8e6v40.scala:28)\n\tat Problem.main(tmpyi8e6v40.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isFlippable = isPalindromic && isBalanced\n      \
    \  isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp06q2shyg.scala:28)\n\tat Problem.main(tmp06q2shyg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n   \
    \     val isPalindromic = q.reverse.forall(e => e == q(0))\n        isBalanced\
    \ && isPalindromic\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd1z_2mte.scala:27)\n\tat Problem.main(tmpd1z_2mte.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlipped = q.forall(_ < maxWeight)\n        isFlippable && isFlipped\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9isooqa9.scala:29)\n\tat Problem.main(tmp9isooqa9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum - maxWeight < 0\n        val isFlippable = q.forall(e\
    \ => e == q(q.length - 1))\n        isPalindromic && isBalanced && isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcddw50c8.scala:28)\n\tat Problem.main(tmpcddw50c8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpirodzlu8.scala:27)\n\tat Problem.main(tmpirodzlu8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindrome = q.reverse\n        val sum\
    \ = palindrome.sum\n        val maxSum = sum + maxWeight\n        val isBalanced\
    \ = palindrome.forall(x => x <= maxSum)\n        val isPalindrome = sum == maxSum\n\
    \        val isLessOrEqual = maxWeight <= sum\n        isBalanced && isPalindrome\
    \ && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc9pwq0mn.scala:30)\n\tat Problem.main(tmpc9pwq0mn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf2jne1ry.scala:28)\n\tat Problem.main(tmpf2jne1ry.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l){ (sum,\
    \ e) => sum + e }\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp32wcfwg6.scala:26)\n\tat Problem.main(tmp32wcfwg6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxButNotBalanced = isLessThanMax && !isBalanced\n    \
    \    val isLessThanMaxButBalanced = isLessThanMax && isBalanced\n        val isLessThanMaxButNotPalindromic\
    \ = isLessThanMax && !isPalindromic\n        val isLessThanMaxButPalindromic =\
    \ isLessThanMax && isPalindromic\n        (isLessThanMaxButNotBalanced || isLessThanMaxButBalanced\
    \ || isLessThanMaxButNotPalindromic || isLessThanMaxButPalindromic)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpllz2jx8o.scala:33)\n\tat Problem.main(tmpllz2jx8o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q.head)\n        val isBalanced = q.forall(x =>\
    \ x <= maxWeight && x >= maxSum - maxWeight)\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8q1aq8j3.scala:27)\n\tat Problem.main(tmp8q1aq8j3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqualToMaxWeight = maxSum\
    \ < maxWeight\n        isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxz7y8i_b.scala:28)\n\tat Problem.main(tmpxz7y8i_b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val sum = 0\n        val maxWeight\
    \ = w.toLong\n        val maxList = q.reverse\n        val maxListSize = maxList.size\n\
    \        val maxListSum = maxList.foldLeft(0)(_ + _)\n        val maxListWeight\
    \ = maxList.foldLeft(0)(_ * _)\n        val maxListSumLessOrEqual = maxListSum\
    \ <= maxWeight\n        val maxListWeightLessOrEqual = maxListWeight <= maxWeight\n\
    \        val maxListSumLessOrEqualAndBalanced = maxListSumLessOrEqual && maxListWeightLessOrEqual\n\
    \        val maxListWeightLessOrEqualAndBalanced = maxListWeightLessOrEqual &&\
    \ maxListSumLessOrEqual\n        val maxListSumLessOrEqualAndBalancedAndPalindromic\
    \ = maxListSumLessOrEqualAndBalanced && isPalindromic(maxList)\n        val maxListWeightLessOrEqualAndBalancedAndPalindromic\
    \ = maxListWeightLessOrEqualAndBalanced && maxListSumLessOrEqualAndBalancedAndPalindromic\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual = maxListSumLessOrEqualAndBalancedAndPalindromic\
    \ && !maxListWeightLessOrEqualAndBalanced\n        val maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual\
    \ = maxListWeightLessOrEqualAndBalancedAndPalindromic && !maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual\n\
    \        val maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual && !maxList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpahiwba0m.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\e\
    [0m = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual &&\
    \ !maxList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpahiwba0m.scala:25:45 --------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e[0m = maxList.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \     Found:    Long\n\e[31m   |\e[0m                                        \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpahiwba0m.scala:26:48\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeight\e\
    [0m = maxList.foldLeft(\e[31m0\e[0m)(_ * _)\n\e[31m\e[31m   |\e[0m           \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                    Found:    Long\n\e[31m   |\e[0m         \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpahiwba0m.scala:31:97 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumLessOrEqualAndBalancedAndPalindromic\e\
    [0m = maxListSumLessOrEqualAndBalanced && isPalindromic(maxLis"
  stdout: ''
  timestamp: 1659800664
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n     \
    \   val isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4r2gkvz_.scala:28)\n\tat Problem.main(tmp4r2gkvz_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isFly = isBalanced && isPalindromic && maxSum == maxWeight\n\
    \        val isNotFly = !isFly && maxSum < maxWeight\n        isFly || isNotFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjy1h4vgh.scala:30)\n\tat Problem.main(tmpjy1h4vgh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800666
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = maxSum - maxWeight < 0\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjycllzx2.scala:28)\n\tat Problem.main(tmpjycllzx2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList\
    \ = q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val\
    \ maxListWeight = maxList.reduceLeft(_ + _)\n        val maxListWeightSum = maxListWeight.reduceLeft(_\
    \ + _)\n        val maxListWeightSumLessOrEqualToMaxWeight = maxListWeightSum.let(maxWeight)\n\
    \        val maxListSumLessOrEqualToMaxSum = maxListSum.let(maxSum)\n        val\
    \ maxListSumLessOrEqualToMaxWeightAndBalanced = maxListSumLessOrEqualToMaxWeight\
    \ && maxListWeightSumLessOrEqualToMaxWeight\n        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromic\
    \ = maxListSumLessOrEqualToMaxWeightAndBalanced && !isPalindromic(maxList)\n \
    \       val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromic && !maxList.isEmpty\n\
    \        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmpty &&\
    \ !maxList.isEmpty && !maxList.isEmpty\n        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmpty\
    \ && !maxList.isEmpty && !maxList.isEmpty && !maxList.isEmpty\n        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmpty\
    \ && !maxList.isEmpty && !maxList.isEmpty && !maxList.isEmpty && !maxList.isEmpty\n\
    \        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNot\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxgtc8xkr.scala:25:45 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightSum\e[0m =\
    \ maxListWeight.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m                     \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \           value reduceLeft is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpxgtc8xkr.scala:27:55 ------------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumLessOrEqualToMaxSum\e[0m\
    \ = maxListSum.let(maxSum)\n\e[31m\e[31m   |\e[0m                            \
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \               value let is not a member of Long\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpxgtc8xkr.scala:28:58 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxListSumLessOrEqualToMaxWeightAndBalanced\e\
    [0m = maxListSumLessOrEqualToMaxWeight && maxListWeightSumLessOrEqualToMaxWeight\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \         Not found: maxListSumLessOrEqualToMaxWeight\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxgtc8xkr.scala:34:130 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty\e\
    [0m = maxListSumLessOrEqualToMaxWeightAndBalancedAndNot\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: maxListSumLessOrEqualToMaxWeightAndBalancedAndNot\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxgtc8xkr.scala:35:5\
    \ ---------------------\e["
  stdout: ''
  timestamp: 1659800671
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sumOfElements = q.foldLeft(0l)\
    \ { (acc, x) => acc + x }\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isFly = palindromic && isBalanced\n        isFly\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg68dplhk.scala:30)\n\tat Problem.main(tmpg68dplhk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlippable\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8qyuvag.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic\
    \ && isBalanced\n        val isNotFly = !isFly\n        isFly\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvle32t8l.scala:29)\n\tat Problem.main(tmpvle32t8l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800673
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val sums = q.map(_.toLong).sum\n\
    \        sums <= maxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_vtjk1eg.scala:26)\n\tat Problem.main(tmp_vtjk1eg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800674
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzkaxg612.scala:28)\n\tat Problem.main(tmpzkaxg612.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isFlippable = q.forall(x => x\
    \ == q.last)\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        isFlippableAndBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpewhnk7o8.scala:29)\n\tat Problem.main(tmpewhnk7o8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlipped = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlipped\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoenihkw8.scala:28)\n\tat Problem.main(tmpoenihkw8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFlippable = q.forall(x => x == q(0))\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        isFlippableAndBalanced\
    \ && isPalindromic\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplxwv0inh.scala:29)\n\tat Problem.main(tmplxwv0inh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800676
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfw73uwtw.scala:27)\n\tat Problem.main(tmpfw73uwtw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800663
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp73awhp6b.scala:28)\n\tat Problem.main(tmp73awhp6b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        (isBalanced && isPalindromic)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpshhb_l3n.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val maxList =\
    \ q.max\n        val maxListSize = maxList.size\n        val maxListSum = maxList.sum\n\
    \        val maxListSumLessOrEqualToMaxWeight = maxListSum < maxWeight\n     \
    \   val maxListSumGreaterOrEqualToMaxWeight = maxListSum > maxWeight\n       \
    \ val maxListIsPalindromic = maxList.reverse == maxList\n        val maxListIsPalindromicAndLessOrEqualToMaxWeight\
    \ = maxListIsPalindromic && maxListSumLessOrEqualToMaxWeight\n        val maxListIsPalindromicAndGreaterOrEqualToMaxWeight\
    \ = maxListIsPalindromic && maxListSumGreaterOrEqualToMaxWeight\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalanced\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeight && maxListSize <= maxListSum\n\
    \        val maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalanced = maxListIsPalindromicAndGreaterOrEqualToMaxWeight\
    \ && maxListSize >= maxListSum\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmpty\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalanced && maxListSize >\
    \ 0\n        val maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalancedAndIsNotEmpty\
    \ = maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalanced && maxListSize\
    \ > 0\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmpty && maxListSize\
    \ > 0\n        val maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\
    \ = maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalancedAndIsNotEmpty &&\
    \ maxListSize > 0\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAnd\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk5hnd_h9.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmaxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\e\
    [0m = maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAnd\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpk5hnd_h9.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxListSize\e[0m = maxList.size\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value size is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpk5hnd_h9.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e[0m = maxList.sum\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value sum is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpk5hnd_h9.scala:27:43 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxListIsPalindromic\e[0m = maxList.reverse\
    \ == maxList\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value reverse is not a\
    \ member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk5hnd_h9.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m "
  stdout: ''
  timestamp: 1659800675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFlippable = q.tail.forall(x => maxWeight\
    \ - x < 0)\n        isPalindromic && isBalanced && isFlippable\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_revm1v3.scala:28)\n\tat Problem.main(tmp_revm1v3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800676
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        val isNotFly\
    \ = !palindromic && !isBalanced\n        isFly || isNotFly\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp13h29ayk.scala:30)\n\tat Problem.main(tmp13h29ayk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800676
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight <= 0\n        val isWon = isPalindromic && isBalanced\n\
    \        val isLost = !isPalindromic && !isBalanced\n        isWon || isLost\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4kfzi9_h.scala:29)\n\tat Problem.main(tmp4kfzi9_h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800676
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindrome = q.reverse.forall(x => x !=\
    \ 0)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindrome && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppinscrvk.scala:29)\n\tat Problem.main(tmppinscrvk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic\n        val isLessThanMaxPalindromicAndBalanced\
    \ = maxSum < maxWeight && isPalindromic && isBalanced\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax\n     \
    \   val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromic = maxSum\
    \ < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax && isPalindromic\n      \
    \  val isLess\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpra7z4v4b.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpra7z4v4b.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphzctx5x1.scala:28)\n\tat Problem.main(tmphzctx5x1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n     \
    \   val isBalanced = maxSum - maxWeight < 0\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprg02k0ym.scala:27)\n\tat Problem.main(tmprg02k0ym.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList\
    \ = q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val\
    \ maxListWeight = maxList.sum\n        val maxListWeightSum = maxListWeight.toLong\n\
    \        val maxListWeightDiff = maxListWeight - maxListWeightSum\n        val\
    \ maxListWeightDiffSum = maxListWeightDiff.toLong\n        val maxListWeightDiffDiff\
    \ = maxListWeightDiff - maxListWeightDiffSum\n        val maxListWeightDiffDiffSum\
    \ = maxListWeightDiffDiff.toLong\n        val maxListWeightDiffDiffDiff = maxListWeightDiffDiffSum\
    \ - maxListWeightDiffSum\n        val maxListWeightDiffDiffDiffSum = maxListWeightDiffDiffDiff.toLong\n\
    \        val maxListWeightDiffDiffDiffDiff = maxListWeightDiffDiffDiffSum - maxListWeightDiffSum\n\
    \        val maxListWeightDiffDiffDiffDiffSum = maxListWeightDiffDiffDiffDiff.toLong\n\
    \        val maxListWeightDiffDiffDiffDiffDiff = maxListWeightDiffDiffDiffDiffSum\
    \ - maxListWeightDiffSum\n        val maxListWeightDiffDiffDiffDiffDiffSum = maxListWeightDiffDiffDiffDiffDiff.toLong\n\
    \        val maxListWeightDiffDiffDiffDiffDiffDiff = maxListWeightDiffDiffDiffDiffDiffSum\
    \ - maxListWeightDiffSum\n        val maxListWeightDiffDiffDiffDiffDiffDiffSum\
    \ = maxListWeightDiffDiffDiffDiffDiffDiffDiff.toLong\n        val maxListWeightDiffDiffDiffDiffDiffDiffDiff\
    \ = maxListWeightDiffDiffDiffDiffDiffDiffDiffSum - maxListWeightDiffSum\n    \
    \    val maxListWeightDiffDiffDiffDiffDiffDiffDiffSum = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiff.toLong\n\
    \        val maxListWeightDiffDiffDiffDiffDiffDiffDiffDiff = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffSum\
    \ - maxListWeightDiffSum\n        val maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffSum\
    \ = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiff.toLong\n        val\
    \ maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffSum = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\
    \ - maxListWeightDiffSum\n        val maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\
    \ = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp99bqlgeo.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\e\
    [0m = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffSum is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp99bqlgeo.scala:41:63 ------------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightDiffDiffDiffDiffDiffDiffDiffDiffSum\e\
    [0m = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiff.toLong\n\e[31m\e[31m\
    \   |\e[0m                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiff\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp99bqlgeo.scala:42:67\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\e[0m = maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\
    \ - maxListWeightDiffSum\n\e[31m\e[31m   |\e[0m                              \
    \                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m     Not found: maxListWeightDiffDiffDiffDiffDiffDiffDiffDiffDiffDiffSum\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp99bqlgeo.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659800674
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFlipped\
    \ = q.forall(elem => elem != q.head)\n        isPalindromic && isBalanced && isFlipped\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb2pxljjb.scala:28)\n\tat Problem.main(tmpb2pxljjb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotPalindromic\
    \ = maxSum < maxWeight && !isPalindromic\n        val isLessThanMaxButPalindromic\
    \ = maxSum < maxWeight && isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButPalindromicAndNotBalanced\
    \ = maxSum < maxWeight && isPalindromic && !isBalanced\n        val isLessThanMaxButPalindromicAndBalanced\
    \ = maxSum < maxWeight && isPalindromic && isBalanced\n        val isLessThanMaxButPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && isPalindromic && !isPalindromic\n        val isLessThanMaxButPalindromicAndPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalin\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfodxde_3.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfodxde_3.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfodxde_3.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalin\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfodxde_3.scala:21:35 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e[0m = "
  stdout: ''
  timestamp: 1659800676
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n  \
    \      val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(e\
    \ => e < maxWeight)\n        isPalindromic && isBalanced && isFlippable\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprqvg0x54.scala:28)\n\tat Problem.main(tmprqvg0x54.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800678
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x == q.reverse.head)\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        isPalindromic\
    \ && isBalanced && isFlippableAndBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe_8bhedk.scala:29)\n\tat Problem.main(tmpe_8bhedk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800681
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic\
    \ = q.isReverse.forall(x => x == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlipped = q.isReverse.forall(x => x == q(q.size - 1))\n       \
    \ isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpywcvezx5.scala:22:30 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isReverse.forall(\e\
    [36mx\e[0m => x == q(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value isReverse is not a member of\
    \ List[Long] - did you mean q.reverse?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpywcvezx5.scala:24:26 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33mval\e[0m \e[36misFlipped\e[0m = q.isReverse.forall(\e[36mx\e\
    [0m => x == q(q.size - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                 \
    \       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value isReverse is not a member of List[Long]\
    \ - did you mean q.reverse?\n2 errors found\n"
  stdout: ''
  timestamp: 1659800683
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isWight = maxWeight <= q.size\n        val\
    \ isWightBalanced = isWight && isBalanced\n        (isPalindromic && isWightBalanced)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpymzxohne.scala:29)\n\tat Problem.main(tmpymzxohne.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList\
    \ = q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val\
    \ maxListWeight = maxList.reduceLeft(_ + _)\n        val maxListWeightSum = maxListWeight.reduceLeft(_\
    \ + _)\n        val maxListSumWeight = maxListSum.reduceLeft(_ + _)\n        val\
    \ maxListSumWeightSum = maxListSumWeight.reduceLeft(_ + _)\n        val maxListWeightSum\
    \ = maxListWeight.reduceLeft(_ + _)\n        val maxListSumWeightSum = maxListSumWeight.reduceLeft(_\
    \ + _)\n        val maxListWeightSum = maxListWeight.reduceLeft(_ + _)\n     \
    \   val maxListSumWeightSum = maxListSumWeight.reduceLeft(_ + _)\n        val\
    \ maxListWeightSum = maxListWeight.reduceLeft(_ + _)\n        val maxListSumWeightSum\
    \ = maxListSumWeight.reduceLeft(_ + _)\n        val maxListWeightSum = maxListWeight.reduceLeft(_\
    \ + _)\n        val maxListSumWeightSum = maxListSumWeight.reduceLeft(_ + _)\n\
    \        val maxListWeightSum = maxListWeight.reduceLeft(_ + _)\n        val maxListSumWeightSum\
    \ = maxListSumWeight.reduceLeft(_ + _)\n        val maxListWeightSum = maxListWeight.reduceLeft(_\
    \ + _)\n        val maxListSumWeightSum = maxListSumWeight.reduceLeft(_ + _)\n\
    \        val maxListWeightSum = maxListWeight.reduceLeft(_ + _)\n        val maxListSumWeightSum\
    \ = maxListSumWeight.reduceLeft(_ + _)\n        val maxListWeightSum = maxListWeight.reduceLeft(_\
    \ + _)\n        val maxListSumWeightSum = maxListSumWeight.reduceLeft(_ + _)\n\
    \        val maxListWeightSum = maxListWeight.reduceLeft(_ + _)\n        val maxListSumWeightSum\
    \ = maxListSumWeight.reduceLeft(_ + _)\n        val maxListWeightSum = maxListWeight.reduceLe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppc4yeuj0.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightSum\e[0m =\
    \ maxListWeight.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWeightSum is already defined as \e[33mvalue\e[0m \e\
    [35mmaxListWeightSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppc4yeuj0.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumWeightSum\e[0m\
    \ = maxListSumWeight.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumWeightSum is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxListSumWeightSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppc4yeuj0.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightSum\e[0m =\
    \ maxListWeight.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListWeightSum is already defined as \e[33mvalue\e[0m \e\
    [35mmaxListWeightSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppc4yeuj0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumWeightSum\e[0m\
    \ = maxListSumWeight.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumWeightSum is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxListSumWeightSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppc4yeuj0.scala"
  stdout: ''
  timestamp: 1659800683
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFly = isPalindromic && isBalanced\n        val result\
    \ = isFly\n        println(s\"$result $q ${q.sum} $maxSum $maxWeight $isPalindromic\
    \ $isBalanced\")\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpn6zxbv06.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1659800680
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlipped = q.forall(_ < maxWeight)\n        (isPalindromic\
    \ && isBalanced && isFlipped)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp66t690y7.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1659800682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlippable\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmplvzkg7fj.scala:22:45 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n1 error found\n"
  stdout: ''
  timestamp: 1659800682
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9tkkvw5g.scala:27)\n\tat Problem.main(tmp9tkkvw5g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isBalanced = maxSum < maxWeight\n        val isPalindromic = q.isEmpty\
    \ || q.reverse.forall(x => x == q(0))\n        val isFlippable = q.forall(x =>\
    \ x == q.reverse(0))\n        isBalanced && isPalindromic && isFlippable\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcl4fp7il.scala:28)\n\tat Problem.main(tmpcl4fp7il.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val balanced = palindromic && q.sum\
    \ == maxSum\n        val unbalanced = palindromic && !balanced\n        val isFlight\
    \ = balanced && unbalanced\n        isFlight\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprokyx4dx.scala:29)\n\tat Problem.main(tmprokyx4dx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val\
    \ isBalanced = q.reduceLeft(_ + _) <= maxWeight\n        val isFlippable = q.forall(x\
    \ => x > maxWeight)\n        isPalindromic && isBalanced && isFlippable\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpefaxys_n.scala:28)\n\tat Problem.main(tmpefaxys_n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val sumOfElements = q.sum\n       \
    \ val isBalanced = sumOfElements <= maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isFlippable = q.forall(x => x > maxWeight)\n    \
    \    val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable =\
    \ q.forall(x => x > maxWeight)\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable\
    \ = q.forall(x => x > maxWeight)\n        val isFlippable = q.forall(x => x >\
    \ maxWeight)\n        val isFlippable = q.forall(x => x > maxWeight)\n       \
    \ val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable = q.forall(x\
    \ => x > maxWeight)\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable\
    \ = q.forall(x => x > maxWeight)\n        val isFlippable = q.forall(x => x >\
    \ maxWeight)\n        val isFlippable = q.forall(x => x > maxWeight)\n       \
    \ val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable = q.forall(x\
    \ => x > maxWeight)\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable\
    \ = q.forall(x => x > maxWeight)\n        val isFlippable = q.forall(x => x >\
    \ maxWeight)\n        val isFlippable = q.forall(x => x > maxWeight)\n       \
    \ val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable = q.forall(x\
    \ => x > maxWeight)\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        val isFlippable = q.forall(x => x > maxWeight)\n        val isFlippable\
    \ = q.forall(x => x > maxWeight)\n        val is\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5s7eapg5.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5s7eapg5.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36misFlippable\e[0m = q.forall(\e[36mx\e[0m => x > maxWeight)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5s7eapg5.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.forall(\e[36mx\e\
    [0m => x > maxWeight)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5s7eapg5.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.forall(\e[36mx\e\
    [0m => x > maxWeight)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5s7eapg5.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.forall(\e[36mx\e\
    [0m => x > maxWeight)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same"
  stdout: ''
  timestamp: 1659800686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(elem => elem == q(0))\n        val isLessOrEqual = maxSum\
    \ < maxWeight\n        (isBalanced && isPalindromic && isLessOrEqual)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwbh2mnp5.scala:28)\n\tat Problem.main(tmpwbh2mnp5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = q.length == maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessThanMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk21rcgg_.scala:28)\n\tat Problem.main(tmpk21rcgg_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.sum\n        val isBalanced\
    \ = sumOfElements <= maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isFlippable = q.forall(x => x > maxWeight)\n    \
    \    val isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndPalindromic\
    \ = isFlippable && isPalindromic\n        val isFlippableAndFlippableAndBalanced\
    \ = isFlippableAndBalanced && isFlippable\n        val isFlippableAndFlippableAndPalindromic\
    \ = isFlippableAndPalindromic && isFlippable\n        val isFlippableAndFlippableAndFlippableAndBalanced\
    \ = isFlippableAndFlippableAndBalanced && isFlippableAndFlippable\n        val\
    \ isFlippableAndFlippableAndFlippableAndPalindromic = isFlippableAndFlippableAndPalindromic\
    \ && isFlippableAndFlippable\n        val isFlippableAndFlippableAndFlippableAndFlippableAndBalanced\
    \ = isFlippableAndFlippableAndFlippableAndBalanced && isFlippableAndFlippableAndFlippable\n\
    \        val isFlippableAndFlippableAndFlippableAndFlippableAndPalindromic = isFlippableAndFlippableAndFlippableAndPalindromic\
    \ && isFlippableAndFlippableAndFlippableAndPalindromic\n        val isFlippableAndFlippableAndFlippableAndFlippableAndFlippableAndBalanced\
    \ = isFlippableAndFlippableAndFlippableAndFlippableAndBalanced && isFlippableAndFlippableAndFlippableAndFlippableAndBalanced\n\
    \        val isFlippableAndFlippableAndFlippableAndFlippableAndFlippableAndPalindromic\
    \ = isFli\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt9jj40pw.scala:29:99 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misFlippableAndFlippableAndFlippableAndBalanced\e\
    [0m = isFlippableAndFlippableAndBalanced && isFlippableAndFlippable\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      Not found: isFlippableAndFlippable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt9jj40pw.scala:30:105\
    \ -----------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36misFlippableAndFlippableAndFlippableAndPalindromic\e[0m = isFlippableAndFlippableAndPalindromic\
    \ && isFlippableAndFlippable\n\e[31m\e[31m   |\e[0m                          \
    \                                                                            \
    \   ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \          Not found: isFlippableAndFlippable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpt9jj40pw.scala:31:123 -----------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36misFlippableAndFlippableAndFlippableAndFlippableAndBalanced\e\
    [0m = isFlippableAndFlippableAndFlippableAndBalanced && isFlippableAndFlippableAndFlippable\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Not found: isFlippableAndFlippableAndFlippable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt9jj40pw.scala:34:88\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36misFlippableAndFlippableAndFlippableAndFlippableAndFlippableAndPalindromic\e\
    [0m = isFli\n\e[31m\e[31m   |\e[0m      "
  stdout: ''
  timestamp: 1659800686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8ghp9u2s.scala:28)\n\tat Problem.main(tmp8ghp9u2s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList\
    \ = q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val\
    \ maxListWeight = maxList.sum\n        val maxListWeightSum = maxListWeight.toLong\n\
    \        val maxListSumLessOrEqual = maxListSum <= maxWeight\n        val maxListWeightLessOrEqual\
    \ = maxListWeight <= maxWeight\n        val maxListWeightLessOrEqualEqual = maxListWeightLessOrEqual\
    \ && maxListWeightLessOrEqual\n        val maxListSumLessOrEqualEqual = maxListSumLessOrEqual\
    \ && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n        val maxListSumLessOrEqualEqualEqual\
    \ = maxList\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl0syu_5u.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxListSumLessOrEqualEqualEqual\e\
    [0m = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumLessOrEqualEqualEqual is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListSumLessOrEqualEqualEqual\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl0syu_5u.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListSumLessOrEqualEqualEqual\e[0m = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumLessOrEqualEqualEqual is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListSumLessOrEqualEqualEqual\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl0syu_5u.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListSumLessOrEqualEqualEqual\e[0m = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumLessOrEqualEqualEqual is already defined as \e[33mvalue\e\
    [0m \e[35mmaxListSumLessOrEqualEqualEqual\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl0syu_5u.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListSumLessOrEqualEqualEqual\e[0m = maxListSumLessOrEqual && maxListWeightLessOrEqualEqual\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^"
  stdout: ''
  timestamp: 1659800686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val balanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !balanced\n        isPalindromic && isLessThanMax &&\
    \ isLessThanMaxButNotBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp357wvq25.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyxbw4qq8.scala:27)\n\tat Problem.main(tmpyxbw4qq8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l) { (sum,\
    \ element) => sum + element }\n        sumOfElements <= maxWeight && q.isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8l0hdv8_.scala:22:40 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        sumOfElements <= maxWeight && q.isBalanced\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          value isBalanced is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800687
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val sum = 0\n        val maxWeight\
    \ = w.toLong\n        val maxList = q.reverse\n        val maxListSize = maxList.size\n\
    \        val maxListSum = maxList.foldLeft(0)(_ + _)\n        val maxListWeight\
    \ = maxList.foldLeft(0)(_ * _)\n        val maxListSumLessOrEqual = maxListSum\
    \ <= maxWeight\n        val maxListWeightLessOrEqual = maxListWeight <= maxWeight\n\
    \        val maxListSumLessOrEqualAndMaxWeightLessOrEqual = maxListSumLessOrEqual\
    \ && maxListWeightLessOrEqual\n        val maxListWeightLessOrEqualAndMaxWeightLessOrEqual\
    \ = maxListWeightLessOrEqual && maxListSumLessOrEqual\n        val maxListSumLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqual\
    \ = maxListSumLessOrEqualAndMaxWeightLessOrEqual && maxListWeightLessOrEqualAndMaxListSizeLessOrEqual\n\
    \        val maxListWeightLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqual\
    \ = maxListWeightLessOrEqualAndMaxListSizeLessOrEqual && maxListSumLessOrEqualAndMaxWeightLessOrEqual\n\
    \        val maxListSumLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqualAndMaxListSumLessOrEqualAndMaxListWeightLessOrEqualAndMaxListSize\
    \ = maxListSumLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqualAndMaxListSumLessOrEqualAndMaxListWeightLessOrEqualAndMaxListSize\n\
    \        val maxListWeightLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqualAndMaxListSumLessOrEqualAndMaxListWeightLessOrEqualAndMaxListWeight\
    \ = maxListWeightLessOrEqualAndMaxListSizeLessOrEqualAndMaxListSumLessOrEqualAndMaxListWeightLessOrEqualAndMaxListWeight\n\
    \        val maxListSumLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqualAndMaxListSumLessOrEqualAndMaxListWeightLessOrEqualAndMaxListWeightLessOrEqualAndMaxListSumLessOrEqualAndMaxListWeightLessOrEqualAndMaxListWeight\
    \ = maxListSumLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqualAndMaxListSumLessOrEqualAndMaxListWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_l908yel.scala:25:45\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e\
    [0m = maxList.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m           \
    \                                  ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                              Found:    Long\n\e[31m   |\e[0m               \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp_l908yel.scala:26:48 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeight\e[0m = maxList.foldLeft(\e\
    [31m0\e[0m)(_ * _)\n\e[31m\e[31m   |\e[0m                                    \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \           Found:    Long\n\e[31m   |\e[0m                                  \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_l908yel.scala:31:132 -----------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        \e[33mval\e[0m \e[36mmaxListSumLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqual\e\
    [0m = maxListSumLessOrEqualAndMaxWeightLessOrEqual && maxListWeightLessOrEqualAndMaxListSizeLessOrEqual\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: maxListWeightLessOrEqualAndMaxListSizeLessOrEqual\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_l908yel.scala:32:87\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListWeightLessOrEqualAndMaxWeightLessOrEqualAndMaxListSizeLessOrEqual\e\
    [0m = maxListWeightLessOrEqualAndMaxListSizeLessOrEqual && maxListSumLessOrEqualAndMaxWeightLessOrEqual\n\
    \e[31m\e[31m   |\e[0m                   "
  stdout: ''
  timestamp: 1659800687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlippable = q.tail.forall(x => maxSum - x\
    \ <= maxWeight)\n        isPalindromic && isBalanced && isFlippable\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0i3bv3wc.scala:28)\n\tat Problem.main(tmp0i3bv3wc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbj9o4eqz.scala:27)\n\tat Problem.main(tmpbj9o4eqz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphzctx5x1.scala:28)\n\tat Problem.main(tmphzctx5x1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ elem) => sum + elem }\n        val isBalanced = maxSum == maxWeight\n      \
    \  val isPalindromic = q.reverse.forall(elem => elem == q.head)\n        val isLessOrEqual\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessOrEqual\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsmvo0ywd.scala:28)\n\tat Problem.main(tmpsmvo0ywd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val\
    \ isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight && isPalindromic\n        !isBalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpudssrolx.scala:28)\n\tat Problem.main(tmpudssrolx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic\
    \ = q.isEmpty\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n \
    \       val isFlippable = q.tail.isEmpty && q.head == q.last\n        val isFlippableAndBalanced\
    \ = isFlippable && isBalanced\n        val isFlippableAndPalindromic = isFlippable\
    \ && isPalindromic\n        val isFlippableAndNotBalanced = isFlippable && !isBalanced\n\
    \        val isFlippableAndNotPalindromic = isFlippable && !isPalindromic\n  \
    \      val isFlippableAndNotBalancedAndNotPalindromic = isFlippable && !isBalanced\
    \ && !isPalindromic\n        val isFlippableAndNotBalancedAndNotPalindromicAndNotFlippable\
    \ = isFlippable && !isBalanced && !isPalindromic && !isFlippable\n        val\
    \ isFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotFlippable = isFlippable\
    \ && !isBalanced && !isPalindromic && !isFlippable && !isFlippable\n        val\
    \ isFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotFlippableAndNotFlippable\
    \ = isFlippable && !isBalanced && !isPalindromic && !isFlippable && !isFlippable\
    \ && !isFlippable && !isFlippable\n        val isFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotFlippableAndNotFlippableAndNotFlippable\
    \ = isFlippable && !isBalanced && !isPalindromic && !isFlippable && !isFlippable\
    \ && !isFlippable && !isFlippable && !isFlippable\n        val isFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotFlippableAndNotFlippableAndNotFlippableAndNotFlippable\
    \ = isFlippable && !isBalanced && !isPalindro\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoibhbpyq.scala:34:163 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36misFlippableAndNotBalancedAndNotPalindromicAndNotFlippableAndNotFlippableAndNotFlippableAndNotFlippableAndNotFlippable\e\
    [0m = isFlippable && !isBalanced && !isPalindro\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                                                                            \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \           Not found: isPalindro\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpoibhbpyq.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduce(_ + _)\n    \
    \    val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvu86gf72.scala:27)\n\tat Problem.main(tmpvu86gf72.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum\
    \ < maxWeight\n        (isPalindromic && isBalanced)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf3c3tshc.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpf3c3tshc.scala:22:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36misPalindromic\e[0m = q.reverse.forall(_ == _)\n\e[31m\e[31m   |\e[0m \
    \                                            ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                             Wrong number of parameters, expected: 1\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800693
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        (isBalanced && isPalindromic && isLessOrEqual)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2a6559_a.scala:28)\n\tat Problem.main(tmp2a6559_a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800694
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val sum = 0\n        val maxWeight\
    \ = w.toLong\n        val maxList = q.reverse\n        val maxListSize = maxList.size\n\
    \        val maxListSum = maxList.foldLeft(0)(_ + _)\n        val maxListWeight\
    \ = maxList.foldLeft(0)(_ * _)\n        val maxListSumLessOrEqual = maxListSum\
    \ <= maxWeight\n        val maxListWeightLessOrEqual = maxListWeight <= maxWeight\n\
    \        val maxListSumLessOrEqualAndBalanced = maxListSumLessOrEqual && maxListWeightLessOrEqual\n\
    \        val maxListWeightLessOrEqualAndBalanced = maxListWeightLessOrEqual &&\
    \ maxListSumLessOrEqual\n        val maxListSumLessOrEqualAndBalancedAndPalindromic\
    \ = maxListSumLessOrEqualAndBalanced && isPalindromic(maxList)\n        val maxListWeightLessOrEqualAndBalancedAndPalindromic\
    \ = maxListWeightLessOrEqualAndBalanced && isPalindromic(maxList)\n        val\
    \ maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual = maxListSumLessOrEqualAndBalancedAndPalindromic\
    \ && !maxListWeightLessOrEqualAndBalanced\n        val maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual\
    \ = maxListWeightLessOrEqualAndBalancedAndPalindromic && !maxListSumLessOrEqualAndBalanced\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListWeightLessOrEqualAndBalancedAndPalindromic\n\
    \        val maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListSumLessOrEqualAndBalancedAndPalindromic\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual\n\
    \        val maxListWeightLessOrEqualAndBalance\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpccvejqx0.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpccvejqx0.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\e\
    [0m = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpccvejqx0.scala:25:45 --------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e[0m = maxList.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \         ^^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \     Found:    Long\n\e[31m   |\e[0m                                        \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpccvejqx0.scala:26:48\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeight\e\
    [0m = maxList.foldLeft(\e[31m0\e[0m)(_ * _)\n\e[31m\e[31m   |\e[0m           \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                    Found:    Long\n\e[31m   |\e[0m         \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available whe"
  stdout: ''
  timestamp: 1659800694
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sumOfElements = q.sum\n\
    \        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = !palindromic && sumOfElements <= maxSum\n        isBalanced && isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_c27wu8d.scala:29)\n\tat Problem.main(tmp_c27wu8d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n     \
    \   val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x == q(0))\n \
    \       val isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndPalindromic\
    \ = isFlippable && isPalindromic\n        val isFlippableAndBalancedAndPalindromic\
    \ = isFlippableAndBalanced && isPalindromic\n        val isFlippableAndBalancedAndPalindromicAndFlippable\
    \ = isFlippableAndBalancedAndPalindromic && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippable\
    \ = isFlippableAndBalancedAndPalindromicAndFlippable && isFlippable\n        val\
    \ isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippable = isFlippableAndBalancedAndPalindromicAndFlippableAndFlippable\
    \ && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippable &&\
    \ isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippable\
    \ && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippableAndBalancedAndPalindromicAndFlippableAndFli\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppuwt9w_s.scala:33:123 -----------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36misFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFlippableAndFlippableAndFlippable\e\
    [0m = isFlippableAndBalancedAndPalindromicAndFlippableAndFli\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       Not found: isFlippableAndBalancedAndPalindromicAndFlippableAndFli\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppuwt9w_s.scala:34:5\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800695
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum - maxWeight < 0\n        isPalindromic && isBalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2mypcae.scala:27)\n\tat Problem.main(tmpl2mypcae.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlipped = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlipped\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoenihkw8.scala:28)\n\tat Problem.main(tmpoenihkw8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800675
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight < 0\n        val isFlippable = q.forall(_ < maxWeight)\n       \
    \ isPalindromic && isBalanced && isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfav47ly0.scala:28)\n\tat Problem.main(tmpfav47ly0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800697
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9tkkvw5g.scala:27)\n\tat Problem.main(tmp9tkkvw5g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800631
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val palindromic = q.reverse.forall(x => x\
    \ == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj7dgil0r.scala:29)\n\tat Problem.main(tmpj7dgil0r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val palindromic = q.reverse.forall(x\
    \ => x.toLong == x)\n        val sumOfElements = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        sumOfElements <= maxWeight && palindromic\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn3j_qwhg.scala:27)\n\tat Problem.main(tmpn3j_qwhg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n\
    \        val maxWeightSum = w.toLong * q.length\n        val maxWeightSum2 = w.toLong\
    \ * q.length * q.length\n        val maxWeightSum3 = w.toLong * q.length * q.length\
    \ * q.length\n        val maxWeightSum4 = w.toLong * q.length * q.length * q.length\
    \ * q.length\n        val maxWeightSum5 = w.toLong * q.length * q.length * q.length\
    \ * q.length * q.length\n        val maxWeightSum6 = w.toLong * q.length * q.length\
    \ * q.length * q.length * q.length * q.length\n        val maxWeightSum7 = w.toLong\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\n\
    \        val maxWeightSum8 = w.toLong * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length\n        val maxWeightSum9\
    \ = w.toLong * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length\n        val maxWeightSum10 = w.toLong\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length\n        val maxWeightSum11 = w.toLong\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length\n        val\
    \ maxWeightSum12 = w.toLong * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length\n        val maxWeightSum13 = w.toLong * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\n\
    \        val maxWeightSum14 = w.toLong * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmphg7265p9.scala:35:203 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSum14\e[0m = w.toLong\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((q : List[Long]))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphg7265p9.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n\
    \        val sum = 0\n        val maxSumOfWeight = 0\n        val maxSumOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeight = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeight = 0\n      \
    \  val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight = 0\n        val\
    \ maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight = 0\n       \
    \ val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight =\
    \ 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeight\
    \ = 0\n        val maxSumOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOfWeightOf\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8pqglmel.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp8pqglmel.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7h8wkcc5.scala:28)\n\tat Problem.main(tmp7h8wkcc5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n     \
    \   val isBalanced = maxSum - maxWeight <= 0\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp85ekzfp.scala:28)\n\tat Problem.main(tmpp85ekzfp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800697
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        isBalanced && isPalindromic\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp320v474w.scala:27)\n\tat Problem.main(tmp320v474w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800697
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.reduce(_ + _)\n    \
    \    val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - q.sum <= maxWeight\n        val isFlipped = q.forall(x => x < maxWeight)\n\
    \        isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2pgof36l.scala:28)\n\tat Problem.main(tmp2pgof36l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum,\
    \ e) => sum + e }\n        val isBalanced = maxSum == 0 || maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7qagcmpn.scala:28)\n\tat Problem.main(tmp7qagcmpn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val balanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        (balanced && isPalindromic)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiisa9rxx.scala:27)\n\tat Problem.main(tmpiisa9rxx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) =>\
    \ sum + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        (isBalanced && isPalindromic)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjqe7uty2.scala:27)\n\tat Problem.main(tmpjqe7uty2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.sum\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val balanced = palindromic && maxSum\
    \ - maxWeight <= 0\n        val unbalanced = palindromic && !balanced\n      \
    \  (balanced || unbalanced)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpav9uub0q.scala:28)\n\tat Problem.main(tmpav9uub0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfList = w.toLong\n        val maxSumOfElementsOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfList = w.toLong\n    \
    \    val maxSumOfElementsOfListOfListOfListOfList = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsuoac79d.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpsuoac79d.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800698
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem)\
    \ => sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem ==\
    \ q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic\
    \ && isBalanced\n        isFly\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb5e9wa1z.scala:28)\n\tat Problem.main(tmpb5e9wa1z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800699
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxSum = w.toLong * w.toLong\n        val maxWeight = w.toLong\n\
    \        val maxList = q.reverse\n        val maxListSum = maxList.reduceLeft(_\
    \ + _)\n        val isBalanced = maxListSum == maxSum\n        val isPalindromic\
    \ = maxList.reverse == maxList\n        val isFlippable = maxList.reverse == maxList.reverse\n\
    \        val isLessOrEqual = maxListSum < maxSum\n        val isLessOrEqualOrBalanced\
    \ = isLessOrEqual || isBalanced\n        val isLessOrEqualOrFlippable = isLessOrEqual\
    \ || isFlippable\n        isLessOrEqualOrBalanced && isLessOrEqualOrFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptvxsyq4n.scala:34)\n\tat Problem.main(tmptvxsyq4n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - q.sum <= maxWeight\n        val isLessThanMaxWeight = maxSum - q.sum\
    \ < maxWeight\n        val isLessThanMaxSum = q.sum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndPalindromic = maxSum\
    \ - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromic = maxSum\
    \ - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic =\
    \ maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndBalancedPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndBalancedAndPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndBalancedPalindromicAndPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndBalancedAndPalindromicAndBalancedPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndBalancedPalindromicAndBalancedAndPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndBalancedPalindromicAndBalancedAndPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndBalancedAndPalindromicAndBalancedPalindromicAndPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndBalancedPalindromicAndBalancedPalindromicAndPalindromic\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndBalance\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuijralq7.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuijralq7.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxSumAndBalancedPalindromicAndBalancedPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum - q.sum < maxWeight\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedPalindromicAndBalancedPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  isLessThanMaxSumAndBalancedPalindromicAndBalancedPalindromicAndBalancedAndPalindromic\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpuijralq7.scala:21:35 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    Long\n\e[31m\
    \   |\e[0m                                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuijralq7.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659800699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isFlipped = q.forall(x => x == q.last)\n\
    \        val isLessThanMax = maxSum < maxWeight\n        isPalindromic && isBalanced\
    \ && isFlipped && isLessThanMax\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmputft5v5w.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800699
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, elem) => sum + elem }\n        val isBalanced = sumOfElements <= maxWeight\n\
    \        val isFly = palindromic && isBalanced\n        isFly\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7t70n9tq.scala:29)\n\tat Problem.main(tmp7t70n9tq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800700
