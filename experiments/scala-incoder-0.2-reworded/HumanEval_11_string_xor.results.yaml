language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val aLen = aList.length\n        val bLen = bList.length\n\
    \        val result = new StringBuilder(aLen * bLen)\n        var i = 0\n    \
    \    while (i < aLen) {\n            val aChar = aList(i)\n            val bChar\
    \ = bList(i)\n            if (aChar != bChar) {\n                result(i) = aChar\n\
    \                i += 1\n            } else {\n                i += 1\n      \
    \      }\n        }\n        return result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: index 1, length 0\n\tat java.base/java.lang.String.checkIndex(String.java:4563)\n\
    \tat java.base/java.lang.AbstractStringBuilder.setCharAt(AbstractStringBuilder.java:533)\n\
    \tat java.base/java.lang.StringBuilder.setCharAt(StringBuilder.java:91)\n\tat\
    \ scala.collection.mutable.StringBuilder.update(StringBuilder.scala:343)\n\tat\
    \ Problem$.stringXor(tmp2t0zboxn.scala:19)\n\tat Problem$.main(tmp2t0zboxn.scala:28)\n\
    \tat Problem.main(tmp2t0zboxn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        val xorBitsIndex = 0\n        var i = 0\n        while\
    \ (i < xorBits.length) {\n            xorBits(i) = aBits(i) xor bBits(i)\n   \
    \         i += 1\n        }\n        xorBits.toString.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3v59ijn_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3v59ijn_.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   for(i <- 0 until aList.size) {\n            val xor = aList(i) xor bList(i)\n\
    \            xorList += xor.toString.reverse\n        }\n        xorList.toList.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc2tws55s.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpc2tws55s.scala:13:31 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aList(i)\
    \ xor bList(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value xor is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(\n            x => x._1 ^ x._2\n        ).map(\n\
    \            x => x.toString.toChar\n        ).mkString\n        xorArray\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq62wz6pq.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[36mx\e[0m => x.toString.toChar\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \         value toChar is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmpq62wz6pq.scala:17:9\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m      \
    \  ).mkString\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         No\
    \ ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new Array[Int](a.length)\n\
    \        var i = 0\n        while (i < a.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(result)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxyasiuc.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value xor is not a member of Int\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpqxyasiuc.scala:17:12 -----------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(result)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((result : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for (i <- 0 until aArray.length)\n            xorArray += (aArray(i)\
    \ xor bArray(i))\n        xorArray.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc3rk4esv.scala:13:35 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray += (aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.ListBuffer[Int]()\n\
    \        var carry = 0\n        for (i <- 0 until aArray.length)\n           \
    \ result += (aArray(i) xor bArray(i) xor carry)\n        result += carry\n   \
    \     new String(result.toArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq63eopku.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy4zaq700.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpy4zaq700.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toList.reverse.mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2rhyej5h.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val result = new mutable.StringBuilder\n        for(i\
    \ <- 0 until aBits) {\n            result.append(aBits XOR bBits XOR i)\n    \
    \    }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2wn_7y8j.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new Array[Int](a.length)\n\
    \        var i = 0\n        while (i < a.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(result)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqxyasiuc.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value xor is not a member of Int\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpqxyasiuc.scala:17:12 -----------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(result)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((result : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9panidxx.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9panidxx.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n   \
    \         val bBit = bBits(i)\n            val aBitVal = aBit + carry\n      \
    \      val bBitVal = bBit + carry\n            val aBitValStr = aBitVal.toString.reverse\n\
    \            val bBitValStr = bBitVal.toString.reverse\n            val aBitValStrLen\
    \ = aBitValStr.length\n            val bBitValStrLen = bBitValStr.length\n   \
    \         val aBitValStrPad = if (aBitValStrLen < bBitValStrLen) aBitValStrLen\
    \ else bBitValStrLen\n            val bBitValStrPad = if (aBitValStrLen < bBitValStrLen)\
    \ bBitValStrLen else aBitValStrLen\n            val aBitValStrPadChar = if (aBitValStrPad\
    \ == 0) \"\" else aBitValStr.charAt(aBitValStrPad - 1)\n            val bBitValStrPadChar\
    \ = if (bBitValStrPad == 0) \"\" else bBitValStr.charAt(bBitValStrPad - 1)\n \
    \           val aBitValStrPadCharLen = aBitValStrPadChar.length\n            val\
    \ bBitValStrPadCharLen = bBitValStrPadChar.length\n            val aBitValStrPadCharVal\
    \ = aBitValStrPadChar.toInt\n            val bBitValStrPadCharVal = bBitValStrPadChar.toInt\n\
    \            val aBitValStrPadCharValStr = aBitValStrPadCharVal.toString.reverse\n\
    \            val bBitValStrPadCharValStr = bBitValStrPadCharVal.toString.reverse\n\
    \            val aBitValStrPadCharValStrLen = aBitValStrPadCharValStr.length\n\
    \            val bBitValStrPadCharValStrLen = bBitValStrPadCharValStr.length\n\
    \            val aBitValStrPadCharValStrPad = if (aBitValStrPadCharValStrLen <\
    \ bBitValStrPadCharValStrLen) aBitValStrPadCharValStrLen else bBitValStrPadCharValStrLen\n\
    \            val bBitValStrPadCharValStrPad = if (aBitValStrPadCharValStrLen <\
    \ bBitValStrPadCharValStrLen) bBitValStrPadCharValStrLen else aBit\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjd23e1aa.scala:45:0 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpjd23e1aa.scala:15:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36maBit\e[0m = aBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35maBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpjd23e1aa.scala:16:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e\
    [0m \e[36mbBit\e[0m = bBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35mbBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjd23e1aa.scala:44:1\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpjd23e1aa.scala:38:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m38 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ xor bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdlif5kie.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        var result = \"\"\n        var carry = 0\n\
    \        var i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n\
    \            val bBit = bBits(i)\n            val aBitAndBBit = carry + (aBit\
    \ & bBit)\n            val aBitAndBBitAndCarry = aBitAndBBit + carry\n       \
    \     val aBitAndBBitAndCarryString = Integer.toString(aBitAndBBitAndCarry)\n\
    \            result += aBitAndBBitAndCarryString\n            carry = aBitAndBBitAndCarryString\
    \ match {\n                case \"\" => 0\n                case c => Integer.parseInt(c)\n\
    \            }\n            i += 1\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpowecr__n.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpowecr__n.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithZeros = xorBitsStringWithZeros.substring(0,\
    \ xorBitsStringWithZeros.length-1)\n        xorBitsStringWithZeros\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp291unlv.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e\
    [0m = xorBitsStringWithZeros.substring(\e[31m0\e[0m, xorBitsStringWithZeros.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp291unlv.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp291unlv.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        for(i <- 0 until xorBits.length)\n            xorBits(i) = aBits(i) xor\
    \ bBits(i)\n        xorBits.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwf1ifcl6.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwf1ifcl6.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toIntArray\n    \
    \    val bArray = b.toIntArray\n        val xorArray = Array.ofDim[Int](aArray.length)\n\
    \        var i = 0\n        while (i < xorArray.length) {\n            xorArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8x_px6j9.scala:9:23 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maArray\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m   \
    \                  value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8x_px6j9.scala:10:23 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbArray\e[0m = b.toIntArray\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                    value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for(i <- 0 until aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aVal = aChar match {\n    \
    \            case '1' => 1\n                case '0' => 0\n                case\
    \ _ => throw new IllegalArgumentException(\"Invalid input\")\n            }\n\
    \            val bVal = bChar match {\n                case '1' => 1\n       \
    \         case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid input\")\n            }\n            val aValInt = aVal + carry\n    \
    \        val bValInt = bVal + carry\n            val result = aValInt.toString\
    \ + bValInt.toString\n            carry = result match {\n                case\
    \ '1' => 1\n                case '0' => 0\n                case _ => throw new\
    \ IllegalArgumentException(\"Invalid input\")\n            }\n            result.append(carry)\n\
    \        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpb3quxnbu.scala:30:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mcase\e[0m \e[31m'1'\e[0m => \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpb3quxnbu.scala:31:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mcase\e[0m \e[31m'0'\e[0m => \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m\
    \        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpb3quxnbu.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            result.append(carry)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value append is\
    \ not a member of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits & (1 <<\
    \ (a.length - i - 1))\n            val bBit = bBits & (1 << (b.length - i - 1))\n\
    \            val aBitAndBBits = aBit | bBit\n            val aBitAndBBitsAsInt\
    \ = aBitAndBBits & 0xff\n            val aBitAndBBitsAsString = aBitAndBBitsAsInt.toString\n\
    \            val aBitAndBBitsAsStringWithLeadingZeros = aBitAndBBitsAsString.padTo(8,\
    \ '0') // pad leading zeros to 8 characters\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndBBitsAsStringWithLeadingZeros.reverse\n            val aBitAndBBitsAsStringWithLeadingZeros\
    \ = aBitAndB\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnhewxyhi.scala:41:0 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnhewxyhi.scala:21:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e\
    [0m \e[36maBitAndBBitsAsStringWithLeadingZeros\e[0m = aBitAndBBitsAsStringWithLeadingZeros.reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitAndBBitsAsStringWithLeadingZeros is already defined as\
    \ \e[33mvalue\e[0m \e[35maBitAndBBitsAsStringWithLeadingZeros\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnhewxyhi.scala:22:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e\
    [0m \e[36maBitAndBBitsAsStringWithLeadingZeros\e[0m = aBitAndBBitsAsStringWithLeadingZeros.reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitAndBBitsAsStringWithLeadingZeros is already defined as\
    \ \e[33mvalue\e[0m \e[35maBitAndBBitsAsStringWithLeadingZeros\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnhewxyhi.scala:23:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e\
    [0m \e[36maBitAndBBitsAsStringWithLeadingZeros\e[0m = aBitAndBBitsAsStringWithLeadingZeros.reverse\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitAndBBitsAsStringWithLeadingZeros is already defined as\
    \ \e[33mvalue\e[0m \e[35maBitAndBBitsAsStringWithLeadingZeros\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnhewxyhi.scala:24:1"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n   \
    \         val bBit = bBits(i)\n            val aBitInt = aBit + carry\n      \
    \      val bBitInt = bBit + carry\n            val aBitString = aBitInt.toString\n\
    \            val bBitString = bBitInt.toString\n            val aBitStringLen\
    \ = aBitString.length\n            val bBitStringLen = bBitString.length\n   \
    \         val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBitStringLenInt = aBitStringLen.toInt\n\
    \            val bBitStringLenInt = bBitStringLen.toInt\n            val aBitStringLenInt\
    \ = aBitStringLen.toInt\n            val bBitStringLenInt = bBitStringLen.toInt\n\
    \            val aBitStringLenInt = aBitStringLen.toInt\n            val bBitStringLenInt\
    \ = bBitStringLen.toInt\n            val aBit\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdieo4r8w.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdieo4r8w.scala:58:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m58 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdieo4r8w.scala:25:16 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m            \e[33mval\e[0m \e[36maBitStringLenInt\e[0m = aBitStringLen.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35maBitStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdieo4r8w.scala:26:16 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mbBitStringLenInt\e[0m\
    \ = bBitStringLen.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBitStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35mbBitStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdieo4r8w.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36maBitStringLenInt\e[0m\
    \ = aBitStringLen.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35maBitStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdieo4r8w.scala:28:16 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mbBitStringLenInt\e[0m\
    \ = bBitStringLen.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.size) {\n            val aChar = aList(i)\n         \
    \   val bChar = bList(i)\n            val aCharInt = aChar.toInt\n           \
    \ val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n \
    \           val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt =\
    \ aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n    \
    \        val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkvovtmje.scala:45:0 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkvovtmje.scala:35:57\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntIntInt\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpkvovtmje.scala:34:57 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36maCharIntIntIntIntIntIntIntIntIntIntInt\e\
    [0m = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\e[31m\e[31m   |\e[0m \
    \                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: aCharIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkvovtmje.scala:44:1\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpkvovtmje.scala:38:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m38 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659793041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   var xor = 0\n        for(i <- 0 until aList.size) {\n            xor = xor\
    \ + aList(i) xor bList(i)\n            xorList.add(xor.toString(2))\n        }\n\
    \        xorList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt5_e2lyi.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpt5_e2lyi.scala:14:33 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzswo37qb.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793043
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu0fgtkzs.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpu0fgtkzs.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toList.reverse.mkString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2rhyej5h.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(0,xorBitsString.length-1)\n        val xorBitsStringWithoutTrailingZeros\
    \ = xorBitsString.substring(xorBitsString.length-1)\n        (xorBitsStringWithoutLeadingZeros\
    \ ++ xorBitsStringWithoutTrailingZeros)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwbbjbv4k.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val aLen =\
    \ aList.length\n        val bLen = bList.length\n        val aIndex = 0\n    \
    \    val bIndex = 0\n        while (aIndex < aLen && bIndex < bLen) {\n      \
    \      val aChar = aList(aIndex)\n            val bChar = bList(bIndex)\n    \
    \        val aCharInt = aChar match {\n                case '1' => 1\n       \
    \         case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string a: \" + aChar)\n            }\n            val bCharInt\
    \ = bChar match {\n                case '1' => 1\n                case '0' =>\
    \ 0\n                case _ => throw new IllegalArgumentException(\"Invalid character\
    \ in string b: \" + bChar)\n            }\n            val aCharInt = aCharInt\
    \ xor bCharInt\n            val aCharChar = aChar match {\n                case\
    \ '1' => if (aCharInt == 1) '0' else '1'\n                case '0' => if (aCharInt\
    \ == 0) '0' else '1'\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string a: \" + aChar)\n            }\n            val bCharChar\
    \ = bChar match {\n                case '1' => if (bCharInt == 1) '0' else '1'\n\
    \                case '0' => if (bCharInt == 0) '0' else '1'\n               \
    \ case _ => throw new IllegalArgumentException(\"Invalid character in string b:\
    \ \" + bChar)\n            }\n            result.append(aCharChar)\n         \
    \   result.append(bCharChar)\n            aIndex += 1\n            bIndex += 1\n\
    \        }\n        if (bIndex < bLen) {\n            val bChar = bList(bIndex)\n\
    \            val bCharInt = bChar match {\n                case '1' => 1\n   \
    \             case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string b: \" + bChar)\n            }\n            val bCharInt\
    \ = bCharInt xor aCharInt\n            val bCharChar = bChar match {\n       \
    \         case '1' => if (bCharInt == 1) '0' else '1'\n                case '0'\
    \ => if (bCharInt == 0) '0' else '1'\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string b: \" + bChar)\n            }\n            result.append(bCharChar)\n\
    \        }\n        if (bIndex == aLen) {\n            val aChar = aList(aIndex)\n\
    \            val aCharInt = aChar match {\n                case '1' => 1\n   \
    \             case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp737zgyrz.scala:65:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m                \e[33mcase\e[0m _ => \e[33mthrow\e[0m\
    \ \e[33mnew\e[0m IllegalArgumentException(\"\n\e[31m\e[31m   |\e[0m          \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                               unclosed string literal\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp737zgyrz.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\nexception occurred while parser /tmp/tmp737zgyrz.scala\nexception\
    \ occurred while compiling /tmp/tmp737zgyrz.scala\nException in thread \"main\"\
    \ java.lang.AssertionError: assertion failed: position error, parent span does\
    \ not contain child span\nparent      = \e[33mnew \e[0m\e[35mIllegalArgumentException\e\
    [0m(\e[31mnull\e[0m) # -1,\nparent span = <2699..2729>,\nchild       = \e[31mnull\e\
    [0m # -1,\nchild span  = [2728..2734..2734]\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:8)\n\
    \tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:172)\n\tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\
    \tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\
    \tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:202)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.checkPos(Positioned.scala:223)\n\tat dotty.tools.dotc.ast.Positioned.check$1(Positioned.scala:197)\n\
    \tat dotty.tools.dotc.ast.Positioned.check$1$$anonfun$3(Positioned.scala:202)\n\
    \t"
  stdout: "error while checking \e[33mnew \e[0m\e[35mIllegalArgumentException\e[0m(\e\
    [31mnull\e[0m)\nerror while checking \e[33mthrow \e[0m\e[33mnew \e[0m\e[35mIllegalArgumentException\e\
    [0m(\e[31mnull\e[0m)\nerror while checking {\n  \e[33mthrow \e[0m\e[33mnew \e\
    [0m\e[35mIllegalArgumentException\e[0m(\e[31mnull\e[0m)\n}\nerror while checking\
    \ \e[33mcase \e[0m_ => \n  \e[33mthrow \e[0m\e[33mnew \e[0m\e[35mIllegalArgumentException\e\
    [0m(\e[31mnull\e[0m)\nerror while checking aChar\e[33m match \e[0m\n  {\n    \e\
    [33mcase \e[0m\e[31m'1'\e[0m => \n      1\n    \e[33mcase \e[0m\e[31m'0'\e[0m\
    \ => \n      0\n    \e[33mcase \e[0m_ => \n      \e[33mthrow \e[0m\e[33mnew \e\
    [0m\e[35mIllegalArgumentException\e[0m(\e[31mnull\e[0m)\n  }\nerror while checking\
    \ \e[33mval\e[0m \e[36maCharInt\e[0m = \n  aChar\e[33m match \e[0m\n    {\n  \
    \    \e[33mcase \e[0m\e[31m'1'\e[0m => \n        1\n      \e[33mcase \e[0m\e[31m'0'\e\
    [0m => \n        0\n      \e[33mcase \e[0m_ => \n        \e[33mthrow \e[0m\e[33mnew\
    \ \e[0m\e[35mIllegalArgumentException\e[0m(\e[31mnull\e[0m)\n    }\nerror while\
    \ checking {\n  \e[33mval\e[0m \e[36maChar\e[0m = aList(aIndex)\n  \e[33mval\e\
    [0m \e[36maCharInt\e[0m = \n    aChar\e[33m match \e[0m\n      {\n        \e[33mcase\
    \ \e[0m\e[31m'1'\e[0m => \n          1\n        \e[33mcase \e[0m\e[31m'0'\e[0m\
    \ => \n          0\n        \e[33mcase \e[0m_ => \n          \e[33mthrow \e[0m\e\
    [33mnew \e[0m\e[35mIllegalArgumentException\e[0m(\e[31mnull\e[0m)\n      }\n \
    \ \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e\
    [0m]) = \n    {\n      assert(stringXor((\e[32m\"111000\"\e[0m), (\e[32m\"101010\"\
    \e[0m)).equals((\e[32m\"010010\"\e[0m)))\n      assert(stringXor((\e[32m\"1\"\e\
    [0m), (\e[32m\"1\"\e[0m)).equals((\e[32m\"0\"\e[0m)))\n      assert(stringXor((\e\
    [32m\"0101\"\e[0m), (\e[32m\"0000\"\e[0m)).equals((\e[32m\"0101\"\e[0m)))\n  \
    \  }\n  <empty>\n}\nerror while checking \e[33mif \e[0m(bIndex == aLen) \n  {\n\
    \    \e[33mval\e[0m \e[36maChar\e[0m = aList(aIndex)\n    \e[33mval\e[0m \e[36maCharInt\e\
    [0m = \n      aChar\e[33m match \e[0m\n        {\n          \e[33mcase \e[0m\e\
    [31m'1'\e[0m => \n            1\n          \e[33mcase \e[0m\e[31m'0'\e[0m => \n\
    \            0\n          \e[33mcase \e[0m_ => \n            \e[33mthrow \e[0m\e\
    [33mnew \e[0m\e[35mIllegalArg"
  timestamp: 1659793041
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n   \
    \         val bBit = bBits(i)\n            val aBitVal = aBit + carry\n      \
    \      val bBitVal = bBit + carry\n            val aBitValStr = aBitVal.toString.reverse\n\
    \            val bBitValStr = bBitVal.toString.reverse\n            val aBitValStrLen\
    \ = aBitValStr.length\n            val bBitValStrLen = bBitValStr.length\n   \
    \         val aBitValStrPad = if (aBitValStrLen > bBitValStrLen) aBitValStrLen\
    \ else bBitValStrLen\n            val bBitValStrPad = if (aBitValStrLen > bBitValStrLen)\
    \ bBitValStrLen else aBitValStrLen\n            val aBitValStrPadChar = if (aBitValStrPad\
    \ == 0) \"\" else aBitValStrPad\n            val bBitValStrPadChar = if (bBitValStrPad\
    \ == 0) \"\" else bBitValStrPad\n            val aBitValStrPadChars = aBitValStrPadChar.takeWhile(_\
    \ != '0')\n            val bBitValStrPadChars = bBitValStrPadChar.takeWhile(_\
    \ != '0')\n            val aBitValStrPadCharsLen = aBitValStrPadChars.length\n\
    \            val bBitValStrPadCharsLen = bBitValStrPadChars.length\n         \
    \   val aBitValStrPadCharsPad = if (aBitValStrPadCharsLen > bBitValStrPadCharsLen)\
    \ aBitValStrPadCharsLen else bBitValStrPadCharsLen\n            val bBitValStrPadCharsPad\
    \ = if (aBitValStrPadCharsLen > bBitValStrPadCharsLen) bBitValStrPadCharsLen else\
    \ aBitValStrPadCharsLen\n            val aBitValStrPadCharsPadChar = if (aBitValStrPadCharsPad\
    \ == 0) \"\" else aBitValStrPadCharsPad\n            val bBitValStrPadCharsPadChar\
    \ = if (bBitValStrPadCharsPad == 0) \"\" else bBitValStrPadCharsPad\n        \
    \    val aBitValStrPadCharsPadChars = aBitValStrPadCharsPadChar.takeWhile\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm3f4nlvy.scala:44:0 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpm3f4nlvy.scala:15:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36maBit\e[0m = aBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35maBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpm3f4nlvy.scala:16:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e\
    [0m \e[36mbBit\e[0m = bBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35mbBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm3f4nlvy.scala:35:71\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36maBitValStrPadCharsPadChars\e[0m = aBitValStrPadCharsPadChar.takeWhile\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value takeWhile is not a member\
    \ of Matchable\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm3f4nlvy.scala:43:1\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpm3f4nlvy.scala:37:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m37 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length) xorList += aList(i) xor bList(i)\n    \
    \    xorList.toList.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp717qxken.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.substring(0,xorBitsString.length-1)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuy2nu7rm.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.ArrayBuffer(a.length)\n\
    \        var i = 0\n        while (i < a.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        result.mkString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp572t9rk7.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(a.length)\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringWithZeros = Array.fill(xorBitsStringLength)(0)\n   \
    \     val xorBitsStringWithZeroString = xorBitsStringWithZeros.mkString(\"\")\n\
    \        val xorBitsStringWithZeroStringLength = xorBitsStringWithZeroString.length\n\
    \        val xorBitsStringWithZeroStringWithSpaces = xorBitsStringWithZeroString\
    \ + \" \"\n        val xorBitsStringWithZeroStringWithSpacesLength = xorBitsStringWithZeroStringWithSpaces.length\n\
    \        val xorBitsStringWithZeroStringWithSpacesWithSpaces = xorBitsStringWithZeroStringWithSpaces\
    \ + \" \"\n        val xorBitsStringWithZeroStringWithSpacesWithSpacesLength =\
    \ xorBitsStringWithZeroStringWithSpacesWithSpaces.length\n        val xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpaces\
    \ = xorBitsStringWithZeroStringWithSpacesWithSpaces + \" \"\n        val xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesLength\
    \ = xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpaces.length\n       \
    \ val xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpaces = xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpaces\
    \ + \" \"\n        val xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpacesLength\
    \ = xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpaces.length\n\
    \        val xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpacesWithSpaces\
    \ = xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpaces + \" \"\
    \n        val xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpacesWithSpacesLength\
    \ = xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpacesWithSpaces.length\n\
    \        val xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpacesWithSpacesWithSpaces\
    \ = xorBitsStringWithZeroStringWithSpacesWithSpacesWithSpacesWithSpaces\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmper76c9zi.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmper76c9zi.scala:28:5 ---------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        xorBitsString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8qpcovbc.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu0fgtkzs.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpu0fgtkzs.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793044
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     var i = 0\n        while (i < aArray.length) {\n            result.append(aArray(i)\
    \ ^ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(1,xorBitsString.length)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.padToLength(32, \"0\")\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.substring(0, xorBitsStringWithoutLeadingZeros.length-1)\n\
    \        val xorBitsStringWithoutLeadingZeros = xorBitsStringWithoutLeadingZeros.padToLength(32,\
    \ \"0\")\n        val xorBitsStringWithoutLeadingZeros = xorBitsStringWithoutLeadingZeros.substring(0,\
    \ xorBitsStringWithoutLeadingZeros.length-1)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.padToLength(32, \"0\")\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.substring(0, xorBitsStringWithoutLeadingZeros.length-1)\n\
    \        val xorBitsStringWithoutLeadingZeros = xorBitsStringWithoutLeadingZeros.padToLength(32,\
    \ \"0\")\n        val xorBitsStringWithoutLeadingZeros = xorBitsStringWithoutLeadingZeros.substring(0,\
    \ xorBitsStringWithoutLeadingZeros.length-1)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.padToLength(32, \"0\")\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.substring(0, xorBitsStringWithoutLeadingZeros.length-1)\n\
    \        val xorBitsStringWithoutLeadingZeros = xorBitsStringWithoutLeadingZeros.padToLength(32,\
    \ \"0\")\n        val xorBitsStringWithoutLeadingZeros = xorBitsStringWithoutLeadingZeros.substring(0,\
    \ xorBitsStringWithoutLeadingZeros.length-1)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.padToLength(32, \"0\")\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.substring(0, xorBitsStringWithoutLeadingZeros.length-1)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp86rxget7.scala:28:11 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp86rxget7.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithoutLeadingZeros\e\
    [0m = xorBitsStringWithoutLeadingZeros.padToLength(\e[31m32\e[0m, \e[31m\"0\"\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutLeadingZeros is already defined as \e\
    [33mvalue\e[0m \e[35mxorBitsStringWithoutLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp86rxget7.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBitsStringWithoutLeadingZeros\e[0m = xorBitsStringWithoutLeadingZeros.substring(\e\
    [31m0\e[0m, xorBitsStringWithoutLeadingZeros.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutLeadingZeros is already defined as \e\
    [33mvalue\e[0m \e[35mxorBitsStringWithoutLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp86rxget7.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBitsStringWithoutLeadingZeros\e[0m = xorBitsStringWithoutLeadingZeros.padToLength(\e\
    [31m32\e[0m, \e[31m\"0\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutLeadingZeros is already defined as \e\
    [33mvalue"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu0fgtkzs.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpu0fgtkzs.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.append(xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.append(xorBitsString.substring(xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz98z44mz.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpz98z44mz.scala:17:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val aLen = aArray.length\n        val\
    \ bLen = bArray.length\n        val result = new Array[Char](aLen + bLen)\n  \
    \      var i = 0\n        var j = 0\n        while (i < aLen && j < bLen) {\n\
    \            result(i) = aArray(i) XOR bArray(j)\n            i += 1\n       \
    \     j += 1\n        }\n        while (i < aLen) {\n            result(i) = aArray(i)\n\
    \            i += 1\n        }\n        while (j < bLen) {\n            result(i)\
    \ = bArray(j)\n            j += 1\n        }\n        new String(result)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkv7pufgp.scala:17:34 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            result(i) = aArray(i) XOR bArray(j)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy3_kfjvz.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793044
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits ^ bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.append(xorBitsString)\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuild\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpc3dkqwdn.scala:16:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmpc3dkqwdn.scala:17:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m--\
    \ Error: /tmp/tmpc3dkqwdn.scala:18:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmpc3dkqwdn.scala:19:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m--\
    \ Error: /tmp/tmpc3dkqwdn.scala:20:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmpc3dkqwdn.scala:21:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mcla"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for (i <- 0 until aArray.length)\n            xorArray += (aArray(i)\
    \ xor bArray(i))\n        xorArray.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk4o76e_7.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793045
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n\
    \        val xorArrayIndex = 0\n        for (i <- 0 until a.length) {\n      \
    \      xorArray(xorArrayIndex) = aArray(i) xor bArray(i)\n            xorArrayIndex\
    \ += 1\n        }\n        xorArray.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_idqlx78.scala:14:48 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(xorArrayIndex) = aArray(i) xor bArray(i)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      value xor is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_idqlx78.scala:15:26\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            xorArrayIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        value += is not a member of Int - did you mean xorArrayIndex.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu1kc1zng.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new mutable.StringBuilder\n\
    \        val xor = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult2 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult3 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult4 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult5\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult6 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult7 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult8 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult9\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult10 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult11 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult12 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult13\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult14 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult15 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult16 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult17\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult18 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult19 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult20 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult21\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult22 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult23 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult24 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult25\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult26 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult27 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult28 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpixyyf5af.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpixyyf5af.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpixyyf5af.scala:12:18\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpixyyf5af.scala:13:24\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpixyyf5af.scala:14:25 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpixyyf5af.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.append(xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.append(xorBitsString.substring(xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz98z44mz.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpz98z44mz.scala:17:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array[Int]()\n        var\
    \ i = 0\n        while (i < aBits.length && i < bBits.length) {\n            xorBits(i)\
    \ = aBits(i) xor bBits(i)\n            i += 1\n        }\n        xorBits.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdxi9el_x.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpdxi9el_x.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var xor = 0\n        var i = 0\n        while (i < aList.size) {\n   \
    \         xor = xor + aList(i) xor bList(i)\n            i = i + 1\n        }\n\
    \        xorList.add(xor.toString)\n        xorList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8sbxuq7j.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8sbxuq7j.scala:15:33 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            xor = xor + aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = 0\n        var carry = 0\n        for(i\
    \ <- 0 until aList.length){\n            val aChar = aList(i)\n            val\
    \ bChar = bList(i)\n            val aInt = aChar match {\n                case\
    \ '1' => 1\n                case '0' => 0\n            }\n            val bInt\
    \ = bChar match {\n                case '1' => 1\n                case '0' =>\
    \ 0\n            }\n            val aBinary = aInt match {\n                case\
    \ 1 => 1\n                case 0 => 0\n            }\n            val bBinary\
    \ = bInt match {\n                case 1 => 1\n                case 0 => 0\n \
    \           }\n            val aBinString = aBinary.toString\n            val\
    \ bBinString = bBinary.toString\n            val aBinStringLen = aBinString.length\n\
    \            val bBinStringLen = bBinString.length\n            val aBinStringLenInt\
    \ = aBinStringLen.toInt\n            val bBinStringLenInt = bBinStringLen.toInt\n\
    \            val aBinStringLenInt = aBinStringLen.toInt\n            val bBinStringLenInt\
    \ = bBinStringLen.toInt\n            val aBinStringLenInt = aBinStringLen.toInt\n\
    \            val bBinStringLenInt = bBinStringLen.toInt\n            val aBinStringLenInt\
    \ = aBinStringLen.toInt\n            val bBinStringLenInt = bBinStringLen.toInt\n\
    \            val aBinStringLenInt = aBinStringLen.toInt\n            val bBinStringLenInt\
    \ = bBinStringLen.toInt\n            val aBinStringLenInt = aBinStringLen.toInt\n\
    \            val bBinStringLenInt = bBinStringLen.toInt\n            val aBinStringLenInt\
    \ = aBinStringLen.toInt\n            val bBinStringLenInt = bBinStringLen.toInt\n\
    \            val aBinStringLenInt = aBinStringLen.toInt\n            val bBinStringLenInt\
    \ = bBinStringLen.toInt\n            val aBinStringLenInt = aBinStringLen.toInt\n\
    \            val bBinStringLenInt = bBinStringLen.toInt\n            val aBinStringLenInt\
    \ = aBinStringLen.toInt\n            val bBinStringLenInt = bBinStringLen.toInt\n\
    \            val aBinStringLenInt = aBinStringLen.toInt\n            val bBinStringLenInt\
    \ = bBinStringLen.toInt\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw0k459ld.scala:66:0 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw0k459ld.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36maBinStringLenInt\e[0m = aBinStringLen.toInt\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maBinStringLenInt\
    \ is already defined as \e[33mvalue\e[0m \e[35maBinStringLenInt\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpw0k459ld.scala:39:16 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mbBinStringLenInt\e[0m = bBinStringLen.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBinStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35mbBinStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw0k459ld.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36maBinStringLenInt\e[0m\
    \ = aBinStringLen.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBinStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35maBinStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw0k459ld.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mbBinStringLenInt\e[0m\
    \ = bBinStringLen.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBinStringLenInt is already defined as \e[33mvalue\e[0m \e\
    [35mbBinStringLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of"
  stdout: ''
  timestamp: 1659793048
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val result = new StringBuilder\n        val xorBits\
    \ = aBits xor bBits\n        result ++= xorBits.toString.reverse\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2_ttgtrg.scala:12:28 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits xor bBits\n        val\
    \ xorBitsString = xorBits.map(x => if (x == 0) \"0\" else \"1\").mkString\n  \
    \      xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsz618pzh.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpsz618pzh.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(\n            x => x._1 ^ x._2\n        ).map(\n\
    \            x => x.toString.toChar\n        ).mkString\n        xorArray\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq62wz6pq.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[36mx\e[0m => x.toString.toChar\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \         value toChar is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmpq62wz6pq.scala:17:9\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m      \
    \  ).mkString\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         No\
    \ ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ var i = 0\n        while (i < aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n  \
    \          val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9l399x2i.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:30:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:32:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:33:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9l399x2i.scala:36:57\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntI"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        val xorBitsIndex = 0\n        for (i <- 0 until xorBits.length)\n\
    \            if (aBits(i) != 0 && bBits(i) != 0)\n                xorBits(xorBitsIndex)\
    \ = xorBits(xorBitsIndex) + aBits(i) ^ bBits(i)\n            xorBitsIndex += 1\n\
    \        xorBits.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv5d_v722.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpv5d_v722.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpv5d_v722.scala:16:25 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m            xorBitsIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value += is not a\
    \ member of Int - did you mean xorBitsIndex.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithZeros = xorBitsStringWithZeros.substring(0,\
    \ xorBitsStringWithZeros.length - 1)\n        xorBitsStringWithZeros\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppalpl4d_.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e\
    [0m = xorBitsStringWithZeros.substring(\e[31m0\e[0m, xorBitsStringWithZeros.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppalpl4d_.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppalpl4d_.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.length){\n            val aChar = aList(i)\n        \
    \    val bChar = bList(i)\n            val aInt = aChar match {\n            \
    \    case '1' => 1\n                case '0' => 0\n            }\n           \
    \ val bInt = bChar match {\n                case '1' => 1\n                case\
    \ '0' => 0\n            }\n            val aInt2 = aInt XOR bInt\n           \
    \ val aInt3 = aInt2 XOR carry\n            val aChar3 = aInt3 match {\n      \
    \          case '1' => 1\n                case '0' => 0\n            }\n     \
    \       result += \"1\" + (aChar3 match {\n                case '1' => 1\n   \
    \             case '0' => 0\n            })\n            carry = aInt3 match {\n\
    \                case '1' => 1\n                case '0' => 0\n            }\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzfjez9c1.scala:24:29 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36maInt2\e[0m = aInt XOR\
    \ bInt\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        value XOR is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < aArray.length || i <\
    \ bArray.length) {\n            if (i < aArray.length) result(i) = aArray(i) XOR\
    \ bArray(i)\n            if (i < bArray.length) result(i) = aArray(i) XOR bArray(i)\n\
    \            i += 1\n        }\n        new String(result)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxnw0us8k.scala:14:57 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (i < aArray.length) result(i)\
    \ = aArray(i) XOR bArray(i)\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                  value XOR is not a member of Char\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpxnw0us8k.scala:15:57 ------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m            \e[33mif\e[0m (i < bArray.length) result(i) = aArray(i)\
    \ XOR bArray(i)\n\e[31m\e[31m   |\e[0m                                       \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \      value XOR is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        var result = \"\"\n        for (i <-\
    \ 0 until aArray.length)\n            result += ((aArray(i) XOR bArray(i)) XOR\
    \ 0xff).toChar\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe_06i264.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aArray(i) XOR bArray(i)) XOR\
    \ \e[31m0xff\e[0m).toChar\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe_06i264.scala:13:34 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aArray(i) XOR bArray(i)) XOR\
    \ \e[31m0xff\e[0m).toChar\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value XOR is not a member of Char\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.append(xorBitsString)\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.reverse()\n        xorBitsString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptky_ee2s.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmptky_ee2s.scala:16:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmptky_ee2s.scala:17:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m--\
    \ Error: /tmp/tmptky_ee2s.scala:18:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmptky_ee2s.scala:19:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m--\
    \ Error: /tmp/tmptky_ee2s.scala:20:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.ArrayBuffer(a.length)\n\
    \        for(i <- 0 until a.length) {\n            result(i) = aArray(i) xor bArray(i)\n\
    \        }\n        new String(result.toArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgr_9jfr2.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(a.length)\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 ^ x._2)\n        val xorString =\
    \ xorArray.toString.reverse\n        xorString.substring(0, xorString.length -\
    \ 1)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp87a8lj2l.scala:18)\n\tat Problem.main(tmp87a8lj2l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      for( i <- 0 until aList.size ) {\n            val aChar = aList(i)\n  \
    \          val bChar = bList(i)\n            if( aChar != bChar ) {\n        \
    \        result.append((aChar ^ bChar))\n            }\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt6ds66g2.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](a.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        xorArray.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprv8oysu_.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxor5it3i.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i).xor(bBits(i))\n            i += 1\n        }\n\
    \        xorBits.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyhru1uk2.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyhru1uk2.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        xorBitsStringWithLeadingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyhdxt2fu.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsStringWithLeadingZeros.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithLeadingZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyhdxt2fu.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyhdxt2fu.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ XOR bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj0a60inp.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach {\n            case (aChar, bChar) =>\n     \
    \           val xorChar = aChar xor bChar\n                xorList += xorChar.toString\n\
    \        }\n        xorList.toList.reverse.mkString(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4woes2f3.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4woes2f3.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                \e[33mval\e[0m \e[36mxorChar\e[0m = aChar\
    \ xor bChar\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              value xor is not a member of Char\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i).xor(bBits(i))\n            i += 1\n        }\n\
    \        xorBits.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyhru1uk2.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyhru1uk2.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        for\
    \ (i <- 0 until aBits) {\n            val aBit = aBits - i\n            val bBit\
    \ = bBits - i\n            val aBitInt = aBit + carry\n            val bBitInt\
    \ = bBit + carry\n            val aBitString = aBitInt.toString\n            val\
    \ bBitString = bBitInt.toString\n            val aBitStringLen = aBitString.length\n\
    \            val bBitStringLen = bBitString.length\n            val aBitStringPad\
    \ = if (aBitStringLen < bBitStringLen) aBitString else bBitString\n          \
    \  val bBitStringPad = if (aBitStringLen < bBitStringLen) bBitString else aBitString\n\
    \            val aBitStringPadLen = aBitStringPad.length\n            val bBitStringPadLen\
    \ = bBitStringPad.length\n            val aBitStringPadPad = if (aBitStringPadLen\
    \ < bBitStringPadLen) aBitStringPad else bBitStringPad\n            val bBitStringPadPad\
    \ = if (aBitStringPadLen < bBitStringPadLen) bBitStringPad else aBitStringPadPad\n\
    \            val aBitStringPadPadLen = aBitStringPadPad.length\n            val\
    \ bBitStringPadPadLen = bBitStringPadPad.length\n            val aBitStringPadPadPad\
    \ = if (aBitStringPadPadLen < bBitStringPadPadLen) aBitStringPadPad else bBitStringPadPad\n\
    \            val bBitStringPadPad = if (aBitStringPadPadLen < bBitStringPadPadLen)\
    \ bBitStringPadPad else aBitStringPadPadPad\n            val aBitStringPadPadPadLen\
    \ = aBitStringPadPadPad.length\n            val bBitStringPadPadLen = bBitStringPadPad.length\n\
    \            val aBitStringPadPadPad = if (aBitStringPadPadLen < bBitStringPadPadLen)\
    \ aBitStringPadPadPad else bBitStringPadPadPad\n            val bBitStringPadPad\
    \ = if (aBitStringPadPadLen < bBitStringPadPadLen) bBitStringPadPad else aBitStringPadPadPad\n\
    \            val aBitStringPadPadPadLen = aBitStringPadPadPad.length\n       \
    \     val bBitStringPadPadLen = bBitStringPadPad.length\n            val aBitStringPad\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpidh5_8j2.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpidh5_8j2.scala:47:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m47 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpidh5_8j2.scala:31:16 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m            \e[33mval\e[0m \e[36mbBitStringPadPad\e[0m = \e[33mif\e\
    [0m (aBitStringPadPadLen < bBitStringPadPadLen) bBitStringPadPad \e[33melse\e\
    [0m aBitStringPadPadPad\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBitStringPadPad is already defined as \e[33mvalue\e[0m \e\
    [35mbBitStringPadPad\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpidh5_8j2.scala:33:16 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mbBitStringPadPadLen\e\
    [0m = bBitStringPadPad.length\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbBitStringPadPadLen is already defined as \e[33mvalue\e[0m\
    \ \e[35mbBitStringPadPadLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpidh5_8j2.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36maBitStringPadPadPad\e\
    [0m = \e[33mif\e[0m (aBitStringPadPadLen < bBitStringPadPadLen) aBitStringPadPadPad\
    \ \e[33melse\e[0m bBitStringPadPadPad\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maBitStringPadPadPad is already defined as \e[33mvalue\e[0m\
    \ \e[35maBitStringPadPadPad\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mN"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        var i = 0\n        while (i < xorArray.length) {\n            xorArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp12rvz_bi.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for(i <- 0 until aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aInt = aChar match {\n    \
    \            case '1' => 1\n                case '0' => 0\n                case\
    \ _ => throw new IllegalArgumentException(\"Invalid character \" + aChar)\n  \
    \          }\n            val bInt = bChar match {\n                case '1' =>\
    \ 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + bChar)\n            }\n            val aBinary = Integer.bitCount(aInt)\n\
    \            val bBinary = Integer.bitCount(bInt)\n            val aBits = aBinary\
    \ / 8\n            val bBits = bBinary / 8\n            val aBitsRemainder = aBinary\
    \ % 8\n            val bBitsRemainder = bBinary % 8\n            val aBitsCarry\
    \ = aBitsRemainder != 0\n            val bBitsCarry = bBitsRemainder != 0\n  \
    \          val aBitsCarryInt = aBitsCarry match {\n                case true =>\
    \ 1\n                case false => 0\n            }\n            val bBitsCarryInt\
    \ = bBitsCarry match {\n                case true => 1\n                case false\
    \ => 0\n            }\n            val aBitsCarryBin = aBitsCarryInt match {\n\
    \                case true => '1'\n                case false => '0'\n       \
    \     }\n            val bBitsCarryBin = bBitsCarryInt match {\n             \
    \   case true => '1'\n                case false => '0'\n            }\n     \
    \       val aBitsCarryBinString = aBitsCarryBin match {\n                case\
    \ '1' => '1'\n                case '0' => '0'\n            }\n            val\
    \ bBitsCarryBinString = bBitsCarryBin match {\n                case '1' => '1'\n\
    \                case '0' => '0'\n            }\n            val aBitsCarryBinString2\
    \ = aBitsCarryBin match {\n                case '1' => '0'\n                case\
    \ '0' => '1'\n            }\n            val bBitsCarryBinString2 = bBitsCarryBin\
    \ match {\n                case '1' => '0'\n                case '0' => '1'\n\
    \            }\n            val aBitsCarryBinString3 = aBitsCarryBin match {\n\
    \                case '1' => '\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp748v90we.scala:67:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m                \e[33mcase\e[0m \e[31m'1'\e[0m => '\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       unclosed character literal\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp748v90we.scala:76:0 ----------------------------\e[0m\e[0m\n\e\
    [31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- Error: /tmp/tmp748v90we.scala:43:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                \e[33mcase\e[0m \e[31mtrue\e[0m => \e\
    [31m'1'\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Boolean and Int cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp748v90we.scala:44:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                \e[33mcase\e[0m \e[31mfalse\e[0m => \e\
    [31m'0'\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Boolean and Int cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp748v90we.scala:47:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                \e[33mcase\e[0m \e[31mtrue\e[0m => \e\
    [31m'1'\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Boolean and Int cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp748v90we.scala:48:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                \e[33mcase\e[0m \e[31mfalse\e[0m => \e\
    [31m'0'\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Boolean and Int cannot be compared with == or !=\n\e\
    [33m\e[33m-- Warning: /tmp/tmp748v90we.scala:69:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m69 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n6 errors found\n"
  stdout: ''
  timestamp: 1659793053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.ListBuffer[Int]()\n        var i = 0\n        while (i < aList.size)\
    \ {\n            xor.append(aList(i) xor bList(i))\n            i += 1\n     \
    \   }\n        result.appendAll(xor)\n        return result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ty48tsp.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793051
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for (i<- 0 until xorBitsStringLength) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcyomo_0p.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793053
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.BitSet(b.length)\n        val xorResult = mutable.BitSet(b.length)\n\
    \        val xorResult2 = mutable.BitSet(b.length)\n        val xorResult3 = mutable.BitSet(b.length)\n\
    \        val xorResult4 = mutable.BitSet(b.length)\n        val xorResult5 = mutable.BitSet(b.length)\n\
    \        val xorResult6 = mutable.BitSet(b.length)\n        val xorResult7 = mutable.BitSet(b.length)\n\
    \        val xorResult8 = mutable.BitSet(b.length)\n        val xorResult9 = mutable.BitSet(b.length)\n\
    \        val xorResult10 = mutable.BitSet(b.length)\n        val xorResult11 =\
    \ mutable.BitSet(b.length)\n        val xorResult12 = mutable.BitSet(b.length)\n\
    \        val xorResult13 = mutable.BitSet(b.length)\n        val xorResult14 =\
    \ mutable.BitSet(b.length)\n        val xorResult15 = mutable.BitSet(b.length)\n\
    \        val xorResult16 = mutable.BitSet(b.length)\n        val xorResult17 =\
    \ mutable.BitSet(b.length)\n        val xorResult18 = mutable.BitSet(b.length)\n\
    \        val xorResult19 = mutable.BitSet(b.length)\n        val xorResult20 =\
    \ mutable.BitSet(b.length)\n        val xorResult21 = mutable.BitSet(b.length)\n\
    \        val xorResult22 = mutable.BitSet(b.length)\n        val xorResult23 =\
    \ mutable.BitSet(b.length)\n        val xorResult24 = mutable.BitSet(b.length)\n\
    \        val xorResult25 = mutable.BitSet(b.length)\n        val xorResult26 =\
    \ mutable.BitSet(b.length)\n        val xorResult27 = mutable.BitSet(b.length)\n\
    \        val xorResult28 = mutable.BitSet(b.length)\n        val xorResult29 =\
    \ mutable.BitSet(b.length)\n        val xorResult30 = mutable.BitSet(b.length)\n\
    \        val xorResult31 = mutable.BitSet(b.length)\n        val xorResult32 =\
    \ mutable.BitSet(b.length)\n        val xorResult33 = mutable.BitSet(b.length)\n\
    \        val xorResult34 = mutable.BitSet(b.length)\n        val xorResult35 =\
    \ mutable.BitSet(b.length)\n        val xorResult36 = mutable.BitSet(b.length)\n\
    \        val xorResult37 = mutable.BitSet(b.length)\n        val xorResult38 =\
    \ mutable.Bit\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpunm07m6b.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpunm07m6b.scala:13:24 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.BitSet(b.length)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:14:25 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:15:25 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:16:25 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:17:25 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mxorResult5\e[0m = mutable.BitSet(b."
  stdout: ''
  timestamp: 1659793056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length) xorList += aList(i) xor bList(i)\n    \
    \    xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa9a21s4b.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.substring(0,xorBitsString.length-1)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp523bsoym.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       val xorResult = mutable.ListBuffer.empty[String]\n        for(i <- 0 until\
    \ aList.size) {\n            xorList += aList(i) xor bList(i)\n            xorResult\
    \ += xorList(i).toChar\n        }\n        xorResult.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb4vuz0q5.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb4vuz0q5.scala:12:24 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorResult = mutable.Buffer.empty[String]\n   \
    \     for(i <- 0 until aList.size) {\n            xorResult += ((aList(i) xor\
    \ bList(i)) and 1).toChar\n        }\n        xorResult.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxmg5txla.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.Buffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793054
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val aLen =\
    \ aList.length\n        val bLen = bList.length\n        val aIndex = 0\n    \
    \    val bIndex = 0\n        while(aIndex < aLen && bIndex < bLen) {\n       \
    \     val aChar = aList(aIndex)\n            val bChar = bList(bIndex)\n     \
    \       if(aChar != bChar) {\n                result.append(aChar)\n         \
    \   }\n            aIndex += 1\n            bIndex += 1\n        }\n        if(result.length\
    \ == aLen && bLen > 0) {\n            result.append(bList(bIndex))\n        }\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpokoahvpq.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            aIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean aIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpokoahvpq.scala:23:19\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            bIndex += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value += is not a member of Int - did you mean bIndex.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList +=\
    \ aChar ^ bChar\n        }\n        xorList.toList.reverse.mkString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkdtccbav.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        var xor = 0\n        for (i <- 0 until aArray.length)\n            xor\
    \ = xor + aArray(i) xor bArray(i)\n        xorArray = xorArray.toArray\n     \
    \   xorArray.reverse.mkString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp75k_z4vn.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp75k_z4vn.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmp75k_z4vn.scala:15:17 -----------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        xorArray = xorArray.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val xorArray\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            for(j <- 0 until bArray.length)\n\
    \                xorArray += (aArray(i) xor bArray(j))\n        xorArray.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphf03pesy.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp278trq8l.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringArray = xorBitsString.toCharArray\n\
    \        val xorBitsStringArrayLength = xorBitsStringArray.length\n        val\
    \ xorBitsStringBuilder = new StringBuilder\n        for (i<-xorBitsStringArrayLength\
    \ to 0) {\n            xorBitsStringBuilder.append(xorBitsStringArray(i))\n  \
    \      }\n        xorBitsStringBuilder.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppxckm1oc.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(0,xorBitsString.length-1)\n        val result = xorBitsStringWithoutLeadingZeros\
    \ + \"0\"\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm1_h0c8m.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        var\
    \ i = 0\n        while (i < a.length) {\n            val aBit = aBits(i)\n   \
    \         val bBit = bBits(i)\n            val aChar = if (aBit == 1) \"1\" else\
    \ \"0\"\n            val bChar = if (bBit == 1) \"1\" else \"0\"\n           \
    \ val aCharBits = aChar.toInt\n            val bCharBits = bChar.toInt\n     \
    \       val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = bCharBits(1)\n\
    \            val aCharBit = aCharBits(0)\n            val bCharBit = bCharBits(0)\n\
    \            val aCharBits = aCharBits(1)\n            val bCharBits = \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptad1p9th.scala:56:27 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m            \e[33mval\e[0m \e[36mbCharBits\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptad1p9th.scala:65:0 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptad1p9th.scala:23:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e\
    [0m \e[36maCharBits\e[0m = aCharBits(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maCharBits is already\
    \ defined as \e[33mvalue\e[0m \e[35maCharBits\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptad1p9th.scala:24:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharBits\e[0m = bCharBits(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mbCharBits is already\
    \ defined as \e[33mvalue\e[0m \e[35mbCharBits\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptad1p9th.scala:25:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36maCharBit\e[0m = aCharBits(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0maCharBit is already defined\
    \ as \e[33mvalue\e[0m \e[35maCharBit\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptad1p9th.scala:26:16 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mbCharBit\e[0m = bCharBits(\e\
    [31m0"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.append(xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.append(xorBitsString.substring(xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfpkkaq_9.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpfpkkaq_9.scala:17:29 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxor5it3i.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793052
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xor = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult2 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult3 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult4 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult5\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult6 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult7 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult8 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult9\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult10 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult11 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult12 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult13\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult14 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult15 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult16 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult17\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult18 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult19 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult20 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult21\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult22 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult23 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult24 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult25\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult26 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult27 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult28 = mutable.ArrayBuffer.fill\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp6pj2hlim.scala:13:24 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scal"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   val xorListSize = a.length\n        val xorListSize2 = b.length\n        val\
    \ xorListSize3 = xorListSize + xorListSize2\n        val xorListSize4 = xorListSize3\
    \ / 2\n        val xorListSize5 = xorListSize4 / 2\n        val xorListSize6 =\
    \ xorListSize5 / 2\n        val xorListSize7 = xorListSize6 / 2\n        val xorListSize8\
    \ = xorListSize7 / 2\n        val xorListSize9 = xorListSize8 / 2\n        val\
    \ xorListSize10 = xorListSize9 / 2\n        val xorListSize11 = xorListSize10\
    \ / 2\n        val xorListSize12 = xorListSize11 / 2\n        val xorListSize13\
    \ = xorListSize12 / 2\n        val xorListSize14 = xorListSize13 / 2\n       \
    \ val xorListSize15 = xorListSize14 / 2\n        val xorListSize16 = xorListSize15\
    \ / 2\n        val xorListSize17 = xorListSize16 / 2\n        val xorListSize18\
    \ = xorListSize17 / 2\n        val xorListSize19 = xorListSize18 / 2\n       \
    \ val xorListSize20 = xorListSize19 / 2\n        val xorListSize21 = xorListSize20\
    \ / 2\n        val xorListSize22 = xorListSize21 / 2\n        val xorListSize23\
    \ = xorListSize22 / 2\n        val xorListSize24 = xorListSize23 / 2\n       \
    \ val xorListSize25 = xorListSize24 / 2\n        val xorListSize26 = xorListSize25\
    \ / 2\n        val xorListSize27 = xorListSize26 / 2\n        val xorListSize28\
    \ = xorListSize27 / 2\n        val xorListSize29 = xorListSize28 / 2\n       \
    \ val xorListSize30 = xorListSize29 / 2\n        val xorListSize31 = xorListSize30\
    \ / 2\n        val xorListSize32 = xorListSize31 / 2\n        val xorListSize33\
    \ = xorListSize32 / 2\n        val xorListSize34 = xorListSize33 / 2\n       \
    \ val xorListSize35 = xorListSize34 / 2\n        val xorListSize36 = x\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpez8b1zwg.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpez8b1zwg.scala:47:28 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mxorListSize36\e[0m = x\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpez8b1zwg.scala:48:5 ---------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i) xor bBits(i)\n            i += 1\n        }\n\
    \        new String(xorBits)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyhvsotd_.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpyhvsotd_.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpyhvsotd_.scala:17:12 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorBits)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorBits : Array[Int]))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9qzmeo2t.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val aLen =\
    \ aList.size\n        val bLen = bList.size\n        val aIndex = 0\n        val\
    \ bIndex = 0\n        while(aIndex < aLen && bIndex < bLen) {\n            val\
    \ aChar = aList(aIndex)\n            val bChar = bList(bIndex)\n            if(aChar\
    \ != bChar) {\n                result += aChar\n            }\n            aIndex\
    \ += 1\n            bIndex += 1\n        }\n        if(!aIndex == aLen) {\n  \
    \          result += aList(aIndex)\n        }\n        if(!bIndex == bLen) {\n\
    \            result += bList(bIndex)\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo20q1m1p.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            aIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean aIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo20q1m1p.scala:23:19\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            bIndex += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value += is not a member of Int - did you mean bIndex.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpo20q1m1p.scala:25:11 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mif\e[0m(!aIndex == aLen) {\n\e[31m\e[31m\
    \   |\e[0m           ^^^^^^^\e[0m\n\e[31m   |\e[0m     value unary_! is not a\
    \ member of Int - did you mean aIndex.unary_+?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpo20q1m1p.scala:28:11 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mif\e[0m(!bIndex == bLen) {\n\e[31m\e[31m   |\e[0m      \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m     value unary_! is not a member of Int -\
    \ did you mean bIndex.unary_+?\n4 errors found\n"
  stdout: ''
  timestamp: 1659793059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithZeros = xorBitsStringWithZeros.substring(0,\
    \ xorBitsStringWithZeros.length - 1)\n        xorBitsStringWithZeros\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppalpl4d_.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e\
    [0m = xorBitsStringWithZeros.substring(\e[31m0\e[0m, xorBitsStringWithZeros.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppalpl4d_.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppalpl4d_.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits ^ bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutZeros = xorBitsString.filter(_\
    \ != '0')\n        val xorBitsStringWithoutZeros = xorBitsStringWithoutZeros.reverse\n\
    \        xorBitsStringWithoutZeros.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16f94w6j.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithoutZeros\e\
    [0m = xorBitsStringWithoutZeros.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithoutZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793057
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ new mutable.HashMap[Int, Int]()\n        val xorResult = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult2 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult3 = new mutable.HashMap[Int, Int]()\n        val xorResult4 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult5 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult6 = new mutable.HashMap[Int, Int]()\n        val xorResult7 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult8 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult9 = new mutable.HashMap[Int, Int]()\n        val xorResult10 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult11 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult12 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult13 = new mutable.HashMap[Int, Int]()\n        val xorResult14 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult15 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult16 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult17 = new mutable.HashMap[Int, Int]()\n        val xorResult18 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult19 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult20 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult21 = new mutable.HashMap[Int, Int]()\n        val xorResult22 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult23 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult24 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult25 = new mutable.HashMap[Int, Int]()\n        val xorResult26 = new\
    \ mutable.HashMap[Int, Int]()\n        val xorResult27 = new mutable.HashMap[Int,\
    \ Int]()\n        val xorResult28 = new mutable.HashMap[Int, Int]()\n        val\
    \ xorResult29 = new mutable.HashMap[Int, Int]()\n        val xorResult30 = new\
    \ mutable.HashMap[In\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp55nydsjw.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp55nydsjw.scala:12:22\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp55nydsjw.scala:13:28 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp55nydsjw.scala:14:29 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                       \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp55nydsjw.scala:15:29\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp55nydsjw.scala:16:29 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e"
  stdout: ''
  timestamp: 1659793059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        val xorArray2 = ArrayBuffer.empty[Int]\n        val xorArray3 = ArrayBuffer.empty[Int]\n\
    \        val xorArray4 = ArrayBuffer.empty[Int]\n        val xorArray5 = ArrayBuffer.empty[Int]\n\
    \        val xorArray6 = ArrayBuffer.empty[Int]\n        val xorArray7 = ArrayBuffer.empty[Int]\n\
    \        val xorArray8 = ArrayBuffer.empty[Int]\n        val xorArray9 = ArrayBuffer.empty[Int]\n\
    \        val xorArray10 = ArrayBuffer.empty[Int]\n        val xorArray11 = ArrayBuffer.empty[Int]\n\
    \        val xorArray12 = ArrayBuffer.empty[Int]\n        val xorArray13 = ArrayBuffer.empty[Int]\n\
    \        val xorArray14 = ArrayBuffer.empty[Int]\n        val xorArray15 = ArrayBuffer.empty[Int]\n\
    \        val xorArray16 = ArrayBuffer.empty[Int]\n        val xorArray17 = ArrayBuffer.empty[Int]\n\
    \        val xorArray18 = ArrayBuffer.empty[Int]\n        val xorArray19 = ArrayBuffer.empty[Int]\n\
    \        val xorArray20 = ArrayBuffer.empty[Int]\n        val xorArray21 = ArrayBuffer.empty[Int]\n\
    \        val xorArray22 = ArrayBuffer.empty[Int]\n        val xorArray23 = ArrayBuffer.empty[Int]\n\
    \        val xorArray24 = ArrayBuffer.empty[Int]\n        val xorArray25 = ArrayBuffer.empty[Int]\n\
    \        val xorArray26 = ArrayBuffer.empty[Int]\n        val xorArray27 = ArrayBuffer.empty[Int]\n\
    \        val xorArray28 = ArrayBuffer.empty[Int]\n        val xorArray29 = ArrayBuffer.empty[Int]\n\
    \        val xorArray30 = ArrayBuffer.empty[Int]\n        val xorArray31 = ArrayBuffer.empty[Int]\n\
    \        val xorArray32 = ArrayBuffer.empty[Int]\n        val xorArray33 = ArrayBuffer.empty[Int]\n\
    \        val xorArray34 = ArrayBuffer.empty[Int]\n        val xorArray35 = ArrayBuffer.empty[Int]\n\
    \        val xorArray36 = ArrayBuffer.empty[Int]\n        val xorArray37 = ArrayBuffer.empty[Int]\n\
    \        val xorArray38 = ArrayBuffer.empty[Int]\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuc3c2fhs.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.reverse.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6ufepa0d.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        for(i <- 0 until aBits.length)\n\
    \            result += ((aBits & (1 << i)) != (bBits & (1 << i)) ? \"1\" : \"\
    0\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcvfpfu00.scala:12:31 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aBits.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value length is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcvfpfu00.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aBits & (\e[31m1\e[0m << i))\
    \ != (bBits & (\e[31m1\e[0m << i)) ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcvfpfu00.scala:13:64 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m            result += ((aBits & (\e[31m1\e[0m << i)) != (bBits\
    \ & (\e[31m1\e[0m << i)) ? \e[31m\"1\"\e[0m : \e[31m\"0\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          value ? is not a\
    \ member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659793060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        for(i <- 0 until aBits)\
    \ {\n            result += (if (aBits & (1 << i)) \"1\" else \"0\") + \"^\" +\
    \ (if (bBits & (1 << i)) \"1\" else \"0\") + \" = \" + (if (aBits & (1 << i))\
    \ \"1\" else \"0\") + \"^\" + (if (bBits & (1 << i)) \"1\" else \"0\") + \"\\\
    n\"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp799dv6sd.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += (\e[33mif\e[0m (aBits & (\e[31m1\e\
    [0m << i)) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m) + \e[31m\"^\"\e\
    [0m + (\e[33mif\e[0m (bBits & (\e[31m1\e[0m << i)) \e[31m\"1\"\e[0m \e[33melse\e\
    [0m \e[31m\"0\"\e[0m) + \e[31m\" = \"\e[0m + (\e[33mif\e[0m (aBits & (\e[31m1\e\
    [0m << i)) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m) + \e[31m\"^\"\e\
    [0m + (\e[33mif\e[0m (bBits & (\e[31m1\e[0m << i)) \e[31m\"1\"\e[0m \e[33melse\e\
    [0m \e[31m\"0\"\e[0m) + \e[31m\"\\n\"\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp799dv6sd.scala:13:27\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            result += (\e[33mif\e\
    [0m (aBits & (\e[31m1\e[0m << i)) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\
    \e[0m) + \e[31m\"^\"\e[0m + (\e[33mif\e[0m (bBits & (\e[31m1\e[0m << i)) \e[31m\"\
    1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m) + \e[31m\" = \"\e[0m + (\e[33mif\e\
    [0m (aBits & (\e[31m1\e[0m << i)) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\
    \e[0m) + \e[31m\"^\"\e[0m + (\e[33mif\e[0m (bBits & (\e[31m1\e[0m << i)) \e[31m\"\
    1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m) + \e[31m\"\\n\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                        Found:    Int\n\e[31m   |\e[0m                      \
    \     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp799dv6sd.scala:13:72\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m            result += (\e[33mif\e\
    [0m (aBits & (\e[31m1\e[0m << i)) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\
    \e[0m) + \e[31m\"^\"\e[0m + (\e[33mif\e[0m (bBits & (\e[31m1\e[0m << i)) \e[31m\"\
    1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m) + \e[31m\" = \"\e[0m + (\e[33mif\e\
    [0m (aBits & (\e[31m1\e[0m << i)) \e[31m\"1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\
    \e[0m) + \e[31m\"^\"\e[0m + (\e[33mif\e[0m (bBits & (\e[31m1\e[0m << i)) \e[31m\"\
    1\"\e[0m \e[33melse\e[0m \e[31m\"0\"\e[0m) + \e[31m\"\\n\"\e[0m\n\e[31m\e[31m\
    \   |\e[0m                                          "
  stdout: ''
  timestamp: 1659793061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithZeros = xorBitsStringWithZeros.substring(0,\
    \ xorBitsStringWithZeros.length - 1)\n        xorBitsStringWithZeros\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppalpl4d_.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e\
    [0m = xorBitsStringWithZeros.substring(\e[31m0\e[0m, xorBitsStringWithZeros.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppalpl4d_.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppalpl4d_.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.BitSet(b.length)\n        val xorResult = mutable.BitSet(b.length)\n\
    \        val xorResult2 = mutable.BitSet(b.length)\n        val xorResult3 = mutable.BitSet(b.length)\n\
    \        val xorResult4 = mutable.BitSet(b.length)\n        val xorResult5 = mutable.BitSet(b.length)\n\
    \        val xorResult6 = mutable.BitSet(b.length)\n        val xorResult7 = mutable.BitSet(b.length)\n\
    \        val xorResult8 = mutable.BitSet(b.length)\n        val xorResult9 = mutable.BitSet(b.length)\n\
    \        val xorResult10 = mutable.BitSet(b.length)\n        val xorResult11 =\
    \ mutable.BitSet(b.length)\n        val xorResult12 = mutable.BitSet(b.length)\n\
    \        val xorResult13 = mutable.BitSet(b.length)\n        val xorResult14 =\
    \ mutable.BitSet(b.length)\n        val xorResult15 = mutable.BitSet(b.length)\n\
    \        val xorResult16 = mutable.BitSet(b.length)\n        val xorResult17 =\
    \ mutable.BitSet(b.length)\n        val xorResult18 = mutable.BitSet(b.length)\n\
    \        val xorResult19 = mutable.BitSet(b.length)\n        val xorResult20 =\
    \ mutable.BitSet(b.length)\n        val xorResult21 = mutable.BitSet(b.length)\n\
    \        val xorResult22 = mutable.BitSet(b.length)\n        val xorResult23 =\
    \ mutable.BitSet(b.length)\n        val xorResult24 = mutable.BitSet(b.length)\n\
    \        val xorResult25 = mutable.BitSet(b.length)\n        val xorResult26 =\
    \ mutable.BitSet(b.length)\n        val xorResult27 = mutable.BitSet(b.length)\n\
    \        val xorResult28 = mutable.BitSet(b.length)\n        val xorResult29 =\
    \ mutable.BitSet(b.length)\n        val xorResult30 = mutable.BitSet(b.length)\n\
    \        val xorResult31 = mutable.BitSet(b.length)\n        val xorResult32 =\
    \ mutable.BitSet(b.length)\n        val xorResult33 = mutable.BitSet(b.length)\n\
    \        val xorResult34 = mutable.BitSet(b.length)\n        val xorResult35 =\
    \ mutable.BitSet(b.length)\n        val xorResult36 = mutable.BitSet(b.length)\n\
    \        val xorResult37 = mutable.BitSet(b.length)\n        val xorResult38 =\
    \ mutable.Bit\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpunm07m6b.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpunm07m6b.scala:13:24 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.BitSet(b.length)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:14:25 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:15:25 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:16:25 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpunm07m6b.scala:17:25 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mxorResult5\e[0m = mutable.BitSet(b."
  stdout: ''
  timestamp: 1659793056
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits ^ bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithZeros.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk1y9vxpr.scala:13:51 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n1 error found\n"
  stdout: ''
  timestamp: 1659793060
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n\
    \                if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.toList.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb429gzjq.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793059
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringWithZeros = Array.fill(xorBitsStringLength)(0)\n   \
    \     val xorBitsStringWithZerosString = String.join(xorBitsStringWithZeros, \"\
    \")\n        val xorBitsStringWithZerosLength = xorBitsStringWithZeros.length\n\
    \        val xorBitsStringWithZerosWithZeros = Array.fill(xorBitsStringWithZerosLength)(0)\n\
    \        val xorBitsStringWithZerosWithZerosString = String.join(xorBitsStringWithZerosWithZeros,\
    \ \"\")\n        val xorBitsStringWithZerosWithZerosLength = xorBitsStringWithZerosWithZeros.length\n\
    \        val xorBitsStringWithZerosWithZerosWithZeros = Array.fill(xorBitsStringWithZerosWithZerosLength)(0)\n\
    \        val xorBitsStringWithZerosWithZerosWithZerosString = String.join(xorBitsStringWithZerosWithZerosWithZeros,\
    \ \"\")\n        val xorBitsStringWithZerosWithZerosWithZerosLength = xorBitsStringWithZerosWithZerosWithZeros.length\n\
    \        val xorBitsStringWithZerosWithZerosWithZerosWithZeros = Array.fill(xorBitsStringWithZerosWithZerosWithZerosLength)(0)\n\
    \        val xorBitsStringWithZerosWithZerosWithZerosWithZerosString = String.join(xorBitsStringWithZerosWithZerosWithZerosWithZeros,\
    \ \"\")\n        val xorBitsStringWithZerosWithZerosWithZerosWithZerosLength =\
    \ xorBitsStringWithZerosWithZerosWithZerosWithZeros.length\n        val xorBitsStringWithZerosWithZerosWithZerosWithZerosWithZeros\
    \ = Array.fill(xorBitsStringWithZerosWithZerosWithZerosWithZerosLength)(0)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprwvhx5ja.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmprwvhx5ja.scala:15:50 -----------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZerosString\e\
    [0m = String.join(xorBitsStringWithZeros, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mjoin\e[0m in \e[33mobject\e\
    [0m \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: CharSequence, x$1: Iterable[?\
    \ <: CharSequence]): String\n\e[31m   |\e[0m (x$0: CharSequence, x$1: CharSequence*):\
    \ String\n\e[31m   |\e[0mmatch arguments ((xorBitsStringWithZeros : Array[Int]),\
    \ (\e[32m\"\"\e[0m : String))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmprwvhx5ja.scala:18:59\
    \ -----------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e\
    [0m \e[36mxorBitsStringWithZerosWithZerosString\e[0m = String.join(xorBitsStringWithZerosWithZeros,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mjoin\e[0m in \e[33mobject\e[0m \e[35mString\e[0m\
    \ with types\n\e[31m   |\e[0m (x$0: CharSequence, x$1: Iterable[? <: CharSequence]):\
    \ String\n\e[31m   |\e[0m (x$0: CharSequence, x$1: CharSequence*): String\n\e\
    [31m   |\e[0mmatch arguments ((xorBitsStringWithZerosWithZeros : Array[Int]),\
    \ (\e[32m\"\"\e[0m : String))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmprwvhx5ja.scala:21:68\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e\
    [0m \e[36mxorBitsStringWithZerosWithZerosWithZerosString\e[0m = String.join(xorBitsStringWithZerosWithZerosWithZeros,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e"
  stdout: ''
  timestamp: 1659793062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val result = xorBitsStringWithZeros.substring(0, xorBitsStringWithZeros.length\
    \ - 1)\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp229ycyux.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp229ycyux.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length)\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu1kc1zng.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.length){\n            val aChar = aList(i)\n        \
    \    val bChar = bList(i)\n            val aCharInt = aChar match {\n        \
    \        case '1' => 1\n                case '0' => 0\n                case _\
    \ => throw new IllegalArgumentException(\"Invalid character in string a: \" +\
    \ aChar)\n            }\n            val bCharInt = bChar match {\n          \
    \      case '1' => 1\n                case '0' => 0\n                case _ =>\
    \ throw new IllegalArgumentException(\"Invalid character in string b: \" + bChar)\n\
    \            }\n            val aCharIntInt = aCharInt xor bCharInt\n        \
    \    val aCharIntIntInt = aCharIntInt\n            val aCharIntIntIntInt = aCharIntIntIntInt\n\
    \            val aCharIntIntIntIntInt = aCharIntIntIntIntIntInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntInt\n            val aCharIntIntIntIntIntIntInt\
    \ = aCharIntIntIntIntIntIntIntIntIntIntInt\n            val aCharIntIntIntIntIntIntIntIntInt\
    \ = aCharIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbaxlx823.scala:41:0 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbaxlx823.scala:26:39\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m\
    \ \e[36maCharIntInt\e[0m = aCharInt xor bCharInt\n\e[31m\e[31m   |\e[0m      \
    \                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \            value xor is not a member of Int\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpbaxlx823.scala:30:42 ------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            \e[33mval\e[0m \e[36maCharIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntInt\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: aCharIntIntIntIntIntIntIntInt\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbaxlx823.scala:31:45\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m\
    \ \e[36maCharIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Not found: aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbaxlx823.scala:32:51\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m\
    \ \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntI"
  stdout: ''
  timestamp: 1659793062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        return xorBitsString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj5t09hdx.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = 0\n        for (i <- 0 until aList.length)\n\
    \            for (j <- 0 until bList.length)\n                result += (if (aList(i)\
    \ XOR bList(j) == 1) 1 else 0)\n        result XOR a.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3u_xu_j6.scala:14:23 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m                result += (\e[33mif\e[0m (aList(i) XOR\
    \ bList(j) == \e[31m1\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp3u_xu_j6.scala:14:40 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m                result += (\e[33mif\e[0m (aList(i) XOR bList(j)\
    \ == \e[31m1\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m                               ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                           value XOR is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3u_xu_j6.scala:15:15 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        result XOR a.length\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value XOR is not a member of Int\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659793063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n    \
    \    var i = 0\n        while (i < aList.size) {\n            xorList += (aList(i)\
    \ xor bList(i))\n            i += 1\n        }\n        xorList.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1gw88kh_.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val result = new StringBuilder\n        val xorBits\
    \ = aBits xor bBits\n        val bits = xorBits shr 8\n        val remainder =\
    \ xorBits rem 8\n        result ++= bits\n        result ++= remainder\n     \
    \   return result.toString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6_25dyu1.scala:12:28 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xor = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult2 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult3 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult4 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult5\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult6 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult7 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult8 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult9\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult10 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult11 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult12 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult13\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult14 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult15 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult16 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult17\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult18 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult19 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult20 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult21\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult22 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult23 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult24 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult25\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult26 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult27 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult28 = mutable.ArrayBuffer.fill\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp6pj2hlim.scala:13:24 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scal"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(\n            bList.zip(\n                aList.map(x => x ^\
    \ bList(0))\n            )\n        ).foreach(x => xorList += x._2)\n        xorList.toList.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaja6eudo.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString)\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString.substring(0, xorBitsStringLength - 1))\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.insert(0, xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString.substring(0, xorBitsStringLength - 1))\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.insert(0, xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString.substring(0, xorBitsStringLength - 1))\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.insert(0, xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString.substring(0, xorBitsStringLength - 1))\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.insert(0, xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString.substring(0, xorBitsStringLength - 1))\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.insert(0, xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString.substring(0, xorBitsStringLength - 1))\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.insert(0, xorBitsString.substring(0, xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.insert(0,\
    \ xorBitsString.substring(0, xorBitsStringLength - 1))\n        xorBitsStringBuilder.reverse()\n\
    \        xor\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycd8u2lx.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpycd8u2lx.scala:15:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmpycd8u2lx.scala:17:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m--\
    \ Error: /tmp/tmpycd8u2lx.scala:19:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmpycd8u2lx.scala:21:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m--\
    \ Error: /tmp/tmpycd8u2lx.scala:23:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1659793063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      val xor = mutable.ListBuffer[Int]()\n        var i = 0\n        while(i\
    \ < aList.size) {\n            xor.append(aList(i) xor bList(i))\n           \
    \ i += 1\n        }\n        while(i < aList.size) {\n            result.append(xor.remove(0))\n\
    \            i += 1\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbz7w2nzl.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbz7w2nzl.scala:12:18\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793062
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = aArray(i) xor bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptxr8mqdj.scala:12:66 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                       value xor is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp22ak10xx.scala:12:63 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aArray.length)\
    \ xorArray += (aArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m               \
    \                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                     value xor is not a member of Int\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp22ak10xx.scala:13:8 ---------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        xorArray.toString.toCharArray\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Array[Char]\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until a.length) xorArray += (aArray(i) xor bArray(i))\n  \
    \      xorArray.toString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphlkogrbk.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       for(i <- 0 until xorBitsStringLength) {\n            xorBitsStringBuilder.append(xorBitsString(i))\n\
    \        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkdbwdh3y.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xorResult = mutable.ArrayBuffer.empty[Int]\n        var i = 0\n \
    \       while (i < a.length && i < b.length) {\n            xorResult += (aArray(i)\
    \ xor bArray(i))\n            i += 1\n        }\n        result.append((xorResult.toList.reverse.mkString))\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9c22jzio.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9c22jzio.scala:12:24 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793063
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      var carry = 0\n        var i = 0\n        while (i < aList.size) {\n  \
    \          val aChar = aList(i)\n            val bChar = bList(i)\n          \
    \  val aInt = aChar match {\n                case '1' => 1\n                case\
    \ '0' => 0\n                case _ => throw new IllegalArgumentException(\"Invalid\
    \ input\")\n            }\n            val bInt = bChar match {\n            \
    \    case '1' => 1\n                case '0' => 0\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid input\")\n            }\n           \
    \ val aInt2 = aInt XOR bInt\n            val aInt3 = aInt2 XOR carry\n       \
    \     val aInt4 = aInt3 XOR carry\n            val aInt5 = aInt4 XOR carry\n \
    \           val aInt6 = aInt5 XOR carry\n            val aInt7 = aInt6 XOR carry\n\
    \            val aInt8 = aInt7 XOR carry\n            val aInt9 = aInt8 XOR carry\n\
    \            val aInt10 = aInt9 XOR carry\n            val aInt11 = aInt10 XOR\
    \ carry\n            val aInt12 = aInt11 XOR carry\n            val aInt13 = aInt12\
    \ XOR carry\n            val aInt14 = aInt13 XOR carry\n            val aInt15\
    \ = aInt14 XOR carry\n            val aInt16 = aInt15 XOR carry\n            val\
    \ aInt17 = aInt16 XOR carry\n            val aInt18 = aInt17 XOR carry\n     \
    \       val aInt19 = aInt18 XOR carry\n            val aInt20 = aInt19 XOR carry\n\
    \            val aInt21 = aInt20 XOR carry\n            val aInt22 = aInt21 XOR\
    \ carry\n            val aInt23 = aInt22 XOR carry\n            val aInt24 = aInt23\
    \ XOR carry\n            val aInt25 = aInt24 XOR carry\n            val aInt26\
    \ = aInt25 XOR carry\n            val aInt27 = aInt26 XOR carry\n            val\
    \ aInt28 = aInt27 XOR carry\n            val aInt29 = aInt28 XOR carry\n     \
    \       val aInt30 = aInt29 XOR carry\n            val aInt31 = aInt30 XOR carry\n\
    \            val aInt32 = aInt31 XOR carry\n            val aInt33 = aInt32 XOR\
    \ carry\n\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8e7g1g16.scala:68:0 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8e7g1g16.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp8e7g1g16.scala:27:29 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m            \e[33mval\e[0m \e[36maInt2\e[0m = aInt XOR bInt\n\e[31m\e[31m \
    \  |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \          value XOR is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8e7g1g16.scala:67:1 ---------------------\e[0m\e[0m\n\e[31m67\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp8e7g1g16.scala:61:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m61 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659793065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val result = xorBitsStringWithLeadingZeros + \"0\"\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1rtf1ki_.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp1rtf1ki_.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793064
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(1,xorBitsString.length)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        xorBitsStringWithoutLeadingZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvo70f772.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithoutLeadingZeros\e\
    [0m = xorBitsStringWithoutLeadingZeros.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutLeadingZeros is already defined as \e\
    [33mvalue\e[0m \e[35mxorBitsStringWithoutLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvo70f772.scala:11:28\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorBits\e[0m = aBits xor bBits\n\e[31m\e[31m   |\e[0m                    \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value xor is not a member\
    \ of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659793065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.reverse\n\
    \        val xorBit\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmpevdnhd.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmpevdnhd.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBitsStringWithLeadingZeros\e[0m = xorBitsStringWithLeadingZeros.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithLeadingZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmpevdnhd.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsStringWithLeadingZeros.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithLeadingZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmpevdnhd.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsStringWithLeadingZeros.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithLeadingZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmpevdnhd.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsStringWithLeading"
  stdout: ''
  timestamp: 1659793065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      var carry = 0\n        for (i <- 0 until aList.size) {\n            val\
    \ aChar = aList(i)\n            val bChar = bList(i)\n            val aCharInt\
    \ = aChar.toInt\n            val bCharInt = bChar.toInt\n            val aCharIntInt\
    \ = aCharInt.toInt\n            val bCharIntInt = bCharInt.toInt\n           \
    \ val aCharIntIntInt = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n\
    \            val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9nna0bmc.scala:45:0 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9nna0bmc.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9nna0bmc.scala:35:57 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m            \e[33mval\e[0m \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m\
    \ = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\e[31m\e[31m   |\e[0m   \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: bCharIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9nna0bmc.scala:34:57\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m\
    \ \e[36maCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: aCharIntIntIntIntIntIntIntIntIntIntIntInt\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9nna0bmc.scala:44:1 ---------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp9nna0bmc.scala:38:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m38 |\e[0m    \e[33m"
  stdout: ''
  timestamp: 1659793066
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.size) {\n            xorList += ((aList(i) xor\
    \ bList(i)).toString + aList(i))\n        }\n        xorList.toList.reverse.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph89uhpjo.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793065
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n    \
    \    var i = 0\n        while (i < aList.size) {\n            xorList += (aList(i)\
    \ xor bList(i))\n            i += 1\n        }\n        xorList.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1gw88kh_.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793061
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9panidxx.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9panidxx.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793040
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793040
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array[Int]()\n        val\
    \ xorResult = Array[Int]()\n        val aLen = aBits.length\n        val bLen\
    \ = bBits.length\n        val aLenInt = aLen.toInt\n        val bLenInt = bLen.toInt\n\
    \        val aLenBits = aLen.toBinaryString\n        val bLenBits = bLen.toBinaryString\n\
    \        val xorLen = (aLen + bLen).toBinaryString\n        val xorLenInt = xorLen.toInt\n\
    \        val xorLenBits = xorLen.toBinaryString\n        val xorResultLen = (aLen\
    \ + bLen).toBinaryString\n        val xorResultLenInt = xorResultLen.toInt\n \
    \       val xorResultLenBits = xorResultLen.toBinaryString\n        val xorBitsLen\
    \ = (aLen + bLen).toBinaryString\n        val xorBitsLenInt = xorBitsLen.toInt\n\
    \        val xorBitsLenBits = xorBitsLen.toBinaryString\n        val xorBitsResultLen\
    \ = (aLen + bLen).toBinaryString\n        val xorBitsResultLenInt = xorBitsResultLen.toInt\n\
    \        val xorBitsResultLenBits = xorBitsResultLen.toBinaryString\n        val\
    \ xorBitsResult = (aLen + bLen).toBinaryString\n        val xorBitsResultInt =\
    \ xorBitsResult.toInt\n        val xorBitsResultBits = xorBitsResult.toBinaryString\n\
    \        val xorBitsResultLen = (aLen + bLen).toBinaryString\n        val xorBitsResultLenInt\
    \ = xorBitsResultLen.toInt\n        val xorBitsResultLenBits = xorBitsResultLen.toBinaryString\n\
    \        val xorBitsResult = (aLen + bLen).toBinaryString\n        val xorBitsResultInt\
    \ = xorBitsResult.toInt\n        val xorBitsResultBits = xorBitsResult.toBinaryString\n\
    \        val xorBitsResultLen = (aLen + bLen).toBinaryString\n        val xorBitsResultLenInt\
    \ = xorBitsResultLen.toInt\n        val xorBitsResultLenBits = xorBitsResultLen.toBinaryString\n\
    \        val xorBitsResult = (aLen + bLen).toBinaryString\n        val xorBitsResultInt\
    \ = xorBitsResult.toInt\n        val xorBitsResultBits = xorBit\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_dg4chzg.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mxorBitsResultLen\e[0m =\
    \ (aLen + bLen).toBinaryString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsResultLen is already defined as \e[33mvalue\e[0m \e\
    [35mxorBitsResultLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_dg4chzg.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mxorBitsResultLenInt\e[0m\
    \ = xorBitsResultLen.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsResultLenInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mxorBitsResultLenInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_dg4chzg.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mxorBitsResultLenBits\e[0m\
    \ = xorBitsResultLen.toBinaryString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsResultLenBits is already defined as \e[33mvalue\e[0m\
    \ \e[35mxorBitsResultLenBits\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_dg4chzg.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mxorBitsResult\e[0m = (aLen\
    \ + bLen).toBinaryString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsResult is already defined as \e[33mvalue\e[0m \e[35mxorBitsResult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_dg4chzg.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38"
  stdout: ''
  timestamp: 1659793067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     val xor = new mutable.HashSet[Int]()\n        val xorArray = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray2 = new mutable.ArrayBuilder[Int]()\n        val xorArray3\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray4 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray5 = new mutable.ArrayBuilder[Int]()\n        val xorArray6\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray7 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray8 = new mutable.ArrayBuilder[Int]()\n        val xorArray9\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray10 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray11 = new mutable.ArrayBuilder[Int]()\n        val xorArray12\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray13 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray14 = new mutable.ArrayBuilder[Int]()\n        val xorArray15\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray16 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray17 = new mutable.ArrayBuilder[Int]()\n        val xorArray18\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray19 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray20 = new mutable.ArrayBuilder[Int]()\n        val xorArray21\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray22 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray23 = new mutable.ArrayBuilder[Int]()\n        val xorArray24\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray25 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray26 = new mutable.ArrayBuilder[Int]()\n        val xorArray27\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray28 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray29 = new mutable.ArrayBuilder[Int]()\n        val xorArray30\
    \ = new mutable.ArrayBuilder[Int]()\n        val xorArray31 = new mutable.ArrayBuilder[Int]()\n\
    \        val xorArray32 = new \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3qv52x4d.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp3qv52x4d.scala:12:22 ------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m mutable.HashSet[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3qv52x4d.scala:13:27 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuilder[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3qv52x4d.scala:14:28\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mxorArray2\e[0m = \e[33mnew\e[0m mutable.ArrayBuilder[\e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp3qv52x4d.scala:15:28 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorArray3\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuilder[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3qv52x4d.scala:16:28\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mxorArray4\e[0m = \e[33mnew\e[0m mutable.ArrayBuilder[\e[35mInt\e[0m]()\n\e\
    [31m\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1659793066
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        val length = aList.length\n\
    \        val length2 = bList.length\n        val maxLength = Math.max(length,\
    \ length2)\n        val aSet = scala.collection.mutable.Set[Int]()\n        val\
    \ bSet = scala.collection.mutable.Set[Int]()\n        var i = 0\n        var j\
    \ = 0\n        while (i < maxLength) {\n            if (aList(i) == bList(j))\
    \ {\n                aSet += aList(i)\n                bSet += bList(j)\n    \
    \            i += 1\n                j += 1\n            } else if (aList(i) !=\
    \ bList(j)) {\n                result += aList(i)\n                i += 1\n  \
    \          } else {\n                result += bList(j)\n                j +=\
    \ 1\n            }\n        }\n        result += aList.last\n        result +=\
    \ bList.last\n        result\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp99lom8or.scala:38)\n\tat Problem.main(tmp99lom8or.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var xor = 0\n        for (i <- 0 until aList.size) {\n            xor\
    \ = xor + aList(i) xor bList(i)\n        }\n        xorList.add(xor.toString.reverse)\n\
    \        xorList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphgvyh564.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphgvyh564.scala:14:33 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + aList(i) xor bList(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \            value xor is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659793067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val xorArray = new Array[Int](a.length)\n\
    \        var xor = 0\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xor = xor + aArray(i) xor bArray(i)\n            i += 1\n       \
    \ }\n        xor.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwyatwc27.scala:15:34 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits XOR bBits\n        val\
    \ xorBitsString = xorBits.map(_ + 48).map(_.toString).mkString(\"\")\n       \
    \ xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9kr1w76f.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9kr1w76f.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        for\
    \ (i <- 0 until aBits) {\n            val aBit = aBits - i\n            val bBit\
    \ = bBits - i\n            val aBitMask = aBit - 1\n            val bBitMask =\
    \ bBit - 1\n            val aBitValue = aBits & aBitMask\n            val bBitValue\
    \ = bBits & bBitMask\n            val aBitResult = aBitValue ^ bBitValue\n   \
    \         val bBitResult = bBitValue ^ aBitValue\n            val aBitResultMask\
    \ = aBitResult - 1\n            val bBitResultMask = bBitResult - 1\n        \
    \    val aBitResultValue = aBitResult & aBitResultMask\n            val bBitResultValue\
    \ = bBitResult & bBitResultMask\n            val aBitResultValueMask = aBitResultValue\
    \ - 1\n            val bBitResultValueMask = bBitResultValue - 1\n           \
    \ val aBitResultValueValue = aBitResultValue & aBitResultValueMask\n         \
    \   val bBitResultValueValue = bBitResultValue & bBitResultValueMask\n       \
    \     val aBitResultValueValueMask = aBitResultValueValue - 1\n            val\
    \ bBitResultValueValueMask = bBitResultValueValue - 1\n            val aBitResultValueValueValue\
    \ = aBitResultValueValue & aBitResultValueValueMask\n            val bBitResultValueValueValue\
    \ = bBitResultValueValue & bBitResultValueValueMask\n            val aBitResultValueValueValueMask\
    \ = aBitResultValueValueValue - 1\n            val bBitResultValueValueValueMask\
    \ = bBitResultValueValueValue - 1\n            val aBitResultValueValueValueValue\
    \ = aBitResultValueValueValue & aBitResultValueValueValueMask\n            val\
    \ bBitResultValueValueValueValue = bBitResultValueValueValue & bBitResultValueValueValueMask\n\
    \            val aBitResultValueValueValueValueMask = aBitResultValueValueValueValue\
    \ - 1\n            val bBitResultValueValueValueValueMask = bBitResultValueValueValueValue\
    \ - 1\n            val aBitResultValueValueValueValueValue = aBitResultValueValueValueValueValue\
    \ & aBitResultValueValueValueValueValueMask\n            val bBitResultValueValueValueValueValue\
    \ = bBitResultValueValueValueValueValue & bBitResultValueValueValueValueValueMask\n\
    \            val aBitResultValueValueValueValueValueMask = aBitResultValueValueValueValueValueValue\
    \ - 1\n            val bBitResult\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvp5slttq.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvp5slttq.scala:52:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m52 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpvp5slttq.scala:42:58 ------------------------\e[0m\e[0m\n\
    \e[31m42 |\e[0m            \e[33mval\e[0m \e[36maBitResultValueValueValueValueValueMask\e\
    [0m = aBitResultValueValueValueValueValueValue - \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: aBitResultValueValueValueValueValueValue\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvp5slttq.scala:51:1\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpvp5slttq.scala:45:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m45 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659793068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp278trq8l.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793055
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new mutable.ListBuffer[String]()\n  \
    \      var carry = 0\n        for(i <- 0 until aList.length){\n            val\
    \ aChar = aList(i)\n            val bChar = bList(i)\n            val aCharInt\
    \ = aChar match {\n                case '1' => 1\n                case '0' =>\
    \ 0\n                case _ => throw new IllegalArgumentException(\"Invalid character\
    \ in string \" + aChar)\n            }\n            val bCharInt = bChar match\
    \ {\n                case '1' => 1\n                case '0' => 0\n          \
    \      case _ => throw new IllegalArgumentException(\"Invalid character in string\
    \ \" + bChar)\n            }\n            val aCharInt = aCharInt xor bCharInt\n\
    \            val aCharChar = aCharInt match {\n                case 1 => '1'\n\
    \                case 0 => '0'\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string \" + aChar)\n            }\n            val bCharChar\
    \ = bCharInt match {\n                case 1 => '1'\n                case 0 =>\
    \ '0'\n                case _ => throw new IllegalArgumentException(\"Invalid\
    \ character in string \" + bChar)\n            }\n            val aCharCharInt\
    \ = aCharChar match {\n                case '1' => 1\n                case '0'\
    \ => 0\n                case _ => throw new IllegalArgumentException(\"Invalid\
    \ character in string \" + aChar)\n            }\n            val bCharCharInt\
    \ = bCharChar match {\n                case '1' => 1\n                case '0'\
    \ => 0\n                case _ => throw new IllegalArgumentException(\"Invalid\
    \ character in string \" + bChar)\n            }\n            val aCharCharChar\
    \ = aCharCharInt xor bCharCharInt\n            val aCharCharCharChar = aCharCharChar\
    \ match {\n                case '1' => 1\n                case '0' => 0\n    \
    \            case _ => throw new IllegalArgumentException(\"Invalid character\
    \ in string \" + aChar)\n            }\n            val bCharCharCharInt = bCharCharInt\
    \ match {\n                case 1 => 1\n                case 0 => 0\n        \
    \        case _ => throw new IllegalArgumentException(\"Invalid character in string\
    \ \" + bChar)\n            }\n            val aCharCharCharChar = bCharCharChar\
    \ match {\n                case '1' => 1\n                case '0' => 0\n    \
    \            case _ => throw new IllegalArgumentException(\"Invalid character\
    \ in string \" + aChar)\n            }\n            val aCharCharCharCharChar\
    \ = aCharCharCharCharInt xor bCharCharCharCharInt\n            val aCharCharCharCharCharChar\
    \ = aCharCharCharCharCh\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprg13o1j0.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprg13o1j0.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprg13o1j0.scala:26:16 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36maCharInt\e[0m = aCharInt xor bCharInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0maCharInt is already defined as \e[33mvalue\e[0m \e[35maCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprg13o1j0.scala:58:16 ---------------------------\e[0m\e[0m\n\e\
    [31m58 |\e[0m            \e[33mval\e[0m \e[36maCharCharCharChar\e[0m = bCharCharChar\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0maCharCharCharChar\
    \ is already defined as \e[33mvalue\e[0m \e[35maCharCharCharChar\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m59 |\e[0m                \e[33mcase\e\
    [0m \e[31m'1'\e[0m => \e[31m1\e[0m\n\e[31m60 |\e[0m                \e[33mcase\e\
    [0m \e[31m'0'\e[0m => \e[31m0\e[0m\n\e[31m61 |\e[0m                \e[33mcase\e\
    [0m _ => \e[33mthrow\e[0m \e[33mnew\e[0m \e[35mIllegalArgumentException\e[0m(\e\
    [31m\"Invalid character in string \"\e[0m + aChar)\n\e[31m62 |\e[0m          \
    \  }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprg13o1j0.scala:47:45 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e[0m \e[36maCharCharChar\e[0m =\
    \ aCharCharInt xor bCharCharInt\n\e[31m\e[31m   |\e[0m                       \
    \         ^^^^^^^^^"
  stdout: ''
  timestamp: 1659793069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ var i = 0\n        while (i < aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n  \
    \          val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9l399x2i.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:30:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:32:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9l399x2i.scala:33:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9l399x2i.scala:36:57\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntI"
  stdout: ''
  timestamp: 1659793050
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = 0\n        var carry = 0\n        var\
    \ i = 0\n        while (i < aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n  \
    \          val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvdvwez3l.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvdvwez3l.scala:30:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvdvwez3l.scala:32:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvdvwez3l.scala:33:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvdvwez3l.scala:36:57\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntI"
  stdout: ''
  timestamp: 1659793069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = aBits XOR bBits\n        val\
    \ xorBitsString = xorBits.map(bit => if (bit == 1) \"1\" else \"0\").mkString\n\
    \        xorBitsString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphmytvs9o.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphmytvs9o.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793068
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ XOR bList(i)\n            i += 1\n        }\n        xorList.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ql6h5aw.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        for (i <- 0 until aList.size) {\n            val aChar = aList(i)\n\
    \            val bChar = bList(i)\n            val xor = aChar xor bChar\n   \
    \         val newCarry = xor and carry\n            carry = newCarry\n       \
    \     result.append(newCarry)\n        }\n        carry match {\n            case\
    \ 0 => result.toString\n            case _ => result.toString + \"1\"\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps0hi9fxc.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length){\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq9iv344g.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793067
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        var i = 0\n        while (i < aList.size) {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val aCharInt = aChar.toInt\n\
    \            val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpchoof3gm.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpchoof3gm.scala:30:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpchoof3gm.scala:31:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpchoof3gm.scala:32:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mbCharIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mbCharIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpchoof3gm.scala:33:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36maCharIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0m             Recursive \e[33mvalue\e[0m \e[35maCharIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation"
  stdout: ''
  timestamp: 1659793069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        var i = 0\n        while (i < a.length) {\n  \
    \          val aBit = aBits(i)\n            val bBit = bBits(i)\n            val\
    \ xor = (aBit xor bBit) xor carry\n            carry = xor shr 1\n           \
    \ result.append(xor and 255)\n            i += 1\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxot79l6r.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxot79l6r.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpxot79l6r.scala:11:25 ------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m\
    \ mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659793069
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new StringBuilder\n   \
    \     var i = 0\n        while (i < a.length) {\n            result.append(aArray(i)\
    \ ^ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        var i = 0\n        while (i < xorBits.length) {\n            xorBits(i)\
    \ = aBits(i) xor bBits(i)\n            i += 1\n        }\n        xorBits.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp29me2qrr.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp29me2qrr.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793070
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList\
    \ += aChar ^ bChar\n        }\n        xorList.toList.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6d0iq0f6.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793069
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.ListBuffer[Int]()\n        val xorResult = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount = mutable.ListBuffer[Int]()\n        val xorResultCount2\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount3 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount4 = mutable.ListBuffer[Int]()\n        val xorResultCount5\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount6 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount7 = mutable.ListBuffer[Int]()\n        val xorResultCount8\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount9 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount10 = mutable.ListBuffer[Int]()\n        val xorResultCount11\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount12 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount13 = mutable.ListBuffer[Int]()\n        val xorResultCount14\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount15 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount16 = mutable.ListBuffer[Int]()\n        val xorResultCount17\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount18 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount19 = mutable.ListBuffer[Int]()\n        val xorResultCount20\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount21 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount22 = mutable.ListBuffer[Int]()\n        val xorResultCount23\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount24 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount25 = mutable.ListBuffer[Int]()\n        val xorResultCount26\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount27 = mutable.ListBuffer[Int]()\n\
    \        val xorResultCount28 = mutable.ListBuffer[Int]()\n        val xorResultCount29\
    \ = mutable.ListBuffer[Int]()\n        val xorResultCount30 = mutable.ListBuffer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcg1ynhay.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcg1ynhay.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcg1ynhay.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResultCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcg1ynhay.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResultCount2\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcg1ynhay.scala:16:30 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResultCount3\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcg1ynhay.scala:17:30 --------------"
  stdout: ''
  timestamp: 1659793071
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.foldLeft(\"\") { (result, x) =>\n\
    \            val y = bList.find(_ == x)\n            result + (if (y == None)\
    \ 0 else 1)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4v189u3h.scala:18)\n\tat Problem.main(tmp4v189u3h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val result = xorBitsStringWithZeros.padToLength(xorBitsStringWithZeros.length,\
    \ \"0\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxb_2yy47.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxb_2yy47.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        for(i\
    \ <- 0 until aBits.length){\n            val aBit = aBits(i)\n            val\
    \ bBit = bBits(i)\n            val aBitVal = aBit + carry\n            val bBitVal\
    \ = bBit + carry\n            val aBitValInt = aBitVal % 2\n            val bBitValInt\
    \ = bBitVal % 2\n            val aBitValString = aBitValInt.toString\n       \
    \     val bBitValString = bBitValInt.toString\n            val aBitValStringWithCarry\
    \ = aBitValString + aBitValString + aBitValString\n            val bBitValStringWithCarry\
    \ = bBitValString + bBitValString + bBitValString\n            val aBitValStringWithCarryInt\
    \ = aBitValStringWithCarry.toInt\n            val bBitValStringWithCarryInt =\
    \ bBitValStringWithCarry.toInt\n            val aBitValStringWithCarryString =\
    \ aBitValStringWithCarryInt.toString\n            val bBitValStringWithCarryString\
    \ = bBitValStringWithCarryInt.toString\n            val aBitValStringWithCarryStringWithCarry\
    \ = aBitValStringWithCarryString + aBitValStringWithCarryString + aBitValStringWithCarryString\n\
    \            val bBitValStringWithCarryStringWithCarry = bBitValStringWithCarryString\
    \ + bBitValStringWithCarryString + bBitValStringWithCarryString\n            val\
    \ aBitValStringWithCarryStringWithCarryInt = aBitValStringWithCarryStringWithCarry.toInt\n\
    \            val bBitValStringWithCarryStringWithCarryInt = bBitValStringWithCarryStringWithCarry.toInt\n\
    \            val aBitValStringWithCarryStringWithCarryString = aBitValStringWithCarryStringWithCarryInt.toString\n\
    \            val bBitValStringWithCarryStringWithCarryString = bBitValStringWithCarryStringWithCarryInt.toString\n\
    \            val aBitValStringWithCarryStringWithCarryStringWithCarry = a\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx2629y3d.scala:43:0 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx2629y3d.scala:13:31\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m(i\
    \ <- \e[31m0\e[0m until aBits.length){\n\e[31m\e[31m   |\e[0m                \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value length\
    \ is not a member of Int\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpx2629y3d.scala:14:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e\
    [0m \e[36maBit\e[0m = aBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35maBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpx2629y3d.scala:15:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36mbBit\e[0m = bBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35mbBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx2629y3d.scala:42:1\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpx2629y3d.scala:36:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m36 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659793072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   val xor = mutable.ListBuffer[String]()\n        val xorResult = mutable.ListBuffer[String]()\n\
    \        val xorResultString = mutable.ListBuffer[String]()\n        val xorResultString2\
    \ = mutable.ListBuffer[String]()\n        val xorResultString3 = mutable.ListBuffer[String]()\n\
    \        val xorResultString4 = mutable.ListBuffer[String]()\n        val xorResultString5\
    \ = mutable.ListBuffer[String]()\n        val xorResultString6 = mutable.ListBuffer[String]()\n\
    \        val xorResultString7 = mutable.ListBuffer[String]()\n        val xorResultString8\
    \ = mutable.ListBuffer[String]()\n        val xorResultString9 = mutable.ListBuffer[String]()\n\
    \        val xorResultString10 = mutable.ListBuffer[String]()\n        val xorResultString11\
    \ = mutable.ListBuffer[String]()\n        val xorResultString12 = mutable.ListBuffer[String]()\n\
    \        val xorResultString13 = mutable.ListBuffer[String]()\n        val xorResultString14\
    \ = mutable.ListBuffer[String]()\n        val xorResultString15 = mutable.ListBuffer[String]()\n\
    \        val xorResultString16 = mutable.ListBuffer[String]()\n        val xorResultString17\
    \ = mutable.ListBuffer[String]()\n        val xorResultString18 = mutable.ListBuffer[String]()\n\
    \        val xorResultString19 = mutable.ListBuffer[String]()\n        val xorResultString20\
    \ = mutable.ListBuffer[String]()\n        val xorResultString21 = mutable.ListBuffer[String]()\n\
    \        val xorResultString22 = mutable.ListBuffer[String]()\n        val xorResultString23\
    \ = mutable.ListBuffer[String]()\n        val xorResultString24 = mutable.ListBuffer[String]()\n\
    \        val xorResultString25 = mutable.ListBuffer[String]()\n        val xorResultString26\
    \ = mutable.ListBuffer[String]()\n        val xorResultString27 = mutable.ListBuffer[String]()\n\
    \        val xorResultString28 = mutable.ListBuffer[String]()\n        val xorResultString29\
    \ = mutable.ListBuffer[String]()\n        val xorResultString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_bq5ti3q.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bq5ti3q.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorList\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bq5ti3q.scala:12:18\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bq5ti3q.scala:13:24\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bq5ti3q.scala:14:30\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResultString\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp_bq5ti3q.scala:15:31 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResultString2\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              "
  stdout: ''
  timestamp: 1659793072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val result =\
    \ xorBits.toBinaryString\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_odkmfv5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793046
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val result = xorBitsString.reverse\n  \
    \      return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprsimfl6_.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = 0\n        var i = 0\n        while (i\
    \ < a.length) {\n            result += (aBits & (1 << (a.length - i - 1))) xor\
    \ (bBits & (1 << (b.length - i - 1)))\n            i += 1\n        }\n       \
    \ val resultString = Integer.toBinaryString(result)\n        resultString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp57k1y0_k.scala:14:19 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result += (aBits & (\e[31m1\e[0m << (a.length\
    \ - i - \e[31m1\e[0m))) xor (bBits & (\e[31m1\e[0m << (b.length - i - \e[31m1\e\
    [0m)))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \       value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp57k1y0_k.scala:14:58 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result += (aBits & (\e[31m1\e[0m << (a.length\
    \ - i - \e[31m1\e[0m))) xor (bBits & (\e[31m1\e[0m << (b.length - i - \e[31m1\e\
    [0m)))\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value xor is not a member of Int\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1659793073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(0,xorBitsString.length-1)\n        xorBitsStringWithoutLeadingZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps678ifgo.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toString(xorBits)\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringWithZeros = Array.fill(xorBitsStringLength)(0)\n   \
    \     xorBitsStringWithZeros ++ xorBitsString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvzbaxor5.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpvzbaxor5.scala:15:8 ---------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        xorBitsStringWithZeros ++ xorBitsString.reverse\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Array[AnyVal]\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ xor bList(i)\n            i += 1\n        }\n        xorList.toList.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphzde8nbn.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793071
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        var result = 0\n        var i = 0\n\
    \        var j = 0\n        while(i < aArray.length && j < bArray.length) {\n\
    \            if(aArray(i) == bArray(j)) {\n                result += aArray(i)\
    \ ^ bArray(j)\n                i += 1\n                j += 1\n            }\n\
    \            else {\n                result += 1\n                i += 1\n   \
    \         }\n        }\n        while(i < aArray.length) {\n            result\
    \ += 1\n            i += 1\n        }\n        while(j < bArray.length) {\n  \
    \          result += 1\n            j += 1\n        }\n        return Integer.toBinaryString(result).padLeft(8,\
    \ '0')\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7f9lvg24.scala:33:46 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mreturn\e[0m Integer.toBinaryString(result).padLeft(\e\
    [31m8\e[0m, \e[31m'0'\e[0m)\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               value padLeft is not a member of String\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1659793073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.size) {\n            val aChar = aList(i)\n         \
    \   val bChar = bList(i)\n            val aInt = aChar match {\n             \
    \   case '1' => 1\n                case '0' => 0\n                case _ => throw\
    \ new IllegalArgumentException(\"Invalid character in string a: \" + aChar)\n\
    \            }\n            val bInt = bChar match {\n                case '1'\
    \ => 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character in string b: \" + bChar)\n            }\n            val aIntInt\
    \ = aInt XOR bInt\n            val aIntIntString = Integer.toString(aIntInt)\n\
    \            val aIntIntStringWithCarry = aIntIntString + Integer.toString(carry)\n\
    \            val aIntIntStringWithCarryWithCarry = aIntIntStringWithCarry + Integer.toString(carry)\n\
    \            val aIntIntStringWithCarryWithCarryWithCarry = aIntIntStringWithCarryWithCarry\
    \ + Integer.toString(carry)\n            val aIntIntStringWithCarryWithCarryWithCarryWithCarry\
    \ = aIntIntStringWithCarryWithCarryWithCarry + Integer.toString(carry)\n     \
    \       val aIntIntStringWithCarryWithCarryWithCarryWithCarryWithCarry = aIntIntStringWithCarryWithCarryWithCarryWithCarry\
    \ + Integer.toString(carry)\n            val aIntIntStringWithCarryWithCarryWithCarryWithCarryWithCarryWithCarry\
    \ = aIntIntStringWithCarryWithCarryWithCarryWithCarryWithCarry + Integer.toString(carry)\n\
    \            val aIntIntStringWithCarryWithCarryWithCarryWithCarryWithCarryWithCarryWithCarry\
    \ = aIntIntStringWithCarryWithCarryWithCarryWithCarryWithCarryWithCarry + Integer.toString(carry)\n\
    \            val aIntIntStringWithCarryWithCarryWithCarryWithCarryWithCarryWithCarryWithCarryWithCarry\
    \ = aIntIntStringWithCarr\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy0uex99v.scala:44:0 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy0uex99v.scala:26:31\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m\
    \ \e[36maIntInt\e[0m = aInt XOR bInt\n\e[31m\e[31m   |\e[0m                  \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value XOR is\
    \ not a member of Int\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy0uex99v.scala:35:104\
    \ -----------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36maIntIntStringWithCarryWithCarryWithCarryWithCarryWithCarryWithCarryWithCarryWithCarry\e\
    [0m = aIntIntStringWithCarr\n\e[31m\e[31m   |\e[0m                           \
    \                                                                            \
    \ ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \        Not found: aIntIntStringWithCarr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpy0uex99v.scala:43:1 ---------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpy0uex99v.scala:37:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m37 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659793074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ xor bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdlif5kie.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793038
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xor = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult2 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult3 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult4 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult5\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult6 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult7 = mutable.ArrayBuffer.fill(aArray.length)(0)\n       \
    \ val xorResult8 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult9\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult10 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult11 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult12 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult13\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult14 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult15 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult16 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult17\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult18 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult19 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult20 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult21\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult22 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult23 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult24 = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult25\
    \ = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xorResult26 = mutable.ArrayBuffer.fill(aArray.length)(0)\n\
    \        val xorResult27 = mutable.ArrayBuffer.fill(aArray.length)(0)\n      \
    \  val xorResult28 = mutable.ArrayBuffer.fill\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp6pj2hlim.scala:13:24 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6pj2hlim.scal"
  stdout: ''
  timestamp: 1659793058
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer[String]()\n     \
    \   aList.zip(bList).foreach { case (aChar, bChar) =>\n            xorList +=\
    \ aChar ^ bChar\n        }\n        xorList.toList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpukz0_xpw.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793072
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringWithZeros = Array.fill(8 - xorBitsStringLength)('0')\
    \ ++ xorBitsString\n        val xorBitsStringWithOnes = Array.fill(8 - xorBitsStringLength)('1')\
    \ ++ xorBitsStringWithZeros\n        val xorBitsStringWithOnesAndZeros = xorBitsStringWithOnes\
    \ ++ xorBitsStringWithZeros\n        val xorBitsStringWithOnesAndZerosAndOnes\
    \ = xorBitsStringWithOnesAndZeros ++ xorBitsStringWithOnes\n        val xorBitsStringWithOnesAndZerosAndOnesAndZeros\
    \ = xorBitsStringWithOnesAndZerosAndOnes ++ xorBitsStringWithZeros\n        val\
    \ xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnes = xorBitsStringWithOnesAndZerosAndOnesAndZeros\
    \ ++ xorBitsStringWithOnesAndZeros\n        val xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZeros\
    \ = xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnes ++ xorBitsStringWithZeros\n\
    \        val xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnes\
    \ = xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZeros ++ xorBitsStringWithOnesAndZeros\n\
    \        val xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZeros\
    \ = xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnes ++ xorBitsStringWithZeros\n\
    \        val xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnes\
    \ = xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZeros\
    \ ++ xorBitsStringWithOnesAndZeros\n        val xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZeros\
    \ = xorBitsStringWithOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnesAndZerosAndOnes\
    \ ++ xorBits\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppmmmrx_c.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmppmmmrx_c.scala:25:5 ---------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793074
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = aList.zip(bList).map {\n            case\
    \ (aChar, bChar) => aChar ^ bChar\n        }.mkString\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i)).toString\n\
    \        xorList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbd_prux_.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793073
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var carry\
    \ = 0\n        var i = 0\n        while (i < aList.size) {\n            val aChar\
    \ = aList(i)\n            val bChar = bList(i)\n            val xor = aChar xor\
    \ bChar\n            if (carry == 0) {\n                result.append(xor)\n \
    \           } else {\n                result.append(xor)\n                carry\
    \ = xor shr 1\n            }\n            i += 1\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp83a1xtpb.scala:17:28 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = Integer.toBinaryString(xorBits)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsString.substring(1,xorBitsString.length)\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsStringWithoutLeadingZeros\
    \ = xorBitsStringWithoutLeadingZeros.reverse\n        val xorBitsString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpss0tbiw_.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpss0tbiw_.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBitsStringWithoutLeadingZeros\e[0m = xorBitsStringWithoutLeadingZeros.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutLeadingZeros is already defined as \e\
    [33mvalue\e[0m \e[35mxorBitsStringWithoutLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpss0tbiw_.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBitsStringWithoutLeadingZeros\e[0m = xorBitsStringWithoutLeadingZeros.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutLeadingZeros is already defined as \e\
    [33mvalue\e[0m \e[35mxorBitsStringWithoutLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpss0tbiw_.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBitsStringWithoutLeadingZeros\e[0m = xorBitsStringWithoutLeadingZeros.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithoutLeadingZeros is already defined as \e\
    [33mvalue\e[0m \e[35mxorBitsStringWithoutLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpss0tbiw_.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorBit"
  stdout: ''
  timestamp: 1659793075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val xorBits = aBits xor bBits\n        val xorBitsString\
    \ = xorBits.toBinaryString\n        val xorBitsStringLength = xorBitsString.length\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsStringLength)\n \
    \       var i = 0\n        while (i < xorBitsStringLength) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \            i += 1\n        }\n        xorBitsStringBuilder.reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9n5qao15.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i)).toString\n\
    \        xorList.toList.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmhkz_ior.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n\
    \        val xorBitsIter = Iterator.continually(xorBits)\n        val xorBitsIterIter\
    \ = Iterator.continually(xorBitsIter)\n        val xorBitsIterIterIter = Iterator.continually(xorBitsIterIter)\n\
    \        val xorBitsIterIterIterIter = Iterator.continually(xorBitsIterIterIter)\n\
    \        val xorBitsIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIterIterIterIter = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIterIterIterIter)\n\
    \        val xorBitsIterIterIterIterIterIterIterIterIterIterIterIterIter = Iterator.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6cxqvtmz.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6cxqvtmz.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mxorBitsIterIterIterIterIterIterIterIter\e\
    [0m = Iterator.continually(xorBitsIterIterIterIterIterIterIterIter)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsIterIterIterIterIterIterIterIter is already defined\
    \ as \e[33mvalue\e[0m \e[35mxorBitsIterIterIterIterIterIterIterIter\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6cxqvtmz.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mxorBitsIterIterIterIterIterIterIterIterIterIter\e\
    [0m = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIterIter)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsIterIterIterIterIterIterIterIterIterIter is already\
    \ defined as \e[33mvalue\e[0m \e[35mxorBitsIterIterIterIterIterIterIterIterIterIter\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6cxqvtmz.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mxorBitsIterIterIterIterIterIterIterIterIterIterIterIter\e\
    [0m = Iterator.continually(xorBitsIterIterIterIterIterIterIterIterIterIterIter)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsIterIterIterIterIterIterIterIterIterIterIterIter is\
    \ alrea"
  stdout: ''
  timestamp: 1659793075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.ListBuffer[Int]()\n        val xorResult = mutable.ListBuffer[Int]()\n\
    \        val xorResult2 = mutable.ListBuffer[Int]()\n        val xorResult3 =\
    \ mutable.ListBuffer[Int]()\n        val xorResult4 = mutable.ListBuffer[Int]()\n\
    \        val xorResult5 = mutable.ListBuffer[Int]()\n        val xorResult6 =\
    \ mutable.ListBuffer[Int]()\n        val xorResult7 = mutable.ListBuffer[Int]()\n\
    \        val xorResult8 = mutable.ListBuffer[Int]()\n        val xorResult9 =\
    \ mutable.ListBuffer[Int]()\n        val xorResult10 = mutable.ListBuffer[Int]()\n\
    \        val xorResult11 = mutable.ListBuffer[Int]()\n        val xorResult12\
    \ = mutable.ListBuffer[Int]()\n        val xorResult13 = mutable.ListBuffer[Int]()\n\
    \        val xorResult14 = mutable.ListBuffer[Int]()\n        val xorResult15\
    \ = mutable.ListBuffer[Int]()\n        val xorResult16 = mutable.ListBuffer[Int]()\n\
    \        val xorResult17 = mutable.ListBuffer[Int]()\n        val xorResult18\
    \ = mutable.ListBuffer[Int]()\n        val xorResult19 = mutable.ListBuffer[Int]()\n\
    \        val xorResult20 = mutable.ListBuffer[Int]()\n        val xorResult21\
    \ = mutable.ListBuffer[Int]()\n        val xorResult22 = mutable.ListBuffer[Int]()\n\
    \        val xorResult23 = mutable.ListBuffer[Int]()\n        val xorResult24\
    \ = mutable.ListBuffer[Int]()\n        val xorResult25 = mutable.ListBuffer[Int]()\n\
    \        val xorResult26 = mutable.ListBuffer[Int]()\n        val xorResult27\
    \ = mutable.ListBuffer[Int]()\n        val xorResult28 = mutable.ListBuffer[Int]()\n\
    \        val xorResult29 = mutable.ListBuffer[Int]()\n        val xorResult30\
    \ = mutable.ListBuffer[Int]()\n        val xorResult31 = mutable.ListBuffer[Int]()\n\
    \        val xorResult32 = mutable.ListBuffer[Int]()\n        val xorResult33\
    \ = mutable.\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpccbazec8.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpccbazec8.scala:12:18 ------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ListBuffer[\e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpccbazec8.scala:13:24 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpccbazec8.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpccbazec8.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpccbazec8.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable\n\e[31m   |"
  stdout: ''
  timestamp: 1659793075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        val xor =\
    \ mutable.ListBuffer[Int]()\n        var i = 0\n        while (i < aList.size)\
    \ {\n            xor.append(aList(i) xor bList(i))\n            i += 1\n     \
    \   }\n        xor.foreach(x => result.append(x))\n        result.toString\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpezrqlv62.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793074
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray\n   \
    \     val bArray = b.toCharArray\n        val result = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < Math.max(aArray.length,\
    \ bArray.length)) {\n            result(i) = aArray(i) XOR bArray(i)\n       \
    \     i += 1\n        }\n        new String(result)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_dkrtxl.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) XOR bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for(i <- 0 until aList.size) {\n            val aChar = aList(i)\n         \
    \   val bChar = bList(i)\n            val aCharInt = aChar.toInt\n           \
    \ val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt * 2\n   \
    \         val bCharIntInt = bCharInt * 2\n            val aCharIntIntInt = aCharIntInt\
    \ + carry\n            val bCharIntIntInt = bCharIntInt + carry\n            val\
    \ aCharIntIntIntInt = aCharIntIntInt + carry\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt + carry\n            val aCharIntIntIntIntInt = aCharIntIntIntInt\
    \ + carry\n            val bCharIntIntIntIntInt = bCharIntIntIntInt + carry\n\
    \            val aCharIntIntIntIntIntInt = aCharIntIntIntIntInt + carry\n    \
    \        val bCharIntIntIntIntIntInt = bCharIntIntIntIntInt + carry\n        \
    \    val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt + carry\n      \
    \      val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt + carry\n \
    \           val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt + carry\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt\
    \ + carry\n            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt\
    \ + carry\n            val bCharIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntInt\
    \ + carry\n            val aCharIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\
    \ + carry\n            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt\
    \ + carry\n            val aCharIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntInt\
    \ + carry\n            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwhcxctev.scala:46:0 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwhcxctev.scala:34:54\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m\
    \ \e[36maCharIntIntIntIntIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntIntIntInt\
    \ + carry\n\e[31m\e[31m   |\e[0m                                             \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Not found: aCharIntIntIntIntIntIntIntIntIntIntInt\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwhcxctev.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36maCharIntIntIntIntIntIntIntIntIntInt\e\
    [0m = aCharIntIntIntIntIntIntIntIntIntIntInt + carry\n\e[31m\e[31m   |\e[0m  \
    \                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Not found: aCharIntIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwhcxctev.scala:45:1\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpwhcxctev.scala:39:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m39 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659793076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       var i = 0\n        while (i < aList.size) {\n            xorList += aList(i)\
    \ xor bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv5uo2uvz.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793075
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        val result = new StringBuilder\n        val xorBits\
    \ = aBits xor bBits\n        result ++= xorBits.toBinaryString\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm8cp42f8.scala:12:28 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        var xor = 0\n        for (i <- 0 until aArray.length)\n            xor\
    \ = xor + aArray(i) xor bArray(i)\n        xorArray = xorArray.toArray\n     \
    \   xorArray(xorArray.length-1) = xor\n        xorArray.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi0llpxey.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             value xor is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpi0llpxey.scala:15:19 --------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        xorArray = xorArray.toArray\n\e[31m\e[31m   |\e[0m           \
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Array[Int]\n\
    \e[31m   |\e[0m                   Required: scala.collection.mutable.ArrayBuffer[Int]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        var result = \"\"\n        var carry = 0\n       \
    \ for (i <- 0 until aList.size) {\n            val aChar = aList(i)\n        \
    \    val bChar = bList(i)\n            val aCharInt = aChar match {\n        \
    \        case '1' => 1\n                case '0' => 0\n            }\n       \
    \     val bCharInt = bChar match {\n                case '1' => 1\n          \
    \      case '0' => 0\n            }\n            val aCharIntInt = aCharInt xor\
    \ bCharInt\n            val aCharIntIntInt = aCharIntInt\n            val aCharIntIntIntInt\
    \ = aCharIntIntIntInt\n            val aCharIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzo4bgya7.scala:36:0 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzo4bgya7.scala:24:39\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36maCharIntInt\e[0m = aCharInt xor bCharInt\n\e[31m\e[31m   |\e[0m      \
    \                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \            value xor is not a member of Int\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpzo4bgya7.scala:27:42 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            \e[33mval\e[0m \e[36maCharIntIntIntIntIntInt\e[0m = aCharIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659793077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n \
    \       for(i <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n\
    \        }\n        xorList.toList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgvm8vqvs.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793076
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toIntArray\n     \
    \   val bBits = b.toIntArray\n        val result = new mutable.StringBuilder\n\
    \        var carry = 0\n        var i = 0\n        while (i < a.length) {\n  \
    \          val aBit = aBits(i)\n            val bBit = bBits(i)\n            val\
    \ aBitInt = aBit + carry\n            val bBitInt = bBit + carry\n           \
    \ val aBitString = aBitInt.toBinaryString\n            val bBitString = bBitInt.toBinaryString\n\
    \            val aBitStringLength = a.length - i\n            val bBitStringLength\
    \ = b.length - i\n            val aBitStringLengthInt = aBitStringLength.toInt\n\
    \            val bBitStringLengthInt = bBitStringLength.toInt\n            val\
    \ aBitStringLengthBits = aBitStringLength.toBinaryString\n            val bBitStringLengthBits\
    \ = bBitStringLength.toBinaryString\n            val aBitStringLengthBitsLength\
    \ = a.length - i - 1\n            val bBitStringLengthBitsLength = b.length -\
    \ i - 1\n            val aBitStringLengthBitsIntLength = aBitStringLengthBitsLength.toInt\n\
    \            val bBitStringLengthBitsIntLength = bBitStringLengthBitsLength.toInt\n\
    \            val aBitStringLengthBitsBitsLength = aBitStringLengthBitsLength.toBinaryString\n\
    \            val bBitStringLengthBitsBitsLength = bBitStringLengthBitsLength.toBinaryString\n\
    \            val aBitStringLengthBitsBitsIntLength = aBitStringLengthBitsBitsLength.toInt\n\
    \            val bBitStringLengthBitsBitsIntLength = bBitStringLengthBitsBitsLength.toInt\n\
    \            val aBitStringLengthBitsBitsBitsLength = aBitStringLengthBitsBitsLength.toBinaryString\n\
    \            val bBitStringLengthBitsBitsBitsLength = bBitStringLengthBitsBitsLength.toBinaryString\n\
    \            val aBitStringLengthBitsBitsBitsIntLength = aBitStringLengthBitsBitsBitsLength.toInt\n\
    \            val bBitStringLengthBitsBitsBitsIntLength = bBitStringLengthBitsBitsBitsLength.toInt\n\
    \            val aBitStringLengthBitsBitsBitsBitsLength = aBitStringLengthBitsBitsBitsLength.toBinaryString\n\
    \            val bBitStringLengthBitsBitsBitsBitsLength = bBitStringLengthBitsBitsBits\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd0kx1ox0.scala:49:0 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd0kx1ox0.scala:9:22\
    \ -------------------------\e[0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e\
    [36maBits\e[0m = a.toIntArray\n\e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m  |\e[0m                    value toIntArray is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd0kx1ox0.scala:10:22 ------------------------\e\
    [0m\e[0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                  value toIntArray is not a member of String\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd0kx1ox0.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd0kx1ox0.scala:35:84 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36maBitStringLengthBitsBitsBitsLength\e\
    [0m = aBitStringLengthBitsBitsLength.toBinaryString\n\e[31m\e[31m   |\e[0m   \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value toBinaryString is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd0kx1ox0.scala:36:84\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbBitStringLengthBitsBitsBitsLength\e[0m = bBitStringLengthBitsBitsLength.toBinaryString\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value toBinaryString is not a member\
    \ of String\n\e[31m\e[31m-- [E006] Not Fou"
  stdout: ''
  timestamp: 1659793077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aBits = a.toInt\n        val\
    \ bBits = b.toInt\n        var result = \"\"\n        var carry = 0\n        for\
    \ (i <- 0 until aBits.length)\n        {\n            val aBit = aBits(i)\n  \
    \          val bBit = bBits(i)\n            val aBitVal = aBit + carry\n     \
    \       val bBitVal = bBit + carry\n            val aBitValStr = aBitVal.toString.reverse\n\
    \            val bBitValStr = bBitVal.toString.reverse\n            val aBitValStrLen\
    \ = aBitValStr.length\n            val bBitValStrLen = bBitValStr.length\n   \
    \         val aBitValStrPad = if (aBitValStrLen < bBitValStrLen) aBitValStrLen\
    \ else bBitValStrLen\n            val bBitValStrPad = if (aBitValStrLen < bBitValStrLen)\
    \ bBitValStrLen else aBitValStrLen\n            val aBitValStrPadChar = if (aBitValStrPad\
    \ == 0) \"\" else aBitValStr.charAt(aBitValStrPad - 1)\n            val bBitValStrPadChar\
    \ = if (bBitValStrPad == 0) \"\" else bBitValStr.charAt(bBitValStrPad - 1)\n \
    \           val aBitValStrPadCharLen = aBitValStrPad + 1\n            val bBitValStrPadCharLen\
    \ = bBitValStrPad + 1\n            val aBitValStrPadCharVal = if (aBitValStrPad\
    \ == 0) 0 else aBitValStr.charAt(aBitValStrPad - 1)\n            val bBitValStrPadCharVal\
    \ = if (bBitValStrPad == 0) 0 else bBitValStr.charAt(bBitValStrPad - 1)\n    \
    \        val aBitValStrPadCharValLen = aBitValStrPad + 1\n            val bBitValStrPadCharValLen\
    \ = bBitValStrPad + 1\n            val aBitValStrPadCharValVal = if (aBitValStrPad\
    \ == 0) 0 else aBitValStr.charAt(aBitValStrPad - 1)\n            val bBitValStrPadCharValVal\
    \ = if (bBitValStrPad == 0) 0 else bBitValStr.charAt(bBitValStrPad - 1)\n    \
    \        val aBitValStrPadCharValValLen = aBitValStrPad + 1\n            val bBitValStrPadCharValValLen\
    \ = bBitValStrPad \n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn2mk8pxs.scala:45:0 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn2mk8pxs.scala:13:32\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (i\
    \ <- \e[31m0\e[0m until aBits.length)\n\e[31m\e[31m   |\e[0m                 \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          value length\
    \ is not a member of Int\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpn2mk8pxs.scala:15:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e\
    [0m \e[36maBit\e[0m = aBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35maBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpn2mk8pxs.scala:16:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e\
    [0m \e[36mbBit\e[0m = bBits(i)\n\e[31m\e[31m   |\e[0m                       ^^^^^\e\
    [0m\n\e[31m   |\e[0m                       \e[33mvalue\e[0m \e[35mbBits\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn2mk8pxs.scala:44:1\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpn2mk8pxs.scala:38:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m38 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659793077
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.ArrayBuffer(a.length)\n\
    \        for(i <- 0 until a.length) result(i) = aArray(i) xor bArray(i)\n    \
    \    result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxtitor8t.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer(a.length)\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793076
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a\
    \ : String, b : String) : String = {\n        val aList = a.toList\n        val\
    \ bList = b.toList\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aList.size) {\n            result.append(aList(i) ^ bList(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793077
