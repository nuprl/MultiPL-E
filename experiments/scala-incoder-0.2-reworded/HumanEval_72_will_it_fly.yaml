name: HumanEval_72_will_it_fly
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that returns true if the object q will fly, and false otherwise.\n\
  \    // The object q will fly if it's balanced (it is a palindromic list) and the\
  \ sum of its elements is less than or equal the maximum possible weight w.\n   \
  \ // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\n\
  \    // (false)\n    // # 1+2 is less than the maximum possible weight, but it's\
  \ unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more than the maximum\
  \ possible weight.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (9l))\n    // (true)\n    // # 3+2+3 is less than the maximum possible weight,\
  \ and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)), (5l))\n    //\
  \ (true)\n    // # 3 is less than the maximum possible weight, and it's balanced.\n\
  \    def willItFly(q : List[Long], w : Long) : Boolean = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
  \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
  \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
  \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
  \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
  \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
  \    }\n\n}\n"
completions: ["        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = maxSum - maxWeight < 0\n        isPalindromic && isBalanced",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight < 0\n        val isFlippable = q.forall(x => x > maxWeight)\n  \
    \      isPalindromic && isBalanced && isFlippable", "        val maxWeight = w\n\
    \        val maxSum = w.toLong\n        val palindromic = q.reverse.forall(x =>\
    \ x.toLong == x)\n        val sumOfElements = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val isBalanced = sumOfElements <= maxWeight\n        val\
    \ isPalindromic = palindromic\n        val isFlippable = isBalanced && isPalindromic\
    \ && sumOfElements <= maxSum\n        isFlippable", "        val maxWeight = w\n\
    \        val maxSum = q.foldLeft(0l)(_ + _)\n        val isBalanced = maxSum ==\
    \ maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      isBalanced && isPalindromic", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == _)\n\
    \        val isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        val isFlippableAndLessThanMaxWeight = isFlippable &&\
    \ maxWeight < maxSum\n        isFlippableAndLessThanMaxWeight", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == q.sum\n\
    \        val isLessThanMaxWeight = maxWeight < q.sum\n        val isLessThanMaxSum\
    \ = maxSum < w\n        val isLessThanMaxSumAndBalanced = isLessThanMaxWeight\
    \ && isLessThanMaxSum\n        val isLessThanMaxSumAndPalindromic = isLessThanMaxWeight\
    \ && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic = isLessThanMaxWeight\
    \ && isBalanced && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic\n   \
    \     val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic && !isPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxSumAndBalancedAndPalindromicAndNot", "        val maxSum\
    \ = w.toLong * q.length\n        val sums = q.foldLeft(List[Long]())((acc, x)\
    \ => acc :+ x.toLong)\n        val isBalanced = sums.size == q.length && sums.forall(x\
    \ => x <= maxSum)\n        val isPalindromic = sums.reverse == sums\n        isBalanced\
    \ && isPalindromic", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)((sum,\
    \ elem) => sum + elem)\n        val isBalanced = maxSum == maxWeight\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        isBalanced &&\
    \ isPalindromic", "        val maxWeight = w\n        val sumOfElements = q.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sumOfElements <= maxWeight", " \
    \       val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n    \
    \    val isNotFly = !isFly\n        isFly", "        val maxWeight = w\n     \
    \   val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isBalanced = maxSum == maxWeight\n        val isFlippable\
    \ = q.tail.forall(_ < q.head)\n        isPalindromic && isBalanced && isFlippable",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqualToMaxWeight = maxSum < maxWeight\n \
    \       val isLessOrEqualToMaxSum = maxSum == maxWeight\n        isBalanced &&\
    \ isPalindromic && isLessOrEqualToMaxWeight && isLessOrEqualToMaxSum", "     \
    \   val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val sumOfElements = q.sum\n    \
    \    val isBalanced = sumOfElements <= maxWeight\n        val isFlippable = palindromic\
    \ && isBalanced\n        val isFlippable = maxSum - sumOfElements <= maxWeight\n\
    \        isFlippable", "        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.reduceRight(_\
    \ + _))\n        val isBalanced = maxSum - maxWeight < 0\n        isPalindromic\
    \ && isBalanced", "        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlippableAndLessThanMaxWeight = isFlippable && maxWeight < maxSum\n\
    \        isFlippableAndLessThanMaxWeight", "        val maxWeight = w\n      \
    \  val maxSum = w.toLong\n        val maxList = q.reverse\n        val maxListSum\
    \ = maxList.foldLeft(0)(_ + _)\n        val isPalindromic = maxListSum == maxWeight\n\
    \        val isBalanced = maxListSum == maxSum && maxListSum == maxList.reduceLeft(_\
    \ + _)\n        isPalindromic && isBalanced", "        val maxWeight = w.toLong\n\
    \        val maxSum = q.foldLeft(0l)(_ + _)\n        val isBalanced = maxSum <\
    \ maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessOrEqual = maxSum < maxWeight\n        isBalanced && isPalindromic\
    \ && isLessOrEqual", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l){\
    \ (sum, e) => sum + e }\n        val isBalanced = maxSum == maxWeight\n      \
    \  val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.foldLeft(0l){\
    \ (sum, e) => sum + e }\n        isBalanced && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum", "        val maxWeight = w\n        val maxSum = w.toLong\n\
    \        val maxList = q.reverse\n        val maxListSum = maxList.reduceLeft(_\
    \ + _)\n        val isBalanced = maxListSum == maxSum\n        val isPalindromic\
    \ = maxList.reduceLeft(_ + _) == maxList.reduceRight(_ + _)\n        val isLessThanMaxWeight\
    \ = maxListSum < maxWeight\n        val isLessThanMaxSum = maxListSum < maxSum\n\
    \        isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxPalindromic = maxSum < maxWeight && isPalindromic\n\
    \        val isLessThanMaxPalindromicAndBalanced = maxSum < maxWeight && isPalindromic\
    \ && isBalanced\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax\n     \
    \   val isLessThanMaxPalindromicAndLessThanMax = maxSum < maxWeight && isPalindromic\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic\n  \
    \      val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndBalanced = maxSum\
    \ < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isBalanced\n\
    \        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isBalanced\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isLessThanMax\n\
    \        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isLessThanMax && isPalindromic && isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndBalanced\
    \ = maxSum < maxWeight && isPalindromic && isLess", "        val maxWeight = w.toLong\n\
    \        val maxSum = w.toLong\n        val maxSumOfElements = w.toLong\n    \
    \    val maxSumOfElementsOfList = w.toLong\n        val maxSumOfElementsOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfList = w.toLong\n    \
    \    val maxSumOfElementsOfListOfListOfListOfList = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfListOfList\
    \ = w.toLong\n        val maxSumOfElementsOfListOfListOfListOfListOfListOfListOfListOfList",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable", "        val maxWeight = w.toLong\n        val sumOfElements =\
    \ q.foldLeft(0L)(_ + _)\n        sumOfElements <= maxWeight && q.isBalanced",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.isEmpty\
    \ || q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isFlippable = q.forall(x => x != q(0))\n        isPalindromic &&\
    \ isBalanced && isFlippable", "        val maxWeight = w.toLong\n        val maxSum\
    \ = q.foldLeft(0l)((acc, x) => acc + x)\n        val isBalanced = maxSum < maxWeight\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        isBalanced\
    \ && isPalindromic", "        val maxSum = w.toLong * q.length\n        val maxWeight\
    \ = w.toLong\n        val maxWeightSum = w.toLong * q.length\n        val maxWeightSumPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromic = w.toLong\
    \ * q.length\n        val maxWeightSumPalindromicPalindromicPalindromic = w.toLong\
    \ * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicP", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x <=\
    \ maxWeight && maxSum - x <= maxWeight)\n        isPalindromic && isBalanced",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val isPalindromic = q.isEmpty || q.head == q.reverse.head\n\
    \        val isBalanced = maxSum == maxWeight\n        val isFlipped = q.head\
    \ != q.reverse.head\n        isPalindromic && isBalanced && isFlipped", "    \
    \    val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && isBalanced\n        val isLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && isPalindromic\n        val isLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isLessThanMaxWeight\n        val isLessThanMaxSumAndLessThanMaxSum\
    \ = maxSum < maxWeight && isLessThanMaxSum\n        val isLessThanMaxSumAndLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && isLessThanMaxSum && isBalanced\n        val isLessThanMaxSumAndLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && isLessThanMaxSum && isPalindromic\n        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxWeight\n        val\
    \ isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSum = maxSum < maxWeight && isLessThanMaxSum\
    \ && isLessThanMaxSum\n        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isBalanced\n\
    \        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isPalindromic\n\
    \        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSumAndLessThanMaxSum\
    \ = maxSum < maxWeight && isLessThanMaxSum && isLessThanMaxSum && isLessThan",
  "        val maxWeight = w\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElements = w.toLong\n        val maxSumOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxSumOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElements", " \
    \       val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n       \
    \ isFlippable", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        val isBalanced = maxSum == maxWeight\n    \
    \    val isPalindromic = q.reverse.forall(e => e == q(0))\n        isBalanced\
    \ && isPalindromic", "        val maxWeight = w\n        val palindrome = q.reverse.forall(x\
    \ => x == x.toLong)\n        val sumOfElements = q.sum\n        val isBalanced\
    \ = sumOfElements <= maxWeight\n        val isFly = palindrome && isBalanced\n\
    \        isFly", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxPalindromic = maxSum < maxWeight && isPalindromic\n\
    \        val isLessThanMaxPalindromicAndBalanced = maxSum < maxWeight && isPalindromic\
    \ && isBalanced\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax\n     \
    \   val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromic = maxSum\
    \ < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax && isPalindromic\n      \
    \  val is", "        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        (isPalindromic && isBalanced)", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isFlippable\
    \ = q.forall(x => x == q.reverse.head)\n        isPalindromic && isBalanced &&\
    \ isFlippable", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n  \
    \      isPalindromic && isBalanced && isFlippable", "        val maxSum = w.toLong\
    \ * q.length\n        val sums = q.foldLeft(List[Long]())((acc, x) => acc :+ x.toLong)\n\
    \        sums.last <= maxSum", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isWon = isPalindromic\
    \ && isBalanced\n        isWon", "        val maxWeight = w\n        val sumOfElements\
    \ = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        sumOfElements <= maxWeight",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n        isPalindromic\
    \ && isBalanced && isFlippable", "        val maxWeight = w.toLong\n        val\
    \ maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == 0 || maxSum == maxWeight\n        val isPalindromic =\
    \ q.reverse.forall(e => e == q(0))\n        val isLessThanMaxWeight = maxSum <\
    \ maxWeight\n        isBalanced && isPalindromic && isLessThanMaxWeight", "  \
    \      val maxWeight = w\n        val palindromic = q.reverse.forall(x => x.toLong\
    \ == x)\n        val sumOfElements = q.sum\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFly = palindromic && isBalanced\n        isFly",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ balanced = maxSum < maxWeight\n        val palindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = balanced && palindromic && isPalindromic\n        isBalanced",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual", "        val maxWeight = w\n        val\
    \ maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum - maxWeight < 0\n        isPalindromic\
    \ && isBalanced", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l){\
    \ (sum, e) => sum + e }\n        val isBalanced = maxSum == maxWeight\n      \
    \  val isPalindromic = q.reverse.forall(e => e == q(0))\n        val isFlippable\
    \ = q.forall(e => e != q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isFlippable && isLessThanMax", "     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isBalanced\
    \ = q.length == maxSum && q.forall(x => x == maxWeight)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isLessThanMaxWeight = maxWeight\
    \ < q.reduce(_ + _)\n        isBalanced && isPalindromic && isLessThanMaxWeight",
  "        val maxWeight = w.toLong\n        val maxSum = q.foldLeft(0)(_ + _)\n \
    \       val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum - q.sum < maxWeight\n        isPalindromic && isBalanced", "      \
    \  val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n      \
    \  val maxWeightSum = maxSum / q.length\n        val maxWeightSumAbs = Math.abs(maxWeightSum)\n\
    \        val maxWeightSumAbsAbs = Math.abs(maxWeightSumAbs)\n        val maxWeightSumAbsAbsAbs\
    \ = Math.abs(maxWeightSumAbsAbs)\n        val maxWeightSumAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs)\n\
    \        val maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs = Math.abs(maxWeightSumAbsAbsAbsAbsAbsAbsAbsAbsAb",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlippable = q.forall(x => x > maxWeight)\n      \
    \  isPalindromic && isBalanced && isFlippable", "        val maxWeight = w\n \
    \       val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isFlippable = isPalindromic && isBalanced\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced = isLessThanMax\
    \ && !isBalanced\n        isFlippable || isLessThanMaxButNotBalanced", "     \
    \   val maxWeight = w\n        val maxSum = w.toLong\n        val palindromic\
    \ = q.reverse.forall(x => x == x.toLong)\n        val sum = palindromic.foldLeft(0l)\
    \ { (sum, element) => sum + element }\n        sum <= maxSum && palindromic",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == _)\n        val isBalanced = maxSum <\
    \ maxWeight\n        val isFly = isPalindromic && isBalanced\n        val isNotFly\
    \ = !isPalindromic || !isBalanced\n        isFly", "        val maxWeight = w.toLong\n\
    \        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.sum\n        val maxList = q.reverse\n        val\
    \ maxListSum = maxList.sum\n        val maxListWeight = maxList.sum\n        val\
    \ maxListWeightDiff = maxListWeight - maxWeight\n        val maxListSumDiff =\
    \ maxListSum - maxSum\n        val maxListWeightDiffAbs = maxListWeightDiff <\
    \ 0 ? -maxListWeightDiff : maxListWeightDiff\n        val maxListSumDiffAbs =\
    \ maxListSumDiff < 0 ? -maxListSumDiff : maxListSumDiff\n        val maxListWeightDiffAbsLessOrEqual\
    \ = maxListWeightDiffAbs <= 0 ? false : true\n        val maxListSumDiffAbsLessOrEqual\
    \ = maxListSumDiffAbs <= 0 ? false : true\n        val maxListWeightDiffLessOrEqual\
    \ = maxListWeightDiffAbsLessOrEqual || maxListWeightDiffAbsLessOrEqual\n     \
    \   val maxListSumDiffLessOrEqual = maxListSumDiffAbsLessOrEqual || maxListSumDiffAbsLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = maxListWeightDiffLessOrEqual || maxListWeightDiffLessOrEqual\n\
    \        val maxListSumDiffLessOrEqual = maxListSumDiffLessOrEqual || maxListSumDiffLessOrEqual\n\
    \        val maxListWeightDiffLessOrEqual = ", "        val maxWeight = w\n  \
    \      val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e => e ==\
    \ q(0))\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic && isLessThanMax\
    \ && isLessThanMaxPalindromic", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        val isBalanced = maxSum == maxWeight\n        val isFlipped =\
    \ q.forall(x => x == q.reverse.head)\n        isPalindromic && isBalanced && isFlipped",
  "        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q.reduceRight(_ + _))\n        val isLessOrEqual = maxSum <= maxWeight\n   \
    \     isBalanced && isPalindromic && isLessOrEqual", "        val maxWeight =\
    \ w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic = q.isEmpty\n\
    \        val isBalanced = maxSum == maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        val isLessThanMaxWeight = maxSum < maxWeight\n      \
    \  val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n        val isLessThanMaxSumAndBalanced\
    \ = isLessThanMaxWeight && isBalanced\n        val isLessThanMaxSumAndFlippable\
    \ = isLessThanMaxWeight && isFlippable\n        isLessThanMaxSumAndBalanced ||\
    \ isLessThanMaxSumAndFlippable", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.isEmpty || q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isFlippable\
    \ = maxWeight < maxSum\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced &&\
    \ isPalindromic\n        val isFlippableAndBalancedAndPalindromicAndNotZero =\
    \ isFlippableAndBalancedAndPalindromic && maxWeight != 0\n        val isFlippableAndBalancedAndPalindromicAndNotNegative\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight < 0\n        val isFlippableAndBalancedAndPalindromicAndNotPositive\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight > 0\n        val isFlippableAndBalancedAndPalindromicAndNotNegativeOrZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight >= 0\n        val isFlippableAndBalancedAndPalindromicAndNotPositiveOrZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight <= 0\n        val isFlippableAndBalancedAndPalindromicAndNotNegativeOrZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight >= 0 && maxWeight != 0\n\
    \        val isFlippableAndBalancedAndPalindromicAndNotPositiveOrZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight <= 0 && maxWeight != 0\n\
    \        val isFlippableAndBalancedAndPalindromicAndNotNegativeOrZeroAndNotZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight >= 0 && maxWeight != 0 &&\
    \ maxWeight != 0\n        val isFlippableAndBalancedAndPalindromicAndNotPositiveOrZeroAndNotZeroAndNotZero\
    \ = isFlippableAndBalancedAndPalindromic && maxWeight <= 0 && maxWeight != 0 &&\
    \ maxWeight ", "        val maxWeight = w\n        val sumOfElements = q.sum\n\
    \        val isPalindromic = q.isReverse.forall(x => x == q(0))\n        val isBalanced\
    \ = sumOfElements <= maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable", "        val maxSum = w.toLong\n        val maxWeight =\
    \ w.toLong\n        val maxList = q.reverse\n        val maxListSum = maxList.foldLeft(0)(_\
    \ + _)\n        val maxListWeight = maxList.foldLeft(0)(_ + _)\n        val isBalanced\
    \ = maxListSum == maxWeight && maxListWeight <= maxSum\n        val isPalindromic\
    \ = maxList.reverse == maxList\n        val isFlippable = maxList.reverse == maxList.reverse\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndPalindromic\
    \ = isFlippable && isPalindromic\n        val isFlippableAndFlippable = isFlippable\
    \ && isFlippable\n        val isFlippableAndFlippableAndBalanced = isFlippable\
    \ && isFlippable && isBalanced\n        val isFlippableAndFlippableAndPalindromic\
    \ = isFlippable && isFlippable && isPalindromic\n        val isFlippableAndFlippableAndFlippable\
    \ = isFlippable && isFlippable && isFlippable\n        val isFlippableAndFlippableAndFlippableAndBalanced\
    \ = isFlippable && isFlippable && isFlippable && isBalanced\n        val isFlippableAndFlippableAndFlippableAndPalindromic\
    \ = isFlippable && isFlippable && isFlippable && isPalindromic\n        val isFlippableAndFlippableAndFlippableAndFlippable\
    \ = isFlippable && isFlippable && isFlippable && isFlippable\n        val isFlippableAndFlippableAndFlippableAndFlippableAndBalanced\
    \ = isFlippable && isFlippable && isFlippable && isFlippable && isBalanced\n \
    \       val isFlippableAndFlippableAndFlippableAndFlippableAndPalindromic = isFlippable\
    \ && isFlippable && isFlippable ", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        isFlippable", "        val maxSum = w.toLong * q.length\n\
    \        val maxWeight = w.toLong\n        val maxWeightSum = maxSum / q.length\n\
    \        val maxWeightSumAbs = maxWeightSum.abs\n        val maxWeightSumAbsRemainder\
    \ = maxWeightSumAbs % 1\n        val maxWeightSumAbsRemainderAbs = maxWeightSumAbsRemainder.abs\n\
    \        val maxWeightSumAbsRemainderAbsRemainder = maxWeightSumAbsRemainderAbs\
    \ % 1\n        val maxWeightSumAbsRemainderAbsRemainderAbs = maxWeightSumAbsRemainderAbsRemainder.abs\n\
    \        val maxWeightSumAbsRemainderAbsRemainderAbsRemainder = maxWeightSumAbsRemainderAbsRemainderAbs\
    \ % 1\n        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbs = maxWeightSumAbsRemainderAbsRemainderAbsRemainder.abs\n\
    \        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainder = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbs\
    \ % 1\n        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainder.abs\n       \
    \ val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs % 1\n    \
    \    val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder.abs\n\
    \        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainder.abs\n\
    \        val maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbsRemainderAbs\
    \ = maxWeightSumAbsRemainderAbsRemainderAbsRemainderAbsRemainderAb", "       \
    \ val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum < maxWeight\n\
    \        (isPalindromic && isBalanced)", "        val maxWeight = w.toLong\n \
    \       val sumOfElements = q.foldLeft(0l) { (sum, element) => sum + element }\n\
    \        sumOfElements <= maxWeight", "        val maxWeight = w\n        val\
    \ maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isFly\
    \ = isPalindromic && isBalanced\n        val isNotFly = !isPalindromic || !isBalanced\n\
    \        isFly", "        val maxWeight = w\n        val palindromic = q.reverse.forall(x\
    \ => x == x.toLong)\n        val sumOfElements = q.foldLeft(0l) { (sum, element)\
    \ => sum + element }\n        sumOfElements <= maxWeight && palindromic", "  \
    \      val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isFlipped = q.tail.reverse.forall(_ == q.head)\n  \
    \      isPalindromic && isBalanced && isFlipped", "        val maxWeight = w\n\
    \        val maxSum = q.reduce(_ + _)\n        val isBalanced = maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessThanMax",
  "        val maxWeight = w\n        val maxSum = q.sum\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val balanced = palindromic && maxSum\
    \ < maxWeight\n        val unbalanced = palindromic && !balanced\n        (balanced\
    \ && unbalanced)", "        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight <= 0\n        val isFlipped = q.forall(_ < maxWeight)\n\
    \        (isPalindromic && isBalanced && isFlipped)", "        val maxWeight =\
    \ w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum - maxWeight\
    \ < 0\n        val isFly = isPalindromic && isBalanced\n        val isNotFly =\
    \ !isPalindromic && !isBalanced\n        isFly", "        val maxWeight = w\n\
    \        val palindromic = q.reverse.forall(x => x % 10 == 0)\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = palindromic && isBalanced\n        isFlippable", "        val maxWeight =\
    \ w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n  \
    \      val isBalanced = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        isBalanced && isPalindromic", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n      \
    \  val isLessThanMaxSum = maxSum < q.foldLeft(0l) { (sum, e) => sum + e }\n  \
    \      isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum",
  "        val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q.reduceRight(_ + _))\n        (isBalanced && isPalindromic)", "        val\
    \ maxWeight = w.toLong\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        (isBalanced && isPalindromic)",
  "        val maxSum = w.toLong * q.length\n        q.reverse.foldLeft(true)(_ &&\
    \ {\n            val sum = 0\n            q.foreach(x => sum += x)\n         \
    \   sum < maxSum\n        })", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isBalanced = maxSum == maxWeight\n      \
    \  val isPalindromic = q.reverse.forall(x => x == q.reduceLeft(_ + _))\n     \
    \   val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < q.reduceLeft(_ + _)\n        isBalanced && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum", "        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val maxList = new mutable.ListBuffer[Long]()\n        q.foreach(x =>\
    \ maxList += x)\n        val isPalindromic = maxList.reverse.forall(x => x ==\
    \ maxList(0))\n        val isBalanced = maxList.sum == maxWeight\n        val\
    \ isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced = isLessThanMax\
    \ && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxAndNotPalindromic = isLessThanMax && !isPalindromic\n\
    \        val isLessThanMaxAndNotBalanced = isLessThanMax && !isBalanced\n    \
    \    val isLessThanMaxAndNotPalindromicAndNotBalanced = isLessThanMax && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic\n       \
    \ val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isBalanced\n        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isBalanced && !isPalindromic\n        val isLessThanMaxAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic && !", " \
    \       val maxSum = w.toLong * q.length\n        val sum = 0\n        for (i\
    \ <- 0 until q.length) {\n            sum += q(i)\n        }\n        sum < maxSum",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isWightBalanced = isPalindromic && isBalanced\n   \
    \     isWightBalanced", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, elem) => sum + elem }\n        val isBalanced = maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(_ == q.head)\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        isBalanced && isPalindromic && isLessThanMaxWeight",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isFlippable = q.forall(x => x < maxWeight)\n     \
    \   isPalindromic && isBalanced && isFlippable", "        val maxWeight = w\n\
    \        val maxSum = q.reduceLeft(_ + _)\n        val isBalanced = maxSum ==\
    \ maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessThanMaxWeight = maxSum < maxWeight\n        isBalanced && isPalindromic\
    \ && isLessThanMaxWeight", "        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        (isPalindromic && isBalanced)",
  "        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList =\
    \ q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val isBalanced\
    \ = maxListSum == maxSum\n        val isPalindromic = maxList.reduceLeft(_ + _)\
    \ == maxListSum\n        val isFlippable = maxList.reduceLeft(_ + _) <= maxWeight\n\
    \        isBalanced && isPalindromic && isFlippable", "        val maxWeight =\
    \ w.toLong\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n    \
    \    val isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        val isFlippable = q.forall(e => e != q(0))\n        isBalanced\
    \ && isPalindromic && isFlippable", "        val maxWeight = w\n        val maxSum\
    \ = q.foldLeft(0l) { (sum, e) => sum + e }\n        val isBalanced = maxSum ==\
    \ 0 || maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_ ==\
    \ q.head)\n        val isLessThanMax = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessThanMax", "        val maxWeight = w\n        val\
    \ maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        (isPalindromic\
    \ && isBalanced)", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n  \
    \      val isFlippableAndBalanced = isFlippable && isBalanced\n        isFlippableAndBalanced",
  "        val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < q.sum\n        isPalindromic && isBalanced && isLessThanMaxWeight\
    \ && isLessThanMaxSum", "        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxSumAndBalanced = maxSum < maxWeight && maxWeight == maxSum\n  \
    \      val isLessThanMaxSumAndPalindromic = maxSum < maxWeight && maxWeight ==\
    \ maxSum && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic = maxSum\
    \ < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isPalindromic && !isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isPalindromic && !isBalanced && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isPalindromic && !isBalanced && !isPalindromic && !isPalindromic\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isBalanced && isPalindromic &&\
    \ !isP", "        val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isBalanced = maxSum < maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        isBalanced && isPalindromic && isFlippable", "        val maxWeight =\
    \ w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isPalindromic = q.reverse.forall(e => e == q(0))\n        val isBalanced = maxSum\
    \ - maxWeight < 0\n        (isPalindromic && isBalanced)", "        val maxWeight\
    \ = w\n        val sumOfElements = q.foldLeft(0l) { (sum, elem) => sum + elem\
    \ }\n        sumOfElements <= maxWeight", "        val maxWeight = w\n       \
    \ val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        (isPalindromic\
    \ && isBalanced)", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isLessOrEqualToMaxWeight = maxSum < maxWeight\n      \
    \  isBalanced && isPalindromic && isLessOrEqualToMaxWeight", "        val maxWeight\
    \ = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == 0 || maxSum == maxWeight\n        val isPalindromic =\
    \ q.reverse.forall(e => e == q(0))\n        isBalanced && isPalindromic", "  \
    \      val maxWeight = w.toLong\n        val maxSum = q.reduceLeft(_ + _)\n  \
    \      val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        val isFlipped = q.forall(_ < maxWeight)\n        isFlippable && isFlipped",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(e => e == q(0))\n      \
    \  val isBalanced = maxSum - maxWeight < 0\n        val isFlippable = q.forall(e\
    \ => e == q(q.length - 1))\n        isPalindromic && isBalanced && isFlippable",
  "        val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ == maxWeight\n        isPalindromic && isBalanced", "        val maxWeight =\
    \ w\n        val palindrome = q.reverse\n        val sum = palindrome.sum\n  \
    \      val maxSum = sum + maxWeight\n        val isBalanced = palindrome.forall(x\
    \ => x <= maxSum)\n        val isPalindrome = sum == maxSum\n        val isLessOrEqual\
    \ = maxWeight <= sum\n        isBalanced && isPalindrome && isLessOrEqual", " \
    \       val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n      \
    \  val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced =\
    \ maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable", "        val maxWeight = w\n        val sumOfElements =\
    \ q.foldLeft(0l){ (sum, e) => sum + e }\n        sumOfElements <= maxWeight",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxButNotBalanced = isLessThanMax && !isBalanced\n    \
    \    val isLessThanMaxButBalanced = isLessThanMax && isBalanced\n        val isLessThanMaxButNotPalindromic\
    \ = isLessThanMax && !isPalindromic\n        val isLessThanMaxButPalindromic =\
    \ isLessThanMax && isPalindromic\n        (isLessThanMaxButNotBalanced || isLessThanMaxButBalanced\
    \ || isLessThanMaxButNotPalindromic || isLessThanMaxButPalindromic)", "      \
    \  val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q.head)\n        val isBalanced = q.forall(x => x\
    \ <= maxWeight && x >= maxSum - maxWeight)\n        isPalindromic && isBalanced",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isBalanced = maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(e => e == q(0))\n        val isLessOrEqualToMaxWeight = maxSum\
    \ < maxWeight\n        isBalanced && isPalindromic && isLessOrEqualToMaxWeight",
  "        val maxSum = w.toLong * w.toLong\n        val sum = 0\n        val maxWeight\
    \ = w.toLong\n        val maxList = q.reverse\n        val maxListSize = maxList.size\n\
    \        val maxListSum = maxList.foldLeft(0)(_ + _)\n        val maxListWeight\
    \ = maxList.foldLeft(0)(_ * _)\n        val maxListSumLessOrEqual = maxListSum\
    \ <= maxWeight\n        val maxListWeightLessOrEqual = maxListWeight <= maxWeight\n\
    \        val maxListSumLessOrEqualAndBalanced = maxListSumLessOrEqual && maxListWeightLessOrEqual\n\
    \        val maxListWeightLessOrEqualAndBalanced = maxListWeightLessOrEqual &&\
    \ maxListSumLessOrEqual\n        val maxListSumLessOrEqualAndBalancedAndPalindromic\
    \ = maxListSumLessOrEqualAndBalanced && isPalindromic(maxList)\n        val maxListWeightLessOrEqualAndBalancedAndPalindromic\
    \ = maxListWeightLessOrEqualAndBalanced && maxListSumLessOrEqualAndBalancedAndPalindromic\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual = maxListSumLessOrEqualAndBalancedAndPalindromic\
    \ && !maxListWeightLessOrEqualAndBalanced\n        val maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual\
    \ = maxListWeightLessOrEqualAndBalancedAndPalindromic && !maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual\n\
    \        val maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListWeightLessOrEqualAndBalancedAndPalindromicAndNotEqual && !maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\n\
    \        val maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual\
    \ = maxListSumLessOrEqualAndBalancedAndPalindromicAndNotEqualAndNotEqual && !maxList",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum\
    \ + e }\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        isFlippable", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isBalanced = maxSum < maxWeight\n       \
    \ val isPalindromic = q.reverse.forall(_ == q(0))\n        val isFly = isBalanced\
    \ && isPalindromic && maxSum == maxWeight\n        val isNotFly = !isFly && maxSum\
    \ < maxWeight\n        isFly || isNotFly", "        val maxWeight = w\n      \
    \  val maxSum = q.foldLeft(0l) { (sum, elem) => sum + elem }\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum - maxWeight\
    \ < 0\n        val isFlippable = isPalindromic && isBalanced\n        isFlippable",
  "        val maxWeight = w\n        val maxSum = w.toLong\n        val maxList =\
    \ q.reverse\n        val maxListSum = maxList.reduceLeft(_ + _)\n        val maxListWeight\
    \ = maxList.reduceLeft(_ + _)\n        val maxListWeightSum = maxListWeight.reduceLeft(_\
    \ + _)\n        val maxListWeightSumLessOrEqualToMaxWeight = maxListWeightSum.let(maxWeight)\n\
    \        val maxListSumLessOrEqualToMaxSum = maxListSum.let(maxSum)\n        val\
    \ maxListSumLessOrEqualToMaxWeightAndBalanced = maxListSumLessOrEqualToMaxWeight\
    \ && maxListWeightSumLessOrEqualToMaxWeight\n        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromic\
    \ = maxListSumLessOrEqualToMaxWeightAndBalanced && !isPalindromic(maxList)\n \
    \       val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromic && !maxList.isEmpty\n\
    \        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmpty &&\
    \ !maxList.isEmpty && !maxList.isEmpty\n        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmpty\
    \ && !maxList.isEmpty && !maxList.isEmpty && !maxList.isEmpty\n        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmpty\
    \ && !maxList.isEmpty && !maxList.isEmpty && !maxList.isEmpty && !maxList.isEmpty\n\
    \        val maxListSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromicAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxListSumLessOrEqualToMaxWeightAndBalancedAndNot", "        val maxWeight\
    \ = w\n        val maxSum = w.toLong\n        val palindromic = q.reverse.forall(x\
    \ => x == x.toLong)\n        val sumOfElements = q.foldLeft(0l) { (acc, x) =>\
    \ acc + x }\n        val isBalanced = sumOfElements <= maxWeight\n        val\
    \ isFly = palindromic && isBalanced\n        isFly", "        val maxWeight =\
    \ w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum == maxWeight\n        val isFlippable\
    \ = q.forall(_ < maxWeight)\n        isPalindromic && isBalanced && isFlippable",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l) { (sum, elem) =>\
    \ sum + elem }\n        val isPalindromic = q.reverse.forall(elem => elem == q.head)\n\
    \        val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic\
    \ && isBalanced\n        val isNotFly = !isFly\n        isFly", "        val maxSum\
    \ = w.toLong * q.length\n        val sums = q.map(_.toLong).sum\n        sums\
    \ <= maxSum", "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)\
    \ { (sum, e) => sum + e }\n        val isPalindromic = q.reverse.forall(e => e\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        isFlippable", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.isEmpty\
    \ || q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isFlippable = q.forall(x => x == q.last)\n        val isFlippableAndBalanced\
    \ = isFlippable && isBalanced\n        isFlippableAndBalanced", "        val maxWeight\
    \ = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q(0))\n        val isBalanced = maxSum < maxWeight\n        val isFlipped\
    \ = q.forall(_ < maxWeight)\n        isPalindromic && isBalanced && isFlipped",
  "        val maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n       \
    \ val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSum - maxWeight < 0\n        val isFlippable = q.forall(x => x == q(0))\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        isFlippableAndBalanced\
    \ && isPalindromic", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced", "        val maxWeight\
    \ = w\n        val maxSum = q.foldLeft(0l) { (sum, e) => sum + e }\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(e\
    \ => e == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual", "        val maxWeight = w\n        val\
    \ maxSum = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSum == maxWeight\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        (isBalanced\
    \ && isPalindromic)", "        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val maxList = q.max\n        val maxListSize = maxList.size\n       \
    \ val maxListSum = maxList.sum\n        val maxListSumLessOrEqualToMaxWeight =\
    \ maxListSum < maxWeight\n        val maxListSumGreaterOrEqualToMaxWeight = maxListSum\
    \ > maxWeight\n        val maxListIsPalindromic = maxList.reverse == maxList\n\
    \        val maxListIsPalindromicAndLessOrEqualToMaxWeight = maxListIsPalindromic\
    \ && maxListSumLessOrEqualToMaxWeight\n        val maxListIsPalindromicAndGreaterOrEqualToMaxWeight\
    \ = maxListIsPalindromic && maxListSumGreaterOrEqualToMaxWeight\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalanced\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeight && maxListSize <= maxListSum\n\
    \        val maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalanced = maxListIsPalindromicAndGreaterOrEqualToMaxWeight\
    \ && maxListSize >= maxListSum\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmpty\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalanced && maxListSize >\
    \ 0\n        val maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalancedAndIsNotEmpty\
    \ = maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalanced && maxListSize\
    \ > 0\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmpty && maxListSize\
    \ > 0\n        val maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\
    \ = maxListIsPalindromicAndGreaterOrEqualToMaxWeightAndBalancedAndIsNotEmpty &&\
    \ maxListSize > 0\n        val maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAndIsNotEmptyAndIsNotNegative\
    \ = maxListIsPalindromicAndLessOrEqualToMaxWeightAndBalancedAnd", "        val\
    \ maxWeight = w\n        val maxSum = q.foldLeft(0l)(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum - maxWeight\
    \ < 0\n        val isFlippable = q.tail.forall(x => maxWeight - x < 0)\n     \
    \   isPalindromic && isBalanced && isFlippable", "        val maxWeight = w\n\
    \        val palindromic = q.reverse.forall(x => x == x.toLong)\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n        val isFly\
    \ = palindromic && isBalanced\n        val isNotFly = !palindromic && !isBalanced\n\
    \        isFly || isNotFly", "        val maxWeight = w.toLong\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        val isBalanced = maxSum - maxWeight <= 0\n        val isWon =\
    \ isPalindromic && isBalanced\n        val isLost = !isPalindromic && !isBalanced\n\
    \        isWon || isLost", "        val maxWeight = w\n        val palindrome\
    \ = q.reverse.forall(x => x != 0)\n        val sumOfElements = q.sum\n       \
    \ val isBalanced = sumOfElements <= maxWeight\n        val isFly = palindrome\
    \ && isBalanced\n        isFly", "        val maxWeight = w\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isBalanced = maxSum == maxWeight\n      \
    \  val isPalindromic = q.reverse.forall(_ == q(0))\n        val isLessThanMax\
    \ = maxSum < maxWeight\n        val isLessThanMaxPalindromic = maxSum < maxWeight\
    \ && isPalindromic\n        val isLessThanMaxPalindromicAndBalanced = maxSum <\
    \ maxWeight && isPalindromic && isBalanced\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax\n     \
    \   val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromic = maxSum\
    \ < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMax\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax\n        val isLessThanMaxPalindromicAndBalancedAndLessThanMaxPalindromicAndLessThanMaxPalindromicAndLessThanMaxPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isPalindromic\
    \ && isLessThanMax && isPalindromic && isLessThanMax && isPalindromic\n      \
    \  val isLess", "        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = isPalindromic && isBalanced\n\
    \        isFlippable"]
stop_tokens:
- "\n    }\n"
